#line 1 "/home/vsc/github/doxygen/Debug/generated_src/pre_intermediate.cpp"
#include <stdint.h>
// forward declare yyscan_t to improve type safety
#define YY_TYPEDEF_YY_SCANNER_T
struct yyguts_t;
typedef yyguts_t *yyscan_t;

#line 8 "/home/vsc/github/doxygen/Debug/generated_src/pre_intermediate.cpp"

#define  YY_INT_ALIGNED short int

/* A lexical scanner generated by flex */

#define FLEX_SCANNER
#define YY_FLEX_MAJOR_VERSION 2
#define YY_FLEX_MINOR_VERSION 6
#define YY_FLEX_SUBMINOR_VERSION 4
#if YY_FLEX_SUBMINOR_VERSION > 0
#define FLEX_BETA
#endif

#ifdef yy_create_buffer
#define preYY_create_buffer_ALREADY_DEFINED
#else
#define yy_create_buffer preYY_create_buffer
#endif

#ifdef yy_delete_buffer
#define preYY_delete_buffer_ALREADY_DEFINED
#else
#define yy_delete_buffer preYY_delete_buffer
#endif

#ifdef yy_scan_buffer
#define preYY_scan_buffer_ALREADY_DEFINED
#else
#define yy_scan_buffer preYY_scan_buffer
#endif

#ifdef yy_scan_string
#define preYY_scan_string_ALREADY_DEFINED
#else
#define yy_scan_string preYY_scan_string
#endif

#ifdef yy_scan_bytes
#define preYY_scan_bytes_ALREADY_DEFINED
#else
#define yy_scan_bytes preYY_scan_bytes
#endif

#ifdef yy_init_buffer
#define preYY_init_buffer_ALREADY_DEFINED
#else
#define yy_init_buffer preYY_init_buffer
#endif

#ifdef yy_flush_buffer
#define preYY_flush_buffer_ALREADY_DEFINED
#else
#define yy_flush_buffer preYY_flush_buffer
#endif

#ifdef yy_load_buffer_state
#define preYY_load_buffer_state_ALREADY_DEFINED
#else
#define yy_load_buffer_state preYY_load_buffer_state
#endif

#ifdef yy_switch_to_buffer
#define preYY_switch_to_buffer_ALREADY_DEFINED
#else
#define yy_switch_to_buffer preYY_switch_to_buffer
#endif

#ifdef yypush_buffer_state
#define preYYpush_buffer_state_ALREADY_DEFINED
#else
#define yypush_buffer_state preYYpush_buffer_state
#endif

#ifdef yypop_buffer_state
#define preYYpop_buffer_state_ALREADY_DEFINED
#else
#define yypop_buffer_state preYYpop_buffer_state
#endif

#ifdef yyensure_buffer_stack
#define preYYensure_buffer_stack_ALREADY_DEFINED
#else
#define yyensure_buffer_stack preYYensure_buffer_stack
#endif

#ifdef yylex
#define preYYlex_ALREADY_DEFINED
#else
#define yylex preYYlex
#endif

#ifdef yyrestart
#define preYYrestart_ALREADY_DEFINED
#else
#define yyrestart preYYrestart
#endif

#ifdef yylex_init
#define preYYlex_init_ALREADY_DEFINED
#else
#define yylex_init preYYlex_init
#endif

#ifdef yylex_init_extra
#define preYYlex_init_extra_ALREADY_DEFINED
#else
#define yylex_init_extra preYYlex_init_extra
#endif

#ifdef yylex_destroy
#define preYYlex_destroy_ALREADY_DEFINED
#else
#define yylex_destroy preYYlex_destroy
#endif

#ifdef yyget_debug
#define preYYget_debug_ALREADY_DEFINED
#else
#define yyget_debug preYYget_debug
#endif

#ifdef yyset_debug
#define preYYset_debug_ALREADY_DEFINED
#else
#define yyset_debug preYYset_debug
#endif

#ifdef yyget_extra
#define preYYget_extra_ALREADY_DEFINED
#else
#define yyget_extra preYYget_extra
#endif

#ifdef yyset_extra
#define preYYset_extra_ALREADY_DEFINED
#else
#define yyset_extra preYYset_extra
#endif

#ifdef yyget_in
#define preYYget_in_ALREADY_DEFINED
#else
#define yyget_in preYYget_in
#endif

#ifdef yyset_in
#define preYYset_in_ALREADY_DEFINED
#else
#define yyset_in preYYset_in
#endif

#ifdef yyget_out
#define preYYget_out_ALREADY_DEFINED
#else
#define yyget_out preYYget_out
#endif

#ifdef yyset_out
#define preYYset_out_ALREADY_DEFINED
#else
#define yyset_out preYYset_out
#endif

#ifdef yyget_leng
#define preYYget_leng_ALREADY_DEFINED
#else
#define yyget_leng preYYget_leng
#endif

#ifdef yyget_text
#define preYYget_text_ALREADY_DEFINED
#else
#define yyget_text preYYget_text
#endif

#ifdef yyget_lineno
#define preYYget_lineno_ALREADY_DEFINED
#else
#define yyget_lineno preYYget_lineno
#endif

#ifdef yyset_lineno
#define preYYset_lineno_ALREADY_DEFINED
#else
#define yyset_lineno preYYset_lineno
#endif

#ifdef yyget_column
#define preYYget_column_ALREADY_DEFINED
#else
#define yyget_column preYYget_column
#endif

#ifdef yyset_column
#define preYYset_column_ALREADY_DEFINED
#else
#define yyset_column preYYset_column
#endif

#ifdef yywrap
#define preYYwrap_ALREADY_DEFINED
#else
#define yywrap preYYwrap
#endif

#ifdef yyalloc
#define preYYalloc_ALREADY_DEFINED
#else
#define yyalloc preYYalloc
#endif

#ifdef yyrealloc
#define preYYrealloc_ALREADY_DEFINED
#else
#define yyrealloc preYYrealloc
#endif

#ifdef yyfree
#define preYYfree_ALREADY_DEFINED
#else
#define yyfree preYYfree
#endif

/* First, we deal with  platform-specific or compiler-specific issues. */

/* begin standard C headers. */
#include <stdio.h>
#include <string.h>
#include <errno.h>
#include <stdlib.h>

/* end standard C headers. */

/* flex integer type definitions */

#ifndef FLEXINT_H
#define FLEXINT_H

/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */

#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L

/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
 * if you want the limit (max/min) macros for int types. 
 */
#ifndef __STDC_LIMIT_MACROS
#define __STDC_LIMIT_MACROS 1
#endif

#include <inttypes.h>
typedef int8_t flex_int8_t;
typedef uint8_t flex_uint8_t;
typedef int16_t flex_int16_t;
typedef uint16_t flex_uint16_t;
typedef int32_t flex_int32_t;
typedef uint32_t flex_uint32_t;
#else
typedef signed char flex_int8_t;
typedef short int flex_int16_t;
typedef int flex_int32_t;
typedef unsigned char flex_uint8_t; 
typedef unsigned short int flex_uint16_t;
typedef unsigned int flex_uint32_t;

/* Limits of integral types. */
#ifndef INT8_MIN
#define INT8_MIN               (-128)
#endif
#ifndef INT16_MIN
#define INT16_MIN              (-32767-1)
#endif
#ifndef INT32_MIN
#define INT32_MIN              (-2147483647-1)
#endif
#ifndef INT8_MAX
#define INT8_MAX               (127)
#endif
#ifndef INT16_MAX
#define INT16_MAX              (32767)
#endif
#ifndef INT32_MAX
#define INT32_MAX              (2147483647)
#endif
#ifndef UINT8_MAX
#define UINT8_MAX              (255U)
#endif
#ifndef UINT16_MAX
#define UINT16_MAX             (65535U)
#endif
#ifndef UINT32_MAX
#define UINT32_MAX             (4294967295U)
#endif

#ifndef SIZE_MAX
#define SIZE_MAX               (~(size_t)0)
#endif

#endif /* ! C99 */

#endif /* ! FLEXINT_H */

/* begin standard C++ headers. */

/* TODO: this is always defined, so inline it */
#define yyconst const

#if defined(__GNUC__) && __GNUC__ >= 3
#define yynoreturn __attribute__((__noreturn__))
#else
#define yynoreturn
#endif

/* Returned upon end-of-file. */
#define YY_NULL 0

/* Promotes a possibly negative, possibly signed char to an
 *   integer in range [0..255] for use as an array index.
 */
#define YY_SC_TO_UI(c) ((YY_CHAR) (c))

/* An opaque pointer. */
#ifndef YY_TYPEDEF_YY_SCANNER_T
#define YY_TYPEDEF_YY_SCANNER_T
typedef void* yyscan_t;
#endif

/* For convenience, these vars (plus the bison vars far below)
   are macros in the reentrant scanner. */
#define yyin yyg->yyin_r
#define yyout yyg->yyout_r
#define yyextra yyg->yyextra_r
#define yyleng yyg->yyleng_r
#define yytext yyg->yytext_r
#define yylineno (YY_CURRENT_BUFFER_LVALUE->yy_bs_lineno)
#define yycolumn (YY_CURRENT_BUFFER_LVALUE->yy_bs_column)
#define yy_flex_debug yyg->yy_flex_debug_r

/* Enter a start condition.  This macro really ought to take a parameter,
 * but we do it the disgusting crufty way forced on us by the ()-less
 * definition of BEGIN.
 */
#define BEGIN yyg->yy_start = 1 + 2 *
/* Translate the current start state into a value that can be later handed
 * to BEGIN to return to the state.  The YYSTATE alias is for lex
 * compatibility.
 */
#define YY_START ((yyg->yy_start - 1) / 2)
#define YYSTATE YY_START
/* Action number for EOF rule of a given start state. */
#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
/* Special action meaning "start processing a new file". */
#define YY_NEW_FILE yyrestart( yyin , yyscanner )
#define YY_END_OF_BUFFER_CHAR 0

/* Size of default input buffer. */
#ifndef YY_BUF_SIZE
#ifdef __ia64__
/* On IA-64, the buffer size is 16k, not 8k.
 * Moreover, YY_BUF_SIZE is 2*YY_READ_BUF_SIZE in the general case.
 * Ditto for the __ia64__ case accordingly.
 */
#define YY_BUF_SIZE 32768
#else
#define YY_BUF_SIZE 16384
#endif /* __ia64__ */
#endif

/* The state buf must be large enough to hold one state per character in the main buffer.
 */
#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))

#ifndef YY_TYPEDEF_YY_BUFFER_STATE
#define YY_TYPEDEF_YY_BUFFER_STATE
typedef struct yy_buffer_state *YY_BUFFER_STATE;
#endif

#ifndef YY_TYPEDEF_YY_SIZE_T
#define YY_TYPEDEF_YY_SIZE_T
typedef size_t yy_size_t;
#endif

#define EOB_ACT_CONTINUE_SCAN 0
#define EOB_ACT_END_OF_FILE 1
#define EOB_ACT_LAST_MATCH 2
    
    #define YY_LESS_LINENO(n)
    #define YY_LINENO_REWIND_TO(ptr)
    
/* Return all but the first "n" matched characters back to the input stream. */
#define yyless(n) \
	do \
		{ \
		/* Undo effects of setting up yytext. */ \
        int yyless_macro_arg = (n); \
        YY_LESS_LINENO(yyless_macro_arg);\
		*yy_cp = yyg->yy_hold_char; \
		YY_RESTORE_YY_MORE_OFFSET \
		yyg->yy_c_buf_p = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
		} \
	while ( 0 )
#define unput(c) yyunput( c, yyg->yytext_ptr , yyscanner )

#ifndef YY_STRUCT_YY_BUFFER_STATE
#define YY_STRUCT_YY_BUFFER_STATE
struct yy_buffer_state
	{
	FILE *yy_input_file;

	char *yy_ch_buf;		/* input buffer */
	char *yy_buf_pos;		/* current position in input buffer */

	/* Size of input buffer in bytes, not including room for EOB
	 * characters.
	 */
	int yy_buf_size;

	/* Number of characters read into yy_ch_buf, not including EOB
	 * characters.
	 */
	int yy_n_chars;

	/* Whether we "own" the buffer - i.e., we know we created it,
	 * and can realloc() it to grow it, and should free() it to
	 * delete it.
	 */
	int yy_is_our_buffer;

	/* Whether this is an "interactive" input source; if so, and
	 * if we're using stdio for input, then we want to use getc()
	 * instead of fread(), to make sure we stop fetching input after
	 * each newline.
	 */
	int yy_is_interactive;

	/* Whether we're considered to be at the beginning of a line.
	 * If so, '^' rules will be active on the next match, otherwise
	 * not.
	 */
	int yy_at_bol;

    int yy_bs_lineno; /**< The line count. */
    int yy_bs_column; /**< The column count. */

	/* Whether to try to fill the input buffer when we reach the
	 * end of it.
	 */
	int yy_fill_buffer;

	int yy_buffer_status;

#define YY_BUFFER_NEW 0
#define YY_BUFFER_NORMAL 1
	/* When an EOF's been seen but there's still some text to process
	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
	 * shouldn't try reading from the input source any more.  We might
	 * still have a bunch of tokens to match, though, because of
	 * possible backing-up.
	 *
	 * When we actually see the EOF, we change the status to "new"
	 * (via yyrestart()), so that the user can continue scanning by
	 * just pointing yyin at a new input file.
	 */
#define YY_BUFFER_EOF_PENDING 2

	};
#endif /* !YY_STRUCT_YY_BUFFER_STATE */

/* We provide macros for accessing buffer states in case in the
 * future we want to put the buffer states in a more general
 * "scanner state".
 *
 * Returns the top of the stack, or NULL.
 */
#define YY_CURRENT_BUFFER ( yyg->yy_buffer_stack \
                          ? yyg->yy_buffer_stack[yyg->yy_buffer_stack_top] \
                          : NULL)
/* Same as previous macro, but useful when we know that the buffer stack is not
 * NULL or when we need an lvalue. For internal use only.
 */
#define YY_CURRENT_BUFFER_LVALUE yyg->yy_buffer_stack[yyg->yy_buffer_stack_top]

void yyrestart ( FILE *input_file , yyscan_t yyscanner );
void yy_switch_to_buffer ( YY_BUFFER_STATE new_buffer , yyscan_t yyscanner );
YY_BUFFER_STATE yy_create_buffer ( FILE *file, int size , yyscan_t yyscanner );
void yy_delete_buffer ( YY_BUFFER_STATE b , yyscan_t yyscanner );
void yy_flush_buffer ( YY_BUFFER_STATE b , yyscan_t yyscanner );
void yypush_buffer_state ( YY_BUFFER_STATE new_buffer , yyscan_t yyscanner );
void yypop_buffer_state ( yyscan_t yyscanner );

static void yyensure_buffer_stack ( yyscan_t yyscanner );
static void yy_load_buffer_state ( yyscan_t yyscanner );
static void yy_init_buffer ( YY_BUFFER_STATE b, FILE *file , yyscan_t yyscanner );
#define YY_FLUSH_BUFFER yy_flush_buffer( YY_CURRENT_BUFFER , yyscanner)

YY_BUFFER_STATE yy_scan_buffer ( char *base, yy_size_t size , yyscan_t yyscanner );
YY_BUFFER_STATE yy_scan_string ( const char *yy_str , yyscan_t yyscanner );
YY_BUFFER_STATE yy_scan_bytes ( const char *bytes, int len , yyscan_t yyscanner );

void *yyalloc ( yy_size_t , yyscan_t yyscanner );
void *yyrealloc ( void *, yy_size_t , yyscan_t yyscanner );
void yyfree ( void * , yyscan_t yyscanner );

#define yy_new_buffer yy_create_buffer
#define yy_set_interactive(is_interactive) \
	{ \
	if ( ! YY_CURRENT_BUFFER ){ \
        yyensure_buffer_stack (yyscanner); \
		YY_CURRENT_BUFFER_LVALUE =    \
            yy_create_buffer( yyin, YY_BUF_SIZE , yyscanner); \
	} \
	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
	}
#define yy_set_bol(at_bol) \
	{ \
	if ( ! YY_CURRENT_BUFFER ){\
        yyensure_buffer_stack (yyscanner); \
		YY_CURRENT_BUFFER_LVALUE =    \
            yy_create_buffer( yyin, YY_BUF_SIZE , yyscanner); \
	} \
	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
	}
#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)

/* Begin user sect3 */

#define preYYwrap(yyscanner) (/*CONSTCOND*/1)
#define YY_SKIP_YYWRAP
typedef flex_uint8_t YY_CHAR;

typedef int yy_state_type;

#define yytext_ptr yytext_r

static yy_state_type yy_get_previous_state ( yyscan_t yyscanner );
static yy_state_type yy_try_NUL_trans ( yy_state_type current_state  , yyscan_t yyscanner);
static int yy_get_next_buffer ( yyscan_t yyscanner );
static void yynoreturn yy_fatal_error ( const char* msg , yyscan_t yyscanner );

/* Done after the current pattern has been matched and before the
 * corresponding action - sets up yytext.
 */
#define YY_DO_BEFORE_ACTION \
	yyg->yytext_ptr = yy_bp; \
	yyleng = (int) (yy_cp - yy_bp); \
	yyg->yy_hold_char = *yy_cp; \
	*yy_cp = '\0'; \
	yyg->yy_c_buf_p = yy_cp;
#define YY_NUM_RULES 246
#define YY_END_OF_BUFFER 247
/* This struct is not used in this scanner,
   but its presence is necessary. */
struct yy_trans_info
	{
	flex_int32_t yy_verify;
	flex_int32_t yy_nxt;
	};
static const flex_int16_t yy_acclist[1888] =
    {   0,
      146,  146,  229,  229,  247,  245,  246,    1,  245,  246,
      244,  246,    3,  245,  246,  245,  246,  245,  246,    2,
      245,  246,   13,  245,  246,    1,   13,  245,  246,   13,
      245,  246,   13,  244,  246,    3,   13,  245,  246,    5,
      245,  246,   13,  245,  246,   13,  245,  246,   13,  245,
      246,   13,  245,  246,   13,  245,  246,   13,  245,  246,
        2,   13,  245,  246,   86,  245,  246,    1,   86,  245,
      246,   81,  244,  246,    3,   86,  245,  246,   86,  245,
      246,   86,  245,  246,   83,   86,  245,  246,   83,   86,
      245,  246,   83,   86,  245,  246,   83,   86,  245,  246,

       83,   86,  245,  246,   83,   86,  245,  246,   83,   86,
      245,  246,    2,   86,  245,  246,  121,  245,  246,    1,
      121,  245,  246,  119,  244,  246,    3,  121,  245,  246,
      121,  245,  246,  121,  245,  246,  120,  121,  245,  246,
      120,  121,  245,  246,  120,  121,  245,  246,    2,  121,
      245,  246,  122,  125,  245,  246,    1,  122,  125,  245,
      246,  130,  244,  246,    3,  122,  125,  245,  246,  124,
      125,  245,  246,  125,  245,  246,  125,  245,  246,  122,
      125,  245,  246,    2,  122,  125,  245,  246,  131,  134,
      245,  246,    1,  131,  134,  245,  246,    3,  131,  134,

      245,  246,  133,  134,  245,  246,  131,  134,  245,  246,
      131,  134,  245,  246,  134,  245,  246,    2,  131,  134,
      245,  246,   47,  245,  246,    1,   47,  245,  246,   48,
      244,  246,    3,   47,  245,  246,   28,   47,  245,  246,
       29,   47,  245,  246,   47,  245,  246,   47,  245,  246,
       47,  245,  246,   44,   47,  245,  246,16427,   44,   47,
      245,  246,16427,   44,   47,  245,  246,16427,   47,  245,
      246,   44,   47,  245,  246,16427,   44,   47,  245,  246,
    16427,   21,   47,  245,  246,   23,   47,  245,  246,    2,
       47,  245,  246,   47,  245,  246,   30,  245,  246,    1,

       30,  245,  246,   33,  245,  246,   30,  245,  246,   30,
      245,  246,  245,  246,    2,   30,  245,  246,   31,  245,
      246,    1,   31,  245,  246,   31,  245,  246,   31,  245,
      246,    2,   31,  245,  246,   37,  245,  246,    1,   37,
      245,  246,   39,  245,  246,   37,  245,  246,   37,  245,
      246,  245,  246,    2,   37,  245,  246,   34,  245,  246,
        1,   34,  245,  246,   36,  245,  246,   34,  245,  246,
       34,  245,  246,  245,  246,    2,   34,  245,  246,   41,
       42,  245,  246,    1,   41,   42,  245,  246,   41,  244,
      246,    3,   41,   42,  245,  246,   42,  245,  246,   41,

       42,  245,  246,   41,   42,  245,  246,    2,   41,   42,
      245,  246,  245,  246,    1,  245,  246,    3,  245,  246,
      245,  246,  245,  246,    2,  245,  246,  136,  245,  246,
      140,  245,  246,    1,  140,  245,  246,  138,  244,  246,
        3,  140,  245,  246,  140,  245,  246,  140,  245,  246,
      140,  245,  246,    2,  140,  245,  246, 8336,  245,  246,
    16525,16527,16528,  146,  245,  246,  148,  245,  246,  149,
      245,  246,  147,  245,  246,  245,  246,  151,  245,  246,
      245,  246,  240,  245,  246,    1,  240,  245,  246,  229,
      240,  245,  246,  228,  244,  246,    3,  240,  245,  246,

      232,  240,  245,  246,  240,  245,  246,  233,  240,  245,
      246,  240,  245,  246,  240,  245,  246,  231,  240,  245,
      246,  225,  240,  245,  246,  240,  245,  246,    2,  240,
      245,  246,  114,  245,  246,    1,  114,  245,  246,  113,
      244,  246,    3,  114,  245,  246,  114,  245,  246,  114,
      245,  246,    2,  114,  245,  246,  112,  114,  245,  246,
        1,  112,  114,  245,  246,  112,  114,  245,  246,  112,
      113,  244,  246,    3,  112,  114,  245,  246,  111,  114,
      245,  246,  112,  114,  245,  246,  112,  114,  245,  246,
        2,  112,  114,  245,  246,  199,  202,  245,  246,    1,

      202,  245,  246,  200,  244,  246,    3,  199,  202,  245,
      246,  202,  245,  246,  202,  245,  246,  199,  202,  245,
      246,  202,  245,  246,  202,  245,  246,  202,  245,  246,
        2,  199,  202,  245,  246,  199,  202,  245,  246,  202,
      245,  246,  202,  245,  246,  202,  245,  246,   58,   61,
      245,  246,    1,   58,   61,  245,  246,   60,  244,  246,
        3,   58,   61,  245,  246,   61,  245,  246,   58,   61,
      245,  246,   58,   61,  245,  246,    2,   58,   61,  245,
      246,  203,  226,  245,  246,    1,  203,  226,  245,  246,
      206,  244,  246,    3,  203,  226,  245,  246,  226,  245,

      246,  203,  226,  245,  246,  203,  226,  245,  246,  225,
      226,  245,  246,  226,  245,  246,    2,  203,  226,  245,
      246,  202,  245,  246,  202,  245,  246,  202,  245,  246,
      199,  202,  245,  246,  202,  245,  246,  202,  245,  246,
      202,  245,  246,  198,  201,  245,  246,    1,  201,  245,
      246,    3,  198,  201,  245,  246,  201,  245,  246,  201,
      245,  246,  198,  201,  245,  246,  201,  245,  246,  201,
      245,  246,    2,  198,  201,  245,  246,  198,  201,  245,
      246,  201,  245,  246,  201,  245,  246,  201,  245,  246,
      214,  218,  219,  245,  246,    1,  214,  219,  245,  246,

      215,  244,  246,    3,  214,  218,  219,  245,  246,  218,
      219,  245,  246,  214,  218,  219,  245,  246,  219,  245,
      246,    2,  214,  218,  219,  245,  246,  197,  245,  246,
        1,  197,  245,  246,  196,  244,  246,    3,  197,  245,
      246,  197,  245,  246,  197,  245,  246,  194,  197,  245,
      246,  195,  197,  245,  246,    2,  197,  245,  246,  211,
      213,  245,  246,    1,  213,  245,  246,  212,  244,  246,
        3,  211,  213,  245,  246,  213,  245,  246,  211,  213,
      245,  246,  211,  213,  245,  246,    2,  211,  213,  245,
      246,  222,  223,  245,  246,    1,  223,  245,  246,    3,

      222,  223,  245,  246,  222,  223,  245,  246,  222,  223,
      245,  246,    2,  222,  223,  245,  246,  103,  245,  246,
        1,  103,  245,  246,  104,  244,  246,    3,  103,  245,
      246,  103,  245,  246,  103,  245,  246,  102,  103,  245,
      246,  101,  103,  245,  246,  103,  245,  246,  101,  103,
      245,  246,  101,  103,  245,  246,  101,  103,  245,  246,
      101,  103,  245,  246,  101,  103,  245,  246,  101,  103,
      245,  246,  101,  103,  245,  246,  101,  103,  245,  246,
      101,  103,  245,  246,    2,  103,  245,  246,  110,  245,
      246,    1,  110,  245,  246,  108,  244,  246,    3,  110,

      245,  246,  110,  245,  246,  110,  245,  246,  106,  110,
      245,  246,  110,  245,  246,    2,  110,  245,  246,  109,
      110,  245,  246,  107,  110,  245,  246,  239,  245,  246,
        1,  239,  245,  246,    3,  239,  245,  246,  236,  239,
      245,  246,  239,  245,  246,  239,  245,  246,  239,  245,
      246,    2,  239,  245,  246,  238,  239,  245,  246,  239,
      245,  246,   87,  245,  246,   85,  245,  246,    1,   85,
      245,  246,    3,   85,  245,  246,   85,  245,  246,   85,
      245,  246,   85,  245,  246,    2,   85,  245,  246,   57,
      245,  246,    1,   57,  245,  246,   55,  244,  246,    3,

       57,  245,  246,   53,   57,  245,  246,   54,   57,  245,
      246,   49,   57,  245,  246,   50,   57,  245,  246,   57,
      245,  246,   57,  245,  246,   56,   57,  245,  246,    2,
       57,  245,  246,   67,  245,  246,    1,   67,  245,  246,
        3,   67,  245,  246,   62,   67,  245,  246,   63,   67,
      245,  246,   67,  245,  246,   67,  245,  246,   67,  245,
      246,    2,   67,  245,  246,  174,  245,  246,    1,  174,
      245,  246,  173,  174,  245,  246,    3,  174,  245,  246,
      174,  245,  246,  174,  245,  246,    2,  174,  245,  246,
      179,  180,  245,  246,    1,  179,  180,  245,  246,  176,

      244,  246,    3,  179,  180,  245,  246,  179,  245,  246,
      179,  245,  246,  179,  180,  245,  246,  179,  245,  246,
        2,  179,  180,  245,  246,  179,  180,  245,  246,  179,
      245,  246,  179,  180,  245,  246,  179,  180,  245,  246,
       12,  245,  246,    1,   12,  245,  246,   11,  244,  246,
        3,   12,  245,  246,   12,  245,  246,   12,  245,  246,
       12,  245,  246,   12,  245,  246,    2,   12,  245,  246,
      242,  243,   13,   13,    5,   13,   13,   13,    6,   83,
       83,   83,   83,   83,   83,   83,   83,   83,   83,  129,
      242,  127,  243,  120,  120,  120,  120,  122,  122,  131,

      128,  131,  242,  126,  131,  243,  131,  132,   27, 8235,
       44,16427,   44,16427,   46,   45,   46,   44,16427,   44,
    16427,   22,   30,   30,  242,   30,  243,   30,   32,   31,
       31,  242,   31,  243,   31,   37,   37,  242,   37,  243,
       37,   38,   34,   34,  242,   34,  243,   34,   35,   41,
       40,   41,  242,   41,  243,   41,  137,  242,  243,  135,
      136,  138,  242,  243,  139, 8336, 8335, 8333, 8336,16525,
    16527,16528,  146,  149,  148,  149,  147,  151,  151,  145,
      229,  230,  224,  152,  242,  153,  243,  225,  227,  112,
      112,  111,  199,  154,  156,  242,  155,  243,  199,  199,

       58,   59,   58,  243,   58,  203,  205,  203,  243,  203,
      204,  203,  193,  193,  242,  199,  198,  192,  192,  242,
      198,  198,  214,  218,  214,  218,  216,  218,  242,  217,
      218,  243,  214,  218,  211,  208,  210,  242,  209,  211,
      243,  211,  222,  220,  222,  242,  221,  222,  243,  222,
      101,   88,  101,  101,  101,  101,  101,  101,  101,  101,
      101,  106,  105,  107,  235,  242,  234,  243,  237,   87,
       84,   52,  242,   64,  242,   64,  243,   66,   65,   66,
      173,  180,  242,  243,  180,  157,  180,  180,  180,  180,
      180,   10,    9,    8,  242,  242,  243,    4,   83,   83,

       83,   83,   83,   75,   83,   83,   83,   83,   83,   83,
      129,  129,  242,  129,  242,  127,  127,  243,  120,  120,
      120,  115,  120,  120,  123,    4,  122,  128,  131,  128,
      131,  242,  128,  128,  131,  242,  126,  131,  126,  131,
      243,  126,    4,  131,   26,   26,   20,   44,16427,   30,
      242,   30,  242,   30,  243,    4,   30,   31,  242,   31,
      242,   31,  243,    4,   31,   37,  242,   37,  242,   37,
      243,    4,   37,   34,  242,   34,  242,   34,  243,    4,
       34,   40,   41,  242,   41,  242,   41,  243,    4,   41,
      242,  242,  243,    4,    4,  137,  242,  242,  243,    4,

      150,  230,  152,  242,  152,  242,  153,  243,  155,  243,
        4,  199,  165,  199,  161,  160,   58,  243,    4,   58,
      203,  243,    4,  203,  187,  199,  191,  190,    4,  198,
      186,  198,  189,  188,  218,  242,  218,  242,  218,  243,
        4,  214,  218,    4,  218,  207,  211,  243,    4,  211,
      222,  242,  222,  242,  222,  243,    4,  222,  101,  101,
      101,  101,  101,  101,   96,  101,  101,  235,  242,  234,
      243,   51,   52,  242,  182,  242,  182,  242,  181,  243,
        4,  180,  178,  180,  159,  180,  158,  180,  241,16398,
    16402,16398,   83,   83,   83,   83,   83,   83,   83,   83,

       83,   83,   83,  129,  241,  120,  116,  120,  120,  120,
      123,  128,  131,  241,   25,   24,   25,   44,16427,   30,
      241,   31,  241,   37,  241,   34,  241,   40,   41,  241,
      241,  241,  142,  151,  155,  163,  199,  161,  160,  199,
      191,  190,  198,  189,  188,  218,  241,  222,  241,   95,
      101,  101,  101,  101,  101,   93,  101,  101,   99,   51,
      180,  159,  158,  159,  180,  158,  180,16398,16402,   16,
     8206,   83,   83,   76,   79,   77,   77,   83,   83,   83,
       83,   83,   83,   83,   83,  117,  120,  118,  120,  120,
       24,   44,16427,   40,  165,  101,  101,  101,  101,  101,

      101,   91,   91,  178,  159,  158,16401, 8206,   16, 8210,
       83,   83,   80,   72,   71,   83,   83,   83,   83,   78,
       44,16427,   40,  163,  172,  175,  171,  101,   98,  100,
      101,   92,   92,  101,  167,   15, 8210,   16,   70,   74,
       73,16452,   69,   40,  170,  162,  164,  168,  187,  186,
       97,  101,   94,  166,  177, 8209,   16, 8260,   40,   90,
       89,   16, 8260,   19,   40,  185,  184,   16,   19,   19,
       40,  183,  169,   16,    7,   82,   40,   16,   40,   16,
       40,   16,   40,   40,   40,   40,   40
    } ;

static const flex_int16_t yy_accept[1700] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    2,    3,    4,    5,    5,
        5,    5,    5,    5,    5,    5,    5,    5,    5,    5,
        5,    5,    5,    5,    5,    5,    5,    5,    5,    5,
        5,    5,    5,    5,    5,    5,    5,    5,    5,    5,
        5,    5,    5,    5,    5,    5,    5,    5,    5,    5,
        5,    5,    5,    5,    5,    6,    8,   11,   13,   16,
       18,   20,   23,   26,   30,   33,   36,   40,   43,   46,

       49,   52,   55,   58,   61,   65,   68,   72,   75,   79,
       82,   85,   89,   93,   97,  101,  105,  109,  113,  117,
      120,  124,  127,  131,  134,  137,  141,  145,  149,  153,
      157,  162,  165,  170,  174,  177,  180,  184,  189,  193,
      198,  203,  207,  211,  215,  218,  223,  226,  230,  233,
      237,  241,  245,  248,  251,  254,  259,  264,  269,  272,
      277,  282,  286,  290,  294,  297,  300,  304,  307,  310,
      313,  315,  319,  322,  326,  329,  332,  336,  339,  343,
      346,  349,  352,  354,  358,  361,  365,  368,  371,  374,
      376,  380,  384,  389,  392,  397,  400,  404,  408,  413,

      415,  418,  421,  423,  425,  428,  431,  434,  438,  441,
      445,  448,  451,  454,  458,  464,  467,  470,  473,  476,
      478,  481,  483,  486,  490,  494,  497,  501,  505,  508,
      512,  515,  518,  522,  526,  529,  533,  536,  540,  543,
      547,  550,  553,  557,  561,  566,  570,  574,  579,  583,
      587,  591,  596,  600,  604,  607,  612,  615,  618,  622,
      625,  628,  631,  636,  640,  643,  646,  649,  653,  658,
      661,  666,  669,  673,  677,  682,  686,  691,  694,  699,
      702,  706,  710,  714,  717,  722,  725,  728,  731,  735,
      738,  741,  744,  748,  752,  757,  760,  763,  767,  770,

      773,  778,  782,  785,  788,  791,  796,  801,  804,  810,
      814,  819,  822,  828,  831,  835,  838,  842,  845,  848,
      852,  856,  860,  864,  868,  871,  876,  879,  883,  887,
      892,  896,  900,  905,  909,  913,  918,  921,  925,  928,
      932,  935,  938,  942,  946,  949,  953,  957,  961,  965,
      969,  973,  977,  981,  985,  989,  992,  996,  999, 1003,
     1006, 1009, 1013, 1016, 1020, 1024, 1028, 1031, 1035, 1039,
     1043, 1046, 1049, 1052, 1056, 1060, 1063, 1066, 1069, 1073,
     1077, 1080, 1083, 1086, 1090, 1093, 1097, 1100, 1104, 1108,
     1112, 1116, 1120, 1123, 1126, 1130, 1134, 1137, 1141, 1145,

     1149, 1153, 1156, 1159, 1162, 1166, 1169, 1173, 1177, 1181,
     1184, 1187, 1191, 1195, 1200, 1203, 1208, 1211, 1214, 1218,
     1221, 1226, 1230, 1233, 1237, 1241, 1244, 1248, 1251, 1255,
     1258, 1261, 1264, 1267, 1271, 1272, 1273, 1273, 1274, 1275,
     1276, 1277, 1278, 1279, 1279, 1280, 1280, 1280, 1280, 1281,
     1282, 1283, 1284, 1285, 1286, 1287, 1288, 1289, 1290, 1292,
     1294, 1295, 1296, 1297, 1298, 1299, 1299, 1299, 1300, 1301,
     1304, 1307, 1308, 1309, 1309, 1309, 1310, 1310, 1311, 1313,
     1315, 1315, 1316, 1317, 1318, 1320, 1322, 1323, 1324, 1326,
     1328, 1329, 1330, 1331, 1333, 1335, 1336, 1337, 1339, 1341,

     1342, 1343, 1344, 1346, 1348, 1349, 1350, 1351, 1351, 1352,
     1354, 1356, 1357, 1357, 1358, 1359, 1360, 1360, 1360, 1361,
     1362, 1362, 1363, 1364, 1365, 1365, 1366, 1366, 1367, 1368,
     1369, 1373, 1373, 1374, 1375, 1376, 1377, 1378, 1378, 1379,
     1379, 1380, 1381, 1382, 1382, 1383, 1384, 1386, 1388, 1389,
     1390, 1390, 1391, 1392, 1393, 1394, 1395, 1397, 1399, 1400,
     1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400, 1400,
     1400, 1400, 1400, 1400, 1400, 1400, 1401, 1401, 1401, 1401,
     1401, 1401, 1401, 1402, 1403, 1405, 1406, 1407, 1407, 1408,
     1410, 1411, 1412, 1413, 1414, 1416, 1416, 1416, 1417, 1417,

     1417, 1417, 1417, 1417, 1417, 1418, 1419, 1421, 1422, 1422,
     1422, 1423, 1423, 1423, 1423, 1423, 1423, 1423, 1425, 1426,
     1427, 1430, 1433, 1435, 1435, 1435, 1436, 1437, 1439, 1442,
     1443, 1444, 1447, 1450, 1451, 1452, 1453, 1453, 1454, 1455,
     1456, 1457, 1458, 1459, 1460, 1461, 1462, 1463, 1464, 1465,
     1467, 1469, 1470, 1471, 1472, 1472, 1472, 1472, 1474, 1476,
     1478, 1479, 1480, 1481, 1482, 1483, 1484, 1485, 1486, 1487,
     1487, 1487, 1487, 1487, 1487, 1487, 1487, 1487, 1487, 1487,
     1487, 1487, 1487, 1488, 1488, 1489, 1490, 1490, 1490, 1490,
     1491, 1492, 1492, 1493, 1494, 1495, 1496, 1497, 1498, 1499,

     1499, 1499, 1499, 1499, 1499, 1499, 1500, 1501, 1502, 1503,
     1504, 1505, 1506, 1507, 1508, 1509, 1510, 1511, 1512, 1514,
     1516, 1517, 1519, 1520, 1521, 1522, 1523, 1524, 1525, 1525,
     1526, 1526, 1526, 1528, 1530, 1533, 1534, 1537, 1539, 1542,
     1543, 1545, 1546, 1546, 1547, 1547, 1547, 1547, 1548, 1550,
     1552, 1554, 1556, 1558, 1560, 1562, 1564, 1566, 1568, 1570,
     1572, 1574, 1576, 1578, 1580, 1582, 1582, 1583, 1585, 1587,
     1589, 1591, 1592, 1593, 1594, 1595, 1597, 1598, 1599, 1600,
     1601, 1601, 1601, 1602, 1602, 1603, 1605, 1607, 1609, 1611,
     1613, 1613, 1613, 1613, 1613, 1613, 1613, 1613, 1613, 1613,

     1613, 1613, 1613, 1613, 1613, 1613, 1613, 1614, 1614, 1614,
     1614, 1614, 1614, 1614, 1614, 1614, 1614, 1614, 1614, 1614,
     1615, 1615, 1616, 1617, 1619, 1621, 1623, 1625, 1625, 1626,
     1627, 1627, 1628, 1629, 1631, 1631, 1632, 1633, 1633, 1634,
     1635, 1637, 1639, 1641, 1644, 1646, 1646, 1646, 1646, 1647,
     1649, 1651, 1653, 1655, 1657, 1659, 1660, 1661, 1662, 1663,
     1664, 1665, 1666, 1667, 1668, 1670, 1672, 1672, 1673, 1673,
     1673, 1675, 1677, 1679, 1681, 1683, 1683, 1683, 1683, 1683,
     1684, 1684, 1684, 1684, 1684, 1684, 1684, 1684, 1684, 1684,
     1684, 1685, 1685, 1685, 1685, 1687, 1689, 1690, 1690, 1690,

     1690, 1692, 1692, 1693, 1693, 1694, 1695, 1696, 1697, 1698,
     1699, 1700, 1701, 1702, 1703, 1704, 1706, 1707, 1709, 1710,
     1711, 1711, 1712, 1712, 1715, 1716, 1718, 1718, 1718, 1718,
     1720, 1722, 1724, 1726, 1728, 1728, 1729, 1731, 1732, 1733,
     1734, 1735, 1736, 1736, 1736, 1736, 1737, 1737, 1737, 1737,
     1737, 1737, 1737, 1737, 1737, 1737, 1737, 1737, 1737, 1737,
     1737, 1737, 1737, 1737, 1737, 1737, 1737, 1737, 1737, 1737,
     1737, 1737, 1737, 1738, 1738, 1739, 1740, 1740, 1741, 1741,
     1742, 1743, 1743, 1744, 1744, 1745, 1746, 1748, 1748, 1748,
     1750, 1751, 1752, 1753, 1754, 1755, 1756, 1757, 1758, 1759,

     1760, 1760, 1761, 1761, 1761, 1761, 1761, 1761, 1761, 1761,
     1761, 1761, 1761, 1761, 1761, 1761, 1761, 1761, 1761, 1762,
     1762, 1763, 1764, 1766, 1768, 1768, 1770, 1770, 1771, 1771,
     1771, 1772, 1772, 1773, 1774, 1776, 1777, 1778, 1779, 1780,
     1781, 1782, 1783, 1784, 1785, 1786, 1787, 1787, 1788, 1790,
     1791, 1791, 1791, 1792, 1792, 1792, 1792, 1794, 1794, 1795,
     1795, 1795, 1795, 1795, 1795, 1795, 1795, 1795, 1795, 1795,
     1795, 1795, 1795, 1795, 1795, 1795, 1795, 1796, 1796, 1796,
     1796, 1796, 1796, 1796, 1796, 1796, 1796, 1796, 1796, 1796,
     1796, 1796, 1796, 1796, 1796, 1796, 1796, 1796, 1796, 1796,

     1796, 1796, 1796, 1796, 1796, 1796, 1796, 1796, 1796, 1796,
     1796, 1797, 1798, 1799, 1800, 1801, 1802, 1803, 1804, 1804,
     1804, 1804, 1804, 1804, 1804, 1804, 1805, 1805, 1805, 1805,
     1805, 1805, 1805, 1805, 1805, 1805, 1805, 1806, 1807, 1807,
     1807, 1807, 1808, 1808, 1809, 1809, 1810, 1810, 1811, 1811,
     1812, 1813, 1813, 1813, 1814, 1815, 1816, 1817, 1818, 1819,
     1820, 1821, 1821, 1821, 1821, 1823, 1823, 1824, 1824, 1824,
     1824, 1825, 1825, 1825, 1825, 1825, 1825, 1825, 1825, 1825,
     1825, 1825, 1825, 1826, 1827, 1827, 1827, 1827, 1827, 1827,
     1827, 1827, 1827, 1827, 1827, 1827, 1827, 1827, 1827, 1827,

     1827, 1827, 1827, 1827, 1827, 1827, 1827, 1827, 1827, 1827,
     1827, 1827, 1827, 1827, 1827, 1827, 1827, 1827, 1827, 1827,
     1827, 1828, 1829, 1830, 1831, 1832, 1833, 1834, 1834, 1835,
     1835, 1835, 1835, 1836, 1836, 1836, 1836, 1836, 1836, 1836,
     1836, 1836, 1836, 1836, 1836, 1836, 1836, 1836, 1837, 1837,
     1838, 1838, 1839, 1839, 1839, 1840, 1840, 1841, 1842, 1843,
     1844, 1844, 1844, 1844, 1844, 1844, 1844, 1844, 1845, 1845,
     1846, 1846, 1846, 1846, 1846, 1846, 1846, 1847, 1847, 1847,
     1847, 1847, 1847, 1847, 1847, 1847, 1847, 1847, 1847, 1847,
     1847, 1847, 1848, 1848, 1848, 1848, 1848, 1849, 1849, 1849,

     1849, 1850, 1850, 1850, 1850, 1850, 1850, 1850, 1850, 1850,
     1850, 1851, 1851, 1851, 1851, 1851, 1851, 1851, 1851, 1852,
     1853, 1853, 1854, 1855, 1855, 1855, 1855, 1855, 1855, 1855,
     1855, 1855, 1855, 1855, 1856, 1856, 1856, 1856, 1856, 1856,
     1856, 1857, 1857, 1858, 1858, 1858, 1859, 1859, 1859, 1859,
     1859, 1859, 1859, 1860, 1860, 1860, 1860, 1860, 1860, 1860,
     1860, 1860, 1860, 1860, 1860, 1860, 1860, 1860, 1860, 1860,
     1860, 1860, 1860, 1860, 1860, 1860, 1860, 1860, 1860, 1860,
     1860, 1860, 1860, 1860, 1860, 1860, 1860, 1860, 1860, 1860,
     1861, 1862, 1862, 1862, 1862, 1862, 1862, 1862, 1862, 1862,

     1862, 1862, 1863, 1863, 1863, 1864, 1864, 1864, 1864, 1864,
     1865, 1865, 1866, 1866, 1866, 1866, 1866, 1866, 1866, 1866,
     1866, 1867, 1867, 1867, 1867, 1867, 1867, 1867, 1867, 1867,
     1867, 1867, 1867, 1867, 1867, 1867, 1867, 1867, 1867, 1867,
     1867, 1868, 1868, 1868, 1868, 1868, 1869, 1869, 1869, 1869,
     1869, 1869, 1869, 1869, 1870, 1871, 1871, 1872, 1872, 1873,
     1873, 1873, 1874, 1874, 1874, 1874, 1874, 1874, 1874, 1874,
     1874, 1874, 1874, 1874, 1874, 1874, 1874, 1874, 1874, 1874,
     1874, 1874, 1874, 1875, 1875, 1875, 1876, 1877, 1877, 1877,
     1877, 1877, 1878, 1878, 1878, 1878, 1878, 1878, 1878, 1878,

     1878, 1878, 1878, 1878, 1878, 1878, 1878, 1878, 1878, 1879,
     1879, 1879, 1879, 1879, 1879, 1880, 1880, 1880, 1880, 1880,
     1880, 1880, 1880, 1880, 1881, 1881, 1881, 1881, 1881, 1881,
     1882, 1882, 1882, 1882, 1882, 1882, 1883, 1883, 1883, 1883,
     1883, 1883, 1884, 1884, 1884, 1884, 1884, 1884, 1884, 1884,
     1884, 1885, 1885, 1885, 1885, 1885, 1886, 1886, 1886, 1886,
     1886, 1887, 1887, 1887, 1887, 1888, 1888, 1888, 1888, 1888,
     1888, 1888, 1888, 1888, 1888, 1888, 1888, 1888, 1888, 1888,
     1888, 1888, 1888, 1888, 1888, 1888, 1888, 1888, 1888, 1888,
     1888, 1888, 1888, 1888, 1888, 1888, 1888, 1888, 1888, 1888,

     1888, 1888, 1888, 1888, 1888, 1888, 1888, 1888, 1888, 1888,
     1888, 1888, 1888, 1888, 1888, 1888, 1888, 1888, 1888, 1888,
     1888, 1888, 1888, 1888, 1888, 1888, 1888, 1888, 1888, 1888,
     1888, 1888, 1888, 1888, 1888, 1888, 1888, 1888, 1888, 1888,
     1888, 1888, 1888, 1888, 1888, 1888, 1888, 1888, 1888, 1888,
     1888, 1888, 1888, 1888, 1888, 1888, 1888, 1888, 1888, 1888,
     1888, 1888, 1888, 1888, 1888, 1888, 1888, 1888, 1888, 1888,
     1888, 1888, 1888, 1888, 1888, 1888, 1888, 1888, 1888, 1888,
     1888, 1888, 1888, 1888, 1888, 1888, 1888, 1888, 1888, 1888,
     1888, 1888, 1888, 1888, 1888, 1888, 1888, 1888, 1888

    } ;

static const YY_CHAR yy_ec[256] =
    {   0,
        1,    1,    1,    1,    1,    2,    1,    1,    3,    4,
        1,    1,    5,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    3,    6,    7,    8,    9,   10,   11,   12,   13,
       14,   15,    1,   16,   17,   18,   19,   20,   21,   20,
       20,   20,   20,   20,   20,   22,   23,   24,    1,   25,
       26,   27,   28,   29,   30,   30,   30,   30,   30,   30,
       30,   30,   30,   30,   30,   31,   30,   30,   30,   30,
       30,   32,   30,   30,   33,   30,   30,   30,   30,   30,
       34,   35,   36,    1,   37,   38,   39,   40,   41,   42,

       43,   44,   45,   46,   47,   48,   49,   50,   51,   52,
       53,   54,   55,   56,   57,   58,   59,   60,   48,   61,
       62,   48,   63,   11,   64,   65,    1,   48,   48,   48,
       48,   48,   48,   48,   48,   48,   48,   48,   48,   48,
       48,   48,   48,   48,   48,   48,   48,   48,   48,   48,
       48,   48,   48,   48,   48,   48,   48,   48,   48,   48,
       48,   48,   48,   48,   48,   48,   48,   48,   48,   48,
       48,   48,   48,   48,   48,   48,   48,   48,   48,   48,
       48,   48,   48,   48,   48,   48,   48,   48,   48,   48,
       48,   48,   48,   48,   48,   48,   48,   48,   48,   48,

       48,   48,   48,   48,   48,   48,   48,   48,   48,   48,
       48,   48,   48,   48,   48,   48,   48,   48,   48,   48,
       48,   48,   48,   48,   48,   48,   48,   48,   48,   48,
       48,   48,   48,   48,   48,   48,   48,   48,   48,   48,
       48,   48,   48,   48,   48,   48,   48,   48,   48,   48,
       48,   48,   48,   48,   48
    } ;

static const YY_CHAR yy_meta[67] =
    {   0,
        1,    2,    3,    4,    5,    6,    7,    8,    1,    1,
        9,   10,   11,   12,   13,    1,    9,   14,   15,   16,
       16,   16,   16,    1,   17,    1,    1,    1,   18,   19,
       19,   19,   19,    1,   20,    1,   19,   21,   19,   19,
       19,   19,   19,   19,   19,   19,   19,   19,   19,   19,
       19,   19,   19,   19,   19,   19,   19,   19,   19,   19,
       19,   19,   21,    1,   21,    1
    } ;

static const flex_int16_t yy_base[1908] =
    {   0,
        0,    4,    8,   74,  140,    0,  206,    0,  271,  275,
      291,  304,  370,    0,    0, 6315,  435,  439,  443,  471,
      475,  479,  511,  515,  519,  547,  551,  555,  621,    0,
      686,  690,  727,    0,  789,    0,  855,    0,  696,  920,
      985, 1050,  925,  930, 1116,    0, 1181, 1246, 1311, 1376,
      950,  990,  969,  979, 1042, 1186, 1193, 1213, 1442,    0,
     1508,    0, 1561,    0, 1235, 1286, 1323, 1622, 1659,    0,
     1267, 1364, 1720, 1785, 1628, 1739, 1851, 1917,    0,    0,
     1982, 2047, 1368, 1750, 6323, 7872, 7872, 7872, 7872,    1,
     6294, 7872, 7872, 7872, 2113, 7872, 7872, 7872,    0,    2,

     6289,   17,    0, 6262, 7872, 7872, 7872, 7872, 7872,    3,
     6286,    0, 6262, 6269,    1,    8, 6255, 6257, 7872, 7872,
     7872, 7872, 7872,   10, 6280,    0,    5, 6263, 7872,    0,
        0, 7872,    0, 7872, 6271,   11, 6277,    0,    0,    0,
        0, 7872,   16, 6272,    0,    0, 7872, 7872, 7872, 7872,
     7872, 6257,   26, 6255, 6272,  309,  312,  342,   10,  523,
      330, 7872, 7872, 7872, 6202,    0,    0, 7872,   27, 6235,
        0,    0,    0,    0,   46, 6214,    0,    0,    0, 7872,
       49, 6193,    0,    0,    0,    0, 7872,   52, 6172,    0,
        0,    0,    0,    0,    0, 6172,   54, 6141,    0,   17,

      274,  277,  321,  293,  278,   30, 6160, 6157, 7872, 6154,
      323,  303,  284, 6149,  453,  283, 6134, 6113, 6092, 6072,
      347, 6085, 7872, 7872,  321, 7872, 7872, 7872, 6079, 7872,
      339, 6058, 7872,    0,  287, 7872, 7872, 7872, 7872, 7872,
      341, 6057, 7872, 7872, 7872,  356, 7872, 7872, 7872,  348,
     6056, 7872,    0, 7872, 7872,    0, 6063,  434, 6053, 2151,
     7872,  435,    0,  529,  928, 6042, 6014,    0,    0, 7872,
        0, 6059,  436, 6049,    0, 6041, 6022, 7872, 6001, 6012,
      450,  333,    0,  507, 5994, 6007,  453,  416,  696,  961,
     5986, 5952,    0, 7872,    0, 5996,  467, 5982,  449, 7872,

        0, 1002, 1279, 5971, 5942,  487,    0, 7872,  506,  481,
      552,  557,  529, 7872, 7872, 7872, 7872,  549, 5977, 7872,
     7872, 7872,    0, 7872, 7872,    0, 5983,  550, 5972,    0,
        0, 7872,    0,  557, 5971,    0, 7872, 7872, 7872, 7872,
      572, 5969, 7872,    0,  584, 5944, 5930, 5919, 5913, 5896,
     5880, 5867, 5858, 5859, 7872, 7872, 7872, 7872, 7872,  578,
     5881,    0, 5903, 7872, 7872,    0, 7872, 7872, 7872, 7872,
      580, 5865,    0, 7872, 7872,  586,    0, 7872, 7872, 7872,
      587, 5863,  599, 7872, 7872, 7872, 7872, 7872, 7872, 5853,
     7872, 7872,  592, 5858, 7872, 7872, 7872, 7872, 7872, 7872,

     7872,  593, 5855,  605, 7872, 7872, 7872,    0, 7872,  599,
     5844, 7872,    0,    0, 7872,    0, 7872,  600, 5839, 2184,
        0, 1021, 1024, 5827, 5786, 7872, 7872, 7872, 7872,  526,
      601, 5818,   27, 7872,  446,  347,  714, 7872, 2245, 7872,
     1060,    0, 5789, 5788, 7872, 2309,  560,  690,    0, 5793,
     5786,  649, 5784,  959, 5766, 5770, 5760, 5748,  489,  683,
        0,  650, 5743, 1060,    0, 5770,  692, 1396,    0,  730,
      716, 1570, 7872, 5768,  696, 7872,  750, 7872,  933, 1091,
     5758, 7872, 7872, 5765, 1220, 1071, 7872,    0,  704,  723,
     1647, 7872,    0,  732,  724, 1805,    0,  927,  944, 1821,

     7872,    0,  945,  951, 1878, 7872,    0, 5738, 5737,  953,
      996, 1944,  934, 7872, 1022, 1201, 2341,  964, 7872, 1009,
     5738, 7872, 1095, 1002, 2365, 7872, 5736, 1190, 7872, 7872,
     1200, 5735, 1027, 5735, 5734, 5733, 5732, 5716, 1069, 5715,
     1181, 7872,  494, 5724, 5728, 7872, 1062, 1052,    0, 7872,
     5723, 7872, 1097, 7872,    0, 7872, 1247, 1183, 1979, 2352,
     5673, 5671, 5671, 1255, 5664, 5671, 5680,  312, 5665, 5659,
     5658, 5672, 5663,  953, 1181, 1242, 1282, 5672, 5624, 1235,
     5650, 5621,    0, 7872, 1224, 2001, 5650, 5649, 7872, 1313,
     2408, 7872,  999, 7872, 1221, 5631, 1320, 1321, 1347, 5643,

     5615, 1300, 5641, 5613,    0, 7872, 1252, 2017, 5625, 1622,
     1352, 1723, 5638, 5610, 1360, 5618, 5586,  730,    0,    0,
     1277, 1304, 2442,  705, 5590,    0, 1103, 1281, 1335, 2067,
        0, 1293, 1382, 2083,    0, 7872, 5638, 5592, 5564, 5558,
     5552, 5544, 5535, 5585, 5519, 5517,    0, 7872,    0, 1316,
     1387, 7872,    0, 7872, 5568, 5542, 1235, 1401, 1412, 1413,
     7872, 7872, 5548,    0,    0, 1414, 1418, 2458, 1066, 5498,
     5493, 5481, 1747, 5473, 5480, 5486, 1304, 5464, 5450, 5446,
     5460, 5450, 1744, 1834, 5462, 5434, 1587, 5460, 5431, 5457,
     5429, 1350, 7872, 7872, 7872, 7872, 5474, 7872, 7872, 5438,

     1423, 1263, 1425, 5457, 1625, 5401, 5382, 5380, 5368, 5361,
     7872, 5344, 5340, 5313, 5306, 5306, 5305,    0,    0, 5326,
        0,    0, 5280, 5260, 5251, 7872, 5253, 5251, 5279, 7872,
     5272, 1565,    0,  267, 1003,    0, 1630, 1199, 1632,    0,
        0, 7872, 5270, 5265, 1634, 1575, 5263, 7872, 1680,    0,
     5255,    0,    0,    0, 5253,    0,    0,    0, 5250,    0,
        0,    0, 5248,    0,    0, 5259, 5257,    0, 5244,    0,
        0, 1330, 1668, 1641, 1644, 7872, 5225, 1341, 5219, 5198,
     1639, 1715, 7872, 5163, 5176, 7872, 5150, 7872, 5141,    0,
     5105, 5102, 5101, 1757, 5081, 5087, 5095, 1343, 5079, 5071,

     5060, 5070, 5060, 1627, 1639, 5055, 7872, 5041, 5042, 5029,
     5026, 5035, 5019, 5022, 5018, 4989, 4986, 4978, 4981, 1897,
     1737, 4988, 4952,    0,    0, 4980, 4956, 4948, 7872, 1934,
     1742, 4950, 4921,    0, 4943, 7872, 1951, 1774, 4946, 4918,
        0, 4963,    0, 1734,    0, 4928, 4928, 1184, 7872,    0,
        0,    0, 4960,    0,    0, 4975, 1726, 1739, 1257, 1057,
     1394, 7872, 1728, 4974, 4954, 7872, 4958, 7872, 4956, 1752,
     4948, 7872, 4946, 7872,    0, 4911, 1742, 1742, 4921, 7872,
     4911, 4914, 4902, 4883, 4893, 4879, 4887, 4891, 4873, 4877,
     2009, 1803, 4888, 4860, 4886, 4858, 7872, 4859, 1663, 4907,

     1904, 4888, 1970, 1841, 4854, 4837, 1823, 2485, 4844, 4836,
     4825, 4783, 4775, 4770, 4775,    0, 1868, 2051, 2019, 2055,
     4806, 7872, 1881, 1728, 7872, 7872, 1918, 2178, 4784, 2314,
        0,    0,    0,    0, 4785, 4775,    0, 1769, 4773, 7872,
     7872, 4757, 1773, 1787, 4716, 7872, 4705, 4708, 4676, 4677,
     4675, 4661, 4669, 4648, 4630, 4634, 4640, 4640, 4641, 1973,
     4638, 4628, 4619, 4633, 4622, 4600, 4580, 4572, 4575, 4559,
     4555, 4533,  315, 1730, 4543, 4511, 2511, 1667, 1785, 4535,
     4505, 2532, 1854, 1845, 3980, 3944,    0, 3954, 3955,    0,
     7872,    4, 1891, 1861,  923, 1800, 7872, 1839, 2034, 7872,

     3982, 7872, 1988, 3933, 3939, 3931, 3931, 2066, 3929, 3911,
     3901, 3915, 3896, 3893, 3893, 3881, 3895, 3881, 1945, 1875,
     3887, 3858, 3884, 3848, 3897, 2561, 2382, 2310, 2320, 1949,
     7872, 2032, 3868, 3858, 7872, 7872, 1818, 3855, 2624, 1885,
     3854, 3831, 3845, 3847, 3874, 7872, 1859, 2193, 2098, 2211,
     3863, 3862, 7872, 3853, 2332, 3850, 2359, 3855, 3846, 3808,
     3808, 3801, 2102, 3798, 3788, 3771, 3784, 3773, 3763, 3762,
     3758, 3765, 3750, 2347, 2184, 3749, 2217, 3740, 3738, 3747,
     3720, 3727, 3775, 3717, 3709, 3727, 3705, 3712, 3711, 3692,
     3690, 3684, 3683, 3692, 1542, 3672, 3670, 3676, 3667, 3656,

     3654, 3648, 3647, 3656, 1964, 3636, 3634, 3640, 3631, 2371,
     1391, 3670, 3668, 1976, 2412, 1626, 2425, 7872, 3666, 3649,
     3647, 3616, 2551, 3646, 3594, 2433, 3593, 3584, 3592, 3573,
     3573, 3620, 3570, 3555, 3572, 3558, 3563, 3534, 2042, 2591,
     2594, 2084, 2427, 2051, 2598, 2641, 2667, 7872, 2394, 3555,
     3586, 2182, 3543, 7872, 2064, 7872, 2187, 2313, 3543, 3574,
     3572, 3530, 2447, 3552, 2670, 3556, 3555, 2616, 3550, 3498,
     2475, 3497, 3488, 3496, 3477, 3477, 3524, 3474, 3459, 3476,
     3462, 3441, 2608, 7872, 2663, 3450, 3450, 3441, 3435, 3437,
     3431, 2037, 3429, 3419, 3411, 3417, 2056, 3410, 3415, 2174,

     3404, 3407, 3387, 3391, 3401, 3389, 3381, 3374, 3371, 3377,
     2175, 3367, 3362, 3349, 3354, 3356, 3351, 3344, 3327, 3321,
     2677, 3356, 7872, 7872, 1759, 2681, 7872, 3343, 3332, 2689,
     3320, 3247, 3296, 3234, 3223, 3211, 3195, 3186, 3183, 2201,
     3178, 3154, 3153, 3143, 2692, 2695, 2420, 7872, 2223, 2329,
     2698, 2709, 2720, 2702, 3184, 2460, 2346, 7872, 2556, 7872,
     2423, 2603, 2723, 3159, 2734,    0, 3163, 3156, 3093, 3146,
     3082, 3079, 3078, 3049, 3043,   22,  532,  540,  537,  646,
      700,  967, 2745, 1015, 1184, 1179, 1267, 1319, 1373, 1436,
     2206, 7872, 1583, 1627, 1683, 1675, 7872, 1769, 1830, 1880,

     7872, 1881, 1876, 1916, 1912, 1937, 1955, 1949, 2029, 2038,
     7872, 2033, 2032, 2141, 2165, 2170, 2199, 2190, 7872, 2573,
     2748, 7872, 2318, 2262, 2759, 2279, 2314, 2307, 2322, 2313,
     2318, 2377, 2385, 7872, 2338, 2354, 2371, 2357, 2762, 2765,
     7872, 2787, 2770, 2792, 2774,    0, 2380, 2795, 2427, 2800,
     2442, 2446, 2450, 2394, 2815, 2413, 2423, 2424, 2442, 2430,
     2498, 2506, 2518, 2530, 2522, 2534,    0, 2527, 2540, 2550,
     2554, 2556, 2573, 2594, 2602, 2613, 2602, 2612, 2617, 2637,
     2626, 2654, 2655, 2667, 2657, 2668, 2669, 2690, 2679, 2729,
     7872, 2681,    0, 2673, 2690, 2693, 2695, 2695, 2818, 2835,

     2841, 2848, 2853, 2775,    0, 2713, 2858, 2743, 2863, 2826,
     2750, 2752, 2718,    0, 2718, 2732, 2734, 2735, 2742, 2749,
     7872, 2740, 2806, 2759, 2762, 2759, 2771, 2776, 2777, 2776,
     2785, 2783, 2789, 2787, 2794, 2798, 2804, 2806, 2819, 2821,
     7872, 2812, 2881, 2888, 2875, 2903, 2910, 2884, 2914, 2832,
     2919, 2869, 2926, 2915, 7872, 2876, 2881, 2838, 7872, 2834,
     2851, 7872, 2854, 2859, 2871, 2873, 2864, 2873, 2889, 2875,
     2891, 2891, 2903, 2891, 2883, 2884, 2900, 2886, 2899, 2950,
     2953, 2956, 2967, 2978, 2981, 2936, 7872, 2993, 2939, 2996,
     2955, 2956, 2915, 2906, 2923, 2917, 2935, 2936, 2936, 2936,

     2928, 2942, 2943, 2943, 2942, 3007, 3019, 3031, 3024, 3034,
     3041, 2992, 3056, 3000, 3001, 2952, 2963, 2955, 2966, 2958,
     3048, 3061, 3074, 3085, 3096, 3099, 3012, 3103, 3025, 3033,
     2992, 2997, 3114, 3118, 3110, 3122, 3136, 3140, 3036, 3151,
     3049, 3050, 3006, 3009, 3147, 3164, 3171, 3060, 3187, 3067,
     3069, 3192, 3067, 3199, 3074, 3076, 3204, 3071, 3211, 3079,
     3084, 3216, 3079, 3227, 7872, 3232, 3239, 3244, 3251, 3256,
     3263, 3268, 3275, 3280, 3287, 3292, 3299, 3304, 3311, 3316,
     3323, 3328, 3335, 3340, 3347, 3352, 3359, 3364, 3371, 3376,
     3383, 3388, 3395, 3400, 3407, 3412, 3419, 3424, 3431, 3436,

     3443, 3448, 3455, 3460, 3467, 3472, 3479, 3484, 3491, 3496,
     3503, 3508, 3515, 3520, 3527, 3532, 3539, 3544, 3551, 3556,
     3563, 3568, 3575, 3580, 3587, 3592, 3599, 3604, 3611, 3616,
     3623, 3628, 3635, 3640, 3647, 3652, 3659, 3664, 3671, 3676,
     3683, 3688, 3695, 3700, 3707, 3712, 3719, 3724, 3731, 3736,
     3743, 3748, 3755, 3760, 3767, 3772, 3779, 3784, 3791, 3796,
     3803, 3808, 3815, 3820, 3827, 3832, 3839, 3844, 3851, 3856,
     3863, 3868, 3875, 3880, 3887, 3892, 3899, 3904, 3911, 3916,
     3923, 3928, 3935, 3940, 3947, 3952, 3959, 3964, 3971, 3082,
     3976, 3983, 3988, 3995, 4000, 4007, 4012, 7872, 4020, 4041,

     4062, 4083, 4104, 4125, 4146, 4167, 4188, 4209, 4230, 4251,
     4272, 4293, 4314, 4335, 4356, 4377, 4398, 4419, 4440, 4461,
     4482, 4503, 4524, 4545, 3146, 3163, 3164, 4566, 4587, 4608,
     4629, 4650, 4669, 4688, 4709, 4730, 4751, 4772, 4793, 4814,
     4835, 4856, 4877, 4898, 4917, 4936, 4955, 4973, 3128, 3170,
     4992, 5013, 5032, 5053, 5074, 5093, 5114, 5135, 5156, 5177,
     3182, 3206, 3207, 5198, 3222, 5219, 5240, 5259, 5278, 3234,
     3246, 5299, 5320, 3258, 5341, 5362, 5383, 5404, 5425, 5446,
     5467, 5486, 5505, 5526, 5547, 5568, 5589, 5610, 5631, 5652,
     5671, 5690, 5709, 5727, 3270, 5746, 5767, 5786, 5807, 5828,

     5847, 5868, 5889, 5910, 5931, 3282, 3294, 3306, 3318, 5952,
     5973, 5992, 6011, 6032, 6053, 6072, 3330, 6091, 6112, 3342,
     6133, 6154, 6175, 6196, 6217, 6238, 6259, 6280, 6299, 6318,
     6339, 6360, 6381, 6402, 6423, 6444, 6465, 6486, 6505, 6526,
     6547, 6566, 6587, 6608, 6629, 4953, 6650, 6671, 6692, 6713,
     6734, 6753, 3354, 6772, 6791, 6810, 6831, 6852, 6871, 6890,
     6911, 6932, 6953, 6974, 6995, 7016, 7037, 7058, 7077, 7098,
     7119, 7140, 7161, 7182, 7203, 7224, 7245, 7266, 7285, 7304,
     7325, 7346, 7367, 3366, 7388, 7409, 7430, 7451, 7472, 7493,
     7514, 7535, 7556, 7577, 7598, 7619, 7640, 7661, 7682, 7703,

     7724, 7745, 7766, 7787, 7808, 7829, 7850
    } ;

static const flex_int16_t yy_def[1908] =
    {   0,
     1699, 1699, 1699, 1698, 1698,    5, 1698,    7, 1700, 1700,
     1701, 1701, 1698,   13,   13,   13, 1702, 1702, 1703, 1703,
     1704, 1704, 1705, 1705, 1706, 1706, 1707, 1707, 1698,   29,
     1708, 1708,   29,   33, 1698,   35, 1698,   37, 1709, 1710,
     1711, 1711, 1712, 1712, 1698,   45, 1711, 1711, 1713, 1713,
     1714, 1714, 1715, 1715, 1716, 1716, 1717, 1717, 1698,   59,
     1698,   61,   61,   63, 1718, 1718, 1718, 1718,   33,   69,
     1719, 1719, 1720, 1720, 1721, 1721, 1722, 1722,   78,   78,
     1723, 1723, 1724, 1724, 1698, 1698, 1698, 1698, 1698, 1698,
     1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698,

     1698, 1725, 1725, 1725, 1698, 1698, 1698, 1698, 1698, 1698,
     1698, 1726, 1726, 1726, 1726, 1726, 1726, 1726, 1698, 1698,
     1698, 1698, 1698, 1698, 1698, 1727, 1727, 1727, 1698, 1728,
     1728, 1698, 1728, 1698, 1729, 1698, 1728, 1728, 1730, 1730,
     1730, 1698, 1730, 1730, 1731, 1730, 1698, 1698, 1698, 1698,
     1698, 1732, 1698, 1698, 1698, 1733, 1733, 1733, 1734, 1733,
     1733, 1698, 1698, 1698, 1698, 1735, 1735, 1698, 1735, 1735,
     1736, 1735, 1737, 1737, 1737, 1737, 1737, 1738, 1738, 1698,
     1738, 1738, 1739, 1738, 1740, 1740, 1698, 1740, 1740, 1741,
     1740, 1742, 1742, 1742, 1742, 1743, 1742, 1742, 1742, 1744,

     1744, 1744, 1744, 1744, 1744, 1745, 1746, 1746, 1698, 1746,
     1746, 1746, 1698, 1746, 1747, 1698, 1698, 1698, 1698, 1698,
     1748, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1749, 1698,
     1698, 1698, 1698, 1750, 1698, 1698, 1698, 1698, 1698, 1698,
     1698, 1698, 1698, 1698, 1698, 1751, 1698, 1698, 1698, 1698,
     1698, 1698, 1752, 1698, 1698, 1752, 1698, 1698, 1752, 1698,
     1698, 1698, 1752, 1752, 1698, 1698, 1698, 1753, 1753, 1698,
     1753, 1698, 1753, 1753, 1753, 1754, 1754, 1698, 1754, 1698,
     1754, 1754, 1750, 1754, 1754, 1698, 1698, 1698, 1752, 1698,
     1698, 1698, 1755, 1698, 1755, 1698, 1698, 1755, 1698, 1698,

     1755, 1755, 1698, 1698, 1698, 1756, 1757, 1698, 1756, 1758,
     1756, 1698, 1756, 1698, 1698, 1698, 1698, 1698, 1698, 1698,
     1698, 1698, 1759, 1698, 1698, 1759, 1698, 1759, 1759, 1759,
     1760, 1698, 1760, 1760, 1760, 1760, 1698, 1698, 1698, 1698,
     1698, 1698, 1698, 1761, 1698, 1761, 1761, 1761, 1761, 1761,
     1761, 1761, 1761, 1761, 1698, 1698, 1698, 1698, 1698, 1698,
     1698, 1762, 1698, 1698, 1698, 1763, 1698, 1698, 1698, 1698,
     1698, 1698, 1764, 1698, 1698, 1698, 1765, 1698, 1698, 1698,
     1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1766,
     1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698,

     1698, 1698, 1698, 1767, 1698, 1698, 1698, 1768, 1698, 1698,
     1698, 1698, 1769, 1769, 1698, 1769, 1698, 1698, 1769, 1698,
     1769, 1769, 1698, 1769, 1769, 1698, 1698, 1698, 1698, 1698,
     1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698,
     1770, 1770, 1770, 1698, 1698, 1770, 1770, 1770, 1771, 1771,
     1771, 1771, 1771, 1771, 1771, 1771, 1771, 1771, 1772, 1773,
     1774, 1774, 1774, 1774, 1775, 1776, 1777, 1775, 1778, 1779,
     1780, 1778, 1698, 1698, 1781, 1698, 1698, 1698, 1782, 1782,
     1783, 1698, 1698, 1698, 1782, 1782, 1698, 1784, 1784, 1784,
     1784, 1698, 1785, 1785, 1785, 1785, 1786, 1786, 1786, 1786,

     1698, 1787, 1787, 1787, 1787, 1698, 1788, 1789, 1789, 1788,
     1788, 1788, 1790, 1698, 1790, 1790, 1790, 1698, 1698, 1791,
     1792, 1698, 1792, 1792, 1792, 1698, 1698, 1698, 1698, 1698,
     1793, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698,
     1794, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1795, 1698,
     1698, 1698, 1796, 1698, 1797, 1698, 1698, 1698, 1797, 1698,
     1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698,
     1698, 1698, 1698, 1698, 1698, 1797, 1698, 1698, 1698, 1698,
     1698, 1698, 1798, 1698, 1798, 1798, 1799, 1799, 1698, 1799,
     1799, 1698, 1799, 1698, 1698, 1698, 1698, 1797, 1698, 1698,

     1698, 1698, 1698, 1698, 1800, 1698, 1698, 1800, 1698, 1698,
     1800, 1698, 1698, 1698, 1698, 1698, 1698, 1801, 1802, 1803,
     1803, 1803, 1801, 1698, 1698, 1804, 1698, 1698, 1804, 1804,
     1805, 1805, 1805, 1805, 1806, 1698, 1698, 1806, 1806, 1806,
     1806, 1806, 1806, 1806, 1806, 1806, 1807, 1698, 1808, 1698,
     1698, 1698, 1809, 1698, 1698, 1810, 1811, 1698, 1698, 1698,
     1698, 1698, 1698, 1812, 1813, 1698, 1698, 1813, 1698, 1698,
     1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698,
     1698, 1698, 1813, 1698, 1813, 1813, 1698, 1698, 1698, 1813,
     1813, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698,

     1698, 1814, 1698, 1815, 1816, 1817, 1817, 1817, 1817, 1817,
     1698, 1817, 1817, 1817, 1817, 1817, 1817, 1818, 1818, 1818,
     1819, 1819, 1820, 1820, 1820, 1698, 1820, 1820, 1821, 1698,
     1698, 1698, 1822, 1823, 1823, 1824, 1823, 1825, 1825, 1826,
     1827, 1698, 1698, 1698, 1698, 1698, 1828, 1698, 1829, 1830,
     1830, 1830, 1830, 1831, 1831, 1831, 1831, 1832, 1832, 1832,
     1832, 1833, 1833, 1833, 1833, 1834, 1834, 1835, 1835, 1835,
     1835, 1836, 1836, 1836, 1836, 1698, 1837, 1837, 1837, 1837,
     1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1838,
     1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698,

     1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698,
     1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1838,
     1698, 1698, 1698, 1839, 1839, 1840, 1840, 1698, 1698, 1838,
     1698, 1698, 1698, 1841, 1698, 1698, 1841, 1698, 1698, 1698,
     1842, 1842, 1842, 1843, 1842, 1698, 1698, 1698, 1698, 1844,
     1844, 1845, 1845, 1845, 1845, 1846, 1846, 1846, 1846, 1846,
     1846, 1698, 1846, 1846, 1698, 1698, 1847, 1698, 1698, 1698,
     1698, 1698, 1698, 1698, 1848, 1698, 1698, 1698, 1698, 1698,
     1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698,
     1848, 1698, 1698, 1698, 1848, 1848, 1698, 1698, 1849, 1850,

     1698, 1851, 1698, 1852, 1853, 1853, 1853, 1698, 1853, 1853,
     1853, 1853, 1853, 1853, 1853, 1854, 1855, 1855, 1855, 1855,
     1856, 1698, 1698, 1857, 1698, 1698, 1698, 1698, 1858, 1859,
     1860, 1861, 1862, 1863, 1864, 1864, 1865, 1866, 1867, 1698,
     1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698,
     1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698,
     1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698,
     1698, 1698, 1838, 1698, 1698, 1698, 1698, 1838, 1698, 1698,
     1698, 1698, 1868, 1698, 1698, 1698, 1842, 1698, 1698, 1845,
     1698, 1846, 1846, 1846, 1846, 1846, 1698, 1846, 1846, 1698,

     1869, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698,
     1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1848, 1698,
     1698, 1698, 1848, 1848, 1850, 1870, 1698, 1698, 1698, 1698,
     1698, 1852, 1853, 1853, 1698, 1698, 1698, 1853, 1853, 1853,
     1853, 1853, 1853, 1853, 1853, 1698, 1698, 1855, 1855, 1855,
     1698, 1698, 1698, 1698, 1698, 1871, 1859, 1872, 1872, 1698,
     1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698,
     1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698,
     1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698,
     1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698,

     1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698,
     1846, 1846, 1846, 1846, 1846, 1846, 1698, 1698, 1698, 1698,
     1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698,
     1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1870, 1870,
     1870, 1698, 1870, 1870, 1698, 1698, 1698, 1698, 1852, 1853,
     1853, 1698, 1698, 1698, 1698, 1698, 1853, 1853, 1853, 1853,
     1698, 1698, 1698, 1873, 1859, 1874, 1874, 1698, 1698, 1698,
     1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698,
     1698, 1875, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698,
     1698, 1876, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698,

     1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698,
     1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698,
     1698, 1846, 1698, 1698, 1846, 1698, 1698, 1698, 1846, 1698,
     1698, 1877, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1878,
     1698, 1698, 1698, 1698, 1870, 1870, 1698, 1698, 1698, 1870,
     1698, 1698, 1698, 1852, 1698, 1698, 1698, 1698, 1879, 1698,
     1698, 1698, 1698, 1880, 1698, 1881, 1882, 1882, 1883, 1698,
     1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698,
     1698, 1875, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1876,
     1876, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698,

     1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698,
     1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1846,
     1698, 1698, 1698, 1877, 1698, 1698, 1698, 1698, 1698, 1698,
     1698, 1878, 1878, 1698, 1698, 1698, 1698, 1698, 1870, 1870,
     1698, 1698, 1698, 1698, 1852, 1884, 1698, 1698, 1885, 1698,
     1881, 1886, 1886, 1883, 1698, 1698, 1698, 1698, 1698, 1698,
     1698, 1698, 1698, 1698, 1698, 1698, 1887, 1698, 1698, 1698,
     1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698,
     1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698,
     1698, 1698, 1888, 1698, 1698, 1698, 1698, 1698, 1870, 1870,

     1698, 1698, 1698, 1852, 1884, 1698, 1698, 1889, 1698, 1698,
     1890, 1890, 1698, 1891, 1698, 1698, 1698, 1698, 1698, 1698,
     1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698,
     1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698,
     1698, 1698, 1870, 1870, 1698, 1698, 1698, 1698, 1892, 1698,
     1698, 1893, 1698, 1698, 1698, 1894, 1894, 1698, 1698, 1698,
     1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698,
     1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1870,
     1870, 1698, 1698, 1698, 1892, 1892, 1698, 1698, 1895, 1698,
     1896, 1896, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698,

     1698, 1698, 1698, 1698, 1698, 1870, 1870, 1698, 1698, 1698,
     1698, 1897, 1698, 1898, 1898, 1698, 1698, 1698, 1698, 1698,
     1870, 1870, 1698, 1698, 1698, 1698, 1899, 1698, 1900, 1900,
     1698, 1698, 1870, 1870, 1698, 1698, 1698, 1698, 1901, 1698,
     1902, 1902, 1698, 1698, 1870, 1870, 1698, 1903, 1698, 1904,
     1904, 1698, 1905, 1698, 1906, 1906, 1698, 1907, 1698, 1698,
     1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698,
     1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698,
     1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698,
     1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698,

     1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698,
     1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698,
     1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698,
     1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698,
     1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698,
     1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698,
     1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698,
     1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698,
     1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698,
     1698, 1698, 1698, 1698, 1698, 1698, 1698,    0, 1698, 1698,

     1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698,
     1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698,
     1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698,
     1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698,
     1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698,
     1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698,
     1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698,
     1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698,
     1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698,
     1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698,

     1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698,
     1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698,
     1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698,
     1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698,
     1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698,
     1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698,
     1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698,
     1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698,
     1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698,
     1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698,

     1698, 1698, 1698, 1698, 1698, 1698, 1698
    } ;

static const flex_int16_t yy_nxt[7939] =
    {   0,
     1698,   87, 1698,   88,   89,   87, 1698,   88,   89,   87,
     1698,   88,   89,  483,  484,  435,  435,  435,   90,  436,
      436,  436,   90,  514,  459,  459,   90,   91,  460,  460,
      470,   91,  518,  694,  471,   91,  446,  446,  446,  446,
      435,  489,  519,  514,  436,  490,  446,  446,  446,  446,
      452,  454,  453,  446,  462, 1111,  463,  444,  455,  456,
      494,  695,  445,  498,  495,   92,  503,  499,  510,   92,
      504, 1361,  511,   92,   93,   94,   95,   96,   97,   93,
       93,   98,   93,   99,   93,   93,   93,   93,   93,   93,
       93,   93,  100,   93,   93,   93,   93,   93,   93,   93,

       93,  101,   93,  102,  102,  102,  102,   93,   93,   93,
      102,   93,  103,  103,  104,  103,  103,  103,  103,  103,
      103,  103,  103,  103,  103,  103,  103,  103,  103,  103,
      103,  103,  103,  103,  103,  103,   93,   93,   93,  105,
      106,  107,  106,  108,  109,  106,  106,  106,  106,  106,
      106,  106,  106,  106,  106,  106,  106,  106,  110,  106,
      106,  106,  106,  106,  106,  106,  106,  111,  106,  112,
      112,  112,  112,  106,  106,  106,  112,  106,  112,  112,
      113,  114,  115,  112,  112,  112,  116,  112,  112,  112,
      112,  112,  112,  117,  112,  112,  112,  112,  118,  112,

      112,  112,  106,  106,  106,  119,  120,  121,  120,  122,
      123,  120,  120,  120,  120,  120,  120,  120,  120,  120,
      120,  120,  120,  120,  124,  120,  120,  120,  120,  120,
      120,  120,  120,  125,  120,  126,  126,  126,  126,  120,
      120,  120,  126,  120,  126,  126,  126,  126,  127,  126,
      126,  126,  128,  126,  126,  126,  126,  126,  126,  126,
      126,  126,  126,  126,  126,  126,  126,  126,  120,  120,
      120,  129,  131,  736,  132,  133,  131,  134,  132,  133,
      514,  134,  135,  514,  514,  533,  135,  526,  527,  136,
      550,  551,  140,  136,   88,  141,  534,  142,  137,  514,

      514,  736,  137,  514,  514,  140,  522,   88,  141,  143,
      142,  477,  477,  477,  477,  477,  477,  973,  144,  514,
      517,  478,  143,  543,  478,  145,  522,  514,  544,  577,
      525,  144,  477,  477,  477,  515,  138,  523,  145,  516,
      138,  524,  478,  480,  477,  477,  477,  514,  481,  539,
      811,  486,  698,  547,  478,  459,  146,  548,  553,  460,
      591,  480,  459,  554,  540,  698,  460,  588,  812,  146,
      147,  148,  147,  149,  150,  147,  151,  147,  147,  147,
      147,  152,  147,  147,  147,  147,  147,  147,  153,  147,
      147,  147,  147,  147,  147,  147,  147,  154,  155,  156,

      157,  158,  157,  147,  159,  147,  156,  147,  156,  156,
      156,  156,  160,  156,  156,  156,  156,  156,  156,  156,
      156,  156,  156,  156,  156,  156,  156,  156,  161,  156,
      156,  156,  162,  163,  147,  164,  167,  574,   88,   89,
      167,  168,   88,   89,  174,  168,   88,   89,  557,  168,
      435,  696,  558,  169,  585,  528,  529,  169,  596,  597,
      697,  175,  170,  575,  435,  530,  170,  595,  590,  171,
      176,  436,  174,  171,   88,   89,  179,  168,   88,   89,
      179,  607,   88,   89,  588,  436,  180,  532,  619,  175,
      180,  609,  610,  181,  719,  621,  543,  181,  176,  622,

      172,  544,  182,  720,  172,  620,  182,  619,  177,  183,
      592,  593,  186,  183,   88,   89,  186,  187,   88,   89,
      193,  187,  194,  195,  620,  477,  477,  477,  692,  188,
      619,  576,  196,  188, 1277,  478,  177,  197,  189,  693,
      184,  588,  189,  577,  184,  190,  198,  620,  193,  190,
      194,  195,  201,  619,   88,  202,  201,   86,   88,  202,
      196,   86,  703,  435,  628,  197,  578,  436,  629,  203,
      620,  632,  704,  203,  198,  633,  191,   86,  204,  623,
      191,   86,  204,  485,  199,  624,  435,  636,  637, 1362,
      436,  624,  435,  579,  650, 1363,  436,  625,  651,  563,

      435,  435,  654,  655,  436,  436,  658,  659,  662,  663,
      436,  660,  199,  435,  666,  435,  205,  436,  667,  436,
      205,   86,   87,   86,   88,   89,   86,   86,   86,   86,
       86,   86,   86,   86,   86,   86,   86,   86,   86,   90,
       86,   86,   86,   86,   86,   86,   86,   86,   91,   86,
      206,  206,  206,  206,   86,   86,   86,  206,   86,  206,
      206,  206,  206,  206,  206,  206,  206,  206,  206,  206,
      206,  206,  206,  206,  206,  206,  206,  206,  206,  206,
      206,  206,  206,   86,   86,   86,   92,  208,  722,  209,
      210,  208,  703,  209,  210,  708,  723,  238,  598,  239,

      240,  722,  704, 1364,  211,  709,  724,  744,  211,  750,
      599,  732,  732,  212,  241,  745,  745,  212,  751,  699,
      213,  739,  740,  242,  213,  699,  699,  699,  752,  756,
      699,  619,  699,  600,  739,  735,  736,  754,  699,  699,
      699,  752,  756,  705,  737,  846,  755,  793,  620, 1365,
      740,  214,  746,  746,  746,  214,  215,  215,  215,  215,
      601,  243,  478,  215,  736,  215,  215,  215,  215,  215,
      215,  215,  215,  215,  215,  215,  215,  215,  215,  215,
      215,  215,  215,  215,  215,  215,  215,  215,  215,   86,
       87,  216,   88,   89,   86,   86,   86,   86,   86,   86,

       86,  217,  218,   86,  219,   86,  220,   90,   86,   86,
       86,   86,   86,   86,   86,   86,   91,   86,  221,  221,
      221,  221,   86,  222,   86,  221,   86,  221,  221,  221,
      221,  221,  221,  221,  221,  221,  221,  221,  221,  221,
      221,  221,  221,  221,  221,  221,  221,  221,  221,  221,
      221,   86,   86,   86,   92,  223,  224,  225,  226,  227,
      223,  228,  229,  223,  223,  223,  230,  223,  223,  223,
      223,  223,  223,  231,  223,  223,  223,  223,  223,  223,
      223,  223,  232,  233,  234,  234,  234,  234,  223,  235,
      223,  234,  223,  234,  234,  234,  234,  234,  234,  234,

      234,  234,  234,  234,  234,  234,  234,  234,  234,  234,
      234,  234,  234,  234,  234,  234,  234,  223,  223,  223,
      236,  245,  246,  247,  248, 1698,  269,  249,  270,  271,
      580,  269,  758,  270,  271,  477,  477,  477,  250,  272,
      514,  759,  577,  273,  272,  478,  556,  251,  273,  760,
      762,  307,  274,  308,  309,  574,  764,  274,  768,  763,
      514,  711,  760,  602,  711,  578,  518,  769,  310,  764,
      315,  711,  316,  317, 1114,  599,  519,  311,  312,  594,
      315,  575,  316,  317,  312,  252,  254,  318,  255,  256,
      275,  307,  579,  308,  309,  275,  319,  318,  600,  257,

      712,  770,  592,  258,  611,  522,  319,  779,  310,  736,
      713,  518,  259,  260,  770,  313,  612,  311,  312,  260,
      779,  519,  261,  683,  312,  601,  687,  772,  514,  533,
     1283,  320,  321,  588,  322,  684,  773,  736,  684,  613,
      534,  320,  321,  324,  322,  325,  326,  262,  514,  261,
      263,  254,  264,  255,  256,  313,  327,  788,  685, 1698,
      328,  688,  726, 1366,  265,  726,  614,  786,  258,  329,
      788,  539,  726,  477,  477,  477,  787,  259,  260,  446,
      446,  446,  446,  478,  260,  686,  540,  266,  689,  446,
      446,  446,  446,  477,  477,  477,  446,  481,  522,  553,

      777,  727,  480,  478,  554,  848,  876,  330,  793,  778,
      849,  728,  262,  996,  267,  263,  276,  277,  276,  278,
      279,  276,  276,  276,  276,  276,  276,  276,  276,  276,
      280,  276,  276,  276,  281,  276,  276,  276,  276,  276,
      276,  276,  276,  282,  276,  283,  283,  283,  283,  276,
      284,  276,  283,  276,  283,  283,  283,  283,  283,  283,
      283,  283,  283,  283,  283,  283,  283,  283,  283,  283,
      283,  283,  283,  283,  283,  283,  283,  283,  276,  276,
      276,  285,  254,  539,  255,  256,  848,  324,  698,  325,
      326,  849,  528,  529,  332,  286,  308,  333,  540,  287,

      327,  789,  528,  529,  328,  740,  774,  514,  259,  288,
      781,  334,  530,  329,  332,  288,  308,  333,  261,  774,
      335,  818,  477,  477,  477, 1367,  696,  514, 1368,  824,
      819,  334,  478,  740,  532,  697,  368,  821,   88,  369,
      335,  370,  824,  261,  820,  261,  263,  254,  289,  255,
      256,  330,  696,  371,  870,  870,  577,  696,  336, 1698,
      290,  697,  372,  807,  287,  556,  697,  807,  379,  373,
      108,  380,  578,  259,  288,  900,  901,  749,  336,  578,
      288,  615,  841,  291,  580,  381,  696,  368,  807,   88,
      369,  842,  370,  612,  382,  697,  577,  606,  852,  579,

      374,  383,  831,  995,  371, 1369,  579,  853,  261,  843,
      292,  263,  294,  372,  255,  295,  613,  807,  826,  578,
      373,  696,  843,  830,  368,  296,   88,  369,  829,  297,
      865,  826,  384,  829,  375,  599,  514,  600,  298,  299,
      850,  376,  884,  614,  522,  299,  579,  588,  300,  602,
      372,  374,  692,  850,  837,  829,  514,  373,  600,  939,
      885,  599,  838,  693,  601,  379,  612,  108,  380,  427,
     1370,  428,  429,  300,  430,  300,  301,  294,  302,  255,
      295,  950,  381,  829,  600,  601,  431,  854,  374,  613,
      303,  382,  698, 1698,  297,  432,  997,  613,  383,  951,

      854,  733,  433,  298,  299,  866,  696,  699,  733,  733,
      299,  601,  733,  304,  699,  871,  614,  696,  698,  872,
      733,  733,  733,  874,  614,  701,  697,  703,  873,  384,
      998,  698, 1222,  434,  960,  702,  874,  704,  300, 1292,
      305,  301,  337,  338,  337,  339,  340,  337,  337,  337,
      337,  337,  337,  337,  337,  337,  337,  337,  337,  337,
      341,  337,  337,  337,  337,  337,  337,  337,  337,  342,
      343,  344,  344,  344,  344,  337,  345,  337,  344,  337,
      346,  347,  348,  349,  344,  350,  344,  344,  344,  344,
      344,  344,  344,  351,  352,  344,  344,  344,  344,  353,

      344,  344,  354,  344,  337,  337,  337,  355,  356,  357,
      356,  358,  359,  356,  356,  356,  356,  356,  356,  356,
      356,  356,  356,  356,  356,  356,  360,  356,  356,  356,
      356,  356,  356,  356,  356,  361,  356,  362,  362,  362,
      362,  356,  363,  356,  362,  356,  362,  362,  362,  362,
      362,  362,  362,  362,  362,  362,  362,  362,  362,  362,
      362,  362,  362,  362,  362,  362,  362,  362,  362,  362,
      356,  356,  356,  364,  365,  741,  922,  928,  928,  928,
     1204,  741,  741,  741,  923,  923,  741,  478,  741,  892,
      366,  366,  366,  366,  741,  741,  741,  366, 1205,  366,

      366,  366,  366,  366,  366,  366,  366,  366,  366,  366,
      366,  366,  366,  366,  366,  366,  366,  366,  366,  366,
      366,  366,  366,  368,  688,   88,  369,  703, 1698,  398,
      836,   88,  399,  375,  400,  836,  736,  704,  740,  401,
      376,  940,  940,  940,  960,  926,  402,  514,  924,  372,
      514,  689,  753,  927,  927,  403,  373,  836,  753,  753,
      753,  904,  404,  753,  736,  753,  740,  514,  957,  978,
      514,  753,  753,  753,  514,  900,  901, 1371,  958,  959,
     1229,  599,  477,  477,  477,  836,  938,  374,  377,  377,
      377,  377,  478,  405,  514,  377,  960,  377,  377,  377,

      377,  377,  377,  377,  377,  377,  377,  377,  377,  377,
      377,  377,  377,  377,  377,  377,  377,  377,  377,  377,
      377,  386,  930,  387,  388,  615,  389,  530, 1698, 1372,
     1698,  390,  391,  392,  736,  619,  960,  612,  393,  974,
      398, 1698,   88,  399,  979,  400,  891,  394,  395,  532,
      401,  427,  620,  428,  429,  880,  430,  402,  684,  880,
      613, 1698,  736, 1002,  992,  946,  403,  578,  431,  946,
      999, 1003, 1003,  404,  578,  514,  984,  432,  993,  600,
      880,  685, 1007, 1005,  433,  396,  386,  614,  387,  388,
      946,  389,  994, 1006,  579,  514,  390,  391,  392, 1008,

     1320,  579, 1698,  393,  405, 1020,  601, 1373,  686,  880,
      757,  613,  394,  395, 1060,  434,  757,  757,  757,  946,
     1152,  757,  600,  757, 1061, 1035,  761, 1062, 1035,  757,
      757,  757,  699,  761,  761, 1035,  687,  761,  614,  761,
      688, 1698, 1115,  703, 1063,  761,  761,  761,  684,  601,
      396,  406,  407,  704,   88,  409,  983,  406,  406,  406,
      406, 1047,  406, 1698, 1153,  406,  406,  689,  612,  410,
     1046,  688, 1301, 1046,  406,  406,  406,  406,  411,  406,
     1046, 1116,  613,  765,  406,  406,  406, 1155,  406,  765,
      765,  765,  730, 1698,  765, 1032,  765, 1156,  689,  973,

     1052, 1052,  765,  765,  765, 1162, 1027, 1028, 1029,  614,
     1113,  577,  688,  406,  406,  406,  412,  406,  407, 1374,
       88,  409, 1030,  406,  406,  406,  406, 1031,  406, 1053,
     1375,  406,  406, 1376,  578,  410,  978, 1054, 1054,  689,
      406,  406,  406,  406,  411,  406, 1112, 1019,  599,  771,
      406,  406,  406,  983,  406,  771,  771,  699, 1377,  684,
      771,  579,  771, 1148, 1378,  612, 1031, 1148,  771,  771,
      771,  600, 1029, 1029, 1029, 1077, 1077, 1077, 1698,  406,
      406,  406,  412,  414,  790,  415,  416,  417,  613, 1379,
      790,  790,  790, 1031, 1380,  790,  417,  699,  601,  868,

      418, 1381, 1215,  790,  790,  790,  825, 1121, 1121,  419,
      420, 1019,  825,  825,  825,  614,  420,  825, 1225,  825,
     1216, 1698,  834,  684, 1698,  825,  825,  825,  834,  834,
      834, 1698, 1031,  834,  703,  699, 1117, 1118, 1119, 1291,
     1292,  834,  834,  834,  704, 1698,  685,  421,  414,  422,
      415,  416,  417, 1047, 1698, 1142, 1698, 1698, 1297, 1297,
     1698,  423, 1049, 1698, 1142,  418, 1155, 1698, 1126, 1126,
     1126, 1311,  851,  686,  419,  420, 1156, 1382,  851,  851,
      851,  420, 1383,  851,  424,  851, 1247, 1248,  855, 1384,
     1149,  851,  851,  851,  855,  855,  855, 1048, 1050,  855,

     1698,  855, 1249, 1698, 1171, 1171, 1171,  855,  855,  855,
     1698,  425,  421,  438,  438,  439,  438,  438,  438,  438,
      440,  438,  438,  438,  438,  438,  438,  438,  438,  438,
      438,  438,  438,  438,  438,  438,  438,  438,  438,  438,
      438,  438,  441,  441,  441,  441,  438,  438,  438,  441,
      438,  442,  442,  443,  442,  442,  442,  442,  442,  442,
      442,  442,  442,  442,  442,  442,  442,  442,  442,  442,
      442,  442,  442,  442,  442,  438,  438,  438,  438,  560,
     1055, 1055, 1055, 1385, 1152,  560, 1183, 1184, 1185, 1257,
      478,  561,  562,  563,  564, 1698,  565,  566, 1698, 1258,

      567,  568,  569, 1333, 1334, 1698,  570,  571, 1291, 1292,
      572,  573,  669,  726, 1300, 1310,  726, 1386,  669, 1077,
     1077, 1077, 1387,  726,  670,  671,  672,  673, 1153,  674,
      675, 1301, 1311,  676,  677,  678,  917, 1341, 1388,  679,
      680, 1341, 1389,  681,  682,  438,  438,  439,  438,  438,
      438,  438,  440,  438,  438,  438,  438,  438,  438,  438,
      438,  438,  438,  438,  438,  438,  438,  438,  438,  438,
      438,  438,  438,  438,  441,  441,  441,  441,  438,  438,
      438,  441,  438,  442,  442,  443,  442,  442,  442,  442,
      442,  442,  442,  442,  442,  442,  442,  442,  442,  442,

      442,  442,  442,  442,  442,  442,  442,  438,  438,  438,
      438,  701, 1147, 1147, 1147, 1259,  477,  477,  477, 1260,
     1323,  702, 1147, 1147, 1147, 1325,  478, 1392,  446,  446,
      446,  446, 1698, 1031, 1163, 1163, 1163, 1260,  446,  446,
      446,  446, 1142, 1031,  478,  446,  775,  514, 1257, 1077,
     1077, 1077,  775,  775,  775, 1393, 1394,  775, 1258,  775,
     1395,  477,  477,  477, 1396,  775,  775,  776,  522, 1057,
      780,  478, 1031, 1221, 1184, 1185,  780,  780,  780, 1008,
     1334,  780, 1031,  780, 1145, 1146, 1147, 1333, 1334,  780,
      780,  780,  791,  792,  793,  794,  703,  795,  796, 1008,

     1030,  797,  798,  799, 1397, 1031,  704,  800,  801, 1182,
     1165,  802,  803,  827, 1226, 1227, 1228, 1398, 1008,  827,
      827,  827, 1247, 1248,  827, 1261,  827, 1230, 1118, 1119,
     1698, 1406,  827,  827,  827, 1126, 1126, 1126, 1249,  748,
     1142, 1250,  588,  619, 1031, 1250, 1254,  844, 1410, 1263,
     1263, 1263, 1412,  844,  844,  844, 1412, 1355,  844,  478,
      845, 1413, 1035,  699, 1414, 1035,  844,  844,  844,  875,
      875,  875, 1035, 1415,  875, 1347,  699, 1171, 1171, 1171,
     1416, 1417,  875,  875,  875, 1036, 1036, 1037, 1036, 1036,
     1036, 1036, 1036, 1036, 1036, 1036, 1036, 1036, 1036, 1036,

     1036, 1036, 1036, 1036,  449,  449,  449,  449, 1036, 1036,
     1036, 1036, 1036, 1036,  449,  449,  449,  449, 1036, 1036,
     1036,  449, 1036,  449,  449,  449,  449,  449,  449,  449,
      449, 1038,  449,  449,  449,  449,  449,  449,  449,  449,
      449,  449,  449,  449,  449,  449,  449, 1036, 1036, 1036,
     1036, 1090, 1091, 1126, 1126, 1126, 1092, 1093, 1259, 1063,
     1094, 1095, 1260, 1140, 1028, 1141, 1096, 1063, 1418, 1097,
     1098, 1099, 1100, 1101, 1142, 1390, 1419, 1102, 1103, 1143,
     1260, 1104, 1105, 1063, 1144, 1391, 1420, 1106,  960,  960,
     1107, 1108, 1109, 1245, 1146, 1246, 1246, 1147, 1246, 1422,

     1251, 1252, 1253,  960, 1142, 1046,  960, 1142, 1046, 1143,
     1183, 1184, 1185, 1232, 1144, 1046, 1030, 1144, 1171, 1171,
     1171, 1031, 1423, 1144, 1154, 1154, 1154, 1154, 1154, 1154,
     1154, 1154, 1154, 1154, 1154, 1154, 1154, 1154, 1154, 1154,
     1154, 1154, 1154, 1253, 1253, 1253, 1424, 1154, 1154, 1154,
     1154, 1154, 1154, 1144, 1425, 1426, 1144, 1154, 1154, 1154,
     1031, 1154, 1427, 1428, 1031, 1185, 1184, 1185, 1429, 1253,
     1253, 1253, 1265, 1265, 1265, 1430, 1266, 1431, 1269, 1221,
     1184, 1185,  478, 1321, 1227, 1228, 1154, 1154, 1154, 1154,
     1031, 1230, 1118, 1119, 1339, 1252, 1340, 1340, 1253, 1340,

     1342, 1343, 1344, 1031,  703, 1142, 1432, 1433, 1142, 1434,
     1143, 1344, 1344, 1344,  704, 1144, 1030, 1435, 1144, 1436,
     1437, 1031, 1344, 1344, 1344, 1348, 1348, 1348, 1438, 1031,
     1439, 1390, 1031, 1440, 1008,  478, 1350, 1350, 1350, 1008,
     1266, 1391, 1442, 1031, 1008, 1008,  478, 1077, 1077, 1077,
     1321, 1227, 1228, 1450, 1144,  748, 1457, 1144, 1457, 1345,
     1031, 1126, 1126, 1126, 1399, 1343, 1400, 1400, 1344, 1400,
     1458, 1031, 1403, 1403, 1403, 1142,  703, 1448, 1142, 1063,
     1143, 1063, 1031, 1460, 1063, 1144,  704, 1449, 1144, 1401,
     1402, 1403, 1063, 1031, 1403, 1403, 1403, 1407, 1407, 1407,

     1461,  960, 1409, 1409, 1409, 1030, 1266,  478, 1462, 1462,
     1031, 1463,  478, 1464, 1465, 1031, 1404, 1171, 1171, 1171,
     1443, 1402, 1444, 1466, 1144, 1467, 1468, 1144, 1454, 1454,
     1454, 1142, 1031, 1469, 1470, 1471, 1143, 1444, 1403, 1444,
     1472, 1144, 1473, 1445, 1446, 1447, 1474, 1475, 1142, 1031,
     1447, 1447, 1447, 1476, 1031, 1447, 1447, 1447, 1144, 1030,
     1451, 1451, 1451, 1477, 1031, 1453, 1453, 1453, 1478, 1266,
      478, 1031, 1479, 1008, 1487,  478, 1031, 1482, 1483, 1484,
     1144,  748, 1492, 1480, 1446, 1481, 1448, 1492, 1455, 1493,
     1481, 1447, 1481, 1030, 1142, 1063, 1449, 1144, 1031, 1143,

     1494, 1142, 1495, 1031, 1144, 1484, 1484, 1484, 1496, 1497,
     1031, 1144, 1484, 1484, 1484, 1031, 1485, 1454, 1454, 1454,
     1486, 1488, 1488, 1488, 1498, 1301, 1031,  903, 1490, 1490,
     1490,  478, 1266, 1031, 1301, 1499, 1301, 1031,  478, 1500,
     1501, 1502, 1503, 1144, 1311, 1311, 1504, 1311, 1505,  903,
     1144,  748, 1506, 1483, 1507, 1507, 1484, 1507, 1508, 1509,
     1510, 1515, 1515, 1142, 1516, 1031, 1142,  960, 1143, 1510,
     1510, 1510, 1031, 1144, 1030, 1517, 1144, 1455, 1301, 1031,
     1510, 1510, 1510, 1485, 1301, 1518, 1301, 1486, 1519, 1311,
     1031, 1311, 1520, 1311,  903, 1511, 1511, 1511, 1513, 1513,

     1513, 1031, 1266, 1008,  748,  478, 1530, 1530,  478, 1521,
     1509, 1522, 1144, 1063, 1531, 1144, 1301, 1532, 1031, 1311,
     1142, 1522, 1510, 1522,  748, 1143, 1525, 1525, 1525, 1031,
     1144, 1542, 1142, 1523, 1524, 1525, 1525, 1525, 1525, 1542,
     1031, 1543, 1144, 1526, 1526, 1526, 1544, 1031,  748, 1030,
     1533, 1524, 1534,  478, 1031, 1551, 1551, 1031, 1528, 1528,
     1528, 1142, 1266, 1534, 1525, 1534, 1143, 1301,  478, 1144,
     1311, 1144,  748, 1556, 1142, 1556, 1535, 1536, 1537,  748,
     1561, 1144, 1561,  748, 1144, 1565, 1031, 1537, 1537, 1537,
     1565,  748, 1030, 1031,  478, 1360, 1031, 1031, 1537, 1537,

     1537, 1538, 1538, 1538, 1359, 1540, 1540, 1540, 1031, 1266,
     1144,  478, 1535, 1536, 1537,  478, 1545, 1536, 1546, 1031,
     1546, 1537, 1546, 1144, 1537, 1537, 1537, 1142, 1030, 1358,
     1357, 1142, 1143, 1031, 1356,  546, 1031, 1144, 1537, 1537,
     1537, 1144, 1547, 1547, 1547, 1031,  546, 1031, 1270, 1545,
     1536, 1546,  478, 1549, 1549, 1549, 1355, 1266, 1031, 1031,
     1142,  447, 1353,  478,  447, 1143, 1546, 1537, 1546, 1353,
     1144,  748, 1031, 1552, 1552, 1552, 1144, 1142,  449,  461,
     1144,  449,  461,  478, 1031,  549, 1255, 1144,  549, 1554,
     1554, 1554, 1338, 1266, 1557, 1557, 1557,  635, 1031,  478,

      635, 1559, 1559, 1559,  478, 1266, 1562, 1562, 1562, 1144,
     1337,  478, 1336, 1564, 1564, 1564,  478, 1266, 1566, 1566,
     1566,  647,  649,  478,  647,  649, 1144, 1335,  478, 1567,
     1567, 1567, 1331, 1266, 1568, 1568, 1568,  653, 1330,  478,
      653, 1569, 1569, 1569,  478, 1266, 1570, 1570, 1570,  447,
     1329,  478,  447, 1571, 1571, 1571,  478, 1266, 1572, 1572,
     1572,  449, 1328,  478,  449, 1573, 1573, 1573,  478, 1266,
     1574, 1574, 1574,  461, 1327,  478,  461, 1575, 1575, 1575,
      478, 1266, 1576, 1576, 1576,  549, 1326,  478,  549, 1577,
     1577, 1577,  478, 1266, 1578, 1578, 1578,  635, 1233,  478,

      635, 1579, 1579, 1579,  478, 1266, 1580, 1580, 1580,  647,
     1325,  478,  647, 1581, 1581, 1581,  478, 1266, 1582, 1582,
     1582,  649, 1323,  478,  649, 1583, 1583, 1583,  478, 1266,
     1584, 1584, 1584,  653, 1322,  478,  653, 1585, 1585, 1585,
      478, 1266, 1586, 1586, 1586,  449, 1227,  478,  449, 1587,
     1587, 1587,  478, 1266, 1588, 1588, 1588,  461, 1319,  478,
      461, 1589, 1589, 1589,  478, 1266, 1590, 1590, 1590,  449,
     1318,  478,  449, 1591, 1591, 1591,  478, 1266, 1592, 1592,
     1592, 1405, 1317,  478, 1405, 1593, 1593, 1593,  478, 1266,
     1594, 1594, 1594, 1311, 1316,  478, 1311, 1595, 1595, 1595,

      478, 1266, 1596, 1596, 1596, 1315, 1314,  478, 1313, 1597,
     1597, 1597,  478, 1266, 1598, 1598, 1598, 1312, 1309,  478,
     1308, 1599, 1599, 1599,  478, 1266, 1600, 1600, 1600, 1307,
     1301,  478, 1306, 1601, 1601, 1601,  478, 1266, 1602, 1602,
     1602, 1301, 1305,  478, 1304, 1603, 1603, 1603,  478, 1266,
     1604, 1604, 1604, 1303, 1302,  478, 1299, 1605, 1605, 1605,
      478, 1266, 1606, 1606, 1606, 1298, 1296,  478, 1295, 1607,
     1607, 1607,  478, 1266, 1608, 1608, 1608, 1294, 1293,  478,
     1289, 1609, 1609, 1609,  478, 1266, 1610, 1610, 1610, 1288,
     1287,  478, 1286, 1611, 1611, 1611,  478, 1266, 1612, 1612,

     1612, 1285, 1284,  478, 1283, 1613, 1613, 1613,  478, 1266,
     1614, 1614, 1614, 1281, 1280,  478, 1279, 1615, 1615, 1615,
      478, 1266, 1616, 1616, 1616, 1278, 1277,  478, 1276, 1617,
     1617, 1617,  478, 1266, 1618, 1618, 1618, 1275, 1274,  478,
     1273, 1619, 1619, 1619,  478, 1266, 1620, 1620, 1620, 1272,
     1271,  478, 1270, 1621, 1621, 1621,  478, 1266, 1622, 1622,
     1622, 1268, 1268,  478,  748, 1623, 1623, 1623,  478, 1266,
     1624, 1624, 1624, 1262, 1161,  478, 1261, 1625, 1625, 1625,
      478, 1266, 1626, 1626, 1626, 1158, 1256,  478, 1255, 1627,
     1627, 1627,  478, 1266, 1628, 1628, 1628,  451, 1138,  478,

     1137, 1629, 1629, 1629,  478, 1266, 1630, 1630, 1630, 1244,
     1243,  478, 1242, 1631, 1631, 1631,  478, 1266, 1632, 1632,
     1632, 1241, 1240,  478, 1239, 1633, 1633, 1633,  478, 1266,
     1634, 1634, 1634, 1238, 1237,  478, 1236, 1635, 1635, 1635,
      478, 1266, 1636, 1636, 1636, 1235, 1234,  478, 1233, 1637,
     1637, 1637,  478, 1266, 1638, 1638, 1638, 1231,  868,  478,
      868, 1639, 1639, 1639,  478, 1266, 1640, 1640, 1640, 1118,
     1224,  478, 1223, 1641, 1641, 1641,  478, 1266, 1642, 1642,
     1642, 1220, 1219,  478, 1218, 1643, 1643, 1643,  478, 1266,
     1644, 1644, 1644, 1217, 1214,  478, 1213, 1645, 1645, 1645,

      478, 1266, 1646, 1646, 1646, 1212, 1211,  478, 1210, 1647,
     1647, 1647,  478, 1266, 1648, 1648, 1648, 1209, 1208,  478,
     1207, 1649, 1649, 1649,  478, 1266, 1650, 1650, 1650, 1206,
     1203,  478, 1202, 1651, 1651, 1651,  478, 1266, 1652, 1652,
     1652, 1201, 1200,  478, 1199, 1653, 1653, 1653,  478, 1266,
     1654, 1654, 1654, 1198, 1197,  478, 1196, 1655, 1655, 1655,
      478, 1266, 1656, 1656, 1656, 1195, 1194,  478, 1193, 1657,
     1657, 1657,  478, 1266, 1658, 1658, 1658, 1192, 1191,  478,
     1190, 1659, 1659, 1659,  478, 1266, 1660, 1660, 1660, 1189,
     1188,  478, 1187, 1661, 1661, 1661,  478, 1266, 1662, 1662,

     1662, 1186, 1181,  478, 1180, 1663, 1663, 1663,  478, 1266,
     1664, 1664, 1664, 1179, 1178,  478, 1177, 1665, 1665, 1665,
      478, 1266, 1666, 1666, 1666, 1176, 1175,  478, 1174, 1667,
     1667, 1667,  478, 1266, 1668, 1668, 1668, 1173, 1172,  478,
     1170, 1669, 1669, 1669,  478, 1266, 1670, 1670, 1670, 1169,
     1168,  478, 1167, 1671, 1671, 1671,  478, 1266, 1672, 1672,
     1672, 1167,  748,  478, 1053, 1673, 1673, 1673,  478, 1266,
     1674, 1674, 1674,  730,  730,  478, 1161, 1675, 1675, 1675,
      478, 1266, 1676, 1676, 1676, 1160, 1159,  478, 1158, 1677,
     1677, 1677,  478, 1266, 1678, 1678, 1678, 1157,  907,  478,

     1151, 1679, 1679, 1679,  478, 1266, 1680, 1680, 1680, 1150,
     1026,  478, 1024, 1681, 1681, 1681,  478, 1266, 1682, 1682,
     1682, 1023, 1138,  478, 1137, 1683, 1683, 1683,  478, 1266,
     1684, 1684, 1684, 1136, 1135,  478, 1134, 1685, 1685, 1685,
      478, 1266, 1686, 1686, 1686, 1133, 1132,  478, 1131, 1687,
     1687, 1687,  478, 1266, 1688, 1688, 1688, 1130, 1129,  478,
     1128, 1689, 1689, 1689,  478, 1266, 1690, 1690, 1690, 1127,
     1125,  478, 1124, 1691, 1691, 1691,  478, 1266, 1692, 1692,
     1692, 1123, 1266,  478, 1122, 1693, 1693, 1693,  478, 1266,
     1694, 1694, 1694,  868, 1266,  478, 1110, 1695, 1695, 1695,

      478, 1266, 1696, 1696, 1696, 1061, 1266,  478,  986, 1697,
     1697, 1697,  478, 1266, 1697, 1697, 1697,  985, 1266,  478,
       86,   86,   86,   86,   86,   86,   86,   86,   86,   86,
       86,   86,   86,   86,   86,   86,   86,   86,   86,   86,
       86,  130,  130,  130,  130,  130,  130,  130,  130,  130,
      130,  130,  130,  130,  130,  130,  130,  130,  130,  130,
      130,  130,  139,  139,  139,  139,  139,  139,  139,  139,
      139,  139,  139,  139,  139,  139,  139,  139,  139,  139,
      139,  139,  139,  166,  166,  166,  166,  166,  166,  166,
      166,  166,  166,  166,  166,  166,  166,  166,  166,  166,

      166,  166,  166,  166,  173,  173,  173,  173,  173,  173,
      173,  173,  173,  173,  173,  173,  173,  173,  173,  173,
      173,  173,  173,  173,  173,  178,  178,  178,  178,  178,
      178,  178,  178,  178,  178,  178,  178,  178,  178,  178,
      178,  178,  178,  178,  178,  178,  185,  185,  185,  185,
      185,  185,  185,  185,  185,  185,  185,  185,  185,  185,
      185,  185,  185,  185,  185,  185,  185,  192,  192,  192,
      192,  192,  192,  192,  192,  192,  192,  192,  192,  192,
      192,  192,  192,  192,  192,  192,  192,  192,  200,  200,
      200,  200,  200,  200,  200,  200,  200,  200,  200,  200,

      200,  200,  200,  200,  200,  200,  200,  200,  200,  207,
      207,  207,  207,  207,  207,  207,  207,  207,  207,  207,
      207,  207,  207,  207,  207,  207,  207,  207,  207,  207,
      237,  237,  237,  237,  237,  237,  237,  237,  237,  237,
      237,  237,  237,  237,  237,  237,  237,  237,  237,  237,
      237,  244,  244,  244,  244,  244,  244,  244,  244,  244,
      244,  244,  244,  244,  244,  244,  244,  244,  244,  244,
      244,  244,  253,  253,  253,  253,  253,  253,  253,  253,
      253,  253,  253,  253,  253,  253,  253,  253,  253,  253,
      253,  253,  253,  268,  268,  268,  268,  268,  268,  268,

      268,  268,  268,  268,  268,  268,  268,  268,  268,  268,
      268,  268,  268,  268,  293,  293,  293,  293,  293,  293,
      293,  293,  293,  293,  293,  293,  293,  293,  293,  293,
      293,  293,  293,  293,  293,  306,  306,  306,  306,  306,
      306,  306,  306,  306,  306,  306,  306,  306,  306,  306,
      306,  306,  306,  306,  306,  306,  314,  314,  314,  314,
      314,  314,  314,  314,  314,  314,  314,  314,  314,  314,
      314,  314,  314,  314,  314,  314,  314,  323,  323,  323,
      323,  323,  323,  323,  323,  323,  323,  323,  323,  323,
      323,  323,  323,  323,  323,  323,  323,  323,  331,  331,

      331,  331,  331,  331,  331,  331,  331,  331,  331,  331,
      331,  331,  331,  331,  331,  331,  331,  331,  331,  367,
      367,  367,  367,  367,  367,  367,  367,  367,  367,  367,
      367,  367,  367,  367,  367,  367,  367,  367,  367,  367,
      378,  378,  378,  378,  378,  378,  378,  378,  378,  378,
      378,  378,  378,  378,  378,  378,  378,  378,  378,  378,
      378,  385,  385,  385,  385,  385,  385,  385,  385,  385,
      385,  385,  385,  385,  385,  385,  385,  385,  385,  385,
      385,  385,  397,  397,  397,  397,  397,  397,  397,  397,
      397,  397,  397,  397,  397,  397,  397,  397,  397,  397,

      397,  397,  397,  408,  408,  408,  408,  408,  408,  408,
      408,  408,  408,  408,  408,  408,  408,  408,  408,  408,
      408,  408,  408,  408,  413,  413,  413,  413,  413,  413,
      413,  413,  413,  413,  413,  413,  413,  413,  413,  413,
      413,  413,  413,  413,  413,  426,  426,  426,  426,  426,
      426,  426,  426,  426,  426,  426,  426,  426,  426,  426,
      426,  426,  426,  426,  426,  426,  465,  465,  465,  981,
      465,  465,  980,  465,  465,  976,  465,  465,  465,  465,
      975,  465,  465,  465,  465,  465,  465,  466,  466,  466,
     1089,  466,  466,  466,  466,  466, 1088,  466,  466,  466,

      466,  466,  466,  466,  466,  466,  466,  466,  469,  469,
      469, 1087,  469,  469, 1086,  469,  469,  469,  469,  469,
      469,  469,  469,  469,  469,  469,  469, 1085,  469,  473,
      473,  473, 1084,  473,  473,  473,  473,  473,  473,  473,
      473,  473,  473,  473,  473,  473,  473,  473,  473,  473,
      474,  474,  474, 1083,  474,  474,  474,  474,  474,  474,
      474,  474,  474,  474,  474,  474,  474,  474,  474,  474,
      474,  479,  479,  479, 1082, 1081, 1080, 1079, 1078,  479,
     1076, 1075, 1074, 1073,  479, 1072, 1071,  479,  482,  482,
      482,  482,  482,  482,  482,  482,  482,  482,  482,  482,

      482,  482,  482,  482,  482,  482,  482,  482,  482,  488,
      488,  488, 1070, 1069,  488, 1063,  488,  488,  488,  488,
      488,  488,  488,  488,  488,  488,  488,  488, 1068,  488,
      492,  492,  492, 1067,  492,  492,  492,  492,  492,  492,
      492,  492,  492,  492,  492,  492,  492,  492,  492,  492,
      492,  493,  493,  493, 1066, 1065,  493, 1064,  493,  493,
      493,  493,  493,  493,  493,  493,  493,  493,  493,  493,
      493,  493,  497,  497,  497,  942,  522,  497,  497,  497,
      497, 1059,  497,  497,  497,  497,  497,  497,  497,  497,
      497, 1059,  497,  501,  501,  501,  748,  501,  501,  501,

      501,  501,  501,  501,  501,  501,  501,  501,  501,  501,
      501,  501,  501,  501,  502,  502,  502,  730, 1045,  502,
     1044,  502,  502,  502,  502,  502,  502,  502,  502,  502,
      502,  502,  502, 1043,  502,  506,  506,  506, 1042,  506,
      506,  506,  506,  506,  506,  506,  506,  506,  506,  506,
      506,  506,  506,  506,  506,  506,  507,  507,  507,  507,
      507,  507,  507,  507,  507,  507,  507, 1041,  507,  507,
      507,  507,  507,  507,  507,  507,  507,  508,  508, 1040,
      508,  508,  508,  508,  508,  508,  508, 1039, 1034,  508,
      508,  508,  508,  508,  508,  508, 1033,  508,  513,  513,

      513,  903,  513,  513,  513,  513,  513,  513,  513,  513,
      513,  513,  513,  513,  513,  513,  513,  513,  513,  520,
     1026,  445, 1024, 1023, 1022, 1021, 1018,  520, 1017, 1016,
     1015, 1014,  520, 1008, 1013,  520,  521,  521,  521,  521,
      521,  521,  521,  521,  521,  521,  521,  521,  521,  521,
      521,  521,  521,  521,  521,  635,  521,  531,  531, 1012,
     1011, 1010, 1009, 1004,  897,  531,  897,  868,  635,  868,
      531,  635,  897,  531,  531,  541, 1000,  991,  990,  989,
      988,  987,  986,  985,  982,  981,  541,  980,  541,  977,
      588,  541,  552,  552,  552,  552,  552,  552,  552,  552,

      552,  552,  552,  552,  552,  552,  552,  552,  552,  552,
      552,  552,  552,  555,  588,  555,  976,  555,  555,  555,
      555,  555,  555,  555,  555,  975,  555,  972,  555,  555,
      971,  555,  583,  583,  583,  970,  583,  583,  583,  583,
      583,  583,  583,  583,  969,  583,  583,  583,  583,  583,
      583,  583,  583,  587,  587,  587,  968,  587,  587,  587,
      587,  587,  587,  587,  587,  967,  587,  587,  587,  587,
      587,  966,  587,  587,  605,  960,  605,  965,  605,  605,
      605,  605,  605,  605,  605,  605,  964,  605,  963,  605,
      605,  962,  605,  618,  618,  618,  961,  618,  618,  618,

      618,  618,  618,  618,  618,  618,  618,  618,  618,  618,
      956,  618,  955,  618,  619,  619,  619,  954,  619,  619,
      619,  619,  619,  619,  619,  619,  619,  619,  953,  619,
      619,  952,  619,  949,  619,  620,  948,  620,  947,  620,
      620,  620,  620,  620,  620,  620,  620,  620,  620,  620,
      620,  620,  945,  620,  944,  620,  626,  943,  626,  942,
      626,  626,  626,  626,  626,  626,  626,  626,  897,  626,
      626,  626,  626,  626,  626,  626,  626,  631,  785,  631,
      941,  631,  631,  631,  631,  631,  631,  631,  631,  631,
      631,  631,  631,  631,  631,  631,  631,  631,  652,  652,

      652,  522,  652,  652,  652,  652,  652,  652,  652,  652,
      652,  652,  652,  652,  652,  652,  652,  652,  652,  656,
      656,  656,  522,  656,  656,  656,  656,  656,  522,  656,
      656,  656,  656,  656,  656,  656,  656,  656,  656,  656,
      661,  661,  661,  661,  661,  661,  661,  661,  661,  661,
      661,  661,  661,  661,  661,  661,  661,  661,  661,  661,
      661,  664,  937,  936,  664,  936,  934,  664,  933,  664,
      664,  932,  664,  931,  664,  748,  925,  664,  665,  665,
      665,  925,  665,  730,  665,  665,  665,  665,  665,  665,
      730,  665,  727,  665,  665,  920,  665,  919,  665,  718,

      718,  718,  918,  718,  718,  718,  718,  718,  718,  718,
      718,  718,  718,  718,  718,  718,  718,  718,  718,  718,
      721,  721,  721,  917,  721,  721,  721,  721,  721,  721,
      721,  721,  721,  721,  721,  721,  721,  721,  721,  721,
      721,  465,  465,  465,  916,  465,  465,  915,  465,  465,
      914,  465,  465,  465,  465,  913,  465,  465,  465,  465,
      465,  465,  729,  729,  729,  912,  729,  729,  729,  729,
      729,  729,  729,  729,  729,  729,  729,  729,  729,  729,
      729,  911,  729,  731,  731,  731,  910,  731,  731,  731,
      731,  731,  731,  731,  731,  731,  731,  731,  731,  731,

      731,  731,  731,  731,  469,  469,  469,  909,  469,  469,
      908,  469,  469,  469,  469,  469,  469,  469,  469,  469,
      469,  469,  469,  907,  469,  734,  734,  734,  906,  734,
      734,  734,  734,  734,  734,  734,  734,  734,  734,  734,
      734,  734,  734,  734,  734,  734,  738,  738,  738,  905,
      738,  738,  738,  738,  738,  738,  738,  738,  738,  738,
      738,  738,  738,  738,  738,  738,  738,  743,  743,  743,
      903,  743,  743,  743,  743,  743,  743,  743,  743,  743,
      743,  743,  743,  743,  743,  743,  743,  743,  479,  479,
      479,  898,  897,  896,  895,  894,  479,  893,  691,  690,

      890,  479,  889,  888,  479,  747,  747,  887,  747,  747,
      747,  747,  747,  747,  747,  747,  886,  747,  747,  747,
      747,  747,  747,  747,  883,  747,  488,  488,  488,  882,
      881,  488,  879,  488,  488,  488,  488,  488,  488,  488,
      488,  488,  488,  488,  488,  878,  488,  493,  493,  493,
      877,  662,  493,  868,  493,  493,  493,  493,  493,  493,
      493,  493,  493,  493,  493,  493,  493,  493,  497,  497,
      497,  654,  864,  497,  497,  497,  497,  863,  497,  497,
      497,  497,  497,  497,  497,  497,  497,  862,  497,  502,
      502,  502,  861,  860,  502,  859,  502,  502,  502,  502,

      502,  502,  502,  502,  502,  502,  502,  502,  858,  502,
      507,  507,  507,  507,  507,  507,  507,  507,  507,  507,
      507,  857,  507,  507,  507,  507,  507,  507,  507,  507,
      507,  766,  766,  856,  766,  766,  766,  766,  766,  766,
      766,  636,  847,  766,  766,  766,  766,  766,  766,  766,
      840,  766,  513,  513,  513,  839,  513,  513,  513,  513,
      513,  513,  513,  513,  513,  513,  513,  513,  513,  513,
      513,  513,  513,  520,  617,  616,  835,  833,  832,  604,
      603,  520,  828,  588,  588,  823,  520,  822,  582,  520,
      521,  521,  521,  521,  521,  521,  521,  521,  521,  521,

      521,  521,  521,  521,  521,  521,  521,  521,  521,  581,
      521,  531,  531,  817,  816,  815,  814,  813,  810,  531,
      809,  808,  806,  805,  531,  804,  550,  531,  531,  541,
      785,  545,  784,  783,  537,  536,  535,  536,  782,  526,
      541,  522,  541,  767,  767,  541,  552,  552,  552,  552,
      552,  552,  552,  552,  552,  552,  552,  552,  552,  552,
      552,  552,  552,  552,  552,  552,  552,  555,  483,  555,
      748,  555,  555,  555,  555,  555,  555,  555,  555,  742,
      555,  730,  555,  555,  725,  555,  583,  583,  583,  717,
      583,  583,  583,  583,  583,  583,  583,  583,  716,  583,

      583,  583,  583,  583,  583,  583,  583,  587,  587,  587,
      715,  587,  587,  587,  587,  587,  587,  587,  587,  714,
      587,  587,  587,  587,  587,  710,  587,  587,  605,  707,
      605,  706,  605,  605,  605,  605,  605,  605,  605,  605,
      700,  605,  448,  605,  605,  437,  605,  618,  618,  618,
      691,  618,  618,  618,  618,  618,  618,  618,  618,  618,
      618,  618,  618,  618,  690,  618,  668,  618,  619,  619,
      619,  437,  619,  619,  619,  619,  619,  619,  619,  619,
      619,  619,  437,  619,  619,  437,  619,  657,  619,  620,
      437,  620,  437,  620,  620,  620,  620,  620,  620,  620,

      620,  620,  620,  620,  620,  620,  648,  620,  437,  620,
      626,  646,  626,  645,  626,  626,  626,  626,  626,  626,
      626,  626,  644,  626,  626,  626,  626,  626,  626,  626,
      626,  631,  643,  631,  642,  631,  631,  631,  631,  631,
      631,  631,  631,  631,  631,  631,  631,  631,  631,  631,
      631,  631,  867,  867,  867,  641,  867,  867,  867,  867,
      867,  867,  867,  867,  867,  867,  867,  867,  867,  867,
      867,  640,  867,  869,  869,  869,  639,  869,  869,  869,
      869,  869,  869,  869,  869,  869,  869,  869,  869,  869,
      869,  869,  869,  869,  664,  638,  437,  664,  634,  630,

      664,  627,  664,  664,  437,  664,  617,  664,  616,  608,
      664,  665,  665,  665,  606,  665,  604,  665,  665,  665,
      665,  665,  665,  603,  665,  594,  665,  665,  588,  665,
      589,  665,  899,  899,  899,  588,  899,  899,  899,  899,
      899,  899,  899,  899,  899,  899,  899,  899,  899,  899,
      899,  899,  899,  902,  902,  902,  588,  902,  902,  902,
      902,  902,  902,  902,  902,  902,  902,  902,  902,  902,
      902,  902,  902,  902,  447,  588,  586,  584,  582,  581,
      559,  556,  447,  437,  437,  437,  545,  447,  542,  538,
      447,  718,  718,  718,  537,  718,  718,  718,  718,  718,

      718,  718,  718,  718,  718,  718,  718,  718,  718,  718,
      718,  718,  721,  721,  721,  536,  721,  721,  721,  721,
      721,  721,  721,  721,  721,  721,  721,  721,  721,  721,
      721,  721,  721,  921,  921,  921,  535,  921,  921,  921,
      921,  921,  921,  921,  921,  921,  921,  921,  921,  921,
      921,  921,  522,  921,  465,  465,  465,  522,  465,  465,
      522,  465,  465,  522,  465,  465,  465,  465,  512,  465,
      465,  465,  465,  465,  465,  734,  734,  734,  509,  734,
      734,  734,  734,  734,  734,  734,  734,  734,  734,  734,
      734,  734,  734,  734,  734,  734,  736,  736,  736,  505,

      736,  736,  736,  736,  736,  736,  736,  736,  736,  736,
      736,  736,  736,  736,  736,  736,  736,  738,  738,  738,
      500,  738,  738,  738,  738,  738,  738,  738,  738,  738,
      738,  738,  738,  738,  738,  738,  738,  738,  740,  740,
      740,  496,  740,  740,  740,  740,  740,  740,  740,  740,
      740,  740,  740,  740,  740,  740,  740,  740,  740,  469,
      469,  469,  491,  469,  469,  487,  469,  469,  469,  469,
      469,  469,  469,  469,  469,  469,  469,  469,  476,  469,
      929,  929,  437,  929,  929,  929,  929,  929,  929,  929,
      929,  475,  929,  929,  929,  929,  929,  929,  929,  472,

      929,  479,  479,  479,  468,  467,  464,  437,  458,  479,
      457,  451,  450,  437,  479,  448,  437,  479,  488,  488,
      488,  437, 1698,  488,  165,  488,  488,  488,  488,  488,
      488,  488,  488,  488,  488,  488,  488, 1698,  488,  493,
      493,  493, 1698, 1698,  493, 1698,  493,  493,  493,  493,
      493,  493,  493,  493,  493,  493,  493,  493,  493,  493,
      497,  497,  497, 1698, 1698,  497,  497,  497,  497, 1698,
      497,  497,  497,  497,  497,  497,  497,  497,  497, 1698,
      497,  502,  502,  502, 1698, 1698,  502, 1698,  502,  502,
      502,  502,  502,  502,  502,  502,  502,  502,  502,  502,

     1698,  502,  935,  935, 1698,  935,  935,  935,  935,  935,
      935,  935, 1698, 1698,  935,  935,  935,  935,  935,  935,
      935, 1698,  935,  507,  507,  507,  507,  507,  507,  507,
      507,  507,  507,  507, 1698,  507,  507,  507,  507,  507,
      507,  507,  507,  507,  513,  513,  513, 1698,  513,  513,
      513,  513,  513,  513,  513,  513,  513,  513,  513,  513,
      513,  513,  513,  513,  513,  521,  521,  521,  521,  521,
      521,  521,  521,  521,  521,  521,  521,  521,  521,  521,
      521,  521,  521,  521, 1698,  521,  555, 1698,  555, 1698,
      555,  555,  555,  555,  555,  555,  555,  555, 1698,  555,

     1698,  555,  555, 1698,  555,  583,  583,  583, 1698,  583,
      583,  583,  583,  583,  583,  583,  583, 1698,  583,  583,
      583,  583,  583,  583,  583,  583,  587,  587,  587, 1698,
      587,  587,  587,  587,  587,  587,  587,  587, 1698,  587,
      587,  587,  587,  587, 1698,  587,  587,  605, 1698,  605,
     1698,  605,  605,  605,  605,  605,  605,  605,  605, 1698,
      605, 1698,  605,  605, 1698,  605,  620, 1698,  620, 1698,
      620,  620,  620,  620,  620,  620,  620,  620,  620,  620,
      620,  620,  620, 1698,  620, 1698,  620,  618,  618,  618,
     1698,  618,  618,  618,  618,  618,  618,  618,  618,  618,

      618,  618,  618,  618, 1698,  618, 1698,  618,  626, 1698,
      626, 1698,  626,  626,  626,  626,  626,  626,  626,  626,
     1698,  626,  626,  626,  626,  626,  626,  626,  626,  631,
     1698,  631, 1698,  631,  631,  631,  631,  631,  631,  631,
      631,  631,  631,  631,  631,  631,  631,  631,  631,  631,
     1001, 1001, 1001, 1698, 1001, 1001, 1001, 1001, 1001, 1001,
     1001, 1001, 1001, 1001, 1001, 1001, 1001, 1001, 1001, 1698,
     1001,  665,  665,  665, 1698,  665, 1698,  665,  665,  665,
      665,  665,  665, 1698,  665, 1698,  665,  665, 1698,  665,
     1698,  665,  899,  899,  899, 1698,  899,  899,  899,  899,

      899,  899,  899,  899,  899,  899,  899,  899,  899,  899,
      899,  899,  899, 1025, 1025, 1025, 1698, 1025, 1025, 1025,
     1025, 1025, 1025, 1025, 1025, 1025, 1025, 1025, 1025, 1025,
     1025, 1025, 1025, 1025,  902,  902,  902, 1698,  902,  902,
      902,  902,  902,  902,  902,  902,  902,  902,  902,  902,
      902,  902,  902,  902,  902,  447, 1698, 1698, 1698, 1698,
     1698, 1698, 1698,  447, 1698, 1698, 1698, 1698,  447, 1698,
     1698,  447,  718,  718,  718, 1698,  718,  718,  718,  718,
      718,  718,  718,  718,  718,  718,  718,  718,  718,  718,
      718,  718,  718,  461, 1698, 1698,  461, 1698, 1698, 1698,

     1698,  461, 1698, 1698, 1698, 1698,  461, 1698, 1698,  461,
     1051, 1051, 1051, 1698, 1051, 1051, 1051, 1051, 1051, 1051,
     1051, 1051, 1051, 1051, 1051, 1051, 1051, 1051, 1051, 1698,
     1051,  734,  734,  734, 1698,  734,  734,  734,  734,  734,
      734,  734,  734,  734,  734,  734,  734,  734,  734,  734,
      734,  734, 1056, 1056, 1698, 1056, 1056, 1056, 1056, 1056,
     1056, 1056, 1056, 1698, 1056, 1056, 1056, 1056, 1056, 1056,
     1056, 1698, 1056,  479,  479,  479, 1698, 1698, 1698, 1698,
     1698,  479, 1698, 1698, 1698, 1698,  479, 1698, 1698,  479,
      488,  488,  488, 1698, 1698,  488, 1698,  488,  488,  488,

      488,  488,  488,  488,  488,  488,  488,  488,  488, 1698,
      488,  493,  493,  493, 1698, 1698,  493, 1698,  493,  493,
      493,  493,  493,  493,  493,  493,  493,  493,  493,  493,
      493,  493,  497,  497,  497, 1698, 1698,  497,  497,  497,
      497, 1698,  497,  497,  497,  497,  497,  497,  497,  497,
      497, 1698,  497,  502,  502,  502, 1698, 1698,  502, 1698,
      502,  502,  502,  502,  502,  502,  502,  502,  502,  502,
      502,  502, 1698,  502, 1058, 1058, 1698, 1058, 1058, 1058,
     1058, 1058, 1058, 1058, 1698, 1698, 1058, 1058, 1058, 1058,
     1058, 1058, 1058, 1698, 1058,  507,  507,  507,  507,  507,

      507,  507,  507,  507,  507,  507, 1698,  507,  507,  507,
      507,  507,  507,  507,  507,  507,  513,  513,  513, 1698,
      513,  513,  513,  513,  513,  513,  513,  513,  513,  513,
      513,  513,  513,  513,  513,  513,  513,  521,  521,  521,
      521,  521,  521,  521,  521,  521,  521,  521,  521,  521,
      521,  521,  521,  521,  521,  521, 1698,  521,  605, 1698,
      605, 1698,  605,  605,  605,  605,  605,  605,  605,  605,
      605,  605, 1698,  605,  605, 1698,  605, 1120, 1120, 1120,
     1698, 1120, 1120, 1120, 1120, 1120, 1120, 1120, 1120, 1120,
     1120, 1120, 1120, 1120, 1120, 1120, 1698, 1120, 1139, 1139,

     1139, 1139, 1139, 1139, 1139, 1139, 1139, 1139, 1139, 1139,
     1139, 1139, 1139, 1139, 1139, 1139, 1139, 1139, 1139, 1164,
     1164, 1698, 1164, 1164, 1164, 1164, 1164, 1164, 1164, 1164,
     1698, 1164, 1164, 1164, 1164, 1164, 1164, 1164, 1698, 1164,
     1166, 1166, 1698, 1166, 1166, 1166, 1166, 1166, 1166, 1166,
     1698, 1698, 1166, 1166, 1166, 1166, 1166, 1166, 1166, 1698,
     1166, 1264, 1264, 1698, 1264, 1264, 1264, 1264, 1264, 1264,
     1264, 1264, 1698, 1264, 1264, 1264, 1264, 1264, 1264, 1264,
     1698, 1264, 1267, 1267, 1698, 1267, 1267, 1267, 1267, 1267,
     1267, 1267, 1698, 1698, 1267, 1267, 1267, 1267, 1267, 1267,

     1267, 1698, 1267, 1282, 1282, 1282, 1282, 1282, 1282, 1282,
     1282, 1282, 1282, 1282, 1282, 1282, 1282, 1282, 1282, 1282,
     1282, 1282, 1282, 1282, 1290, 1290, 1290, 1290, 1290, 1290,
     1290, 1290, 1290, 1290, 1290, 1290, 1290, 1290, 1290, 1290,
     1290, 1290, 1290, 1290, 1290, 1324, 1324, 1324, 1324, 1324,
     1324, 1324, 1324, 1324, 1324, 1324, 1324, 1324, 1324, 1324,
     1324, 1324, 1324, 1324, 1324, 1324, 1332, 1332, 1332, 1332,
     1332, 1332, 1332, 1332, 1332, 1332, 1332, 1332, 1332, 1332,
     1332, 1332, 1332, 1332, 1332, 1332, 1332, 1346, 1698, 1698,
     1698, 1346, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698,

     1698, 1346, 1698, 1346, 1349, 1349, 1698, 1349, 1349, 1349,
     1349, 1349, 1349, 1349, 1349, 1698, 1349, 1349, 1349, 1349,
     1349, 1349, 1349, 1698, 1349, 1351, 1351, 1351, 1351, 1351,
     1351, 1698, 1351, 1351, 1351, 1351, 1351, 1351, 1351, 1351,
     1351, 1351, 1351, 1351, 1351, 1351, 1352, 1352, 1698, 1352,
     1352, 1352, 1352, 1352, 1352, 1352, 1698, 1698, 1352, 1352,
     1352, 1352, 1352, 1352, 1352, 1698, 1352, 1354, 1354, 1354,
     1354, 1354, 1354, 1354, 1354, 1354, 1354, 1354, 1354, 1354,
     1354, 1354, 1354, 1354, 1354, 1354, 1354, 1354, 1408, 1408,
     1698, 1408, 1408, 1408, 1408, 1408, 1408, 1408, 1408, 1698,

     1408, 1408, 1408, 1408, 1408, 1408, 1408, 1698, 1408, 1411,
     1411, 1698, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1698,
     1698, 1411, 1411, 1411, 1411, 1411, 1411, 1411, 1698, 1411,
     1421, 1421, 1421, 1421, 1421, 1421, 1421, 1421, 1421, 1421,
     1421, 1421, 1421, 1421, 1421, 1698, 1421, 1421, 1698, 1421,
     1421, 1441, 1441, 1441, 1441, 1441, 1441, 1441, 1441, 1441,
     1441, 1441, 1441, 1441, 1441, 1441, 1698, 1441, 1441, 1698,
     1441, 1441, 1452, 1452, 1698, 1452, 1452, 1452, 1452, 1452,
     1452, 1452, 1452, 1698, 1452, 1452, 1452, 1452, 1452, 1452,
     1452, 1698, 1452, 1456, 1456, 1698, 1456, 1456, 1456, 1456,

     1456, 1456, 1456, 1698, 1698, 1456, 1456, 1456, 1456, 1456,
     1456, 1456, 1698, 1456, 1459, 1459, 1459, 1459, 1459, 1459,
     1459, 1459, 1459, 1459, 1459, 1459, 1459, 1459, 1459, 1698,
     1459, 1459, 1698, 1459, 1459,  902,  902,  902, 1698,  902,
      902,  902,  902,  902,  902,  902,  902,  902,  902,  902,
      902,  902,  902,  902,  902,  902, 1489, 1489, 1698, 1489,
     1489, 1489, 1489, 1489, 1489, 1489, 1489, 1698, 1489, 1489,
     1489, 1489, 1489, 1489, 1489, 1698, 1489, 1491, 1491, 1698,
     1491, 1491, 1491, 1491, 1491, 1491, 1491, 1698, 1698, 1491,
     1491, 1491, 1491, 1491, 1491, 1491, 1698, 1491, 1512, 1512,

     1698, 1512, 1512, 1512, 1512, 1512, 1512, 1512, 1512, 1698,
     1512, 1512, 1512, 1512, 1512, 1512, 1512, 1698, 1512, 1514,
     1514, 1698, 1514, 1514, 1514, 1514, 1514, 1514, 1514, 1698,
     1698, 1514, 1514, 1514, 1514, 1514, 1514, 1514, 1698, 1514,
     1527, 1527, 1698, 1527, 1527, 1527, 1527, 1527, 1527, 1527,
     1527, 1698, 1527, 1527, 1527, 1527, 1527, 1527, 1527, 1698,
     1527, 1529, 1529, 1698, 1529, 1529, 1529, 1529, 1529, 1529,
     1529, 1698, 1698, 1529, 1529, 1529, 1529, 1529, 1529, 1529,
     1698, 1529, 1539, 1539, 1698, 1539, 1539, 1539, 1539, 1539,
     1539, 1539, 1539, 1698, 1539, 1539, 1539, 1539, 1539, 1539,

     1539, 1698, 1539, 1541, 1541, 1698, 1541, 1541, 1541, 1541,
     1541, 1541, 1541, 1698, 1698, 1541, 1541, 1541, 1541, 1541,
     1541, 1541, 1698, 1541, 1548, 1548, 1698, 1548, 1548, 1548,
     1548, 1548, 1548, 1548, 1548, 1698, 1548, 1548, 1548, 1548,
     1548, 1548, 1548, 1698, 1548, 1550, 1550, 1698, 1550, 1550,
     1550, 1550, 1550, 1550, 1550, 1698, 1698, 1550, 1550, 1550,
     1550, 1550, 1550, 1550, 1698, 1550, 1553, 1553, 1698, 1553,
     1553, 1553, 1553, 1553, 1553, 1553, 1553, 1698, 1553, 1553,
     1553, 1553, 1553, 1553, 1553, 1698, 1553, 1555, 1555, 1698,
     1555, 1555, 1555, 1555, 1555, 1555, 1555, 1698, 1698, 1555,

     1555, 1555, 1555, 1555, 1555, 1555, 1698, 1555, 1558, 1558,
     1698, 1558, 1558, 1558, 1558, 1558, 1558, 1558, 1558, 1698,
     1558, 1558, 1558, 1558, 1558, 1558, 1558, 1698, 1558, 1560,
     1560, 1698, 1560, 1560, 1560, 1560, 1560, 1560, 1560, 1698,
     1698, 1560, 1560, 1560, 1560, 1560, 1560, 1560, 1698, 1560,
     1563, 1563, 1698, 1563, 1563, 1563, 1563, 1563, 1563, 1563,
     1563, 1698, 1563, 1563, 1563, 1563, 1563, 1563, 1563, 1698,
     1563,   85, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698,
     1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698,
     1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698,

     1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698,
     1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698,
     1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698,
     1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698
    } ;

static const flex_int16_t yy_chk[7939] =
    {   0,
        0,    1,    0,    1,    1,    2,  992,    2,    2,    3,
        0,    3,    3,  159,  159,   90,  100,  110,    1,   90,
      100,  110,    2,  200,  124,  136,    3,    1,  124,  136,
      143,    2,  206,  433,  143,    3,  102,  102,  102,  102,
      153,  169,  206,  200,  153,  169,  102,  102,  102,  102,
      115,  116,  115,  102,  127,  992,  127,   99,  116,  116,
      175,  433,   99,  181,  175,    1,  188,  181,  197,    2,
      188, 1276,  197,    3,    4,    4,    4,    4,    4,    4,
        4,    4,    4,    4,    4,    4,    4,    4,    4,    4,
        4,    4,    4,    4,    4,    4,    4,    4,    4,    4,

        4,    4,    4,    4,    4,    4,    4,    4,    4,    4,
        4,    4,    4,    4,    4,    4,    4,    4,    4,    4,
        4,    4,    4,    4,    4,    4,    4,    4,    4,    4,
        4,    4,    4,    4,    4,    4,    4,    4,    4,    4,
        5,    5,    5,    5,    5,    5,    5,    5,    5,    5,
        5,    5,    5,    5,    5,    5,    5,    5,    5,    5,
        5,    5,    5,    5,    5,    5,    5,    5,    5,    5,
        5,    5,    5,    5,    5,    5,    5,    5,    5,    5,
        5,    5,    5,    5,    5,    5,    5,    5,    5,    5,
        5,    5,    5,    5,    5,    5,    5,    5,    5,    5,

        5,    5,    5,    5,    5,    5,    7,    7,    7,    7,
        7,    7,    7,    7,    7,    7,    7,    7,    7,    7,
        7,    7,    7,    7,    7,    7,    7,    7,    7,    7,
        7,    7,    7,    7,    7,    7,    7,    7,    7,    7,
        7,    7,    7,    7,    7,    7,    7,    7,    7,    7,
        7,    7,    7,    7,    7,    7,    7,    7,    7,    7,
        7,    7,    7,    7,    7,    7,    7,    7,    7,    7,
        7,    7,    9,  734,    9,    9,   10,    9,   10,   10,
      201,   10,    9,  202,  205,  216,   10,  213,  213,    9,
      235,  235,   11,   10,   11,   11,  216,   11,    9,  204,

      201,  734,   10,  202,  205,   12,  212,   12,   12,   11,
       12,  156,  156,  156,  157,  157,  157,  973,   11,  204,
      204,  156,   12,  225,  157,   11,  211,  203,  225,  973,
      212,   12,  161,  161,  161,  203,    9,  211,   12,  203,
       10,  211,  161,  157,  158,  158,  158,  203,  158,  221,
      568,  161,  436,  231,  158,  241,   11,  231,  246,  241,
      282,  161,  250,  246,  221,  436,  250,  282,  568,   12,
       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,

       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
       13,   13,   13,   13,   13,   13,   17,  262,   17,   17,
       18,   17,   18,   18,   19,   18,   19,   19,  258,   19,
      273,  435,  258,   17,  273,  215,  215,   18,  288,  288,
      435,   19,   17,  262,  281,  215,   18,  287,  281,   17,
       19,  287,   20,   18,   20,   20,   21,   20,   21,   21,
       22,  297,   22,   22,  281,  297,   21,  215,  306,   20,
       22,  299,  299,   21,  459,  310,  543,   22,   20,  310,

       17,  543,   21,  459,   18,  306,   22,  309,   19,   21,
      284,  284,   23,   22,   23,   23,   24,   23,   24,   24,
       25,   24,   25,   25,  309,  160,  160,  160,  430,   23,
      313,  264,   25,   24, 1277,  160,   20,   25,   23,  430,
       21,  284,   24,  264,   22,   23,   25,  313,   26,   24,
       26,   26,   27,  311,   27,   27,   28,   27,   28,   28,
       26,   28,  447,  318,  328,   26,  264,  318,  328,   27,
      311,  334,  447,   28,   26,  334,   23,   27,   27,  311,
       24,   28,   28,  160,   25,  312,  341,  345,  345, 1278,
      341,  312,  360,  264,  371, 1279,  360,  312,  371,  312,

      376,  381,  383,  383,  376,  381,  393,  402,  404,  404,
      393,  402,   26,  410,  418,  431,   27,  410,  418,  431,
       28,   29,   29,   29,   29,   29,   29,   29,   29,   29,
       29,   29,   29,   29,   29,   29,   29,   29,   29,   29,
       29,   29,   29,   29,   29,   29,   29,   29,   29,   29,
       29,   29,   29,   29,   29,   29,   29,   29,   29,   29,
       29,   29,   29,   29,   29,   29,   29,   29,   29,   29,
       29,   29,   29,   29,   29,   29,   29,   29,   29,   29,
       29,   29,   29,   29,   29,   29,   29,   31,  460,   31,
       31,   32,  448,   32,   32,  452,  462,   39,  289,   39,

       39,  460,  448, 1280,   31,  452,  462,  475,   32,  489,
      289,  467,  467,   31,   39,  475,  475,   32,  489,  437,
       31,  471,  471,   39,   32,  437,  437,  437,  490,  495,
      437,  618,  437,  289,  471,  470,  470,  494,  437,  437,
      437,  490,  495,  448,  470,  624,  494,  624,  618, 1281,
      471,   31,  477,  477,  477,   32,   33,   33,   33,   33,
      289,   39,  477,   33,  470,   33,   33,   33,   33,   33,
       33,   33,   33,   33,   33,   33,   33,   33,   33,   33,
       33,   33,   33,   33,   33,   33,   33,   33,   33,   35,
       35,   35,   35,   35,   35,   35,   35,   35,   35,   35,

       35,   35,   35,   35,   35,   35,   35,   35,   35,   35,
       35,   35,   35,   35,   35,   35,   35,   35,   35,   35,
       35,   35,   35,   35,   35,   35,   35,   35,   35,   35,
       35,   35,   35,   35,   35,   35,   35,   35,   35,   35,
       35,   35,   35,   35,   35,   35,   35,   35,   35,   35,
       35,   35,   35,   35,   35,   37,   37,   37,   37,   37,
       37,   37,   37,   37,   37,   37,   37,   37,   37,   37,
       37,   37,   37,   37,   37,   37,   37,   37,   37,   37,
       37,   37,   37,   37,   37,   37,   37,   37,   37,   37,
       37,   37,   37,   37,   37,   37,   37,   37,   37,   37,

       37,   37,   37,   37,   37,   37,   37,   37,   37,   37,
       37,   37,   37,   37,   37,   37,   37,   37,   37,   37,
       37,   40,   40,   40,   40,  995,   43,   40,   43,   43,
      265,   44,  498,   44,   44,  479,  479,  479,   40,   43,
      513,  498,  265,   43,   44,  479,  265,   40,   44,  499,
      503,   51,   43,   51,   51,  574,  504,   44,  510,  503,
      513,  454,  499,  290,  454,  265,  518,  510,   51,  504,
       53,  454,   53,   53,  995,  290,  518,   51,   51,  290,
       54,  574,   54,   54,   51,   40,   41,   53,   41,   41,
       43,   52,  265,   52,   52,   44,   53,   54,  290,   41,

      454,  511,  593,   41,  302,  524,   54,  524,   52,  735,
      454,  520,   41,   41,  511,   51,  302,   52,   52,   41,
      524,  520,   41,  422,   52,  290,  423,  515,  515,  533,
     1282,   53,   53,  593,   53,  422,  515,  735,  423,  302,
      533,   54,   54,   55,   54,   55,   55,   41,  515,   41,
       41,   42,   42,   42,   42,   52,   55,  548,  422,  860,
       55,  423,  464, 1284,   42,  464,  302,  547,   42,   55,
      548,  539,  464,  486,  486,  486,  547,   42,   42,  441,
      441,  441,  441,  486,   42,  422,  539,   42,  423,  441,
      441,  441,  441,  480,  480,  480,  441,  480,  523,  553,

      523,  464,  486,  480,  553,  627,  669,   55,  669,  523,
      627,  464,   42,  860,   42,   42,   45,   45,   45,   45,
       45,   45,   45,   45,   45,   45,   45,   45,   45,   45,
       45,   45,   45,   45,   45,   45,   45,   45,   45,   45,
       45,   45,   45,   45,   45,   45,   45,   45,   45,   45,
       45,   45,   45,   45,   45,   45,   45,   45,   45,   45,
       45,   45,   45,   45,   45,   45,   45,   45,   45,   45,
       45,   45,   45,   45,   45,   45,   45,   45,   45,   45,
       45,   45,   47,  541,   47,   47,  848,   56,  558,   56,
       56,  848,  528,  528,   57,   47,   57,   57,  541,   47,

       56,  558,  531,  531,   56,  738,  516,  516,   47,   47,
      528,   57,  531,   56,   58,   47,   58,   58,   47,  516,
       57,  575,  485,  485,  485, 1285,  595,  516, 1286,  585,
      575,   58,  485,  738,  531,  595,   65,  580,   65,   65,
       58,   65,  585,   47,  576,   47,   47,   48,   48,   48,
       48,   56,  557,   65,  657,  657,  576,  607,   57,  859,
       48,  557,   65,  564,   48,  557,  607,  564,   71,   65,
       71,   71,  580,   48,   48,  702,  702,  485,   58,  576,
       48,  303,  621,   48,  577,   71,  628,   66,  564,   66,
       66,  621,   66,  303,   71,  628,  577,  303,  632,  580,

       65,   71,  602,  859,   66, 1287,  576,  632,   48,  622,
       48,   48,   49,   66,   49,   49,  303,  564,  590,  577,
       66,  650,  622,  598,   67,   49,   67,   67,  597,   49,
      650,  590,   71,  597,   67,  598,  772,  602,   49,   49,
      629,   67,  677,  303,  778,   49,  577,  590,   49,  599,
       67,   66,  692,  629,  611,  597,  772,   67,  598,  778,
      677,  599,  615,  692,  602,   72,  611,   72,   72,   83,
     1288,   83,   83,   49,   83,   49,   49,   50,   50,   50,
       50,  798,   72,  597,  599,  598,   83,  633,   67,  611,
       50,   72,  651, 1111,   50,   83,  861,  615,   72,  798,

      633,  468,   83,   50,   50,  651,  658,  468,  468,  468,
       50,  599,  468,   50,  468,  658,  611,  659,  660,  666,
      468,  468,  468,  667,  615,  701,  659,  703,  666,   72,
      861,  660, 1111,   83, 1289,  701,  667,  703,   50, 1290,
       50,   50,   59,   59,   59,   59,   59,   59,   59,   59,
       59,   59,   59,   59,   59,   59,   59,   59,   59,   59,
       59,   59,   59,   59,   59,   59,   59,   59,   59,   59,
       59,   59,   59,   59,   59,   59,   59,   59,   59,   59,
       59,   59,   59,   59,   59,   59,   59,   59,   59,   59,
       59,   59,   59,   59,   59,   59,   59,   59,   59,   59,

       59,   59,   59,   59,   59,   59,   59,   59,   61,   61,
       61,   61,   61,   61,   61,   61,   61,   61,   61,   61,
       61,   61,   61,   61,   61,   61,   61,   61,   61,   61,
       61,   61,   61,   61,   61,   61,   61,   61,   61,   61,
       61,   61,   61,   61,   61,   61,   61,   61,   61,   61,
       61,   61,   61,   61,   61,   61,   61,   61,   61,   61,
       61,   61,   61,   61,   61,   61,   61,   61,   61,   61,
       61,   61,   61,   61,   63,  472,  732,  746,  746,  746,
     1095,  472,  472,  472,  732,  732,  472,  746,  472,  687,
       63,   63,   63,   63,  472,  472,  472,   63, 1095,   63,

       63,   63,   63,   63,   63,   63,   63,   63,   63,   63,
       63,   63,   63,   63,   63,   63,   63,   63,   63,   63,
       63,   63,   63,   68,  687,   68,   68,  705, 1116,   75,
      610,   75,   75,   68,   75,  610,  737,  705,  739,   75,
       68,  781,  781,  781, 1293,  745,   75,  774,  737,   68,
      775,  687,  491,  745,  745,   75,   68,  610,  491,  491,
      491,  705,   75,  491,  737,  491,  739,  774,  804,  978,
      775,  491,  491,  491,  773,  899,  899, 1294,  804,  805,
     1116,  978,  749,  749,  749,  610,  773,   68,   69,   69,
       69,   69,  749,   75,  773,   69,  805,   69,   69,   69,

       69,   69,   69,   69,   69,   69,   69,   69,   69,   69,
       69,   69,   69,   69,   69,   69,   69,   69,   69,   69,
       69,   73,  749,   73,   73,  612,   73,  782,  857, 1295,
      863,   73,   73,   73,  924,  844, 1296,  612,   73,  821,
       76,  858,   76,   76,  831,   76,  683,   73,   73,  782,
       76,   84,  844,   84,   84,  673,   84,   76,  683,  673,
      612, 1225,  924,  870,  857,  794,   76,  974,   84,  794,
      863,  870,  870,   76,  821,  938,  838,   84,  857,  831,
      673,  683,  878,  877,   84,   73,   74,  612,   74,   74,
      794,   74,  858,  877,  974,  938,   74,   74,   74,  878,

     1225,  821,  996,   74,   76,  892,  831, 1298,  683,  673,
      496,  838,   74,   74,  943,   84,  496,  496,  496,  794,
     1037,  496,  979,  496,  943,  907,  500,  944,  907,  496,
      496,  496,  500,  500,  500,  907,  684,  500,  838,  500,
      892,  998,  996,  904,  944,  500,  500,  500,  684,  979,
       74,   77,   77,  904,   77,   77,  983,   77,   77,   77,
       77, 1047,   77,  994, 1037,   77,   77,  892,  983,   77,
      917,  684, 1299,  917,   77,   77,   77,   77,   77,   77,
      917,  998,  984,  505,   77,   77,   77, 1040,   77,  505,
      505,  505,  923,  993,  505,  904,  505, 1040,  684,  820,

      923,  923,  505,  505,  505, 1047,  901,  901,  901,  984,
      994,  820, 1020,   77,   77,   77,   77,   78,   78, 1300,
       78,   78,  901,   78,   78,   78,   78,  901,   78,  927,
     1302,   78,   78, 1303,  820,   78,  830,  927,  927, 1020,
       78,   78,   78,   78,   78,   78,  993, 1019,  830,  512,
       78,   78,   78,  837,   78,  512,  512,  512, 1304, 1019,
      512,  820,  512, 1030, 1305,  837,  901, 1030,  512,  512,
      512,  830,  903,  903,  903,  960,  960,  960, 1114,   78,
       78,   78,   78,   81,  559,   81,   81,   81,  837, 1306,
      559,  559,  559,  903, 1307,  559,   81,  559,  830, 1003,

       81, 1308, 1105,  559,  559,  559,  586, 1003, 1003,   81,
       81,  891,  586,  586,  586,  837,   81,  586, 1114,  586,
     1105,  919,  608,  891,  919,  586,  586,  586,  608,  608,
      608,  919,  903,  608, 1032,  608,  999,  999,  999, 1192,
     1192,  608,  608,  608, 1032, 1139,  891,   81,   82,   82,
       82,   82,   82,  918, 1144, 1139,  918,  920, 1197, 1197,
      920,   82,  919,  918, 1144,   82, 1155,  920, 1008, 1008,
     1008, 1309,  630,  891,   82,   82, 1155, 1310,  630,  630,
      630,   82, 1312,  630,   82,  630, 1142, 1142,  634, 1313,
     1032,  630,  630,  630,  634,  634,  634,  918,  920,  634,

     1049,  634, 1142, 1049, 1063, 1063, 1063,  634,  634,  634,
     1049,   82,   82,   95,   95,   95,   95,   95,   95,   95,
       95,   95,   95,   95,   95,   95,   95,   95,   95,   95,
       95,   95,   95,   95,   95,   95,   95,   95,   95,   95,
       95,   95,   95,   95,   95,   95,   95,   95,   95,   95,
       95,   95,   95,   95,   95,   95,   95,   95,   95,   95,
       95,   95,   95,   95,   95,   95,   95,   95,   95,   95,
       95,   95,   95,   95,   95,   95,   95,   95,   95,  260,
      928,  928,  928, 1314, 1152,  260, 1075, 1075, 1075, 1157,
      928,  260,  260,  260,  260, 1048,  260,  260, 1048, 1157,

      260,  260,  260, 1240, 1240, 1048,  260,  260, 1291, 1291,
      260,  260,  420, 1050, 1200, 1211, 1050, 1315,  420, 1077,
     1077, 1077, 1316, 1050,  420,  420,  420,  420, 1152,  420,
      420, 1200, 1211,  420,  420,  420, 1048, 1249, 1317,  420,
      420, 1249, 1318,  420,  420,  439,  439,  439,  439,  439,
      439,  439,  439,  439,  439,  439,  439,  439,  439,  439,
      439,  439,  439,  439,  439,  439,  439,  439,  439,  439,
      439,  439,  439,  439,  439,  439,  439,  439,  439,  439,
      439,  439,  439,  439,  439,  439,  439,  439,  439,  439,
      439,  439,  439,  439,  439,  439,  439,  439,  439,  439,

      439,  439,  439,  439,  439,  439,  439,  439,  439,  439,
      439,  446, 1028, 1028, 1028, 1158,  930,  930,  930, 1158,
     1323,  446, 1029, 1029, 1029, 1324,  930, 1326,  446,  446,
      446,  446, 1250, 1028, 1055, 1055, 1055, 1158,  446,  446,
      446,  446, 1250, 1029, 1055,  446,  517,  517, 1257, 1074,
     1074, 1074,  517,  517,  517, 1327, 1328,  517, 1257,  517,
     1329, 1057, 1057, 1057, 1330,  517,  517,  517,  525,  930,
      525, 1057, 1028, 1110, 1110, 1110,  525,  525,  525, 1331,
     1332,  525, 1029,  525, 1027, 1027, 1027, 1333, 1333,  525,
      525,  525,  560,  560,  560,  560, 1149,  560,  560, 1335,

     1027,  560,  560,  560, 1336, 1027, 1149,  560,  560, 1074,
     1057,  560,  560,  591, 1115, 1115, 1115, 1337, 1338,  591,
      591,  591, 1247, 1247,  591, 1261,  591, 1117, 1117, 1117,
     1143, 1347,  591,  591,  591, 1126, 1126, 1126, 1247, 1349,
     1143, 1143,  591,  623, 1027, 1143, 1149,  623, 1351, 1163,
     1163, 1163, 1352,  623,  623,  623, 1353, 1354,  623, 1163,
      623, 1356, 1256,  668, 1357, 1256,  623,  623,  623,  668,
      668,  668, 1256, 1358,  668, 1261,  668, 1171, 1171, 1171,
     1359, 1360,  668,  668,  668,  908,  908,  908,  908,  908,
      908,  908,  908,  908,  908,  908,  908,  908,  908,  908,

      908,  908,  908,  908,  908,  908,  908,  908,  908,  908,
      908,  908,  908,  908,  908,  908,  908,  908,  908,  908,
      908,  908,  908,  908,  908,  908,  908,  908,  908,  908,
      908,  908,  908,  908,  908,  908,  908,  908,  908,  908,
      908,  908,  908,  908,  908,  908,  908,  908,  908,  908,
      908,  977,  977, 1123, 1123, 1123,  977,  977, 1259, 1361,
      977,  977, 1259, 1026, 1026, 1026,  977, 1362, 1363,  977,
      977,  977,  982,  982, 1026, 1320, 1364,  982,  982, 1026,
     1259,  982,  982, 1365, 1026, 1320, 1366,  982, 1368, 1369,
      982,  982,  982, 1140, 1140, 1140, 1141, 1141, 1141, 1370,

     1145, 1145, 1145, 1371, 1140, 1262, 1372, 1141, 1262, 1140,
     1183, 1183, 1183, 1123, 1140, 1262, 1145, 1141, 1168, 1168,
     1168, 1145, 1373, 1026, 1039, 1039, 1039, 1039, 1039, 1039,
     1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039, 1039,
     1039, 1039, 1039, 1146, 1146, 1146, 1374, 1039, 1039, 1039,
     1039, 1039, 1039, 1140, 1375, 1376, 1141, 1039, 1039, 1039,
     1145, 1039, 1377, 1378, 1146, 1185, 1185, 1185, 1379, 1147,
     1147, 1147, 1165, 1165, 1165, 1380, 1165, 1381, 1168, 1221,
     1221, 1221, 1165, 1226, 1226, 1226, 1039, 1039, 1039, 1039,
     1147, 1230, 1230, 1230, 1245, 1245, 1245, 1246, 1246, 1246,

     1251, 1251, 1251, 1146, 1254, 1245, 1382, 1383, 1246, 1384,
     1245, 1252, 1252, 1252, 1254, 1245, 1251, 1385, 1246, 1386,
     1387, 1251, 1253, 1253, 1253, 1263, 1263, 1263, 1388, 1147,
     1389, 1390, 1252, 1392, 1394, 1263, 1265, 1265, 1265, 1395,
     1265, 1390, 1396, 1253, 1397, 1398, 1265, 1283, 1283, 1283,
     1321, 1321, 1321, 1406, 1245, 1408, 1411, 1246, 1412, 1254,
     1251, 1325, 1325, 1325, 1339, 1339, 1339, 1340, 1340, 1340,
     1413, 1252, 1343, 1343, 1343, 1339, 1345, 1404, 1340, 1415,
     1339, 1416, 1253, 1417, 1418, 1339, 1345, 1404, 1340, 1342,
     1342, 1342, 1419, 1343, 1344, 1344, 1344, 1348, 1348, 1348,

     1420, 1422, 1350, 1350, 1350, 1342, 1350, 1348, 1423, 1423,
     1342, 1424, 1350, 1425, 1426, 1344, 1345, 1355, 1355, 1355,
     1399, 1399, 1399, 1427, 1339, 1428, 1429, 1340, 1410, 1410,
     1410, 1399, 1343, 1430, 1431, 1432, 1399, 1400, 1400, 1400,
     1433, 1399, 1434, 1401, 1401, 1401, 1435, 1436, 1400, 1342,
     1402, 1402, 1402, 1437, 1344, 1403, 1403, 1403, 1400, 1401,
     1407, 1407, 1407, 1438, 1401, 1409, 1409, 1409, 1439, 1409,
     1407, 1402, 1440, 1442, 1450, 1409, 1403, 1445, 1445, 1445,
     1399, 1452, 1456, 1443, 1443, 1443, 1448, 1457, 1410, 1458,
     1444, 1444, 1444, 1445, 1443, 1460, 1448, 1400, 1445, 1443,

     1461, 1444, 1463, 1401, 1443, 1446, 1446, 1446, 1464, 1465,
     1402, 1444, 1447, 1447, 1447, 1403, 1449, 1454, 1454, 1454,
     1449, 1451, 1451, 1451, 1466, 1467, 1446, 1449, 1453, 1453,
     1453, 1451, 1453, 1447, 1468, 1469, 1470, 1445, 1453, 1471,
     1472, 1473, 1474, 1443, 1475, 1476, 1477, 1478, 1479, 1486,
     1444, 1489, 1480, 1480, 1480, 1481, 1481, 1481, 1482, 1482,
     1482, 1491, 1492, 1480, 1493, 1446, 1481, 1494, 1480, 1483,
     1483, 1483, 1447, 1480, 1482, 1495, 1481, 1454, 1496, 1482,
     1484, 1484, 1484, 1485, 1497, 1498, 1499, 1485, 1500, 1501,
     1483, 1502, 1503, 1504, 1485, 1488, 1488, 1488, 1490, 1490,

     1490, 1484, 1490, 1505, 1512, 1488, 1514, 1515, 1490, 1506,
     1506, 1506, 1480, 1516, 1517, 1481, 1518, 1519, 1482, 1520,
     1506, 1507, 1507, 1507, 1527, 1506, 1509, 1509, 1509, 1483,
     1506, 1529, 1507, 1508, 1508, 1508, 1510, 1510, 1510, 1530,
     1484, 1531, 1507, 1511, 1511, 1511, 1532, 1509, 1539, 1508,
     1521, 1521, 1521, 1511, 1508, 1541, 1542, 1510, 1513, 1513,
     1513, 1521, 1513, 1522, 1522, 1522, 1521, 1543, 1513, 1506,
     1544, 1521, 1548, 1550, 1522, 1551, 1523, 1523, 1523, 1553,
     1555, 1507, 1556, 1558, 1522, 1560, 1509, 1524, 1524, 1524,
     1561, 1563, 1523, 1508, 1690, 1275, 1510, 1523, 1525, 1525,

     1525, 1526, 1526, 1526, 1274, 1528, 1528, 1528, 1524, 1528,
     1521, 1526, 1535, 1535, 1535, 1528, 1533, 1533, 1533, 1525,
     1534, 1534, 1534, 1522, 1536, 1536, 1536, 1533, 1535, 1273,
     1272, 1534, 1533, 1535, 1271, 1749, 1523, 1533, 1537, 1537,
     1537, 1534, 1538, 1538, 1538, 1536, 1749, 1524, 1270, 1545,
     1545, 1545, 1538, 1540, 1540, 1540, 1269, 1540, 1525, 1537,
     1545, 1725, 1268, 1540, 1725, 1545, 1546, 1546, 1546, 1267,
     1545, 1264, 1535, 1547, 1547, 1547, 1533, 1546, 1726, 1727,
     1534, 1726, 1727, 1547, 1536, 1750, 1255, 1546, 1750, 1549,
     1549, 1549, 1244, 1549, 1552, 1552, 1552, 1761, 1537, 1549,

     1761, 1554, 1554, 1554, 1552, 1554, 1557, 1557, 1557, 1545,
     1243, 1554, 1242, 1559, 1559, 1559, 1557, 1559, 1562, 1562,
     1562, 1762, 1763, 1559, 1762, 1763, 1546, 1241, 1562, 1564,
     1564, 1564, 1239, 1564, 1566, 1566, 1566, 1765, 1238, 1564,
     1765, 1567, 1567, 1567, 1566, 1567, 1568, 1568, 1568, 1770,
     1237, 1567, 1770, 1569, 1569, 1569, 1568, 1569, 1570, 1570,
     1570, 1771, 1236, 1569, 1771, 1571, 1571, 1571, 1570, 1571,
     1572, 1572, 1572, 1774, 1235, 1571, 1774, 1573, 1573, 1573,
     1572, 1573, 1574, 1574, 1574, 1795, 1234, 1573, 1795, 1575,
     1575, 1575, 1574, 1575, 1576, 1576, 1576, 1806, 1233, 1575,

     1806, 1577, 1577, 1577, 1576, 1577, 1578, 1578, 1578, 1807,
     1232, 1577, 1807, 1579, 1579, 1579, 1578, 1579, 1580, 1580,
     1580, 1808, 1231, 1579, 1808, 1581, 1581, 1581, 1580, 1581,
     1582, 1582, 1582, 1809, 1229, 1581, 1809, 1583, 1583, 1583,
     1582, 1583, 1584, 1584, 1584, 1817, 1228, 1583, 1817, 1585,
     1585, 1585, 1584, 1585, 1586, 1586, 1586, 1820, 1222, 1585,
     1820, 1587, 1587, 1587, 1586, 1587, 1588, 1588, 1588, 1853,
     1220, 1587, 1853, 1589, 1589, 1589, 1588, 1589, 1590, 1590,
     1590, 1884, 1219, 1589, 1884, 1591, 1591, 1591, 1590, 1591,
     1592, 1592, 1592, 1218, 1217, 1591, 1216, 1593, 1593, 1593,

     1592, 1593, 1594, 1594, 1594, 1215, 1214, 1593, 1213, 1595,
     1595, 1595, 1594, 1595, 1596, 1596, 1596, 1212, 1210, 1595,
     1209, 1597, 1597, 1597, 1596, 1597, 1598, 1598, 1598, 1208,
     1207, 1597, 1206, 1599, 1599, 1599, 1598, 1599, 1600, 1600,
     1600, 1205, 1204, 1599, 1203, 1601, 1601, 1601, 1600, 1601,
     1602, 1602, 1602, 1202, 1201, 1601, 1199, 1603, 1603, 1603,
     1602, 1603, 1604, 1604, 1604, 1198, 1196, 1603, 1195, 1605,
     1605, 1605, 1604, 1605, 1606, 1606, 1606, 1194, 1193, 1605,
     1191, 1607, 1607, 1607, 1606, 1607, 1608, 1608, 1608, 1190,
     1189, 1607, 1188, 1609, 1609, 1609, 1608, 1609, 1610, 1610,

     1610, 1187, 1186, 1609, 1182, 1611, 1611, 1611, 1610, 1611,
     1612, 1612, 1612, 1181, 1180, 1611, 1179, 1613, 1613, 1613,
     1612, 1613, 1614, 1614, 1614, 1178, 1177, 1613, 1176, 1615,
     1615, 1615, 1614, 1615, 1616, 1616, 1616, 1175, 1174, 1615,
     1173, 1617, 1617, 1617, 1616, 1617, 1618, 1618, 1618, 1172,
     1170, 1617, 1169, 1619, 1619, 1619, 1618, 1619, 1620, 1620,
     1620, 1167, 1166, 1619, 1164, 1621, 1621, 1621, 1620, 1621,
     1622, 1622, 1622, 1162, 1161, 1621, 1160, 1623, 1623, 1623,
     1622, 1623, 1624, 1624, 1624, 1159, 1153, 1623, 1151, 1625,
     1625, 1625, 1624, 1625, 1626, 1626, 1626, 1150, 1138, 1625,

     1137, 1627, 1627, 1627, 1626, 1627, 1628, 1628, 1628, 1136,
     1135, 1627, 1134, 1629, 1629, 1629, 1628, 1629, 1630, 1630,
     1630, 1133, 1132, 1629, 1131, 1631, 1631, 1631, 1630, 1631,
     1632, 1632, 1632, 1130, 1129, 1631, 1128, 1633, 1633, 1633,
     1632, 1633, 1634, 1634, 1634, 1127, 1125, 1633, 1124, 1635,
     1635, 1635, 1634, 1635, 1636, 1636, 1636, 1122, 1121, 1635,
     1120, 1637, 1637, 1637, 1636, 1637, 1638, 1638, 1638, 1119,
     1113, 1637, 1112, 1639, 1639, 1639, 1638, 1639, 1640, 1640,
     1640, 1109, 1108, 1639, 1107, 1641, 1641, 1641, 1640, 1641,
     1642, 1642, 1642, 1106, 1104, 1641, 1103, 1643, 1643, 1643,

     1642, 1643, 1644, 1644, 1644, 1102, 1101, 1643, 1100, 1645,
     1645, 1645, 1644, 1645, 1646, 1646, 1646, 1099, 1098, 1645,
     1097, 1647, 1647, 1647, 1646, 1647, 1648, 1648, 1648, 1096,
     1094, 1647, 1093, 1649, 1649, 1649, 1648, 1649, 1650, 1650,
     1650, 1092, 1091, 1649, 1090, 1651, 1651, 1651, 1650, 1651,
     1652, 1652, 1652, 1089, 1088, 1651, 1087, 1653, 1653, 1653,
     1652, 1653, 1654, 1654, 1654, 1086, 1085, 1653, 1084, 1655,
     1655, 1655, 1654, 1655, 1656, 1656, 1656, 1083, 1082, 1655,
     1081, 1657, 1657, 1657, 1656, 1657, 1658, 1658, 1658, 1080,
     1079, 1657, 1078, 1659, 1659, 1659, 1658, 1659, 1660, 1660,

     1660, 1076, 1073, 1659, 1072, 1661, 1661, 1661, 1660, 1661,
     1662, 1662, 1662, 1071, 1070, 1661, 1069, 1663, 1663, 1663,
     1662, 1663, 1664, 1664, 1664, 1068, 1067, 1663, 1066, 1665,
     1665, 1665, 1664, 1665, 1666, 1666, 1666, 1065, 1064, 1665,
     1062, 1667, 1667, 1667, 1666, 1667, 1668, 1668, 1668, 1061,
     1060, 1667, 1059, 1669, 1669, 1669, 1668, 1669, 1670, 1670,
     1670, 1058, 1056, 1669, 1054, 1671, 1671, 1671, 1670, 1671,
     1672, 1672, 1672, 1052, 1051, 1671, 1045, 1673, 1673, 1673,
     1672, 1673, 1674, 1674, 1674, 1044, 1043, 1673, 1042, 1675,
     1675, 1675, 1674, 1675, 1676, 1676, 1676, 1041, 1038, 1675,

     1034, 1677, 1677, 1677, 1676, 1677, 1678, 1678, 1678, 1033,
     1025, 1677, 1024, 1679, 1679, 1679, 1678, 1679, 1680, 1680,
     1680, 1023, 1022, 1679, 1021, 1681, 1681, 1681, 1680, 1681,
     1682, 1682, 1682, 1018, 1017, 1681, 1016, 1683, 1683, 1683,
     1682, 1683, 1684, 1684, 1684, 1015, 1014, 1683, 1013, 1685,
     1685, 1685, 1684, 1685, 1686, 1686, 1686, 1012, 1011, 1685,
     1010, 1687, 1687, 1687, 1686, 1687, 1688, 1688, 1688, 1009,
     1007, 1687, 1006, 1689, 1689, 1689, 1688, 1689, 1691, 1691,
     1691, 1005, 1691, 1689, 1004, 1692, 1692, 1692, 1691, 1692,
     1693, 1693, 1693, 1001, 1693, 1692,  989, 1694, 1694, 1694,

     1693, 1694, 1695, 1695, 1695,  988, 1695, 1694,  986, 1696,
     1696, 1696, 1695, 1696, 1697, 1697, 1697,  985, 1697, 1696,
     1699, 1699, 1699, 1699, 1699, 1699, 1699, 1699, 1699, 1699,
     1699, 1699, 1699, 1699, 1699, 1699, 1699, 1699, 1699, 1699,
     1699, 1700, 1700, 1700, 1700, 1700, 1700, 1700, 1700, 1700,
     1700, 1700, 1700, 1700, 1700, 1700, 1700, 1700, 1700, 1700,
     1700, 1700, 1701, 1701, 1701, 1701, 1701, 1701, 1701, 1701,
     1701, 1701, 1701, 1701, 1701, 1701, 1701, 1701, 1701, 1701,
     1701, 1701, 1701, 1702, 1702, 1702, 1702, 1702, 1702, 1702,
     1702, 1702, 1702, 1702, 1702, 1702, 1702, 1702, 1702, 1702,

     1702, 1702, 1702, 1702, 1703, 1703, 1703, 1703, 1703, 1703,
     1703, 1703, 1703, 1703, 1703, 1703, 1703, 1703, 1703, 1703,
     1703, 1703, 1703, 1703, 1703, 1704, 1704, 1704, 1704, 1704,
     1704, 1704, 1704, 1704, 1704, 1704, 1704, 1704, 1704, 1704,
     1704, 1704, 1704, 1704, 1704, 1704, 1705, 1705, 1705, 1705,
     1705, 1705, 1705, 1705, 1705, 1705, 1705, 1705, 1705, 1705,
     1705, 1705, 1705, 1705, 1705, 1705, 1705, 1706, 1706, 1706,
     1706, 1706, 1706, 1706, 1706, 1706, 1706, 1706, 1706, 1706,
     1706, 1706, 1706, 1706, 1706, 1706, 1706, 1706, 1707, 1707,
     1707, 1707, 1707, 1707, 1707, 1707, 1707, 1707, 1707, 1707,

     1707, 1707, 1707, 1707, 1707, 1707, 1707, 1707, 1707, 1708,
     1708, 1708, 1708, 1708, 1708, 1708, 1708, 1708, 1708, 1708,
     1708, 1708, 1708, 1708, 1708, 1708, 1708, 1708, 1708, 1708,
     1709, 1709, 1709, 1709, 1709, 1709, 1709, 1709, 1709, 1709,
     1709, 1709, 1709, 1709, 1709, 1709, 1709, 1709, 1709, 1709,
     1709, 1710, 1710, 1710, 1710, 1710, 1710, 1710, 1710, 1710,
     1710, 1710, 1710, 1710, 1710, 1710, 1710, 1710, 1710, 1710,
     1710, 1710, 1711, 1711, 1711, 1711, 1711, 1711, 1711, 1711,
     1711, 1711, 1711, 1711, 1711, 1711, 1711, 1711, 1711, 1711,
     1711, 1711, 1711, 1712, 1712, 1712, 1712, 1712, 1712, 1712,

     1712, 1712, 1712, 1712, 1712, 1712, 1712, 1712, 1712, 1712,
     1712, 1712, 1712, 1712, 1713, 1713, 1713, 1713, 1713, 1713,
     1713, 1713, 1713, 1713, 1713, 1713, 1713, 1713, 1713, 1713,
     1713, 1713, 1713, 1713, 1713, 1714, 1714, 1714, 1714, 1714,
     1714, 1714, 1714, 1714, 1714, 1714, 1714, 1714, 1714, 1714,
     1714, 1714, 1714, 1714, 1714, 1714, 1715, 1715, 1715, 1715,
     1715, 1715, 1715, 1715, 1715, 1715, 1715, 1715, 1715, 1715,
     1715, 1715, 1715, 1715, 1715, 1715, 1715, 1716, 1716, 1716,
     1716, 1716, 1716, 1716, 1716, 1716, 1716, 1716, 1716, 1716,
     1716, 1716, 1716, 1716, 1716, 1716, 1716, 1716, 1717, 1717,

     1717, 1717, 1717, 1717, 1717, 1717, 1717, 1717, 1717, 1717,
     1717, 1717, 1717, 1717, 1717, 1717, 1717, 1717, 1717, 1718,
     1718, 1718, 1718, 1718, 1718, 1718, 1718, 1718, 1718, 1718,
     1718, 1718, 1718, 1718, 1718, 1718, 1718, 1718, 1718, 1718,
     1719, 1719, 1719, 1719, 1719, 1719, 1719, 1719, 1719, 1719,
     1719, 1719, 1719, 1719, 1719, 1719, 1719, 1719, 1719, 1719,
     1719, 1720, 1720, 1720, 1720, 1720, 1720, 1720, 1720, 1720,
     1720, 1720, 1720, 1720, 1720, 1720, 1720, 1720, 1720, 1720,
     1720, 1720, 1721, 1721, 1721, 1721, 1721, 1721, 1721, 1721,
     1721, 1721, 1721, 1721, 1721, 1721, 1721, 1721, 1721, 1721,

     1721, 1721, 1721, 1722, 1722, 1722, 1722, 1722, 1722, 1722,
     1722, 1722, 1722, 1722, 1722, 1722, 1722, 1722, 1722, 1722,
     1722, 1722, 1722, 1722, 1723, 1723, 1723, 1723, 1723, 1723,
     1723, 1723, 1723, 1723, 1723, 1723, 1723, 1723, 1723, 1723,
     1723, 1723, 1723, 1723, 1723, 1724, 1724, 1724, 1724, 1724,
     1724, 1724, 1724, 1724, 1724, 1724, 1724, 1724, 1724, 1724,
     1724, 1724, 1724, 1724, 1724, 1724, 1728, 1728, 1728,  981,
     1728, 1728,  980, 1728, 1728,  976, 1728, 1728, 1728, 1728,
      975, 1728, 1728, 1728, 1728, 1728, 1728, 1729, 1729, 1729,
      972, 1729, 1729, 1729, 1729, 1729,  971, 1729, 1729, 1729,

     1729, 1729, 1729, 1729, 1729, 1729, 1729, 1729, 1730, 1730,
     1730,  970, 1730, 1730,  969, 1730, 1730, 1730, 1730, 1730,
     1730, 1730, 1730, 1730, 1730, 1730, 1730,  968, 1730, 1731,
     1731, 1731,  967, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
     1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731, 1731,
     1732, 1732, 1732,  966, 1732, 1732, 1732, 1732, 1732, 1732,
     1732, 1732, 1732, 1732, 1732, 1732, 1732, 1732, 1732, 1732,
     1732, 1733, 1733, 1733,  965,  964,  963,  962,  961, 1733,
      959,  958,  957,  956, 1733,  955,  954, 1733, 1734, 1734,
     1734, 1734, 1734, 1734, 1734, 1734, 1734, 1734, 1734, 1734,

     1734, 1734, 1734, 1734, 1734, 1734, 1734, 1734, 1734, 1735,
     1735, 1735,  953,  952, 1735,  951, 1735, 1735, 1735, 1735,
     1735, 1735, 1735, 1735, 1735, 1735, 1735, 1735,  950, 1735,
     1736, 1736, 1736,  949, 1736, 1736, 1736, 1736, 1736, 1736,
     1736, 1736, 1736, 1736, 1736, 1736, 1736, 1736, 1736, 1736,
     1736, 1737, 1737, 1737,  948,  947, 1737,  945, 1737, 1737,
     1737, 1737, 1737, 1737, 1737, 1737, 1737, 1737, 1737, 1737,
     1737, 1737, 1738, 1738, 1738,  942,  939, 1738, 1738, 1738,
     1738,  936, 1738, 1738, 1738, 1738, 1738, 1738, 1738, 1738,
     1738,  935, 1738, 1739, 1739, 1739,  929, 1739, 1739, 1739,

     1739, 1739, 1739, 1739, 1739, 1739, 1739, 1739, 1739, 1739,
     1739, 1739, 1739, 1739, 1740, 1740, 1740,  921,  915, 1740,
      914, 1740, 1740, 1740, 1740, 1740, 1740, 1740, 1740, 1740,
     1740, 1740, 1740,  913, 1740, 1741, 1741, 1741,  912, 1741,
     1741, 1741, 1741, 1741, 1741, 1741, 1741, 1741, 1741, 1741,
     1741, 1741, 1741, 1741, 1741, 1741, 1742, 1742, 1742, 1742,
     1742, 1742, 1742, 1742, 1742, 1742, 1742,  911, 1742, 1742,
     1742, 1742, 1742, 1742, 1742, 1742, 1742, 1743, 1743,  910,
     1743, 1743, 1743, 1743, 1743, 1743, 1743,  909,  906, 1743,
     1743, 1743, 1743, 1743, 1743, 1743,  905, 1743, 1744, 1744,

     1744,  902, 1744, 1744, 1744, 1744, 1744, 1744, 1744, 1744,
     1744, 1744, 1744, 1744, 1744, 1744, 1744, 1744, 1744, 1745,
      900,  898,  896,  895,  894,  893,  890, 1745,  889,  888,
      887,  886, 1745,  885,  884, 1745, 1746, 1746, 1746, 1746,
     1746, 1746, 1746, 1746, 1746, 1746, 1746, 1746, 1746, 1746,
     1746, 1746, 1746, 1746, 1746, 1846, 1746, 1747, 1747,  883,
      882,  881,  879,  876,  873, 1747,  871,  869, 1846,  867,
     1747, 1846,  865, 1747, 1747, 1748,  864,  856,  853,  847,
      846,  842,  840,  839,  835,  833, 1748,  832, 1748,  828,
      827, 1748, 1751, 1751, 1751, 1751, 1751, 1751, 1751, 1751,

     1751, 1751, 1751, 1751, 1751, 1751, 1751, 1751, 1751, 1751,
     1751, 1751, 1751, 1752,  826, 1752,  823, 1752, 1752, 1752,
     1752, 1752, 1752, 1752, 1752,  822, 1752,  819, 1752, 1752,
      818, 1752, 1753, 1753, 1753,  817, 1753, 1753, 1753, 1753,
     1753, 1753, 1753, 1753,  816, 1753, 1753, 1753, 1753, 1753,
     1753, 1753, 1753, 1754, 1754, 1754,  815, 1754, 1754, 1754,
     1754, 1754, 1754, 1754, 1754,  814, 1754, 1754, 1754, 1754,
     1754,  813, 1754, 1754, 1755,  812, 1755,  811, 1755, 1755,
     1755, 1755, 1755, 1755, 1755, 1755,  810, 1755,  809, 1755,
     1755,  808, 1755, 1756, 1756, 1756,  806, 1756, 1756, 1756,

     1756, 1756, 1756, 1756, 1756, 1756, 1756, 1756, 1756, 1756,
      803, 1756,  802, 1756, 1757, 1757, 1757,  801, 1757, 1757,
     1757, 1757, 1757, 1757, 1757, 1757, 1757, 1757,  800, 1757,
     1757,  799, 1757,  797, 1757, 1758,  796, 1758,  795, 1758,
     1758, 1758, 1758, 1758, 1758, 1758, 1758, 1758, 1758, 1758,
     1758, 1758,  793, 1758,  792, 1758, 1759,  791, 1759,  789,
     1759, 1759, 1759, 1759, 1759, 1759, 1759, 1759,  787, 1759,
     1759, 1759, 1759, 1759, 1759, 1759, 1759, 1760,  785, 1760,
      784, 1760, 1760, 1760, 1760, 1760, 1760, 1760, 1760, 1760,
     1760, 1760, 1760, 1760, 1760, 1760, 1760, 1760, 1764, 1764,

     1764,  780, 1764, 1764, 1764, 1764, 1764, 1764, 1764, 1764,
     1764, 1764, 1764, 1764, 1764, 1764, 1764, 1764, 1764, 1766,
     1766, 1766,  779, 1766, 1766, 1766, 1766, 1766,  777, 1766,
     1766, 1766, 1766, 1766, 1766, 1766, 1766, 1766, 1766, 1766,
     1767, 1767, 1767, 1767, 1767, 1767, 1767, 1767, 1767, 1767,
     1767, 1767, 1767, 1767, 1767, 1767, 1767, 1767, 1767, 1767,
     1767, 1768,  769,  767, 1768,  766,  763, 1768,  759, 1768,
     1768,  755, 1768,  751, 1768,  747,  744, 1768, 1769, 1769,
     1769,  743, 1769,  731, 1769, 1769, 1769, 1769, 1769, 1769,
      729, 1769,  728, 1769, 1769,  727, 1769,  725, 1769, 1772,

     1772, 1772,  724, 1772, 1772, 1772, 1772, 1772, 1772, 1772,
     1772, 1772, 1772, 1772, 1772, 1772, 1772, 1772, 1772, 1772,
     1773, 1773, 1773,  723, 1773, 1773, 1773, 1773, 1773, 1773,
     1773, 1773, 1773, 1773, 1773, 1773, 1773, 1773, 1773, 1773,
     1773, 1775, 1775, 1775,  720, 1775, 1775,  717, 1775, 1775,
      716, 1775, 1775, 1775, 1775,  715, 1775, 1775, 1775, 1775,
     1775, 1775, 1776, 1776, 1776,  714, 1776, 1776, 1776, 1776,
     1776, 1776, 1776, 1776, 1776, 1776, 1776, 1776, 1776, 1776,
     1776,  713, 1776, 1777, 1777, 1777,  712, 1777, 1777, 1777,
     1777, 1777, 1777, 1777, 1777, 1777, 1777, 1777, 1777, 1777,

     1777, 1777, 1777, 1777, 1778, 1778, 1778,  710, 1778, 1778,
      709, 1778, 1778, 1778, 1778, 1778, 1778, 1778, 1778, 1778,
     1778, 1778, 1778,  708, 1778, 1779, 1779, 1779,  707, 1779,
     1779, 1779, 1779, 1779, 1779, 1779, 1779, 1779, 1779, 1779,
     1779, 1779, 1779, 1779, 1779, 1779, 1780, 1780, 1780,  706,
     1780, 1780, 1780, 1780, 1780, 1780, 1780, 1780, 1780, 1780,
     1780, 1780, 1780, 1780, 1780, 1780, 1780, 1781, 1781, 1781,
      704, 1781, 1781, 1781, 1781, 1781, 1781, 1781, 1781, 1781,
     1781, 1781, 1781, 1781, 1781, 1781, 1781, 1781, 1782, 1782,
     1782,  700,  697,  691,  690,  689, 1782,  688,  686,  685,

      682, 1782,  681,  680, 1782, 1783, 1783,  679, 1783, 1783,
     1783, 1783, 1783, 1783, 1783, 1783,  678, 1783, 1783, 1783,
     1783, 1783, 1783, 1783,  676, 1783, 1784, 1784, 1784,  675,
      674, 1784,  672, 1784, 1784, 1784, 1784, 1784, 1784, 1784,
     1784, 1784, 1784, 1784, 1784,  671, 1784, 1785, 1785, 1785,
      670,  663, 1785,  656, 1785, 1785, 1785, 1785, 1785, 1785,
     1785, 1785, 1785, 1785, 1785, 1785, 1785, 1785, 1786, 1786,
     1786,  655,  646, 1786, 1786, 1786, 1786,  645, 1786, 1786,
     1786, 1786, 1786, 1786, 1786, 1786, 1786,  644, 1786, 1787,
     1787, 1787,  643,  642, 1787,  641, 1787, 1787, 1787, 1787,

     1787, 1787, 1787, 1787, 1787, 1787, 1787, 1787,  640, 1787,
     1788, 1788, 1788, 1788, 1788, 1788, 1788, 1788, 1788, 1788,
     1788,  639, 1788, 1788, 1788, 1788, 1788, 1788, 1788, 1788,
     1788, 1789, 1789,  638, 1789, 1789, 1789, 1789, 1789, 1789,
     1789,  637,  625, 1789, 1789, 1789, 1789, 1789, 1789, 1789,
      617, 1789, 1790, 1790, 1790,  616, 1790, 1790, 1790, 1790,
     1790, 1790, 1790, 1790, 1790, 1790, 1790, 1790, 1790, 1790,
     1790, 1790, 1790, 1791,  614,  613,  609,  604,  603,  601,
      600, 1791,  596,  588,  587,  582, 1791,  581,  579, 1791,
     1792, 1792, 1792, 1792, 1792, 1792, 1792, 1792, 1792, 1792,

     1792, 1792, 1792, 1792, 1792, 1792, 1792, 1792, 1792,  578,
     1792, 1793, 1793,  573,  572,  571,  570,  569,  567, 1793,
      566,  565,  563,  562, 1793,  561,  551, 1793, 1793, 1794,
      545,  544,  540,  538,  537,  536,  535,  534,  532,  527,
     1794,  521, 1794,  509,  508, 1794, 1796, 1796, 1796, 1796,
     1796, 1796, 1796, 1796, 1796, 1796, 1796, 1796, 1796, 1796,
     1796, 1796, 1796, 1796, 1796, 1796, 1796, 1797,  484, 1797,
      481, 1797, 1797, 1797, 1797, 1797, 1797, 1797, 1797,  474,
     1797,  466, 1797, 1797,  463, 1797, 1798, 1798, 1798,  458,
     1798, 1798, 1798, 1798, 1798, 1798, 1798, 1798,  457, 1798,

     1798, 1798, 1798, 1798, 1798, 1798, 1798, 1799, 1799, 1799,
      456, 1799, 1799, 1799, 1799, 1799, 1799, 1799, 1799,  455,
     1799, 1799, 1799, 1799, 1799,  453, 1799, 1799, 1800,  451,
     1800,  450, 1800, 1800, 1800, 1800, 1800, 1800, 1800, 1800,
      444, 1800,  443, 1800, 1800,  432, 1800, 1801, 1801, 1801,
      425, 1801, 1801, 1801, 1801, 1801, 1801, 1801, 1801, 1801,
     1801, 1801, 1801, 1801,  424, 1801,  419, 1801, 1802, 1802,
     1802,  411, 1802, 1802, 1802, 1802, 1802, 1802, 1802, 1802,
     1802, 1802,  403, 1802, 1802,  394, 1802,  390, 1802, 1803,
      382, 1803,  372, 1803, 1803, 1803, 1803, 1803, 1803, 1803,

     1803, 1803, 1803, 1803, 1803, 1803,  363, 1803,  361, 1803,
     1804,  354, 1804,  353, 1804, 1804, 1804, 1804, 1804, 1804,
     1804, 1804,  352, 1804, 1804, 1804, 1804, 1804, 1804, 1804,
     1804, 1805,  351, 1805,  350, 1805, 1805, 1805, 1805, 1805,
     1805, 1805, 1805, 1805, 1805, 1805, 1805, 1805, 1805, 1805,
     1805, 1805, 1810, 1810, 1810,  349, 1810, 1810, 1810, 1810,
     1810, 1810, 1810, 1810, 1810, 1810, 1810, 1810, 1810, 1810,
     1810,  348, 1810, 1811, 1811, 1811,  347, 1811, 1811, 1811,
     1811, 1811, 1811, 1811, 1811, 1811, 1811, 1811, 1811, 1811,
     1811, 1811, 1811, 1811, 1812,  346,  342, 1812,  335,  329,

     1812,  327, 1812, 1812,  319, 1812,  305, 1812,  304,  298,
     1812, 1813, 1813, 1813,  296, 1813,  292, 1813, 1813, 1813,
     1813, 1813, 1813,  291, 1813,  286, 1813, 1813,  285, 1813,
      280, 1813, 1814, 1814, 1814,  279, 1814, 1814, 1814, 1814,
     1814, 1814, 1814, 1814, 1814, 1814, 1814, 1814, 1814, 1814,
     1814, 1814, 1814, 1815, 1815, 1815,  277, 1815, 1815, 1815,
     1815, 1815, 1815, 1815, 1815, 1815, 1815, 1815, 1815, 1815,
     1815, 1815, 1815, 1815, 1816,  276,  274,  272,  267,  266,
      259,  257, 1816,  251,  242,  232,  229, 1816,  222,  220,
     1816, 1818, 1818, 1818,  219, 1818, 1818, 1818, 1818, 1818,

     1818, 1818, 1818, 1818, 1818, 1818, 1818, 1818, 1818, 1818,
     1818, 1818, 1819, 1819, 1819,  218, 1819, 1819, 1819, 1819,
     1819, 1819, 1819, 1819, 1819, 1819, 1819, 1819, 1819, 1819,
     1819, 1819, 1819, 1821, 1821, 1821,  217, 1821, 1821, 1821,
     1821, 1821, 1821, 1821, 1821, 1821, 1821, 1821, 1821, 1821,
     1821, 1821,  214, 1821, 1822, 1822, 1822,  210, 1822, 1822,
      208, 1822, 1822,  207, 1822, 1822, 1822, 1822,  198, 1822,
     1822, 1822, 1822, 1822, 1822, 1823, 1823, 1823,  196, 1823,
     1823, 1823, 1823, 1823, 1823, 1823, 1823, 1823, 1823, 1823,
     1823, 1823, 1823, 1823, 1823, 1823, 1824, 1824, 1824,  189,

     1824, 1824, 1824, 1824, 1824, 1824, 1824, 1824, 1824, 1824,
     1824, 1824, 1824, 1824, 1824, 1824, 1824, 1825, 1825, 1825,
      182, 1825, 1825, 1825, 1825, 1825, 1825, 1825, 1825, 1825,
     1825, 1825, 1825, 1825, 1825, 1825, 1825, 1825, 1826, 1826,
     1826,  176, 1826, 1826, 1826, 1826, 1826, 1826, 1826, 1826,
     1826, 1826, 1826, 1826, 1826, 1826, 1826, 1826, 1826, 1827,
     1827, 1827,  170, 1827, 1827,  165, 1827, 1827, 1827, 1827,
     1827, 1827, 1827, 1827, 1827, 1827, 1827, 1827,  155, 1827,
     1828, 1828,  154, 1828, 1828, 1828, 1828, 1828, 1828, 1828,
     1828,  152, 1828, 1828, 1828, 1828, 1828, 1828, 1828,  144,

     1828, 1829, 1829, 1829,  137,  135,  128,  125,  118, 1829,
      117,  114,  113,  111, 1829,  104,  101, 1829, 1830, 1830,
     1830,   91,   85, 1830,   16, 1830, 1830, 1830, 1830, 1830,
     1830, 1830, 1830, 1830, 1830, 1830, 1830,    0, 1830, 1831,
     1831, 1831,    0,    0, 1831,    0, 1831, 1831, 1831, 1831,
     1831, 1831, 1831, 1831, 1831, 1831, 1831, 1831, 1831, 1831,
     1832, 1832, 1832,    0,    0, 1832, 1832, 1832, 1832,    0,
     1832, 1832, 1832, 1832, 1832, 1832, 1832, 1832, 1832,    0,
     1832, 1833, 1833, 1833,    0,    0, 1833,    0, 1833, 1833,
     1833, 1833, 1833, 1833, 1833, 1833, 1833, 1833, 1833, 1833,

        0, 1833, 1834, 1834,    0, 1834, 1834, 1834, 1834, 1834,
     1834, 1834,    0,    0, 1834, 1834, 1834, 1834, 1834, 1834,
     1834,    0, 1834, 1835, 1835, 1835, 1835, 1835, 1835, 1835,
     1835, 1835, 1835, 1835,    0, 1835, 1835, 1835, 1835, 1835,
     1835, 1835, 1835, 1835, 1836, 1836, 1836,    0, 1836, 1836,
     1836, 1836, 1836, 1836, 1836, 1836, 1836, 1836, 1836, 1836,
     1836, 1836, 1836, 1836, 1836, 1837, 1837, 1837, 1837, 1837,
     1837, 1837, 1837, 1837, 1837, 1837, 1837, 1837, 1837, 1837,
     1837, 1837, 1837, 1837,    0, 1837, 1838,    0, 1838,    0,
     1838, 1838, 1838, 1838, 1838, 1838, 1838, 1838,    0, 1838,

        0, 1838, 1838,    0, 1838, 1839, 1839, 1839,    0, 1839,
     1839, 1839, 1839, 1839, 1839, 1839, 1839,    0, 1839, 1839,
     1839, 1839, 1839, 1839, 1839, 1839, 1840, 1840, 1840,    0,
     1840, 1840, 1840, 1840, 1840, 1840, 1840, 1840,    0, 1840,
     1840, 1840, 1840, 1840,    0, 1840, 1840, 1841,    0, 1841,
        0, 1841, 1841, 1841, 1841, 1841, 1841, 1841, 1841,    0,
     1841,    0, 1841, 1841,    0, 1841, 1842,    0, 1842,    0,
     1842, 1842, 1842, 1842, 1842, 1842, 1842, 1842, 1842, 1842,
     1842, 1842, 1842,    0, 1842,    0, 1842, 1843, 1843, 1843,
        0, 1843, 1843, 1843, 1843, 1843, 1843, 1843, 1843, 1843,

     1843, 1843, 1843, 1843,    0, 1843,    0, 1843, 1844,    0,
     1844,    0, 1844, 1844, 1844, 1844, 1844, 1844, 1844, 1844,
        0, 1844, 1844, 1844, 1844, 1844, 1844, 1844, 1844, 1845,
        0, 1845,    0, 1845, 1845, 1845, 1845, 1845, 1845, 1845,
     1845, 1845, 1845, 1845, 1845, 1845, 1845, 1845, 1845, 1845,
     1847, 1847, 1847,    0, 1847, 1847, 1847, 1847, 1847, 1847,
     1847, 1847, 1847, 1847, 1847, 1847, 1847, 1847, 1847,    0,
     1847, 1848, 1848, 1848,    0, 1848,    0, 1848, 1848, 1848,
     1848, 1848, 1848,    0, 1848,    0, 1848, 1848,    0, 1848,
        0, 1848, 1849, 1849, 1849,    0, 1849, 1849, 1849, 1849,

     1849, 1849, 1849, 1849, 1849, 1849, 1849, 1849, 1849, 1849,
     1849, 1849, 1849, 1850, 1850, 1850,    0, 1850, 1850, 1850,
     1850, 1850, 1850, 1850, 1850, 1850, 1850, 1850, 1850, 1850,
     1850, 1850, 1850, 1850, 1851, 1851, 1851,    0, 1851, 1851,
     1851, 1851, 1851, 1851, 1851, 1851, 1851, 1851, 1851, 1851,
     1851, 1851, 1851, 1851, 1851, 1852,    0,    0,    0,    0,
        0,    0,    0, 1852,    0,    0,    0,    0, 1852,    0,
        0, 1852, 1854, 1854, 1854,    0, 1854, 1854, 1854, 1854,
     1854, 1854, 1854, 1854, 1854, 1854, 1854, 1854, 1854, 1854,
     1854, 1854, 1854, 1855,    0,    0, 1855,    0,    0,    0,

        0, 1855,    0,    0,    0,    0, 1855,    0,    0, 1855,
     1856, 1856, 1856,    0, 1856, 1856, 1856, 1856, 1856, 1856,
     1856, 1856, 1856, 1856, 1856, 1856, 1856, 1856, 1856,    0,
     1856, 1857, 1857, 1857,    0, 1857, 1857, 1857, 1857, 1857,
     1857, 1857, 1857, 1857, 1857, 1857, 1857, 1857, 1857, 1857,
     1857, 1857, 1858, 1858,    0, 1858, 1858, 1858, 1858, 1858,
     1858, 1858, 1858,    0, 1858, 1858, 1858, 1858, 1858, 1858,
     1858,    0, 1858, 1859, 1859, 1859,    0,    0,    0,    0,
        0, 1859,    0,    0,    0,    0, 1859,    0,    0, 1859,
     1860, 1860, 1860,    0,    0, 1860,    0, 1860, 1860, 1860,

     1860, 1860, 1860, 1860, 1860, 1860, 1860, 1860, 1860,    0,
     1860, 1861, 1861, 1861,    0,    0, 1861,    0, 1861, 1861,
     1861, 1861, 1861, 1861, 1861, 1861, 1861, 1861, 1861, 1861,
     1861, 1861, 1862, 1862, 1862,    0,    0, 1862, 1862, 1862,
     1862,    0, 1862, 1862, 1862, 1862, 1862, 1862, 1862, 1862,
     1862,    0, 1862, 1863, 1863, 1863,    0,    0, 1863,    0,
     1863, 1863, 1863, 1863, 1863, 1863, 1863, 1863, 1863, 1863,
     1863, 1863,    0, 1863, 1864, 1864,    0, 1864, 1864, 1864,
     1864, 1864, 1864, 1864,    0,    0, 1864, 1864, 1864, 1864,
     1864, 1864, 1864,    0, 1864, 1865, 1865, 1865, 1865, 1865,

     1865, 1865, 1865, 1865, 1865, 1865,    0, 1865, 1865, 1865,
     1865, 1865, 1865, 1865, 1865, 1865, 1866, 1866, 1866,    0,
     1866, 1866, 1866, 1866, 1866, 1866, 1866, 1866, 1866, 1866,
     1866, 1866, 1866, 1866, 1866, 1866, 1866, 1867, 1867, 1867,
     1867, 1867, 1867, 1867, 1867, 1867, 1867, 1867, 1867, 1867,
     1867, 1867, 1867, 1867, 1867, 1867,    0, 1867, 1868,    0,
     1868,    0, 1868, 1868, 1868, 1868, 1868, 1868, 1868, 1868,
     1868, 1868,    0, 1868, 1868,    0, 1868, 1869, 1869, 1869,
        0, 1869, 1869, 1869, 1869, 1869, 1869, 1869, 1869, 1869,
     1869, 1869, 1869, 1869, 1869, 1869,    0, 1869, 1870, 1870,

     1870, 1870, 1870, 1870, 1870, 1870, 1870, 1870, 1870, 1870,
     1870, 1870, 1870, 1870, 1870, 1870, 1870, 1870, 1870, 1871,
     1871,    0, 1871, 1871, 1871, 1871, 1871, 1871, 1871, 1871,
        0, 1871, 1871, 1871, 1871, 1871, 1871, 1871,    0, 1871,
     1872, 1872,    0, 1872, 1872, 1872, 1872, 1872, 1872, 1872,
        0,    0, 1872, 1872, 1872, 1872, 1872, 1872, 1872,    0,
     1872, 1873, 1873,    0, 1873, 1873, 1873, 1873, 1873, 1873,
     1873, 1873,    0, 1873, 1873, 1873, 1873, 1873, 1873, 1873,
        0, 1873, 1874, 1874,    0, 1874, 1874, 1874, 1874, 1874,
     1874, 1874,    0,    0, 1874, 1874, 1874, 1874, 1874, 1874,

     1874,    0, 1874, 1875, 1875, 1875, 1875, 1875, 1875, 1875,
     1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875, 1875,
     1875, 1875, 1875, 1875, 1876, 1876, 1876, 1876, 1876, 1876,
     1876, 1876, 1876, 1876, 1876, 1876, 1876, 1876, 1876, 1876,
     1876, 1876, 1876, 1876, 1876, 1877, 1877, 1877, 1877, 1877,
     1877, 1877, 1877, 1877, 1877, 1877, 1877, 1877, 1877, 1877,
     1877, 1877, 1877, 1877, 1877, 1877, 1878, 1878, 1878, 1878,
     1878, 1878, 1878, 1878, 1878, 1878, 1878, 1878, 1878, 1878,
     1878, 1878, 1878, 1878, 1878, 1878, 1878, 1879,    0,    0,
        0, 1879,    0,    0,    0,    0,    0,    0,    0,    0,

        0, 1879,    0, 1879, 1880, 1880,    0, 1880, 1880, 1880,
     1880, 1880, 1880, 1880, 1880,    0, 1880, 1880, 1880, 1880,
     1880, 1880, 1880,    0, 1880, 1881, 1881, 1881, 1881, 1881,
     1881,    0, 1881, 1881, 1881, 1881, 1881, 1881, 1881, 1881,
     1881, 1881, 1881, 1881, 1881, 1881, 1882, 1882,    0, 1882,
     1882, 1882, 1882, 1882, 1882, 1882,    0,    0, 1882, 1882,
     1882, 1882, 1882, 1882, 1882,    0, 1882, 1883, 1883, 1883,
     1883, 1883, 1883, 1883, 1883, 1883, 1883, 1883, 1883, 1883,
     1883, 1883, 1883, 1883, 1883, 1883, 1883, 1883, 1885, 1885,
        0, 1885, 1885, 1885, 1885, 1885, 1885, 1885, 1885,    0,

     1885, 1885, 1885, 1885, 1885, 1885, 1885,    0, 1885, 1886,
     1886,    0, 1886, 1886, 1886, 1886, 1886, 1886, 1886,    0,
        0, 1886, 1886, 1886, 1886, 1886, 1886, 1886,    0, 1886,
     1887, 1887, 1887, 1887, 1887, 1887, 1887, 1887, 1887, 1887,
     1887, 1887, 1887, 1887, 1887,    0, 1887, 1887,    0, 1887,
     1887, 1888, 1888, 1888, 1888, 1888, 1888, 1888, 1888, 1888,
     1888, 1888, 1888, 1888, 1888, 1888,    0, 1888, 1888,    0,
     1888, 1888, 1889, 1889,    0, 1889, 1889, 1889, 1889, 1889,
     1889, 1889, 1889,    0, 1889, 1889, 1889, 1889, 1889, 1889,
     1889,    0, 1889, 1890, 1890,    0, 1890, 1890, 1890, 1890,

     1890, 1890, 1890,    0,    0, 1890, 1890, 1890, 1890, 1890,
     1890, 1890,    0, 1890, 1891, 1891, 1891, 1891, 1891, 1891,
     1891, 1891, 1891, 1891, 1891, 1891, 1891, 1891, 1891,    0,
     1891, 1891,    0, 1891, 1891, 1892, 1892, 1892,    0, 1892,
     1892, 1892, 1892, 1892, 1892, 1892, 1892, 1892, 1892, 1892,
     1892, 1892, 1892, 1892, 1892, 1892, 1893, 1893,    0, 1893,
     1893, 1893, 1893, 1893, 1893, 1893, 1893,    0, 1893, 1893,
     1893, 1893, 1893, 1893, 1893,    0, 1893, 1894, 1894,    0,
     1894, 1894, 1894, 1894, 1894, 1894, 1894,    0,    0, 1894,
     1894, 1894, 1894, 1894, 1894, 1894,    0, 1894, 1895, 1895,

        0, 1895, 1895, 1895, 1895, 1895, 1895, 1895, 1895,    0,
     1895, 1895, 1895, 1895, 1895, 1895, 1895,    0, 1895, 1896,
     1896,    0, 1896, 1896, 1896, 1896, 1896, 1896, 1896,    0,
        0, 1896, 1896, 1896, 1896, 1896, 1896, 1896,    0, 1896,
     1897, 1897,    0, 1897, 1897, 1897, 1897, 1897, 1897, 1897,
     1897,    0, 1897, 1897, 1897, 1897, 1897, 1897, 1897,    0,
     1897, 1898, 1898,    0, 1898, 1898, 1898, 1898, 1898, 1898,
     1898,    0,    0, 1898, 1898, 1898, 1898, 1898, 1898, 1898,
        0, 1898, 1899, 1899,    0, 1899, 1899, 1899, 1899, 1899,
     1899, 1899, 1899,    0, 1899, 1899, 1899, 1899, 1899, 1899,

     1899,    0, 1899, 1900, 1900,    0, 1900, 1900, 1900, 1900,
     1900, 1900, 1900,    0,    0, 1900, 1900, 1900, 1900, 1900,
     1900, 1900,    0, 1900, 1901, 1901,    0, 1901, 1901, 1901,
     1901, 1901, 1901, 1901, 1901,    0, 1901, 1901, 1901, 1901,
     1901, 1901, 1901,    0, 1901, 1902, 1902,    0, 1902, 1902,
     1902, 1902, 1902, 1902, 1902,    0,    0, 1902, 1902, 1902,
     1902, 1902, 1902, 1902,    0, 1902, 1903, 1903,    0, 1903,
     1903, 1903, 1903, 1903, 1903, 1903, 1903,    0, 1903, 1903,
     1903, 1903, 1903, 1903, 1903,    0, 1903, 1904, 1904,    0,
     1904, 1904, 1904, 1904, 1904, 1904, 1904,    0,    0, 1904,

     1904, 1904, 1904, 1904, 1904, 1904,    0, 1904, 1905, 1905,
        0, 1905, 1905, 1905, 1905, 1905, 1905, 1905, 1905,    0,
     1905, 1905, 1905, 1905, 1905, 1905, 1905,    0, 1905, 1906,
     1906,    0, 1906, 1906, 1906, 1906, 1906, 1906, 1906,    0,
        0, 1906, 1906, 1906, 1906, 1906, 1906, 1906,    0, 1906,
     1907, 1907,    0, 1907, 1907, 1907, 1907, 1907, 1907, 1907,
     1907,    0, 1907, 1907, 1907, 1907, 1907, 1907, 1907,    0,
     1907, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698,
     1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698,
     1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698,

     1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698,
     1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698,
     1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698,
     1698, 1698, 1698, 1698, 1698, 1698, 1698, 1698
    } ;

#define YY_TRAILING_MASK 0x2000
#define YY_TRAILING_HEAD_MASK 0x4000
#define REJECT \
{ \
*yy_cp = yyg->yy_hold_char; /* undo effects of setting up yytext */ \
yy_cp = yyg->yy_full_match; /* restore poss. backed-over text */ \
yyg->yy_lp = yyg->yy_full_lp; /* restore orig. accepting pos. */ \
yyg->yy_state_ptr = yyg->yy_full_state; /* restore orig. state */ \
yy_current_state = *yyg->yy_state_ptr; /* restore curr. state */ \
++yyg->yy_lp; \
goto find_rule; \
}

#define yymore() yymore_used_but_not_detected
#define YY_MORE_ADJ 0
#define YY_RESTORE_YY_MORE_OFFSET
#line 1 "/home/vsc/github/doxygen/src/pre.l"
/******************************************************************************
 *
 * Copyright (C) 1997-2020 by Dimitri van Heesch.
 *
 * Permission to use, copy, modify, and distribute this software and its
 * documentation under the terms of the GNU General Public License is hereby
 * granted. No representations are made about the suitability of this software
 * for any purpose. It is provided "as is" without express or implied warranty.
 * See the GNU General Public License for more details.
 *
 * Documents produced by Doxygen are derivative works derived from the
 * input used in their production; they are not affected by this license.
 *
 */

#line 28 "/home/vsc/github/doxygen/src/pre.l"

/*
 *      includes
 */

#include "doxygen.h"

#include <stack>
#include <deque>
#include <algorithm>
#include <utility>
#include <mutex>
#include <thread>
#include <algorithm>
#include <cstdio>
#include <cassert>
#include <cctype>
#include <cerrno>

#include "qcstring.h"
#include "containers.h"
#include "pre.h"
#include "constexp.h"
#include "define.h"
#include "message.h"
#include "util.h"
#include "defargs.h"
#include "debug.h"
#include "bufstr.h"
#include "portable.h"
#include "bufstr.h"
#include "arguments.h"
#include "entry.h"
#include "condparser.h"
#include "config.h"
#include "filedef.h"
#include "regex.h"
#include "fileinfo.h"
#include "trace.h"
#include "debug.h"

#define YY_NO_UNISTD_H 1

#define USE_STATE2STRING 0

#if USE_STATE2STRING
static const char *stateToString(int state);
#endif

struct preYY_CondCtx
{
  preYY_CondCtx(int line,const QCString &id,bool b)
    : lineNr(line), sectionId(id), skip(b) {}
  int lineNr;
  QCString sectionId;
  bool skip;
};

struct FileState
{
  FileState(uint32_t size) : fileBuf(size) {}
  int lineNr = 1;
  int curlyCount = 0;
  BufStr fileBuf;
  BufStr *oldFileBuf = 0;
  int oldFileBufPos = 0;
  YY_BUFFER_STATE bufState = 0;
  QCString fileName;
};

struct PreIncludeInfo
{
  PreIncludeInfo(const QCString &fn,FileDef *srcFd, FileDef *dstFd,const QCString &iName,bool loc, bool imp)
    : fileName(fn), fromFileDef(srcFd), toFileDef(dstFd), includeName(iName), local(loc), imported(imp)
  {
  }
  QCString fileName;    // file name in which the include statement was found
  FileDef *fromFileDef; // filedef in which the include statement was found
  FileDef *toFileDef;   // filedef to which the include is pointing
  QCString includeName; // name used in the #include statement
  bool local;           // is it a "local" or <global> include
  bool imported;        // include via "import" keyword (Objective-C)
};

/** A dictionary of managed Define objects. */
typedef std::map< std::string, Define > DefineMap;

/** @brief Class that manages the defines available while
 *  preprocessing files.
 */
class DefineManager
{
  private:
    /** Local class used to hold the defines for a single file */
    class DefinesPerFile
    {
      public:
        /** Creates an empty container for defines */
        DefinesPerFile(DefineManager *parent)
          : m_parent(parent)
        {
        }
        void addInclude(const std::string &fileName)
        {
          m_includedFiles.insert(fileName);
        }
        void store(const DefineMap &fromMap)
        {
          for (auto &[name,define] : fromMap)
          {
            m_defines.emplace(name,define);
          }
          //printf("  m_defines.size()=%zu\n",m_defines.size());
          m_stored=true;
        }
        void retrieve(DefineMap &toMap)
        {
          StringSet includeStack;
          retrieveRec(toMap,includeStack);
        }
        void retrieveRec(DefineMap &toMap,StringSet &includeStack)
        {
          //printf("  retrieveRec #includedFiles=%zu\n",m_includedFiles.size());
          for (auto incFile : m_includedFiles)
          {
            DefinesPerFile *dpf = m_parent->find(incFile);
            if (dpf && includeStack.find(incFile)==includeStack.end())
            {
              includeStack.insert(incFile);
              dpf->retrieveRec(toMap,includeStack);
              //printf("  retrieveRec: processing include %s: #toMap=%zu\n",qPrint(incFile),toMap.size());
            }
          }
          for (auto &[name,define] : m_defines)
          {
            toMap.emplace(name,define);
          }
        }
        bool stored() const { return m_stored; }
      private:
        DefineManager *m_parent;
        DefineMap m_defines;
        StringSet m_includedFiles;
        bool m_stored = false;
    };

    friend class DefinesPerFile;
  public:

    void addInclude(const std::string &fromFileName,const std::string &toFileName)
    {
      //printf("DefineManager::addInclude('%s'->'%s')\n",fromFileName.c_str(),toFileName.c_str());
      auto it = m_fileMap.find(fromFileName);
      if (it==m_fileMap.end())
      {
        it = m_fileMap.emplace(fromFileName,std::make_unique<DefinesPerFile>(this)).first;
      }
      auto &dpf = it->second;
      dpf->addInclude(toFileName);
    }

    void store(const std::string &fileName,const DefineMap &fromMap)
    {
      //printf("DefineManager::store(%s,#=%zu)\n",fileName.c_str(),fromMap.size());
      auto it = m_fileMap.find(fileName);
      if (it==m_fileMap.end())
      {
        it = m_fileMap.emplace(fileName,std::make_unique<DefinesPerFile>(this)).first;
      }
      it->second->store(fromMap);
    }

    void retrieve(const std::string &fileName,DefineMap &toMap)
    {
      auto it = m_fileMap.find(fileName);
      if (it!=m_fileMap.end())
      {
        auto &dpf = it->second;
        dpf->retrieve(toMap);
      }
      //printf("DefineManager::retrieve(%s,#=%zu)\n",fileName.c_str(),toMap.size());
    }

    bool alreadyProcessed(const std::string &fileName) const
    {
      auto it = m_fileMap.find(fileName);
      if (it!=m_fileMap.end())
      {
        return it->second->stored();
      }
      return false;
    }

  private:
    /** Helper function to return the DefinesPerFile object for a given file name. */
    DefinesPerFile *find(const std::string &fileName) const
    {
      auto it = m_fileMap.find(fileName);
      return it!=m_fileMap.end() ? it->second.get() : nullptr;
    }

    std::unordered_map< std::string, std::unique_ptr<DefinesPerFile> > m_fileMap;
};


/* -----------------------------------------------------------------
 *
 *      global state
 */
static std::mutex            g_debugMutex;
static std::mutex            g_globalDefineMutex;
static std::mutex            g_updateGlobals;
static DefineManager         g_defineManager;


/* -----------------------------------------------------------------
 *
 *      scanner's state
 */

struct preYY_state
{
  int                yyLineNr       = 1;
  int                yyMLines       = 1;
  int                yyColNr        = 1;
  QCString           fileName;
  FileDef           *yyFileDef      = 0;
  FileDef           *inputFileDef   = 0;
  int                ifcount        = 0;
  int                defArgs        = -1;
  QCString           defName;
  QCString           defText;
  QCString           defLitText;
  QCString           defArgsStr;
  QCString           defExtraSpacing;
  bool               defContinue = false;
  bool               defVarArgs     = false;
  int                lastCContext   = 0;
  int                lastCPPContext = 0;
  BufStr            *inputBuf       = 0;
  int                inputBufPos    = 0;
  BufStr            *outputBuf      = 0;
  int                roundCount     = 0;
  bool               quoteArg       = false;
  bool               idStart        = false;
  int                findDefArgContext = 0;
  bool               expectGuard    = false;
  QCString           guardName;
  QCString           lastGuardName;
  QCString           incName;
  QCString           guardExpr;
  int                curlyCount     = 0;
  bool               nospaces       = false; // add extra spaces during macro expansion
  int                javaBlock      = 0;

  bool               macroExpansion = false; // from the configuration
  bool               expandOnlyPredef = false; // from the configuration
  QCString           potentialDefine;
  int                commentCount   = 0;
  bool               insideComment  = false;
  bool               isImported     = false;
  QCString           blockName;
  int                condCtx        = 0;
  bool               skip           = false;
  bool               insideIDL      = false;
  bool               insideCS       = false; // C# has simpler preprocessor
  bool               insideFtn      = false;
  bool               isSource       = false;

  yy_size_t          fenceSize      = 0;
  bool               ccomment       = false;
  QCString           delimiter;
  bool               isSpecialComment = false;
  StringVector                             pathList;
  IntMap                                   argMap;
  BoolStack                                levelGuard;
  std::stack< std::unique_ptr<preYY_CondCtx> >   condStack;
  std::deque< std::unique_ptr<FileState> > includeStack;
  std::unordered_map<std::string,Define*>  expandedDict;
  StringUnorderedSet                       expanded;
  ConstExpressionParser                    constExpParser;
  DefineMap                                contextDefines; // macros imported from other files
  DefineMap                                localDefines;   // macros defined in this file
  DefineList                               macroDefinitions;
  LinkedMap<PreIncludeInfo>                includeRelations;
};

// stateless functions
static QCString escapeAt(const QCString &text);
static QCString extractTrailingComment(const QCString &s);
static char resolveTrigraph(char c);

// stateful functions
static inline void  outputArray(yyscan_t yyscanner,const char *a,yy_size_t len);
static inline void outputString(yyscan_t yyscanner,const QCString &s);
static inline void   outputChar(yyscan_t yyscanner,char c);
static inline void outputSpaces(yyscan_t yyscanner,char *s);
static inline void  outputSpace(yyscan_t yyscanner,char c);
static inline void extraSpacing(yyscan_t yyscanner);
static QCString     expandMacro(yyscan_t yyscanner,const QCString &name);
static void     readIncludeFile(yyscan_t yyscanner,const QCString &inc);
static void           incrLevel(yyscan_t yyscanner);
static void           decrLevel(yyscan_t yyscanner);
static void         setCaseDone(yyscan_t yyscanner,bool value);
static bool       otherCaseDone(yyscan_t yyscanner);
static bool   computeExpression(yyscan_t yyscanner,const QCString &expr);
static void    startCondSection(yyscan_t yyscanner,const QCString &sectId);
static void      endCondSection(yyscan_t yyscanner);
static void  addMacroDefinition(yyscan_t yyscanner);
static void           addDefine(yyscan_t yyscanner);
static void         setFileName(yyscan_t yyscanner,const QCString &name);
static int               yyread(yyscan_t yyscanner,char *buf,int max_size);
static Define *       isDefined(yyscan_t yyscanner,const QCString &name);
static void  determineBlockName(yyscan_t yyscanner);

/* ----------------------------------------------------------------- */

#undef  YY_INPUT
#define YY_INPUT(buf,result,max_size) result=yyread(yyscanner,buf,max_size);

// otherwise the filename would be the name of the converted file (*.cpp instead of *.l)
static inline const char *getLexerFILE() {return __FILE__;}
#include "doxygen_lex.h"

/* ----------------------------------------------------------------- */

#line 3552 "/home/vsc/github/doxygen/Debug/generated_src/pre_intermediate.cpp"
#line 374 "/home/vsc/github/doxygen/src/pre.l"
  // C start comment
  // C end comment
  // Cpp comment
  // optional characters after import
  // Optional white space









































#line 3600 "/home/vsc/github/doxygen/Debug/generated_src/pre_intermediate.cpp"

#define INITIAL 0
#define Start 1
#define Command 2
#define SkipCommand 3
#define SkipLine 4
#define SkipString 5
#define CopyLine 6
#define LexCopyLine 7
#define CopyString 8
#define CopyStringCs 9
#define CopyStringFtn 10
#define CopyStringFtnDouble 11
#define CopyRawString 12
#define Include 13
#define IncludeID 14
#define EndImport 15
#define DefName 16
#define DefineArg 17
#define DefineText 18
#define SkipCPPBlock 19
#define SkipCComment 20
#define ArgCopyCComment 21
#define CopyCComment 22
#define SkipVerbatim 23
#define SkipCondVerbatim 24
#define SkipCPPComment 25
#define JavaDocVerbatimCode 26
#define RemoveCComment 27
#define RemoveCPPComment 28
#define Guard 29
#define DefinedExpr1 30
#define DefinedExpr2 31
#define SkipDoubleQuote 32
#define SkipSingleQuote 33
#define UndefName 34
#define IgnoreLine 35
#define FindDefineArgs 36
#define ReadString 37
#define CondLineC 38
#define CondLineCpp 39
#define SkipCond 40
#define IDLquote 41

#ifndef YY_NO_UNISTD_H
/* Special case for "unistd.h", since it is non-ANSI. We include it way
 * down here because we want the user's section 1 to have been scanned first.
 * The user has a chance to override it with an option.
 */
#include <unistd.h>
#endif

#define YY_EXTRA_TYPE struct preYY_state *

/* Holds the entire state of the reentrant scanner. */
struct yyguts_t
    {

    /* User-defined. Not touched by flex. */
    YY_EXTRA_TYPE yyextra_r;

    /* The rest are the same as the globals declared in the non-reentrant scanner. */
    FILE *yyin_r, *yyout_r;
    size_t yy_buffer_stack_top; /**< index of top of stack. */
    size_t yy_buffer_stack_max; /**< capacity of stack. */
    YY_BUFFER_STATE * yy_buffer_stack; /**< Stack as an array. */
    char yy_hold_char;
    int yy_n_chars;
    int yyleng_r;
    char *yy_c_buf_p;
    int yy_init;
    int yy_start;
    int yy_did_buffer_switch_on_eof;
    int yy_start_stack_ptr;
    int yy_start_stack_depth;
    int *yy_start_stack;
    yy_state_type yy_last_accepting_state;
    char* yy_last_accepting_cpos;

    int yylineno_r;
    int yy_flex_debug_r;

    yy_state_type *yy_state_buf;
    yy_state_type *yy_state_ptr;
    char *yy_full_match;
    int yy_lp;

    /* These are only needed for trailing context rules,
     * but there's no conditional variable for that yet. */
    int yy_looking_for_trail_begin;
    int yy_full_lp;
    int *yy_full_state;

    char *yytext_r;
    int yy_more_flag;
    int yy_more_len;

    }; /* end struct yyguts_t */

static int yy_init_globals ( yyscan_t yyscanner );

int yylex_init (yyscan_t* scanner);

int yylex_init_extra ( YY_EXTRA_TYPE user_defined, yyscan_t* scanner);

/* Accessor methods to globals.
   These are made visible to non-reentrant scanners for convenience. */

int yylex_destroy ( yyscan_t yyscanner );

int yyget_debug ( yyscan_t yyscanner );

void yyset_debug ( int debug_flag , yyscan_t yyscanner );

YY_EXTRA_TYPE yyget_extra ( yyscan_t yyscanner );

void yyset_extra ( YY_EXTRA_TYPE user_defined , yyscan_t yyscanner );

FILE *yyget_in ( yyscan_t yyscanner );

void yyset_in  ( FILE * _in_str , yyscan_t yyscanner );

FILE *yyget_out ( yyscan_t yyscanner );

void yyset_out  ( FILE * _out_str , yyscan_t yyscanner );

			int yyget_leng ( yyscan_t yyscanner );

char *yyget_text ( yyscan_t yyscanner );

int yyget_lineno ( yyscan_t yyscanner );

void yyset_lineno ( int _line_number , yyscan_t yyscanner );

int yyget_column  ( yyscan_t yyscanner );

void yyset_column ( int _column_no , yyscan_t yyscanner );

/* Macros after this point can all be overridden by user definitions in
 * section 1.
 */

#ifndef YY_SKIP_YYWRAP
#ifdef __cplusplus
extern "C" int yywrap ( yyscan_t yyscanner );
#else
extern int yywrap ( yyscan_t yyscanner );
#endif
#endif

#ifndef YY_NO_UNPUT
    
    static void yyunput ( int c, char *buf_ptr  , yyscan_t yyscanner);
    
#endif

#ifndef yytext_ptr
static void yy_flex_strncpy ( char *, const char *, int , yyscan_t yyscanner);
#endif

#ifdef YY_NEED_STRLEN
static int yy_flex_strlen ( const char * , yyscan_t yyscanner);
#endif

#ifndef YY_NO_INPUT
#ifdef __cplusplus
static int yyinput ( yyscan_t yyscanner );
#else
static int input ( yyscan_t yyscanner );
#endif

#endif

/* Amount of stuff to slurp up with each read. */
#ifndef YY_READ_BUF_SIZE
#ifdef __ia64__
/* On IA-64, the buffer size is 16k, not 8k */
#define YY_READ_BUF_SIZE 16384
#else
#define YY_READ_BUF_SIZE 8192
#endif /* __ia64__ */
#endif

/* Copy whatever the last rule matched to the standard output. */
#ifndef ECHO
/* This used to be an fputs(), but since the string might contain NUL's,
 * we now use fwrite().
 */
#define ECHO do { if (fwrite( yytext, (size_t) yyleng, 1, yyout )) {} } while (0)
#endif

/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
 * is returned in "result".
 */
#ifndef YY_INPUT
#define YY_INPUT(buf,result,max_size) \
	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
		{ \
		int c = '*'; \
		int n; \
		for ( n = 0; n < max_size && \
			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
			buf[n] = (char) c; \
		if ( c == '\n' ) \
			buf[n++] = (char) c; \
		if ( c == EOF && ferror( yyin ) ) \
			YY_FATAL_ERROR( "input in flex scanner failed" ); \
		result = n; \
		} \
	else \
		{ \
		errno=0; \
		while ( (result = (int) fread(buf, 1, (yy_size_t) max_size, yyin)) == 0 && ferror(yyin)) \
			{ \
			if( errno != EINTR) \
				{ \
				YY_FATAL_ERROR( "input in flex scanner failed" ); \
				break; \
				} \
			errno=0; \
			clearerr(yyin); \
			} \
		}\
\

#endif

/* No semi-colon after return; correct usage is to write "yyterminate();" -
 * we don't want an extra ';' after the "return" because that will cause
 * some compilers to complain about unreachable statements.
 */
#ifndef yyterminate
#define yyterminate() return YY_NULL
#endif

/* Number of entries by which start-condition stack grows. */
#ifndef YY_START_STACK_INCR
#define YY_START_STACK_INCR 25
#endif

/* Report a fatal error. */
#ifndef YY_FATAL_ERROR
#define YY_FATAL_ERROR(msg) yy_fatal_error( msg , yyscanner)
#endif

/* end tables serialization structures and prototypes */

/* Default declaration of generated scanner - a define so the user can
 * easily add parameters.
 */
#ifndef YY_DECL
#define YY_DECL_IS_OURS 1

extern int yylex (yyscan_t yyscanner);

#define YY_DECL int yylex (yyscan_t yyscanner)
#endif /* !YY_DECL */

/* Code executed at the beginning of each rule, after yytext and yyleng
 * have been set up.
 */
#ifndef YY_USER_ACTION
#define YY_USER_ACTION
#endif

/* Code executed at the end of each rule. */
#ifndef YY_BREAK
#define YY_BREAK /*LINTED*/break;
#endif

#define YY_RULE_SETUP \
	if ( yyleng > 0 ) \
		YY_CURRENT_BUFFER_LVALUE->yy_at_bol = \
				(yytext[yyleng - 1] == '\n'); \
	YY_USER_ACTION

/** The main scanner function which does all the work.
 */
YY_DECL
{
	yy_state_type yy_current_state;
	char *yy_cp, *yy_bp;
	int yy_act;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

	if ( !yyg->yy_init )
		{
		yyg->yy_init = 1;

#ifdef YY_USER_INIT
		YY_USER_INIT;
#endif

        /* Create the reject buffer large enough to save one state per allowed character. */
        if ( ! yyg->yy_state_buf )
            yyg->yy_state_buf = (yy_state_type *)yyalloc(YY_STATE_BUF_SIZE  , yyscanner);
            if ( ! yyg->yy_state_buf )
                YY_FATAL_ERROR( "out of dynamic memory in yylex()" );

		if ( ! yyg->yy_start )
			yyg->yy_start = 1;	/* first start state */

		if ( ! yyin )
			yyin = stdin;

		if ( ! yyout )
			yyout = stdout;

		if ( ! YY_CURRENT_BUFFER ) {
			yyensure_buffer_stack (yyscanner);
			YY_CURRENT_BUFFER_LVALUE =
				yy_create_buffer( yyin, YY_BUF_SIZE , yyscanner);
		}

		yy_load_buffer_state( yyscanner );
		}

	{
#line 429 "/home/vsc/github/doxygen/src/pre.l"


#line 3922 "/home/vsc/github/doxygen/Debug/generated_src/pre_intermediate.cpp"

	while ( /*CONSTCOND*/1 )		/* loops until end-of-file is reached */
		{
		yy_cp = yyg->yy_c_buf_p;

		/* Support of yytext. */
		*yy_cp = yyg->yy_hold_char;

		/* yy_bp points to the position in yy_ch_buf of the start of
		 * the current run.
		 */
		yy_bp = yy_cp;

		yy_current_state = yyg->yy_start;
		yy_current_state += YY_AT_BOL();

		yyg->yy_state_ptr = yyg->yy_state_buf;
		*yyg->yy_state_ptr++ = yy_current_state;

yy_match:
		do
			{
			YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;
			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
				{
				yy_current_state = (int) yy_def[yy_current_state];
				if ( yy_current_state >= 1699 )
					yy_c = yy_meta[yy_c];
				}
			yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
			*yyg->yy_state_ptr++ = yy_current_state;
			++yy_cp;
			}
		while ( yy_current_state != 1698 );

yy_find_action:
		yy_current_state = *--yyg->yy_state_ptr;
		yyg->yy_lp = yy_accept[yy_current_state];
find_rule: /* we branch to this label when backing up */
		for ( ; ; ) /* until we find what rule we matched */
			{
			if ( yyg->yy_lp && yyg->yy_lp < yy_accept[yy_current_state + 1] )
				{
				yy_act = yy_acclist[yyg->yy_lp];
				if ( yy_act & YY_TRAILING_HEAD_MASK ||
				     yyg->yy_looking_for_trail_begin )
					{
					if ( yy_act == yyg->yy_looking_for_trail_begin )
						{
						yyg->yy_looking_for_trail_begin = 0;
						yy_act &= ~YY_TRAILING_HEAD_MASK;
						break;
						}
					}
				else if ( yy_act & YY_TRAILING_MASK )
					{
					yyg->yy_looking_for_trail_begin = yy_act & ~YY_TRAILING_MASK;
					yyg->yy_looking_for_trail_begin |= YY_TRAILING_HEAD_MASK;
					yyg->yy_full_match = yy_cp;
					yyg->yy_full_state = yyg->yy_state_ptr;
					yyg->yy_full_lp = yyg->yy_lp;
					}
				else
					{
					yyg->yy_full_match = yy_cp;
					yyg->yy_full_state = yyg->yy_state_ptr;
					yyg->yy_full_lp = yyg->yy_lp;
					break;
					}
				++yyg->yy_lp;
				goto find_rule;
				}
			--yy_cp;
			yy_current_state = *--yyg->yy_state_ptr;
			yyg->yy_lp = yy_accept[yy_current_state];
			}

		YY_DO_BEFORE_ACTION;

do_action:	/* This label is used only to access EOF actions. */

		switch ( yy_act )
	{ /* beginning of action switch */
case 1:
YY_RULE_SETUP
#line 431 "/home/vsc/github/doxygen/src/pre.l"

	YY_BREAK
case 2:
YY_RULE_SETUP
#line 432 "/home/vsc/github/doxygen/src/pre.l"

	YY_BREAK
case 3:
YY_RULE_SETUP
#line 433 "/home/vsc/github/doxygen/src/pre.l"

	YY_BREAK
case 4:
YY_RULE_SETUP
#line 434 "/home/vsc/github/doxygen/src/pre.l"
{ // Trigraph
                                          unput(resolveTrigraph(yytext[2]));
                                        }
	YY_BREAK
case 5:
YY_RULE_SETUP
#line 437 "/home/vsc/github/doxygen/src/pre.l"
{
                                          yyextra->yyColNr+=(int)yyleng;
                                          yyextra->yyMLines=0;
                                          yyextra->potentialDefine=yytext;
                                          BEGIN(Command);
                                        }
	YY_BREAK
case 6:
YY_RULE_SETUP
#line 443 "/home/vsc/github/doxygen/src/pre.l"
{
                                          if (getLanguageFromFileName(yyextra->fileName)!=SrcLangExt_Lex) REJECT
                                          outputArray(yyscanner,yytext,yyleng);
                                          BEGIN(LexCopyLine);
                                        }
	YY_BREAK
case 7:
YY_RULE_SETUP
#line 448 "/home/vsc/github/doxygen/src/pre.l"
{
                                          if (yyextra->insideIDL)
                                          {
                                            BEGIN(IDLquote);
                                          }
                                          else
                                          {
                                            REJECT;
                                          }
                                        }
	YY_BREAK
case 8:
YY_RULE_SETUP
#line 458 "/home/vsc/github/doxygen/src/pre.l"
{
                                          outputArray(yyscanner,"\\",1);
                                        }
	YY_BREAK
case 9:
YY_RULE_SETUP
#line 461 "/home/vsc/github/doxygen/src/pre.l"
{
                                          outputArray(yyscanner,"\"",1);
                                        }
	YY_BREAK
case 10:
YY_RULE_SETUP
#line 464 "/home/vsc/github/doxygen/src/pre.l"
{
                                          BEGIN(Start);
                                        }
	YY_BREAK
case 11:
/* rule 11 can match eol */
YY_RULE_SETUP
#line 467 "/home/vsc/github/doxygen/src/pre.l"
{
                                          outputChar(yyscanner,'\n');
                                          yyextra->yyLineNr++;
                                        }
	YY_BREAK
case 12:
YY_RULE_SETUP
#line 471 "/home/vsc/github/doxygen/src/pre.l"
{
                                          outputArray(yyscanner,yytext,yyleng);
                                        }
	YY_BREAK
case 13:
/* rule 13 can match eol */
*yy_cp = yyg->yy_hold_char; /* undo effects of setting up yytext */
YY_LINENO_REWIND_TO(yy_cp - 1);
yyg->yy_c_buf_p = yy_cp -= 1;
YY_DO_BEFORE_ACTION; /* set up yytext again */
YY_RULE_SETUP
#line 474 "/home/vsc/github/doxygen/src/pre.l"
{
                                          outputArray(yyscanner,yytext,yyleng);
                                          BEGIN(CopyLine);
                                        }
	YY_BREAK
case 14:
/* rule 14 can match eol */
YY_RULE_SETUP
#line 478 "/home/vsc/github/doxygen/src/pre.l"
{ // constructors?
                                          int i;
                                          for (i=(int)yyleng-1;i>=0;i--)
                                          {
                                            unput(yytext[i]);
                                          }
                                          BEGIN(CopyLine);
                                        }
	YY_BREAK
case 15:
/* rule 15 can match eol */
#line 487 "/home/vsc/github/doxygen/src/pre.l"
case 16:
/* rule 16 can match eol */
#line 488 "/home/vsc/github/doxygen/src/pre.l"
case 17:
/* rule 17 can match eol */
#line 489 "/home/vsc/github/doxygen/src/pre.l"
case 18:
/* rule 18 can match eol */
YY_RULE_SETUP
#line 489 "/home/vsc/github/doxygen/src/pre.l"
{ // function like macro followed by comment
                                          bool skipFuncMacros = Config_getBool(SKIP_FUNCTION_MACROS);
                                          QCString name(yytext);
                                          int pos = name.find('(');
                                          if (pos<0) pos=0; // should never happen
                                          name=name.left(pos).stripWhiteSpace();

                                          Define *def=0;
                                          if (skipFuncMacros && !yyextra->insideFtn &&
                                              name!="Q_PROPERTY" &&
                                              !(
                                                 (yyextra->includeStack.empty() || yyextra->curlyCount>0) &&
                                                 yyextra->macroExpansion &&
                                                 (def=isDefined(yyscanner,name)) &&
                                                 /*macroIsAccessible(def) &&*/
                                                 (!yyextra->expandOnlyPredef || def->isPredefined)
                                               )
                                             )
                                          {
                                            // Only when ends on \n
                                            if (yytext[yyleng-1] == '\n')
                                            {
                                              outputChar(yyscanner,'\n');
                                              yyextra->yyLineNr++;
                                            }
                                          }
                                          else // don't skip
                                          {
                                            int i;
                                            for (i=(int)yyleng-1;i>=0;i--)
                                            {
                                              unput(yytext[i]);
                                            }
                                            BEGIN(CopyLine);
                                          }
                                        }
	YY_BREAK
case 19:
/* rule 19 can match eol */
YY_RULE_SETUP
#line 525 "/home/vsc/github/doxygen/src/pre.l"
{
                                          QCString text=yytext;
                                          yyextra->yyLineNr+=text.contains('\n');
                                          outputArray(yyscanner,yytext,yyleng);
                                        }
	YY_BREAK
case 20:
/* rule 20 can match eol */
YY_RULE_SETUP
#line 530 "/home/vsc/github/doxygen/src/pre.l"
{
                                          yyextra->delimiter = yytext+2;
                                          yyextra->delimiter=yyextra->delimiter.left(yyextra->delimiter.length()-1);
                                          outputArray(yyscanner,yytext,yyleng);
                                          BEGIN(CopyRawString);
                                        }
	YY_BREAK
case 21:
YY_RULE_SETUP
#line 536 "/home/vsc/github/doxygen/src/pre.l"
{ // count brackets inside the main file
                                          if (yyextra->includeStack.empty())
                                          {
                                            yyextra->curlyCount++;
                                          }
                                          outputChar(yyscanner,*yytext);
                                        }
	YY_BREAK
case 22:
YY_RULE_SETUP
#line 543 "/home/vsc/github/doxygen/src/pre.l"
{
                                          outputArray(yyscanner,yytext,yyleng);
                                        }
	YY_BREAK
case 23:
YY_RULE_SETUP
#line 546 "/home/vsc/github/doxygen/src/pre.l"
{ // count brackets inside the main file
                                          if (yyextra->includeStack.empty() && yyextra->curlyCount>0)
                                          {
                                            yyextra->curlyCount--;
                                          }
                                          outputChar(yyscanner,*yytext);
                                        }
	YY_BREAK
case 24:
YY_RULE_SETUP
#line 553 "/home/vsc/github/doxygen/src/pre.l"
{
                                          outputArray(yyscanner,yytext,yyleng);
                                        }
	YY_BREAK
case 25:
YY_RULE_SETUP
#line 556 "/home/vsc/github/doxygen/src/pre.l"
{
                                          outputArray(yyscanner,yytext,yyleng);
                                        }
	YY_BREAK
case 26:
YY_RULE_SETUP
#line 559 "/home/vsc/github/doxygen/src/pre.l"
{
                                          outputArray(yyscanner,yytext,yyleng);
                                        }
	YY_BREAK
case 27:
YY_RULE_SETUP
#line 562 "/home/vsc/github/doxygen/src/pre.l"
{
                                          if (getLanguageFromFileName(yyextra->fileName)!=SrcLangExt_CSharp) REJECT;
                                          outputArray(yyscanner,yytext,yyleng);
                                          BEGIN( CopyStringCs );
                                        }
	YY_BREAK
case 28:
YY_RULE_SETUP
#line 567 "/home/vsc/github/doxygen/src/pre.l"
{
                                          outputChar(yyscanner,*yytext);
                                          if (getLanguageFromFileName(yyextra->fileName)!=SrcLangExt_Fortran)
                                          {
                                            BEGIN( CopyString );
                                          }
                                          else
                                          {
                                            BEGIN( CopyStringFtnDouble );
                                          }
                                        }
	YY_BREAK
case 29:
YY_RULE_SETUP
#line 578 "/home/vsc/github/doxygen/src/pre.l"
{
                                          if (getLanguageFromFileName(yyextra->fileName)!=SrcLangExt_Fortran) REJECT;
                                          outputChar(yyscanner,*yytext);
                                          BEGIN( CopyStringFtn );
                                        }
	YY_BREAK
case 30:
YY_RULE_SETUP
#line 583 "/home/vsc/github/doxygen/src/pre.l"
{
                                          outputArray(yyscanner,yytext,yyleng);
                                        }
	YY_BREAK
case 31:
YY_RULE_SETUP
#line 586 "/home/vsc/github/doxygen/src/pre.l"
{
                                          outputArray(yyscanner,yytext,yyleng);
                                        }
	YY_BREAK
case 32:
YY_RULE_SETUP
#line 589 "/home/vsc/github/doxygen/src/pre.l"
{
                                          outputArray(yyscanner,yytext,yyleng);
                                        }
	YY_BREAK
case 33:
YY_RULE_SETUP
#line 592 "/home/vsc/github/doxygen/src/pre.l"
{
                                          outputChar(yyscanner,*yytext);
                                          BEGIN( CopyLine );
                                        }
	YY_BREAK
case 34:
YY_RULE_SETUP
#line 596 "/home/vsc/github/doxygen/src/pre.l"
{
                                          outputArray(yyscanner,yytext,yyleng);
                                        }
	YY_BREAK
case 35:
YY_RULE_SETUP
#line 599 "/home/vsc/github/doxygen/src/pre.l"
{
                                          outputArray(yyscanner,yytext,yyleng);
                                        }
	YY_BREAK
case 36:
YY_RULE_SETUP
#line 602 "/home/vsc/github/doxygen/src/pre.l"
{
                                          outputChar(yyscanner,*yytext);
                                          BEGIN( CopyLine );
                                        }
	YY_BREAK
case 37:
YY_RULE_SETUP
#line 606 "/home/vsc/github/doxygen/src/pre.l"
{
                                          outputArray(yyscanner,yytext,yyleng);
                                        }
	YY_BREAK
case 38:
YY_RULE_SETUP
#line 609 "/home/vsc/github/doxygen/src/pre.l"
{
                                          outputArray(yyscanner,yytext,yyleng);
                                        }
	YY_BREAK
case 39:
YY_RULE_SETUP
#line 612 "/home/vsc/github/doxygen/src/pre.l"
{
                                          outputChar(yyscanner,*yytext);
                                          BEGIN( CopyLine );
                                        }
	YY_BREAK
case 40:
/* rule 40 can match eol */
YY_RULE_SETUP
#line 616 "/home/vsc/github/doxygen/src/pre.l"
{
                                          outputArray(yyscanner,yytext,yyleng);
                                          QCString delimiter = yytext+1;
                                          delimiter=delimiter.left(delimiter.length()-1);
                                          if (delimiter==yyextra->delimiter)
                                          {
                                            BEGIN( CopyLine );
                                          }
                                        }
	YY_BREAK
case 41:
/* rule 41 can match eol */
YY_RULE_SETUP
#line 625 "/home/vsc/github/doxygen/src/pre.l"
{
                                          outputArray(yyscanner,yytext,yyleng);
                                        }
	YY_BREAK
case 42:
YY_RULE_SETUP
#line 628 "/home/vsc/github/doxygen/src/pre.l"
{
                                          outputChar(yyscanner,*yytext);
                                        }
	YY_BREAK
case 43:
/* rule 43 can match eol */
YY_RULE_SETUP
#line 631 "/home/vsc/github/doxygen/src/pre.l"
{
                                          yyextra->expectGuard = FALSE;
                                          Define *def=0;
                                          //def=yyextra->globalDefineDict->find(yytext);
                                          //def=isDefined(yyscanner,yytext);
                                          //printf("Search for define %s found=%d yyextra->includeStack.empty()=%d "
                                          //       "yyextra->curlyCount=%d yyextra->macroExpansion=%d yyextra->expandOnlyPredef=%d "
                                          //     "isPreDefined=%d\n",yytext,def ? 1 : 0,
                                          //     yyextra->includeStack.empty(),yyextra->curlyCount,yyextra->macroExpansion,yyextra->expandOnlyPredef,
                                          //     def ? def->isPredefined : -1
                                          //    );
                                          if ((yyextra->includeStack.empty() || yyextra->curlyCount>0) &&
                                              yyextra->macroExpansion &&
                                              (def=isDefined(yyscanner,yytext)) &&
                                              (!yyextra->expandOnlyPredef || def->isPredefined)
                                             )
                                          {
                                            //printf("Found it! #args=%d\n",def->nargs);
                                            yyextra->roundCount=0;
                                            yyextra->defArgsStr=yytext;
                                            if (def->nargs==-1) // no function macro
                                            {
                                              QCString result = def->isPredefined && !def->expandAsDefined ?
                                                def->definition :
                                                expandMacro(yyscanner,yyextra->defArgsStr);
                                              outputString(yyscanner,result);
                                            }
                                            else // zero or more arguments
                                            {
                                              yyextra->findDefArgContext = CopyLine;
                                              BEGIN(FindDefineArgs);
                                            }
                                          }
                                          else
                                          {
                                            outputArray(yyscanner,yytext,yyleng);
                                          }
                                        }
	YY_BREAK
case 44:
YY_RULE_SETUP
#line 669 "/home/vsc/github/doxygen/src/pre.l"
{
                                          Define *def=0;
                                          if ((yyextra->includeStack.empty() || yyextra->curlyCount>0) &&
                                              yyextra->macroExpansion &&
                                              (def=isDefined(yyscanner,yytext)) &&
                                              def->nargs==-1 &&
                                              (!yyextra->expandOnlyPredef || def->isPredefined)
                                             )
                                          {
                                            QCString result=def->isPredefined && !def->expandAsDefined ?
                                              def->definition :
                                              expandMacro(yyscanner,yytext);
                                            outputString(yyscanner,result);
                                          }
                                          else
                                          {
                                            outputArray(yyscanner,yytext,yyleng);
                                          }
                                        }
	YY_BREAK
case 45:
/* rule 45 can match eol */
*yy_cp = yyg->yy_hold_char; /* undo effects of setting up yytext */
YY_LINENO_REWIND_TO(yy_cp - 1);
yyg->yy_c_buf_p = yy_cp -= 1;
YY_DO_BEFORE_ACTION; /* set up yytext again */
YY_RULE_SETUP
#line 688 "/home/vsc/github/doxygen/src/pre.l"
{ // strip line continuation characters
                                          if (getLanguageFromFileName(yyextra->fileName)==SrcLangExt_Fortran) outputChar(yyscanner,*yytext);
                                        }
	YY_BREAK
case 46:
YY_RULE_SETUP
#line 691 "/home/vsc/github/doxygen/src/pre.l"
{
                                          outputArray(yyscanner,yytext,(int)yyleng);
                                        }
	YY_BREAK
case 47:
YY_RULE_SETUP
#line 694 "/home/vsc/github/doxygen/src/pre.l"
{
                                          outputChar(yyscanner,*yytext);
                                        }
	YY_BREAK
case 48:
/* rule 48 can match eol */
YY_RULE_SETUP
#line 697 "/home/vsc/github/doxygen/src/pre.l"
{
                                          outputChar(yyscanner,'\n');
                                          BEGIN(Start);
                                          yyextra->yyLineNr++;
                                          yyextra->yyColNr=1;
                                        }
	YY_BREAK
case 49:
YY_RULE_SETUP
#line 703 "/home/vsc/github/doxygen/src/pre.l"
{
                                          yyextra->defArgsStr+='(';
                                          yyextra->roundCount++;
                                        }
	YY_BREAK
case 50:
YY_RULE_SETUP
#line 707 "/home/vsc/github/doxygen/src/pre.l"
{
                                          yyextra->defArgsStr+=')';
                                          yyextra->roundCount--;
                                          if (yyextra->roundCount==0)
                                          {
                                            QCString result=expandMacro(yyscanner,yyextra->defArgsStr);
                                            //printf("yyextra->defArgsStr='%s'->'%s'\n",qPrint(yyextra->defArgsStr),qPrint(result));
                                            if (yyextra->findDefArgContext==CopyLine)
                                            {
                                              outputString(yyscanner,result);
                                              BEGIN(yyextra->findDefArgContext);
                                            }
                                            else // yyextra->findDefArgContext==IncludeID
                                            {
                                              readIncludeFile(yyscanner,result);
                                              yyextra->nospaces=FALSE;
                                              BEGIN(Start);
                                            }
                                          }
                                        }
	YY_BREAK
/*
<FindDefineArgs>")"{B}*"("              {
                                          yyextra->defArgsStr+=yytext;
                                        }
  */
case 51:
YY_RULE_SETUP
#line 732 "/home/vsc/github/doxygen/src/pre.l"
{
                                          yyextra->defArgsStr+=yytext;
                                        }
	YY_BREAK
case 52:
YY_RULE_SETUP
#line 735 "/home/vsc/github/doxygen/src/pre.l"
{
                                          yyextra->defArgsStr+=yytext;
                                          BEGIN(ArgCopyCComment);
                                        }
	YY_BREAK
case 53:
YY_RULE_SETUP
#line 739 "/home/vsc/github/doxygen/src/pre.l"
{
                                          yyextra->defArgsStr+=*yytext;
                                          BEGIN(ReadString);
                                        }
	YY_BREAK
case 54:
YY_RULE_SETUP
#line 743 "/home/vsc/github/doxygen/src/pre.l"
{
                                          if (getLanguageFromFileName(yyextra->fileName)!=SrcLangExt_Fortran) REJECT;
                                          yyextra->defArgsStr+=*yytext;
                                          BEGIN(ReadString);
                                        }
	YY_BREAK
case 55:
/* rule 55 can match eol */
YY_RULE_SETUP
#line 748 "/home/vsc/github/doxygen/src/pre.l"
{
                                          yyextra->defArgsStr+=' ';
                                          yyextra->yyLineNr++;
                                          outputChar(yyscanner,'\n');
                                        }
	YY_BREAK
case 56:
YY_RULE_SETUP
#line 753 "/home/vsc/github/doxygen/src/pre.l"
{
                                          yyextra->defArgsStr+="@@";
                                        }
	YY_BREAK
case 57:
YY_RULE_SETUP
#line 756 "/home/vsc/github/doxygen/src/pre.l"
{
                                          yyextra->defArgsStr+=*yytext;
                                        }
	YY_BREAK
case 58:
YY_RULE_SETUP
#line 759 "/home/vsc/github/doxygen/src/pre.l"
{
                                          yyextra->defArgsStr+=yytext;
                                        }
	YY_BREAK
case 59:
YY_RULE_SETUP
#line 762 "/home/vsc/github/doxygen/src/pre.l"
{
                                          yyextra->defArgsStr+=yytext;
                                          BEGIN(FindDefineArgs);
                                        }
	YY_BREAK
case 60:
/* rule 60 can match eol */
YY_RULE_SETUP
#line 766 "/home/vsc/github/doxygen/src/pre.l"
{
                                          yyextra->defArgsStr+=' ';
                                          yyextra->yyLineNr++;
                                          outputChar(yyscanner,'\n');
                                        }
	YY_BREAK
case 61:
YY_RULE_SETUP
#line 771 "/home/vsc/github/doxygen/src/pre.l"
{
                                          yyextra->defArgsStr+=yytext;
                                        }
	YY_BREAK
case 62:
YY_RULE_SETUP
#line 774 "/home/vsc/github/doxygen/src/pre.l"
{
                                          yyextra->defArgsStr+=*yytext;
                                          BEGIN(FindDefineArgs);
                                        }
	YY_BREAK
case 63:
YY_RULE_SETUP
#line 778 "/home/vsc/github/doxygen/src/pre.l"
{
                                          if (getLanguageFromFileName(yyextra->fileName)!=SrcLangExt_Fortran) REJECT;
                                          yyextra->defArgsStr+=*yytext;
                                          BEGIN(FindDefineArgs);
                                        }
	YY_BREAK
case 64:
YY_RULE_SETUP
#line 784 "/home/vsc/github/doxygen/src/pre.l"
{
                                          yyextra->defArgsStr+=yytext;
                                        }
	YY_BREAK
case 65:
/* rule 65 can match eol */
*yy_cp = yyg->yy_hold_char; /* undo effects of setting up yytext */
YY_LINENO_REWIND_TO(yy_bp + 1);
yyg->yy_c_buf_p = yy_cp = yy_bp + 1;
YY_DO_BEFORE_ACTION; /* set up yytext again */
YY_RULE_SETUP
#line 787 "/home/vsc/github/doxygen/src/pre.l"
{ // line continuation
                                        }
	YY_BREAK
case 66:
YY_RULE_SETUP
#line 789 "/home/vsc/github/doxygen/src/pre.l"
{
                                          yyextra->defArgsStr+=yytext;
                                        }
	YY_BREAK
case 67:
YY_RULE_SETUP
#line 792 "/home/vsc/github/doxygen/src/pre.l"
{
                                          yyextra->defArgsStr+=*yytext;
                                        }
	YY_BREAK
case 68:
YY_RULE_SETUP
#line 795 "/home/vsc/github/doxygen/src/pre.l"
{
                                          yyextra->isImported = yytext[1]=='m';
                                          if (yyextra->macroExpansion)
                                            BEGIN(IncludeID);
                                        }
	YY_BREAK
case 69:
YY_RULE_SETUP
#line 800 "/home/vsc/github/doxygen/src/pre.l"
{
                                          yyextra->isImported = yytext[1]=='m';
                                          char c[2];
                                          c[0]=yytext[yyleng-1];c[1]='\0';
                                          yyextra->incName=c;
                                          BEGIN(Include);
                                        }
	YY_BREAK
case 70:
YY_RULE_SETUP
#line 807 "/home/vsc/github/doxygen/src/pre.l"
{
                                          yyextra->potentialDefine += substitute(yytext,"cmake","     ");
                                          //printf("!!!DefName\n");
                                          yyextra->yyColNr+=(int)yyleng;
                                          BEGIN(DefName);
                                        }
	YY_BREAK
case 71:
*yy_cp = yyg->yy_hold_char; /* undo effects of setting up yytext */
yyg->yy_c_buf_p = yy_cp = yy_bp + 5;
YY_DO_BEFORE_ACTION; /* set up yytext again */
YY_RULE_SETUP
#line 813 "/home/vsc/github/doxygen/src/pre.l"
{
                                          incrLevel(yyscanner);
                                          yyextra->guardExpr.resize(0);
                                          BEGIN(DefinedExpr2);
                                        }
	YY_BREAK
case 72:
*yy_cp = yyg->yy_hold_char; /* undo effects of setting up yytext */
yyg->yy_c_buf_p = yy_cp = yy_bp + 5;
YY_DO_BEFORE_ACTION; /* set up yytext again */
YY_RULE_SETUP
#line 818 "/home/vsc/github/doxygen/src/pre.l"
{
                                          //printf("Pre.l: ifdef\n");
                                          incrLevel(yyscanner);
                                          yyextra->guardExpr.resize(0);
                                          BEGIN(DefinedExpr1);
                                        }
	YY_BREAK
case 73:
*yy_cp = yyg->yy_hold_char; /* undo effects of setting up yytext */
yyg->yy_c_buf_p = yy_cp = yy_bp + 6;
YY_DO_BEFORE_ACTION; /* set up yytext again */
YY_RULE_SETUP
#line 824 "/home/vsc/github/doxygen/src/pre.l"
{
                                          incrLevel(yyscanner);
                                          yyextra->guardExpr="! ";
                                          BEGIN(DefinedExpr2);
                                        }
	YY_BREAK
case 74:
*yy_cp = yyg->yy_hold_char; /* undo effects of setting up yytext */
yyg->yy_c_buf_p = yy_cp = yy_bp + 6;
YY_DO_BEFORE_ACTION; /* set up yytext again */
YY_RULE_SETUP
#line 829 "/home/vsc/github/doxygen/src/pre.l"
{
                                          incrLevel(yyscanner);
                                          yyextra->guardExpr="! ";
                                          BEGIN(DefinedExpr1);
                                        }
	YY_BREAK
case 75:
*yy_cp = yyg->yy_hold_char; /* undo effects of setting up yytext */
yyg->yy_c_buf_p = yy_cp = yy_bp + 2;
YY_DO_BEFORE_ACTION; /* set up yytext again */
YY_RULE_SETUP
#line 834 "/home/vsc/github/doxygen/src/pre.l"
{
                                          incrLevel(yyscanner);
                                          yyextra->guardExpr.resize(0);
                                          BEGIN(Guard);
                                        }
	YY_BREAK
case 76:
*yy_cp = yyg->yy_hold_char; /* undo effects of setting up yytext */
yyg->yy_c_buf_p = yy_cp -= 1;
YY_DO_BEFORE_ACTION; /* set up yytext again */
YY_RULE_SETUP
#line 839 "/home/vsc/github/doxygen/src/pre.l"
{
                                          if (!otherCaseDone(yyscanner))
                                          {
                                            yyextra->guardExpr.resize(0);
                                            BEGIN(Guard);
                                          }
                                          else
                                          {
                                            yyextra->ifcount=0;
                                            BEGIN(SkipCPPBlock);
                                          }
                                        }
	YY_BREAK
case 77:
/* rule 77 can match eol */
*yy_cp = yyg->yy_hold_char; /* undo effects of setting up yytext */
YY_LINENO_REWIND_TO(yy_bp + 4);
yyg->yy_c_buf_p = yy_cp = yy_bp + 4;
YY_DO_BEFORE_ACTION; /* set up yytext again */
YY_RULE_SETUP
#line 851 "/home/vsc/github/doxygen/src/pre.l"
{
                                          if (otherCaseDone(yyscanner))
                                          {
                                            yyextra->ifcount=0;
                                            BEGIN(SkipCPPBlock);
                                          }
                                          else
                                          {
                                            setCaseDone(yyscanner,TRUE);
                                          }
                                        }
	YY_BREAK
case 78:
YY_RULE_SETUP
#line 862 "/home/vsc/github/doxygen/src/pre.l"
{
                                          BEGIN(UndefName);
                                        }
	YY_BREAK
case 79:
*yy_cp = yyg->yy_hold_char; /* undo effects of setting up yytext */
yyg->yy_c_buf_p = yy_cp -= 1;
YY_DO_BEFORE_ACTION; /* set up yytext again */
YY_RULE_SETUP
#line 865 "/home/vsc/github/doxygen/src/pre.l"
{
                                          if (!otherCaseDone(yyscanner))
                                          {
                                            yyextra->guardExpr.resize(0);
                                            BEGIN(Guard);
                                          }
                                        }
	YY_BREAK
case 80:
/* rule 80 can match eol */
*yy_cp = yyg->yy_hold_char; /* undo effects of setting up yytext */
YY_LINENO_REWIND_TO(yy_bp + 5);
yyg->yy_c_buf_p = yy_cp = yy_bp + 5;
YY_DO_BEFORE_ACTION; /* set up yytext again */
YY_RULE_SETUP
#line 872 "/home/vsc/github/doxygen/src/pre.l"
{
                                          //printf("Pre.l: #endif\n");
                                          decrLevel(yyscanner);
                                        }
	YY_BREAK
case 81:
/* rule 81 can match eol */
YY_RULE_SETUP
#line 876 "/home/vsc/github/doxygen/src/pre.l"
{
                                          outputChar(yyscanner,'\n');
                                          BEGIN(Start);
                                          yyextra->yyLineNr++;
                                        }
	YY_BREAK
case 82:
YY_RULE_SETUP
#line 881 "/home/vsc/github/doxygen/src/pre.l"
{
                                          yyextra->expectGuard = FALSE;
                                        }
	YY_BREAK
case 83:
YY_RULE_SETUP
#line 884 "/home/vsc/github/doxygen/src/pre.l"
{ // unknown directive
                                          BEGIN(IgnoreLine);
                                        }
	YY_BREAK
case 84:
/* rule 84 can match eol */
YY_RULE_SETUP
#line 887 "/home/vsc/github/doxygen/src/pre.l"
{
                                          outputChar(yyscanner,'\n');
                                          yyextra->yyLineNr++;
                                        }
	YY_BREAK
case 85:
YY_RULE_SETUP
#line 891 "/home/vsc/github/doxygen/src/pre.l"

	YY_BREAK
case 86:
YY_RULE_SETUP
#line 892 "/home/vsc/github/doxygen/src/pre.l"
{ yyextra->potentialDefine += yytext[0]=='\t' ? '\t' : ' ';
                                          yyextra->yyColNr+=(int)yyleng;
                                        }
	YY_BREAK
case 87:
YY_RULE_SETUP
#line 895 "/home/vsc/github/doxygen/src/pre.l"
{
                                          Define *def;
                                          if ((def=isDefined(yyscanner,yytext))
                                              /*&& !def->isPredefined*/
                                              && !def->nonRecursive
                                             )
                                          {
                                            //printf("undefining %s\n",yytext);
                                            def->undef=TRUE;
                                          }
                                          BEGIN(Start);
                                        }
	YY_BREAK
case 88:
/* rule 88 can match eol */
YY_RULE_SETUP
#line 907 "/home/vsc/github/doxygen/src/pre.l"
{
                                          outputChar(yyscanner,'\n');
                                          yyextra->guardExpr+=' ';
                                          yyextra->yyLineNr++;
                                        }
	YY_BREAK
case 89:
*yy_cp = yyg->yy_hold_char; /* undo effects of setting up yytext */
yyg->yy_c_buf_p = yy_cp = yy_bp + 7;
YY_DO_BEFORE_ACTION; /* set up yytext again */
YY_RULE_SETUP
#line 912 "/home/vsc/github/doxygen/src/pre.l"
{
                                          BEGIN(DefinedExpr2);
                                        }
	YY_BREAK
case 90:
*yy_cp = yyg->yy_hold_char; /* undo effects of setting up yytext */
yyg->yy_c_buf_p = yy_cp = yy_bp + 7;
YY_DO_BEFORE_ACTION; /* set up yytext again */
YY_RULE_SETUP
#line 915 "/home/vsc/github/doxygen/src/pre.l"
{
                                          BEGIN(DefinedExpr1);
                                        }
	YY_BREAK
case 91:
/* rule 91 can match eol */
*yy_cp = yyg->yy_hold_char; /* undo effects of setting up yytext */
YY_LINENO_REWIND_TO(yy_bp + 4);
yyg->yy_c_buf_p = yy_cp = yy_bp + 4;
YY_DO_BEFORE_ACTION; /* set up yytext again */
YY_RULE_SETUP
#line 918 "/home/vsc/github/doxygen/src/pre.l"
{ yyextra->guardExpr+="1L"; }
	YY_BREAK
case 92:
/* rule 92 can match eol */
*yy_cp = yyg->yy_hold_char; /* undo effects of setting up yytext */
YY_LINENO_REWIND_TO(yy_bp + 5);
yyg->yy_c_buf_p = yy_cp = yy_bp + 5;
YY_DO_BEFORE_ACTION; /* set up yytext again */
YY_RULE_SETUP
#line 919 "/home/vsc/github/doxygen/src/pre.l"
{ yyextra->guardExpr+="0L"; }
	YY_BREAK
case 93:
*yy_cp = yyg->yy_hold_char; /* undo effects of setting up yytext */
yyg->yy_c_buf_p = yy_cp = yy_bp + 3;
YY_DO_BEFORE_ACTION; /* set up yytext again */
YY_RULE_SETUP
#line 920 "/home/vsc/github/doxygen/src/pre.l"
{ yyextra->guardExpr+='!'; }
	YY_BREAK
case 94:
*yy_cp = yyg->yy_hold_char; /* undo effects of setting up yytext */
yyg->yy_c_buf_p = yy_cp = yy_bp + 6;
YY_DO_BEFORE_ACTION; /* set up yytext again */
YY_RULE_SETUP
#line 921 "/home/vsc/github/doxygen/src/pre.l"
{ yyextra->guardExpr+="!="; }
	YY_BREAK
case 95:
*yy_cp = yyg->yy_hold_char; /* undo effects of setting up yytext */
yyg->yy_c_buf_p = yy_cp = yy_bp + 3;
YY_DO_BEFORE_ACTION; /* set up yytext again */
YY_RULE_SETUP
#line 922 "/home/vsc/github/doxygen/src/pre.l"
{ yyextra->guardExpr+="&&"; }
	YY_BREAK
case 96:
*yy_cp = yyg->yy_hold_char; /* undo effects of setting up yytext */
yyg->yy_c_buf_p = yy_cp = yy_bp + 2;
YY_DO_BEFORE_ACTION; /* set up yytext again */
YY_RULE_SETUP
#line 923 "/home/vsc/github/doxygen/src/pre.l"
{ yyextra->guardExpr+="||"; }
	YY_BREAK
case 97:
*yy_cp = yyg->yy_hold_char; /* undo effects of setting up yytext */
yyg->yy_c_buf_p = yy_cp = yy_bp + 6;
YY_DO_BEFORE_ACTION; /* set up yytext again */
YY_RULE_SETUP
#line 924 "/home/vsc/github/doxygen/src/pre.l"
{ yyextra->guardExpr+="&"; }
	YY_BREAK
case 98:
*yy_cp = yyg->yy_hold_char; /* undo effects of setting up yytext */
yyg->yy_c_buf_p = yy_cp = yy_bp + 5;
YY_DO_BEFORE_ACTION; /* set up yytext again */
YY_RULE_SETUP
#line 925 "/home/vsc/github/doxygen/src/pre.l"
{ yyextra->guardExpr+="|"; }
	YY_BREAK
case 99:
*yy_cp = yyg->yy_hold_char; /* undo effects of setting up yytext */
yyg->yy_c_buf_p = yy_cp = yy_bp + 3;
YY_DO_BEFORE_ACTION; /* set up yytext again */
YY_RULE_SETUP
#line 926 "/home/vsc/github/doxygen/src/pre.l"
{ yyextra->guardExpr+="^"; }
	YY_BREAK
case 100:
*yy_cp = yyg->yy_hold_char; /* undo effects of setting up yytext */
yyg->yy_c_buf_p = yy_cp = yy_bp + 5;
YY_DO_BEFORE_ACTION; /* set up yytext again */
YY_RULE_SETUP
#line 927 "/home/vsc/github/doxygen/src/pre.l"
{ yyextra->guardExpr+="~"; }
	YY_BREAK
case 101:
YY_RULE_SETUP
#line 928 "/home/vsc/github/doxygen/src/pre.l"
{ yyextra->guardExpr+=yytext; }
	YY_BREAK
case 102:
YY_RULE_SETUP
#line 929 "/home/vsc/github/doxygen/src/pre.l"
{ yyextra->guardExpr+="@@"; }
	YY_BREAK
case 103:
YY_RULE_SETUP
#line 930 "/home/vsc/github/doxygen/src/pre.l"
{ yyextra->guardExpr+=*yytext; }
	YY_BREAK
case 104:
/* rule 104 can match eol */
YY_RULE_SETUP
#line 931 "/home/vsc/github/doxygen/src/pre.l"
{
                                          unput(*yytext);
                                          //printf("Guard: '%s'\n",
                                          //    qPrint(yyextra->guardExpr));
                                          bool guard=computeExpression(yyscanner,yyextra->guardExpr);
                                          setCaseDone(yyscanner,guard);
                                          if (guard)
                                          {
                                            BEGIN(Start);
                                          }
                                          else
                                          {
                                            yyextra->ifcount=0;
                                            BEGIN(SkipCPPBlock);
                                          }
                                        }
	YY_BREAK
case 105:
/* rule 105 can match eol */
YY_RULE_SETUP
#line 947 "/home/vsc/github/doxygen/src/pre.l"
{ yyextra->yyLineNr++; outputChar(yyscanner,'\n'); }
	YY_BREAK
case 106:
YY_RULE_SETUP
#line 948 "/home/vsc/github/doxygen/src/pre.l"
{
                                          if (isDefined(yyscanner,yytext) || yyextra->guardName==yytext)
                                            yyextra->guardExpr+=" 1L ";
                                          else
                                            yyextra->guardExpr+=" 0L ";
                                          yyextra->lastGuardName=yytext;
                                          BEGIN(Guard);
                                        }
	YY_BREAK
case 107:
YY_RULE_SETUP
#line 956 "/home/vsc/github/doxygen/src/pre.l"
{
                                          if (isDefined(yyscanner,yytext) || yyextra->guardName==yytext)
                                            yyextra->guardExpr+=" 1L ";
                                          else
                                            yyextra->guardExpr+=" 0L ";
                                          yyextra->lastGuardName=yytext;
                                        }
	YY_BREAK
case 108:
/* rule 108 can match eol */
YY_RULE_SETUP
#line 963 "/home/vsc/github/doxygen/src/pre.l"
{ // should not happen, handle anyway
                                          yyextra->yyLineNr++;
                                          yyextra->ifcount=0;
                                          BEGIN(SkipCPPBlock);
                                        }
	YY_BREAK
case 109:
YY_RULE_SETUP
#line 968 "/home/vsc/github/doxygen/src/pre.l"
{
                                          BEGIN(Guard);
                                        }
	YY_BREAK
case 110:
YY_RULE_SETUP
#line 971 "/home/vsc/github/doxygen/src/pre.l"

	YY_BREAK
case 111:
YY_RULE_SETUP
#line 972 "/home/vsc/github/doxygen/src/pre.l"
{ BEGIN(SkipCommand); }
	YY_BREAK
case 112:
/* rule 112 can match eol */
*yy_cp = yyg->yy_hold_char; /* undo effects of setting up yytext */
YY_LINENO_REWIND_TO(yy_cp - 1);
yyg->yy_c_buf_p = yy_cp -= 1;
YY_DO_BEFORE_ACTION; /* set up yytext again */
YY_RULE_SETUP
#line 973 "/home/vsc/github/doxygen/src/pre.l"
{ BEGIN(SkipLine); }
	YY_BREAK
case 113:
/* rule 113 can match eol */
YY_RULE_SETUP
#line 974 "/home/vsc/github/doxygen/src/pre.l"
{ yyextra->yyLineNr++; outputChar(yyscanner,'\n'); }
	YY_BREAK
case 114:
YY_RULE_SETUP
#line 975 "/home/vsc/github/doxygen/src/pre.l"

	YY_BREAK
case 115:
*yy_cp = yyg->yy_hold_char; /* undo effects of setting up yytext */
yyg->yy_c_buf_p = yy_cp -= 1;
YY_DO_BEFORE_ACTION; /* set up yytext again */
YY_RULE_SETUP
#line 976 "/home/vsc/github/doxygen/src/pre.l"
{
                                          incrLevel(yyscanner);
                                          yyextra->ifcount++;
                                          //printf("#if... depth=%d\n",yyextra->ifcount);
                                        }
	YY_BREAK
case 116:
YY_RULE_SETUP
#line 981 "/home/vsc/github/doxygen/src/pre.l"
{
                                          //printf("Else! yyextra->ifcount=%d otherCaseDone=%d\n",yyextra->ifcount,otherCaseDone());
                                          if (yyextra->ifcount==0 && !otherCaseDone(yyscanner))
                                          {
                                            setCaseDone(yyscanner,TRUE);
                                            //outputChar(yyscanner,'\n');
                                            BEGIN(Start);
                                          }
                                        }
	YY_BREAK
case 117:
*yy_cp = yyg->yy_hold_char; /* undo effects of setting up yytext */
yyg->yy_c_buf_p = yy_cp -= 1;
YY_DO_BEFORE_ACTION; /* set up yytext again */
YY_RULE_SETUP
#line 990 "/home/vsc/github/doxygen/src/pre.l"
{
                                          if (yyextra->ifcount==0)
                                          {
                                            if (!otherCaseDone(yyscanner))
                                            {
                                              yyextra->guardExpr.resize(0);
                                              yyextra->lastGuardName.resize(0);
                                              BEGIN(Guard);
                                            }
                                            else
                                            {
                                              BEGIN(SkipCPPBlock);
                                            }
                                          }
                                        }
	YY_BREAK
case 118:
YY_RULE_SETUP
#line 1005 "/home/vsc/github/doxygen/src/pre.l"
{
                                          yyextra->expectGuard = FALSE;
                                          decrLevel(yyscanner);
                                          if (--yyextra->ifcount<0)
                                          {
                                            //outputChar(yyscanner,'\n');
                                            BEGIN(Start);
                                          }
                                        }
	YY_BREAK
case 119:
/* rule 119 can match eol */
YY_RULE_SETUP
#line 1014 "/home/vsc/github/doxygen/src/pre.l"
{
                                          outputChar(yyscanner,'\n');
                                          yyextra->yyLineNr++;
                                          BEGIN(SkipCPPBlock);
                                        }
	YY_BREAK
case 120:
YY_RULE_SETUP
#line 1019 "/home/vsc/github/doxygen/src/pre.l"
{ // unknown directive
                                          BEGIN(SkipLine);
                                        }
	YY_BREAK
case 121:
YY_RULE_SETUP
#line 1022 "/home/vsc/github/doxygen/src/pre.l"

	YY_BREAK
case 122:
YY_RULE_SETUP
#line 1023 "/home/vsc/github/doxygen/src/pre.l"

	YY_BREAK
case 123:
YY_RULE_SETUP
#line 1024 "/home/vsc/github/doxygen/src/pre.l"
{ }
	YY_BREAK
case 124:
YY_RULE_SETUP
#line 1025 "/home/vsc/github/doxygen/src/pre.l"
{
                                          BEGIN(SkipString);
                                        }
	YY_BREAK
case 125:
YY_RULE_SETUP
#line 1028 "/home/vsc/github/doxygen/src/pre.l"

	YY_BREAK
case 126:
*yy_cp = yyg->yy_hold_char; /* undo effects of setting up yytext */
yyg->yy_c_buf_p = yy_cp = yy_bp + 2;
YY_DO_BEFORE_ACTION; /* set up yytext again */
YY_RULE_SETUP
#line 1029 "/home/vsc/github/doxygen/src/pre.l"
{
                                        }
	YY_BREAK
case 127:
YY_RULE_SETUP
#line 1031 "/home/vsc/github/doxygen/src/pre.l"
{
                                          yyextra->lastCPPContext=YY_START;
                                          BEGIN(RemoveCPPComment);
                                        }
	YY_BREAK
case 128:
*yy_cp = yyg->yy_hold_char; /* undo effects of setting up yytext */
yyg->yy_c_buf_p = yy_cp = yy_bp + 2;
YY_DO_BEFORE_ACTION; /* set up yytext again */
YY_RULE_SETUP
#line 1035 "/home/vsc/github/doxygen/src/pre.l"
{
                                        }
	YY_BREAK
case 129:
*yy_cp = yyg->yy_hold_char; /* undo effects of setting up yytext */
yyg->yy_c_buf_p = yy_cp = yy_bp + 2;
YY_DO_BEFORE_ACTION; /* set up yytext again */
YY_RULE_SETUP
#line 1037 "/home/vsc/github/doxygen/src/pre.l"
{
                                          yyextra->lastCContext=YY_START;
                                          BEGIN(RemoveCComment);
                                        }
	YY_BREAK
case 130:
/* rule 130 can match eol */
YY_RULE_SETUP
#line 1041 "/home/vsc/github/doxygen/src/pre.l"
{
                                          outputChar(yyscanner,'\n');
                                          yyextra->yyLineNr++;
                                          BEGIN(SkipCPPBlock);
                                        }
	YY_BREAK
case 131:
YY_RULE_SETUP
#line 1046 "/home/vsc/github/doxygen/src/pre.l"
{ }
	YY_BREAK
case 132:
YY_RULE_SETUP
#line 1047 "/home/vsc/github/doxygen/src/pre.l"
{ }
	YY_BREAK
case 133:
YY_RULE_SETUP
#line 1048 "/home/vsc/github/doxygen/src/pre.l"
{
                                          BEGIN(SkipLine);
                                        }
	YY_BREAK
case 134:
YY_RULE_SETUP
#line 1051 "/home/vsc/github/doxygen/src/pre.l"
{ }
	YY_BREAK
case 135:
*yy_cp = yyg->yy_hold_char; /* undo effects of setting up yytext */
yyg->yy_c_buf_p = yy_cp -= 1;
YY_DO_BEFORE_ACTION; /* set up yytext again */
YY_RULE_SETUP
#line 1052 "/home/vsc/github/doxygen/src/pre.l"
{
                                          yyextra->nospaces=TRUE;
                                          yyextra->roundCount=0;
                                          yyextra->defArgsStr=yytext;
                                          yyextra->findDefArgContext = IncludeID;
                                          BEGIN(FindDefineArgs);
                                        }
	YY_BREAK
case 136:
YY_RULE_SETUP
#line 1059 "/home/vsc/github/doxygen/src/pre.l"
{
                                          yyextra->nospaces=TRUE;
                                          readIncludeFile(yyscanner,expandMacro(yyscanner,yytext));
                                          BEGIN(Start);
                                        }
	YY_BREAK
case 137:
YY_RULE_SETUP
#line 1064 "/home/vsc/github/doxygen/src/pre.l"
{
                                          yyextra->incName+=yytext;
                                          readIncludeFile(yyscanner,yyextra->incName);
                                          if (yyextra->isImported)
                                          {
                                            BEGIN(EndImport);
                                          }
                                          else
                                          {
                                            BEGIN(Start);
                                          }
                                        }
	YY_BREAK
case 138:
/* rule 138 can match eol */
*yy_cp = yyg->yy_hold_char; /* undo effects of setting up yytext */
YY_LINENO_REWIND_TO(yy_cp - 1);
yyg->yy_c_buf_p = yy_cp -= 1;
YY_DO_BEFORE_ACTION; /* set up yytext again */
YY_RULE_SETUP
#line 1076 "/home/vsc/github/doxygen/src/pre.l"
{
                                          BEGIN(Start);
                                        }
	YY_BREAK
case 139:
/* rule 139 can match eol */
YY_RULE_SETUP
#line 1079 "/home/vsc/github/doxygen/src/pre.l"
{
                                          outputChar(yyscanner,'\n');
                                          yyextra->yyLineNr++;
                                        }
	YY_BREAK
case 140:
YY_RULE_SETUP
#line 1083 "/home/vsc/github/doxygen/src/pre.l"
{
                                        }
	YY_BREAK
case 141:
/* rule 141 can match eol */
YY_RULE_SETUP
#line 1085 "/home/vsc/github/doxygen/src/pre.l"
{ // define with argument
                                          //printf("Define() '%s'\n",yytext);
                                          yyextra->argMap.clear();
                                          yyextra->defArgs = 0;
                                          yyextra->defArgsStr.resize(0);
                                          yyextra->defText.resize(0);
                                          yyextra->defLitText.resize(0);
                                          yyextra->defName = yytext;
                                          yyextra->defVarArgs = FALSE;
                                          yyextra->defExtraSpacing.resize(0);
                                          yyextra->defContinue = false;
                                          BEGIN(DefineArg);
                                        }
	YY_BREAK
case 142:
/* rule 142 can match eol */
*yy_cp = yyg->yy_hold_char; /* undo effects of setting up yytext */
YY_LINENO_REWIND_TO(yy_cp - 1);
yyg->yy_c_buf_p = yy_cp -= 1;
YY_DO_BEFORE_ACTION; /* set up yytext again */
YY_RULE_SETUP
#line 1098 "/home/vsc/github/doxygen/src/pre.l"
{ // special case: define with 1 -> can be "guard"
                                          //printf("Define '%s'\n",yytext);
                                          yyextra->argMap.clear();
                                          yyextra->defArgs = -1;
                                          yyextra->defArgsStr.resize(0);
                                          yyextra->defName = QCString(yytext).left(yyleng-1).stripWhiteSpace();
                                          yyextra->defVarArgs = FALSE;
                                          //printf("Guard check: %s!=%s || %d\n",
                                          //    qPrint(yyextra->defName),qPrint(yyextra->lastGuardName),yyextra->expectGuard);
                                          if (yyextra->curlyCount>0 || yyextra->defName!=yyextra->lastGuardName || !yyextra->expectGuard)
                                          { // define may appear in the output
                                            QCString def = yyextra->potentialDefine +
                                                           yyextra->defName         ;
                                            outputString(yyscanner,def);
                                            outputSpaces(yyscanner,yytext+yyextra->defName.length());
                                            yyextra->quoteArg=FALSE;
                                            yyextra->insideComment=FALSE;
                                            yyextra->lastGuardName.resize(0);
                                            yyextra->defText="1";
                                            yyextra->defLitText="1";
                                            BEGIN(DefineText);
                                          }
                                          else // define is a guard => hide
                                          {
                                            //printf("Found a guard %s\n",yytext);
                                            yyextra->defText.resize(0);
                                            yyextra->defLitText.resize(0);
                                            BEGIN(Start);
                                          }
                                          yyextra->expectGuard=FALSE;
                                        }
	YY_BREAK
case 143:
/* rule 143 can match eol */
YY_RULE_SETUP
#line 1129 "/home/vsc/github/doxygen/src/pre.l"
{ // empty define
                                          yyextra->argMap.clear();
                                          yyextra->defArgs = -1;
                                          yyextra->defName = yytext;
                                          yyextra->defArgsStr.resize(0);
                                          yyextra->defText.resize(0);
                                          yyextra->defLitText.resize(0);
                                          yyextra->defVarArgs = FALSE;
                                          //printf("Guard check: %s!=%s || %d\n",
                                          //    qPrint(yyextra->defName),qPrint(yyextra->lastGuardName),yyextra->expectGuard);
                                          if (yyextra->curlyCount>0 || yyextra->defName!=yyextra->lastGuardName || !yyextra->expectGuard)
                                          { // define may appear in the output
                                            QCString def = yyextra->potentialDefine + yyextra->defName;
                                            outputString(yyscanner,def);
                                            yyextra->quoteArg=FALSE;
                                            yyextra->insideComment=FALSE;
                                            if (yyextra->insideCS) yyextra->defText="1"; // for C#, use "1" as define text
                                            BEGIN(DefineText);
                                          }
                                          else // define is a guard => hide
                                          {
                                            //printf("Found a guard %s\n",yytext);
                                            yyextra->guardName = yytext;
                                            yyextra->lastGuardName.resize(0);
                                            BEGIN(Start);
                                          }
                                          yyextra->expectGuard=FALSE;
                                        }
	YY_BREAK
case 144:
YY_RULE_SETUP
#line 1157 "/home/vsc/github/doxygen/src/pre.l"
{ // define with content
                                          //printf("Define '%s'\n",yytext);
                                          yyextra->argMap.clear();
                                          yyextra->defArgs = -1;
                                          yyextra->defArgsStr.resize(0);
                                          yyextra->defText.resize(0);
                                          yyextra->defLitText.resize(0);
                                          yyextra->defName = yytext;
                                          yyextra->defVarArgs = FALSE;
                                          QCString def = yyextra->potentialDefine +
                                                         yyextra->defName         +
                                                         yyextra->defArgsStr      ;
                                          outputString(yyscanner,def);
                                          yyextra->quoteArg=FALSE;
                                          yyextra->insideComment=FALSE;
                                          BEGIN(DefineText);
                                        }
	YY_BREAK
case 145:
/* rule 145 can match eol */
YY_RULE_SETUP
#line 1174 "/home/vsc/github/doxygen/src/pre.l"
{
                                          yyextra->defExtraSpacing+="\n";
                                          yyextra->defContinue = true;
                                          yyextra->yyLineNr++;
                                        }
	YY_BREAK
case 146:
YY_RULE_SETUP
#line 1179 "/home/vsc/github/doxygen/src/pre.l"
{ yyextra->defExtraSpacing+=yytext; }
	YY_BREAK
case 147:
YY_RULE_SETUP
#line 1180 "/home/vsc/github/doxygen/src/pre.l"
{ yyextra->defArgsStr+=yytext; }
	YY_BREAK
case 148:
YY_RULE_SETUP
#line 1181 "/home/vsc/github/doxygen/src/pre.l"
{ yyextra->defArgsStr+=yytext; }
	YY_BREAK
case 149:
YY_RULE_SETUP
#line 1182 "/home/vsc/github/doxygen/src/pre.l"
{
                                          extraSpacing(yyscanner);
                                          yyextra->defArgsStr+=yytext;
                                          QCString def = yyextra->potentialDefine +
                                                         yyextra->defName         +
                                                         yyextra->defArgsStr      +
                                                         yyextra->defExtraSpacing ;
                                          outputString(yyscanner,def);
                                          yyextra->quoteArg=FALSE;
                                          yyextra->insideComment=FALSE;
                                          BEGIN(DefineText);
                                        }
	YY_BREAK
case 150:
YY_RULE_SETUP
#line 1194 "/home/vsc/github/doxygen/src/pre.l"
{ // Variadic macro
                                          yyextra->defVarArgs = TRUE;
                                          yyextra->defArgsStr+=yytext;
                                          yyextra->argMap.emplace(std::string("__VA_ARGS__"),yyextra->defArgs);
                                          yyextra->defArgs++;
                                        }
	YY_BREAK
case 151:
YY_RULE_SETUP
#line 1200 "/home/vsc/github/doxygen/src/pre.l"
{
                                          //printf("Define addArg(%s)\n",yytext);
                                          QCString argName=yytext;
                                          yyextra->defVarArgs = yytext[yyleng-1]=='.';
                                          if (yyextra->defVarArgs) // strip ellipsis
                                          {
                                            argName=argName.left(argName.length()-3);
                                          }
                                          argName = argName.stripWhiteSpace();
                                          yyextra->defArgsStr+=yytext;
                                          yyextra->argMap.emplace(toStdString(argName),yyextra->defArgs);
                                          yyextra->defArgs++;
                                          extraSpacing(yyscanner);
                                        }
	YY_BREAK
/*
<DefineText>"/ **"|"/ *!"                       {
                                          yyextra->defText+=yytext;
                                          yyextra->defLitText+=yytext;
                                          yyextra->insideComment=TRUE;
                                        }
<DefineText>"* /"                       {
                                          yyextra->defText+=yytext;
                                          yyextra->defLitText+=yytext;
                                          yyextra->insideComment=FALSE;
                                        }
  */
case 152:
YY_RULE_SETUP
#line 1226 "/home/vsc/github/doxygen/src/pre.l"
{
                                          yyextra->defText+=yytext;
                                          yyextra->defLitText+=yytext;
                                          yyextra->lastCContext=YY_START;
                                          yyextra->commentCount=1;
                                          BEGIN(CopyCComment);
                                        }
	YY_BREAK
case 153:
YY_RULE_SETUP
#line 1233 "/home/vsc/github/doxygen/src/pre.l"
{
                                          outputArray(yyscanner,yytext,yyleng);
                                          yyextra->lastCPPContext=YY_START;
                                          yyextra->defLitText+=' ';
                                          BEGIN(SkipCPPComment);
                                        }
	YY_BREAK
case 154:
YY_RULE_SETUP
#line 1239 "/home/vsc/github/doxygen/src/pre.l"
{
                                          if (yytext[0]=='/') outputChar(yyscanner,'/');
                                          outputChar(yyscanner,'*');outputChar(yyscanner,'/');
                                          if (--yyextra->commentCount<=0)
                                          {
                                            if (yyextra->lastCContext==Start)
                                              // small hack to make sure that ^... rule will
                                              // match when going to Start... Example: "/*...*/ some stuff..."
                                            {
                                              YY_CURRENT_BUFFER->yy_at_bol=1;
                                            }
                                            BEGIN(yyextra->lastCContext);
                                          }
                                        }
	YY_BREAK
case 155:
YY_RULE_SETUP
#line 1253 "/home/vsc/github/doxygen/src/pre.l"
{
                                          outputArray(yyscanner,yytext,yyleng);
                                        }
	YY_BREAK
case 156:
YY_RULE_SETUP
#line 1256 "/home/vsc/github/doxygen/src/pre.l"
{
                                          outputChar(yyscanner,'/');outputChar(yyscanner,'*');
                                          //yyextra->commentCount++;
                                        }
	YY_BREAK
case 157:
YY_RULE_SETUP
#line 1260 "/home/vsc/github/doxygen/src/pre.l"
{ }
	YY_BREAK
case 158:
YY_RULE_SETUP
#line 1261 "/home/vsc/github/doxygen/src/pre.l"
{
                                          bool markdownSupport = Config_getBool(MARKDOWN_SUPPORT);
                                          if (!markdownSupport || !yyextra->isSpecialComment)
                                          {
                                            REJECT;
                                          }
                                          else
                                          {
                                            yyextra->fenceSize=(int)yyleng;
                                            BEGIN(SkipCondVerbatim);
                                          }
                                        }
	YY_BREAK
case 159:
YY_RULE_SETUP
#line 1273 "/home/vsc/github/doxygen/src/pre.l"
{
                                          bool markdownSupport = Config_getBool(MARKDOWN_SUPPORT);
                                          if (!markdownSupport || !yyextra->isSpecialComment)
                                          {
                                            REJECT;
                                          }
                                          else
                                          {
                                            yyextra->fenceSize=(int)yyleng;
                                            BEGIN(SkipCondVerbatim);
                                          }
                                        }
	YY_BREAK
case 160:
YY_RULE_SETUP
#line 1285 "/home/vsc/github/doxygen/src/pre.l"
{
                                          bool markdownSupport = Config_getBool(MARKDOWN_SUPPORT);
                                          if (!markdownSupport || !yyextra->isSpecialComment)
                                          {
                                            REJECT;
                                          }
                                          else
                                          {
                                            outputArray(yyscanner,yytext,yyleng);
                                            yyextra->fenceSize=(int)yyleng;
                                            BEGIN(SkipVerbatim);
                                          }
                                        }
	YY_BREAK
case 161:
YY_RULE_SETUP
#line 1298 "/home/vsc/github/doxygen/src/pre.l"
{
                                          bool markdownSupport = Config_getBool(MARKDOWN_SUPPORT);
                                          if (!markdownSupport || !yyextra->isSpecialComment)
                                          {
                                            REJECT;
                                          }
                                          else
                                          {
                                            outputArray(yyscanner,yytext,yyleng);
                                            yyextra->fenceSize=(int)yyleng;
                                            BEGIN(SkipVerbatim);
                                          }
                                        }
	YY_BREAK
case 162:
#line 1312 "/home/vsc/github/doxygen/src/pre.l"
case 163:
/* rule 163 can match eol */
YY_RULE_SETUP
#line 1312 "/home/vsc/github/doxygen/src/pre.l"
{ // escaped command
                                          outputArray(yyscanner,yytext,yyleng);
                                          yyextra->yyLineNr+=QCString(yytext).contains('\n');
                                        }
	YY_BREAK
case 164:
/* rule 164 can match eol */
*yy_cp = yyg->yy_hold_char; /* undo effects of setting up yytext */
YY_LINENO_REWIND_TO(yy_cp - 1);
yyg->yy_c_buf_p = yy_cp -= 1;
YY_DO_BEFORE_ACTION; /* set up yytext again */
YY_RULE_SETUP
#line 1316 "/home/vsc/github/doxygen/src/pre.l"
{ // normal command
                                          outputArray(yyscanner,yytext,yyleng);
                                        }
	YY_BREAK
case 165:
/* rule 165 can match eol */
YY_RULE_SETUP
#line 1319 "/home/vsc/github/doxygen/src/pre.l"
{ // normal block command
                                          outputArray(yyscanner,yytext,yyleng);
                                          yyextra->yyLineNr+=QCString(yytext).contains('\n');
                                          determineBlockName(yyscanner);
                                          BEGIN(SkipVerbatim);
                                        }
	YY_BREAK
case 166:
YY_RULE_SETUP
#line 1325 "/home/vsc/github/doxygen/src/pre.l"
{}// escaped cond command
	YY_BREAK
case 167:
YY_RULE_SETUP
#line 1326 "/home/vsc/github/doxygen/src/pre.l"
{ // cond command in a skipped cond section, this section has to be skipped as well
                                          // but has to be recorded to match the endcond command
                                          startCondSection(yyscanner," ");
                                        }
	YY_BREAK
case 168:
/* rule 168 can match eol */
*yy_cp = yyg->yy_hold_char; /* undo effects of setting up yytext */
YY_LINENO_REWIND_TO(yy_cp - 1);
yyg->yy_c_buf_p = yy_cp -= 1;
YY_DO_BEFORE_ACTION; /* set up yytext again */
YY_RULE_SETUP
#line 1330 "/home/vsc/github/doxygen/src/pre.l"
{
                                          outputArray(yyscanner,"@iliteral{code}",15);
                                          yyextra->javaBlock=1;
                                          BEGIN(JavaDocVerbatimCode);
                                        }
	YY_BREAK
case 169:
/* rule 169 can match eol */
*yy_cp = yyg->yy_hold_char; /* undo effects of setting up yytext */
YY_LINENO_REWIND_TO(yy_cp - 1);
yyg->yy_c_buf_p = yy_cp -= 1;
YY_DO_BEFORE_ACTION; /* set up yytext again */
YY_RULE_SETUP
#line 1335 "/home/vsc/github/doxygen/src/pre.l"
{
                                          outputArray(yyscanner,"@iliteral",9);
                                          yyextra->javaBlock=1;
                                          BEGIN(JavaDocVerbatimCode);
                                        }
	YY_BREAK
case 170:
YY_RULE_SETUP
#line 1340 "/home/vsc/github/doxygen/src/pre.l"
{ // escaped @cond
                                          outputArray(yyscanner,yytext,yyleng);
                                        }
	YY_BREAK
case 171:
YY_RULE_SETUP
#line 1343 "/home/vsc/github/doxygen/src/pre.l"
{ // conditional section
                                          yyextra->ccomment=TRUE;
                                          yyextra->condCtx=YY_START;
                                          BEGIN(CondLineCpp);
                                        }
	YY_BREAK
case 172:
YY_RULE_SETUP
#line 1348 "/home/vsc/github/doxygen/src/pre.l"
{ // conditional section
                                          yyextra->ccomment=FALSE;
                                          yyextra->condCtx=YY_START;
                                          BEGIN(CondLineC);
                                        }
	YY_BREAK
case 173:
YY_RULE_SETUP
#line 1353 "/home/vsc/github/doxygen/src/pre.l"
{
                                          startCondSection(yyscanner,yytext);
                                          if (yyextra->skip)
                                          {
                                            if (YY_START==CondLineC)
                                            {
                                              // end C comment
                                              outputArray(yyscanner,"*/",2);
                                              yyextra->ccomment=TRUE;
                                            }
                                            else
                                            {
                                              yyextra->ccomment=FALSE;
                                            }
                                            BEGIN(SkipCond);
                                          }
                                          else
                                          {
                                            BEGIN(yyextra->condCtx);
                                          }
                                        }
	YY_BREAK
case 174:
YY_RULE_SETUP
#line 1374 "/home/vsc/github/doxygen/src/pre.l"
{ // non-guard character
                                          unput(*yytext);
                                          startCondSection(yyscanner," ");
                                          if (yyextra->skip)
                                          {
                                            if (YY_START==CondLineC)
                                            {
                                              // end C comment
                                              outputArray(yyscanner,"*/",2);
                                              yyextra->ccomment=TRUE;
                                            }
                                            else
                                            {
                                              yyextra->ccomment=FALSE;
                                            }
                                            BEGIN(SkipCond);
                                          }
                                          else
                                          {
                                            BEGIN(yyextra->condCtx);
                                          }
                                        }
	YY_BREAK
case 175:
/* rule 175 can match eol */
*yy_cp = yyg->yy_hold_char; /* undo effects of setting up yytext */
YY_LINENO_REWIND_TO(yy_cp - 1);
yyg->yy_c_buf_p = yy_cp -= 1;
YY_DO_BEFORE_ACTION; /* set up yytext again */
YY_RULE_SETUP
#line 1396 "/home/vsc/github/doxygen/src/pre.l"
{ // no guard
                                          if (YY_START==SkipCComment)
                                          {
                                            yyextra->ccomment=TRUE;
                                            // end C comment
                                            outputArray(yyscanner,"*/",2);
                                          }
                                          else
                                          {
                                            yyextra->ccomment=FALSE;
                                          }
                                          yyextra->condCtx=YY_START;
                                          startCondSection(yyscanner," ");
                                          BEGIN(SkipCond);
                                        }
	YY_BREAK
case 176:
/* rule 176 can match eol */
YY_RULE_SETUP
#line 1411 "/home/vsc/github/doxygen/src/pre.l"
{ yyextra->yyLineNr++; outputChar(yyscanner,'\n'); }
	YY_BREAK
case 177:
/* rule 177 can match eol */
*yy_cp = yyg->yy_hold_char; /* undo effects of setting up yytext */
YY_LINENO_REWIND_TO(yy_cp - 1);
yyg->yy_c_buf_p = yy_cp -= 1;
YY_DO_BEFORE_ACTION; /* set up yytext again */
YY_RULE_SETUP
#line 1412 "/home/vsc/github/doxygen/src/pre.l"
{ }
	YY_BREAK
case 178:
/* rule 178 can match eol */
YY_RULE_SETUP
#line 1413 "/home/vsc/github/doxygen/src/pre.l"
{
                                          auto numNLs = QCString(yytext).contains('\n');
                                          yyextra->yyLineNr+=numNLs;
                                          for (int i = 0; i < numNLs; i++) outputChar(yyscanner,'\n');
                                          determineBlockName(yyscanner);
                                          BEGIN(SkipCondVerbatim);
                                        }
	YY_BREAK
case 179:
YY_RULE_SETUP
#line 1421 "/home/vsc/github/doxygen/src/pre.l"
{ }
	YY_BREAK
case 180:
YY_RULE_SETUP
#line 1422 "/home/vsc/github/doxygen/src/pre.l"
{ }
	YY_BREAK
case 181:
YY_RULE_SETUP
#line 1423 "/home/vsc/github/doxygen/src/pre.l"
{ yyextra->ccomment=FALSE; }
	YY_BREAK
case 182:
YY_RULE_SETUP
#line 1424 "/home/vsc/github/doxygen/src/pre.l"
{ yyextra->ccomment=TRUE; }
	YY_BREAK
case 183:
/* rule 183 can match eol */
*yy_cp = yyg->yy_hold_char; /* undo effects of setting up yytext */
YY_LINENO_REWIND_TO(yy_bp + 9);
yyg->yy_c_buf_p = yy_cp = yy_bp + 9;
YY_DO_BEFORE_ACTION; /* set up yytext again */
YY_RULE_SETUP
#line 1425 "/home/vsc/github/doxygen/src/pre.l"
{
                                          if (!yyextra->skip)
                                          {
                                            outputArray(yyscanner,yytext,yyleng);
                                          }
                                        }
	YY_BREAK
case 184:
/* rule 184 can match eol */
*yy_cp = yyg->yy_hold_char; /* undo effects of setting up yytext */
YY_LINENO_REWIND_TO(yy_bp + 8);
yyg->yy_c_buf_p = yy_cp = yy_bp + 8;
YY_DO_BEFORE_ACTION; /* set up yytext again */
YY_RULE_SETUP
#line 1431 "/home/vsc/github/doxygen/src/pre.l"
{
                                          bool oldSkip = yyextra->skip;
                                          endCondSection(yyscanner);
                                          if (oldSkip && !yyextra->skip)
                                          {
                                            if (yyextra->ccomment)
                                            {
                                              outputArray(yyscanner,"/** ",4); // */
                                            }
                                            BEGIN(yyextra->condCtx);
                                          }
                                        }
	YY_BREAK
case 185:
/* rule 185 can match eol */
*yy_cp = yyg->yy_hold_char; /* undo effects of setting up yytext */
YY_LINENO_REWIND_TO(yy_bp + 8);
yyg->yy_c_buf_p = yy_cp = yy_bp + 8;
YY_DO_BEFORE_ACTION; /* set up yytext again */
YY_RULE_SETUP
#line 1443 "/home/vsc/github/doxygen/src/pre.l"
{
                                          bool oldSkip = yyextra->skip;
                                          endCondSection(yyscanner);
                                          if (oldSkip && !yyextra->skip)
                                          {
                                            BEGIN(yyextra->condCtx);
                                          }
                                        }
	YY_BREAK
case 186:
YY_RULE_SETUP
#line 1451 "/home/vsc/github/doxygen/src/pre.l"
{ /* end of verbatim block */
                                          if (yytext[1]=='f' && yyextra->blockName==&yytext[2])
                                          {
                                            BEGIN(SkipCond);
                                          }
                                          else if (&yytext[4]==yyextra->blockName)
                                          {
                                            BEGIN(SkipCond);
                                          }
                                        }
	YY_BREAK
case 187:
YY_RULE_SETUP
#line 1461 "/home/vsc/github/doxygen/src/pre.l"
{ /* end of verbatim block */
                                          outputArray(yyscanner,yytext,yyleng);
                                          if (yytext[1]=='f' && yyextra->blockName==&yytext[2])
                                          {
                                            BEGIN(SkipCComment);
                                          }
                                          else if (&yytext[4]==yyextra->blockName)
                                          {
                                            BEGIN(SkipCComment);
                                          }
                                        }
	YY_BREAK
case 188:
YY_RULE_SETUP
#line 1472 "/home/vsc/github/doxygen/src/pre.l"
{
                                          if (yyextra->fenceSize==(yy_size_t)yyleng)
                                          {
                                            BEGIN(SkipCond);
                                          }
                                        }
	YY_BREAK
case 189:
YY_RULE_SETUP
#line 1478 "/home/vsc/github/doxygen/src/pre.l"
{
                                          if (yyextra->fenceSize==(yy_size_t)yyleng)
                                          {
                                            BEGIN(SkipCond);
                                          }
                                        }
	YY_BREAK
case 190:
YY_RULE_SETUP
#line 1484 "/home/vsc/github/doxygen/src/pre.l"
{
                                          outputArray(yyscanner,yytext,yyleng);
                                          if (yyextra->fenceSize==(yy_size_t)yyleng)
                                          {
                                            BEGIN(SkipCComment);
                                          }
                                        }
	YY_BREAK
case 191:
YY_RULE_SETUP
#line 1491 "/home/vsc/github/doxygen/src/pre.l"
{
                                          outputArray(yyscanner,yytext,yyleng);
                                          if (yyextra->fenceSize==(yy_size_t)yyleng)
                                          {
                                            BEGIN(SkipCComment);
                                          }
                                        }
	YY_BREAK
case 192:
YY_RULE_SETUP
#line 1498 "/home/vsc/github/doxygen/src/pre.l"
{ }
	YY_BREAK
case 193:
YY_RULE_SETUP
#line 1499 "/home/vsc/github/doxygen/src/pre.l"
{
                                          outputArray(yyscanner,yytext,yyleng);
                                        }
	YY_BREAK
case 194:
YY_RULE_SETUP
#line 1502 "/home/vsc/github/doxygen/src/pre.l"
{
                                          if (yyextra->javaBlock==0)
                                          {
                                            REJECT;
                                          }
                                          else
                                          {
                                            yyextra->javaBlock++;
                                            outputArray(yyscanner,yytext,(int)yyleng);
                                          }
                                        }
	YY_BREAK
case 195:
YY_RULE_SETUP
#line 1513 "/home/vsc/github/doxygen/src/pre.l"
{
                                          if (yyextra->javaBlock==0)
                                          {
                                            REJECT;
                                          }
                                          else
                                          {
                                            yyextra->javaBlock--;
                                            if (yyextra->javaBlock==0)
                                            {
                                              outputArray(yyscanner," @endiliteral ",14);
                                              BEGIN(SkipCComment);
                                            }
                                            else
                                            {
                                              outputArray(yyscanner,yytext,(int)yyleng);
                                            }
                                          }
                                        }
	YY_BREAK
case 196:
/* rule 196 can match eol */
YY_RULE_SETUP
#line 1532 "/home/vsc/github/doxygen/src/pre.l"
{ /* new line in verbatim block */
                                          outputArray(yyscanner,yytext,(int)yyleng);
                                        }
	YY_BREAK
case 197:
YY_RULE_SETUP
#line 1535 "/home/vsc/github/doxygen/src/pre.l"
{ /* any other character */
                                          outputArray(yyscanner,yytext,(int)yyleng);
                                        }
	YY_BREAK
case 198:
YY_RULE_SETUP
#line 1538 "/home/vsc/github/doxygen/src/pre.l"
{ }
	YY_BREAK
case 199:
YY_RULE_SETUP
#line 1539 "/home/vsc/github/doxygen/src/pre.l"
{
                                          outputArray(yyscanner,yytext,yyleng);
                                        }
	YY_BREAK
case 200:
/* rule 200 can match eol */
YY_RULE_SETUP
#line 1542 "/home/vsc/github/doxygen/src/pre.l"
{
                                          yyextra->yyLineNr++;
                                          outputChar(yyscanner,'\n');
                                        }
	YY_BREAK
case 201:
YY_RULE_SETUP
#line 1546 "/home/vsc/github/doxygen/src/pre.l"
{ }
	YY_BREAK
case 202:
YY_RULE_SETUP
#line 1547 "/home/vsc/github/doxygen/src/pre.l"
{ 
                                          outputChar(yyscanner,*yytext);
                                        }
	YY_BREAK
case 203:
YY_RULE_SETUP
#line 1550 "/home/vsc/github/doxygen/src/pre.l"
{
                                          yyextra->defLitText+=yytext;
                                          yyextra->defText+=escapeAt(yytext);
                                        }
	YY_BREAK
case 204:
/* rule 204 can match eol */
YY_RULE_SETUP
#line 1554 "/home/vsc/github/doxygen/src/pre.l"
{
                                          yyextra->defLitText+=yytext;
                                          yyextra->defText+=" ";
                                          yyextra->yyLineNr++;
                                          yyextra->yyMLines++;
                                        }
	YY_BREAK
case 205:
YY_RULE_SETUP
#line 1560 "/home/vsc/github/doxygen/src/pre.l"
{
                                          yyextra->defLitText+=yytext;
                                          yyextra->defText+=yytext;
                                          BEGIN(yyextra->lastCContext);
                                        }
	YY_BREAK
case 206:
/* rule 206 can match eol */
YY_RULE_SETUP
#line 1565 "/home/vsc/github/doxygen/src/pre.l"
{
                                          yyextra->yyLineNr++;
                                          yyextra->defLitText+=yytext;
                                          yyextra->defText+=' ';
                                        }
	YY_BREAK
case 207:
YY_RULE_SETUP
#line 1570 "/home/vsc/github/doxygen/src/pre.l"
{ // see bug 594021 for a usecase for this rule
                                          if (yyextra->lastCContext==SkipCPPBlock)
                                          {
                                            BEGIN(SkipCommand);
                                          }
                                          else
                                          {
                                            REJECT;
                                          }
                                        }
	YY_BREAK
case 208:
YY_RULE_SETUP
#line 1580 "/home/vsc/github/doxygen/src/pre.l"
{ BEGIN(yyextra->lastCContext); }
	YY_BREAK
case 209:
YY_RULE_SETUP
#line 1581 "/home/vsc/github/doxygen/src/pre.l"

	YY_BREAK
case 210:
YY_RULE_SETUP
#line 1582 "/home/vsc/github/doxygen/src/pre.l"

	YY_BREAK
case 211:
YY_RULE_SETUP
#line 1583 "/home/vsc/github/doxygen/src/pre.l"

	YY_BREAK
case 212:
/* rule 212 can match eol */
YY_RULE_SETUP
#line 1584 "/home/vsc/github/doxygen/src/pre.l"
{ yyextra->yyLineNr++; outputChar(yyscanner,'\n'); }
	YY_BREAK
case 213:
YY_RULE_SETUP
#line 1585 "/home/vsc/github/doxygen/src/pre.l"

	YY_BREAK
case 214:
YY_RULE_SETUP
#line 1586 "/home/vsc/github/doxygen/src/pre.l"
{
                                          outputArray(yyscanner,yytext,yyleng);
                                        }
	YY_BREAK
case 215:
/* rule 215 can match eol */
YY_RULE_SETUP
#line 1589 "/home/vsc/github/doxygen/src/pre.l"
{
                                          unput(*yytext);
                                          BEGIN(yyextra->lastCPPContext);
                                        }
	YY_BREAK
case 216:
YY_RULE_SETUP
#line 1593 "/home/vsc/github/doxygen/src/pre.l"
{
                                          outputChar(yyscanner,'/');outputChar(yyscanner,'*');
                                        }
	YY_BREAK
case 217:
YY_RULE_SETUP
#line 1596 "/home/vsc/github/doxygen/src/pre.l"
{
                                          outputChar(yyscanner,'/');outputChar(yyscanner,'/');
                                        }
	YY_BREAK
case 218:
YY_RULE_SETUP
#line 1599 "/home/vsc/github/doxygen/src/pre.l"
{
                                          outputArray(yyscanner,yytext,yyleng);
                                        }
	YY_BREAK
case 219:
YY_RULE_SETUP
#line 1602 "/home/vsc/github/doxygen/src/pre.l"
{
                                          outputChar(yyscanner,*yytext);
                                        }
	YY_BREAK
case 220:
YY_RULE_SETUP
#line 1605 "/home/vsc/github/doxygen/src/pre.l"

	YY_BREAK
case 221:
YY_RULE_SETUP
#line 1606 "/home/vsc/github/doxygen/src/pre.l"

	YY_BREAK
case 222:
YY_RULE_SETUP
#line 1607 "/home/vsc/github/doxygen/src/pre.l"

	YY_BREAK
case 223:
YY_RULE_SETUP
#line 1608 "/home/vsc/github/doxygen/src/pre.l"

	YY_BREAK
case 224:
*yy_cp = yyg->yy_hold_char; /* undo effects of setting up yytext */
yyg->yy_c_buf_p = yy_cp = yy_bp + 1;
YY_DO_BEFORE_ACTION; /* set up yytext again */
YY_RULE_SETUP
#line 1609 "/home/vsc/github/doxygen/src/pre.l"
{
                                          outputChar(yyscanner,' ');
                                          yyextra->quoteArg=TRUE;
                                          yyextra->idStart=true;
                                          yyextra->defLitText+=yytext;
                                        }
	YY_BREAK
case 225:
YY_RULE_SETUP
#line 1615 "/home/vsc/github/doxygen/src/pre.l"
{
                                          yyextra->defLitText+=yytext;
                                          if (YY_START == DefineText) outputSpaces(yyscanner,yytext);
                                          if (yyextra->quoteArg)
                                          {
                                            yyextra->defText+="\"";
                                          }
                                          if (yyextra->defArgs>0)
                                          {
                                            auto it = yyextra->argMap.find(yytext);
                                            if (it!=yyextra->argMap.end())
                                            {
                                              int n = it->second;
                                              yyextra->defText+='@';
                                              yyextra->defText+=QCString().setNum(n);
                                            }
                                            else
                                            {
                                              if (yyextra->idStart)
                                              {
                                                warn(yyextra->fileName,yyextra->yyLineNr,
                                                  "'#' is not followed by a macro parameter '%s': '%s'",
                                                  qPrint(yyextra->defName),qPrint(yyextra->defLitText.stripWhiteSpace()));
                                              }
                                              yyextra->defText+=yytext;
                                            }
                                          }
                                          else
                                          {
                                            yyextra->defText+=yytext;
                                          }
                                          if (yyextra->quoteArg)
                                          {
                                            yyextra->defText+="\"";
                                          }
                                          yyextra->quoteArg=FALSE;
                                          yyextra->idStart=false;
                                        }
	YY_BREAK
case 226:
YY_RULE_SETUP
#line 1653 "/home/vsc/github/doxygen/src/pre.l"
{
                                          yyextra->defLitText+=yytext;
                                          yyextra->defText+=yytext;
                                        }
	YY_BREAK
case 227:
/* rule 227 can match eol */
YY_RULE_SETUP
#line 1657 "/home/vsc/github/doxygen/src/pre.l"
{
                                          yyextra->defLitText+=yytext;
                                          outputChar(yyscanner,'\n');
                                          yyextra->defText += ' ';
                                          yyextra->yyLineNr++;
                                          yyextra->yyMLines++;
                                        }
	YY_BREAK
case 228:
/* rule 228 can match eol */
YY_RULE_SETUP
#line 1664 "/home/vsc/github/doxygen/src/pre.l"
{
                                          QCString comment=extractTrailingComment(yyextra->defLitText);
                                          yyextra->defText = yyextra->defText.stripWhiteSpace();
                                          if (yyextra->defText.startsWith("##"))
                                          {
                                            warn(yyextra->fileName,yyextra->yyLineNr,
                                                 "'##' cannot occur at the beginning of a macro definition '%s': '%s'",
                                                 qPrint(yyextra->defName),qPrint(yyextra->defLitText.stripWhiteSpace()));
                                          }
                                          else if (yyextra->defText.endsWith("##"))
                                          {
                                            warn(yyextra->fileName,yyextra->yyLineNr,
                                                 "'##' cannot occur at the end of a macro definition '%s': '%s'",
                                                 qPrint(yyextra->defName),qPrint(yyextra->defLitText.stripWhiteSpace()));
                                          }
                                          else if (yyextra->defText.endsWith("#"))
                                          {
                                            warn(yyextra->fileName,yyextra->yyLineNr,
                                                 "expected formal parameter after # in macro definition '%s': '%s'",
                                                 qPrint(yyextra->defName),qPrint(yyextra->defLitText.stripWhiteSpace()));
                                          }
                                          yyextra->defLitText+=yytext;
                                          if (!comment.isEmpty())
                                          {
                                            outputString(yyscanner,comment);
                                            yyextra->defLitText=yyextra->defLitText.left(yyextra->defLitText.length()-comment.length()-1);
                                          }
                                          outputChar(yyscanner,'\n');
                                          Define *def=0;
                                          //printf("Define name='%s' text='%s' litTexti='%s'\n",qPrint(yyextra->defName),qPrint(yyextra->defText),qPrint(yyextra->defLitText));
                                          if (yyextra->includeStack.empty() || yyextra->curlyCount>0)
                                          {
                                            addMacroDefinition(yyscanner);
                                          }
                                          def=isDefined(yyscanner,yyextra->defName);
                                          if (def==0) // new define
                                          {
                                            //printf("new define '%s'!\n",qPrint(yyextra->defName));
                                            addDefine(yyscanner);
                                          }
                                          else if (def /*&& macroIsAccessible(def)*/)
                                               // name already exists
                                          {
                                            //printf("existing define!\n");
                                            //printf("define found\n");
                                            if (def->undef) // undefined name
                                            {
                                              def->undef = FALSE;
                                              def->name = yyextra->defName;
                                              def->definition = yyextra->defText.stripWhiteSpace();
                                              def->nargs = yyextra->defArgs;
                                              def->fileName = yyextra->fileName;
                                              def->lineNr = yyextra->yyLineNr-yyextra->yyMLines;
                                              def->columnNr = yyextra->yyColNr;
                                            }
                                            else
                                            {
                                              //printf("error: define %s is defined more than once!\n",qPrint(yyextra->defName));
                                            }
                                          }
                                          yyextra->argMap.clear();
                                          yyextra->yyLineNr++;
                                          yyextra->yyColNr=1;
                                          yyextra->lastGuardName.resize(0);
                                          BEGIN(Start);
                                        }
	YY_BREAK
case 229:
YY_RULE_SETUP
#line 1730 "/home/vsc/github/doxygen/src/pre.l"
{ outputString(yyscanner,yytext);
                                          yyextra->defText += ' ';
                                          yyextra->defLitText+=yytext;
                                        }
	YY_BREAK
case 230:
YY_RULE_SETUP
#line 1734 "/home/vsc/github/doxygen/src/pre.l"
{ outputString(yyscanner,substitute(yytext,"##","  "));
                                          yyextra->defText += "##";
                                          yyextra->defLitText+=yytext;
                                        }
	YY_BREAK
case 231:
YY_RULE_SETUP
#line 1738 "/home/vsc/github/doxygen/src/pre.l"
{ outputString(yyscanner,substitute(yytext,"@@","  "));
                                          yyextra->defText += "@@";
                                          yyextra->defLitText+=yytext;
                                        }
	YY_BREAK
case 232:
YY_RULE_SETUP
#line 1742 "/home/vsc/github/doxygen/src/pre.l"
{
                                          outputChar(yyscanner,' ');
                                          yyextra->defText += *yytext;
                                          yyextra->defLitText+=yytext;
                                          if (!yyextra->insideComment)
                                          {
                                            BEGIN(SkipDoubleQuote);
                                          }
                                        }
	YY_BREAK
case 233:
YY_RULE_SETUP
#line 1751 "/home/vsc/github/doxygen/src/pre.l"
{
                                          outputChar(yyscanner,' ');
                                          yyextra->defText += *yytext;
                                          yyextra->defLitText+=yytext;
                                          if (!yyextra->insideComment)
                                          {
                                            BEGIN(SkipSingleQuote);
                                          }
                                        }
	YY_BREAK
case 234:
YY_RULE_SETUP
#line 1760 "/home/vsc/github/doxygen/src/pre.l"
{ outputSpaces(yyscanner,yytext);
                                          yyextra->defText += yytext;
                                          yyextra->defLitText+=yytext;
                                        }
	YY_BREAK
case 235:
YY_RULE_SETUP
#line 1764 "/home/vsc/github/doxygen/src/pre.l"
{ outputSpaces(yyscanner,yytext);
                                          yyextra->defText += yytext;
                                          yyextra->defLitText+=yytext;
                                        }
	YY_BREAK
case 236:
YY_RULE_SETUP
#line 1768 "/home/vsc/github/doxygen/src/pre.l"
{
                                          outputChar(yyscanner,' ');
                                          yyextra->defText += *yytext;
                                          yyextra->defLitText+=yytext;
                                          BEGIN(DefineText);
                                        }
	YY_BREAK
case 237:
YY_RULE_SETUP
#line 1774 "/home/vsc/github/doxygen/src/pre.l"
{
                                          outputSpaces(yyscanner,yytext);
                                          yyextra->defText += yytext;
                                          yyextra->defLitText+=yytext;
                                        }
	YY_BREAK
case 238:
YY_RULE_SETUP
#line 1779 "/home/vsc/github/doxygen/src/pre.l"
{
                                          outputChar(yyscanner,' ');
                                          yyextra->defText += *yytext;
                                          yyextra->defLitText+=yytext;
                                          BEGIN(DefineText);
                                        }
	YY_BREAK
case 239:
YY_RULE_SETUP
#line 1785 "/home/vsc/github/doxygen/src/pre.l"
{ outputSpace(yyscanner,yytext[0]);
                                          yyextra->defText    += *yytext;
                                          yyextra->defLitText += *yytext;
                                        }
	YY_BREAK
case 240:
YY_RULE_SETUP
#line 1789 "/home/vsc/github/doxygen/src/pre.l"
{ outputSpace(yyscanner,yytext[0]);
                                          yyextra->defText    += *yytext;
                                          yyextra->defLitText += *yytext;
                                        }
	YY_BREAK
case YY_STATE_EOF(INITIAL):
case YY_STATE_EOF(Start):
case YY_STATE_EOF(Command):
case YY_STATE_EOF(SkipCommand):
case YY_STATE_EOF(SkipLine):
case YY_STATE_EOF(SkipString):
case YY_STATE_EOF(CopyLine):
case YY_STATE_EOF(LexCopyLine):
case YY_STATE_EOF(CopyString):
case YY_STATE_EOF(CopyStringCs):
case YY_STATE_EOF(CopyStringFtn):
case YY_STATE_EOF(CopyStringFtnDouble):
case YY_STATE_EOF(CopyRawString):
case YY_STATE_EOF(Include):
case YY_STATE_EOF(IncludeID):
case YY_STATE_EOF(EndImport):
case YY_STATE_EOF(DefName):
case YY_STATE_EOF(DefineArg):
case YY_STATE_EOF(DefineText):
case YY_STATE_EOF(SkipCPPBlock):
case YY_STATE_EOF(SkipCComment):
case YY_STATE_EOF(ArgCopyCComment):
case YY_STATE_EOF(CopyCComment):
case YY_STATE_EOF(SkipVerbatim):
case YY_STATE_EOF(SkipCondVerbatim):
case YY_STATE_EOF(SkipCPPComment):
case YY_STATE_EOF(JavaDocVerbatimCode):
case YY_STATE_EOF(RemoveCComment):
case YY_STATE_EOF(RemoveCPPComment):
case YY_STATE_EOF(Guard):
case YY_STATE_EOF(DefinedExpr1):
case YY_STATE_EOF(DefinedExpr2):
case YY_STATE_EOF(SkipDoubleQuote):
case YY_STATE_EOF(SkipSingleQuote):
case YY_STATE_EOF(UndefName):
case YY_STATE_EOF(IgnoreLine):
case YY_STATE_EOF(FindDefineArgs):
case YY_STATE_EOF(ReadString):
case YY_STATE_EOF(CondLineC):
case YY_STATE_EOF(CondLineCpp):
case YY_STATE_EOF(SkipCond):
case YY_STATE_EOF(IDLquote):
#line 1793 "/home/vsc/github/doxygen/src/pre.l"
{
                                          TRACE("End of include file");
                                          //printf("Include stack depth=%d\n",yyextra->includeStack.size());
                                          if (yyextra->includeStack.empty())
                                          {
                                            TRACE("Terminating scanner");
                                            yyterminate();
                                          }
                                          else
                                          {
                                            QCString toFileName = yyextra->fileName;
                                            const std::unique_ptr<FileState> &fs=yyextra->includeStack.back();
                                            //fileDefineCache->merge(yyextra->fileName,fs->fileName);
                                            YY_BUFFER_STATE oldBuf = YY_CURRENT_BUFFER;
                                            yy_switch_to_buffer( fs->bufState, yyscanner );
                                            yy_delete_buffer( oldBuf, yyscanner );
                                            yyextra->yyLineNr    = fs->lineNr;
                                            //preYYin = fs->oldYYin;
                                            yyextra->inputBuf    = fs->oldFileBuf;
                                            yyextra->inputBufPos = fs->oldFileBufPos;
                                            yyextra->curlyCount  = fs->curlyCount;
                                            setFileName(yyscanner,fs->fileName);
                                            TRACE("switching to {}",yyextra->fileName);

                                            // Deal with file changes due to
                                            // #include's within { .. } blocks
                                            QCString lineStr(15+yyextra->fileName.length());
                                            lineStr.sprintf("# %d \"%s\" 2",yyextra->yyLineNr,qPrint(yyextra->fileName));
                                            outputString(yyscanner,lineStr);

                                            yyextra->includeStack.pop_back();

                                            {
                                              std::lock_guard<std::mutex> lock(g_globalDefineMutex);
                                              // to avoid deadlocks we allow multiple threads to process the same header file.
                                              // The first one to finish will store the results globally. After that the
                                              // next time the same file is encountered, the stored data is used and the file
                                              // is not processed again.
                                              if (!g_defineManager.alreadyProcessed(toFileName.str()))
                                              {
                                                // now that the file is completely processed, prevent it from processing it again
                                                g_defineManager.addInclude(yyextra->fileName.str(),toFileName.str());
                                                g_defineManager.store(toFileName.str(),yyextra->localDefines);
                                              }
                                              else
                                              {
                                                if (Debug::isFlagSet(Debug::Preprocessor))
                                                {
                                                  Debug::print(Debug::Preprocessor,0,"#include %s: was already processed by another thread! not storing data...\n",qPrint(toFileName));
                                                }
                                              }
                                            }
                                            // move the local macros definitions for in this file to the translation unit context
                                            for (const auto &kv : yyextra->localDefines)
                                            {
                                              auto pair = yyextra->contextDefines.insert(kv);
                                              if (!pair.second) // define already in context -> replace with local version
                                              {
                                                yyextra->contextDefines.erase(pair.first);
                                                yyextra->contextDefines.insert(kv);
                                              }
                                            }
                                            yyextra->localDefines.clear();
                                          }
                                        }
	YY_BREAK
case 241:
*yy_cp = yyg->yy_hold_char; /* undo effects of setting up yytext */
yyg->yy_c_buf_p = yy_cp = yy_bp + 2;
YY_DO_BEFORE_ACTION; /* set up yytext again */
#line 1859 "/home/vsc/github/doxygen/src/pre.l"
case 242:
YY_RULE_SETUP
#line 1859 "/home/vsc/github/doxygen/src/pre.l"
{
                                          if (YY_START==SkipVerbatim || YY_START == SkipCondVerbatim || YY_START==SkipCond || YY_START==IDLquote)
                                          {
                                            REJECT;
                                          }
                                          else
                                          {
                                            outputArray(yyscanner,yytext,yyleng);
                                            yyextra->lastCContext=YY_START;
                                            yyextra->commentCount=1;
                                            if (yyleng==3)
                                            {
                                              yyextra->isSpecialComment = true;
                                              yyextra->lastGuardName.resize(0); // reset guard in case the #define is documented!
                                            }
                                            else
                                            {
                                              yyextra->isSpecialComment = false;
                                            }
                                            BEGIN(SkipCComment);
                                          }
                                        }
	YY_BREAK
case 243:
YY_RULE_SETUP
#line 1881 "/home/vsc/github/doxygen/src/pre.l"
{
                                          if (YY_START==SkipVerbatim || YY_START == SkipCondVerbatim || YY_START==SkipCond || getLanguageFromFileName(yyextra->fileName)==SrcLangExt_Fortran || YY_START==IDLquote)
                                          {
                                            REJECT;
                                          }
                                          else
                                          {
                                            outputArray(yyscanner,yytext,yyleng);
                                            yyextra->lastCPPContext=YY_START;
                                            if (yyleng==3)
                                            {
                                              yyextra->isSpecialComment = true;
                                              yyextra->lastGuardName.resize(0); // reset guard in case the #define is documented!
                                            }
                                            else
                                            {
                                              yyextra->isSpecialComment = false;
                                            }
                                            BEGIN(SkipCPPComment);
                                          }
                                        }
	YY_BREAK
case 244:
/* rule 244 can match eol */
YY_RULE_SETUP
#line 1902 "/home/vsc/github/doxygen/src/pre.l"
{
                                          outputChar(yyscanner,'\n');
                                          yyextra->yyLineNr++;
                                        }
	YY_BREAK
case 245:
YY_RULE_SETUP
#line 1906 "/home/vsc/github/doxygen/src/pre.l"
{
                                          yyextra->expectGuard = FALSE;
                                          outputChar(yyscanner,*yytext);
                                        }
	YY_BREAK
case 246:
YY_RULE_SETUP
#line 1911 "/home/vsc/github/doxygen/src/pre.l"
ECHO;
	YY_BREAK
#line 6702 "/home/vsc/github/doxygen/Debug/generated_src/pre_intermediate.cpp"

	case YY_END_OF_BUFFER:
		{
		/* Amount of text matched not including the EOB char. */
		int yy_amount_of_matched_text = (int) (yy_cp - yyg->yytext_ptr) - 1;

		/* Undo the effects of YY_DO_BEFORE_ACTION. */
		*yy_cp = yyg->yy_hold_char;
		YY_RESTORE_YY_MORE_OFFSET

		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
			{
			/* We're scanning a new file or input source.  It's
			 * possible that this happened because the user
			 * just pointed yyin at a new source and called
			 * yylex().  If so, then we have to assure
			 * consistency between YY_CURRENT_BUFFER and our
			 * globals.  Here is the right place to do so, because
			 * this is the first action (other than possibly a
			 * back-up) that will match for the new input source.
			 */
			yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
			YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
			}

		/* Note that here we test for yy_c_buf_p "<=" to the position
		 * of the first EOB in the buffer, since yy_c_buf_p will
		 * already have been incremented past the NUL character
		 * (since all states make transitions on EOB to the
		 * end-of-buffer state).  Contrast this with the test
		 * in input().
		 */
		if ( yyg->yy_c_buf_p <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )
			{ /* This was really a NUL. */
			yy_state_type yy_next_state;

			yyg->yy_c_buf_p = yyg->yytext_ptr + yy_amount_of_matched_text;

			yy_current_state = yy_get_previous_state( yyscanner );

			/* Okay, we're now positioned to make the NUL
			 * transition.  We couldn't have
			 * yy_get_previous_state() go ahead and do it
			 * for us because it doesn't know how to deal
			 * with the possibility of jamming (and we don't
			 * want to build jamming into it because then it
			 * will run more slowly).
			 */

			yy_next_state = yy_try_NUL_trans( yy_current_state , yyscanner);

			yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;

			if ( yy_next_state )
				{
				/* Consume the NUL. */
				yy_cp = ++yyg->yy_c_buf_p;
				yy_current_state = yy_next_state;
				goto yy_match;
				}

			else
				{
				yy_cp = yyg->yy_c_buf_p;
				goto yy_find_action;
				}
			}

		else switch ( yy_get_next_buffer( yyscanner ) )
			{
			case EOB_ACT_END_OF_FILE:
				{
				yyg->yy_did_buffer_switch_on_eof = 0;

				if ( yywrap( yyscanner ) )
					{
					/* Note: because we've taken care in
					 * yy_get_next_buffer() to have set up
					 * yytext, we can now set up
					 * yy_c_buf_p so that if some total
					 * hoser (like flex itself) wants to
					 * call the scanner after we return the
					 * YY_NULL, it'll still work - another
					 * YY_NULL will get returned.
					 */
					yyg->yy_c_buf_p = yyg->yytext_ptr + YY_MORE_ADJ;

					yy_act = YY_STATE_EOF(YY_START);
					goto do_action;
					}

				else
					{
					if ( ! yyg->yy_did_buffer_switch_on_eof )
						YY_NEW_FILE;
					}
				break;
				}

			case EOB_ACT_CONTINUE_SCAN:
				yyg->yy_c_buf_p =
					yyg->yytext_ptr + yy_amount_of_matched_text;

				yy_current_state = yy_get_previous_state( yyscanner );

				yy_cp = yyg->yy_c_buf_p;
				yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;
				goto yy_match;

			case EOB_ACT_LAST_MATCH:
				yyg->yy_c_buf_p =
				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars];

				yy_current_state = yy_get_previous_state( yyscanner );

				yy_cp = yyg->yy_c_buf_p;
				yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;
				goto yy_find_action;
			}
		break;
		}

	default:
		YY_FATAL_ERROR(
			"fatal flex scanner internal error--no action found" );
	} /* end of action switch */
		} /* end of scanning one token */
	} /* end of user's declarations */
} /* end of yylex */

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *	EOB_ACT_LAST_MATCH -
 *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *	EOB_ACT_END_OF_FILE - end of file
 */
static int yy_get_next_buffer (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
	char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
	char *source = yyg->yytext_ptr;
	int number_to_move, i;
	int ret_val;

	if ( yyg->yy_c_buf_p > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] )
		YY_FATAL_ERROR(
		"fatal flex scanner internal error--end of buffer missed" );

	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
		{ /* Don't try to fill the buffer, so this is an EOF. */
		if ( yyg->yy_c_buf_p - yyg->yytext_ptr - YY_MORE_ADJ == 1 )
			{
			/* We matched a single character, the EOB, so
			 * treat this as a final EOF.
			 */
			return EOB_ACT_END_OF_FILE;
			}

		else
			{
			/* We matched some text prior to the EOB, first
			 * process it.
			 */
			return EOB_ACT_LAST_MATCH;
			}
		}

	/* Try to read more data. */

	/* First move last chars to start of buffer. */
	number_to_move = (int) (yyg->yy_c_buf_p - yyg->yytext_ptr - 1);

	for ( i = 0; i < number_to_move; ++i )
		*(dest++) = *(source++);

	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
		/* don't do the read, it's not guaranteed to return an EOF,
		 * just force an EOF
		 */
		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars = 0;

	else
		{
			int num_to_read =
			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;

		while ( num_to_read <= 0 )
			{ /* Not enough room in the buffer - grow it. */

			YY_FATAL_ERROR(
"input buffer overflow, can't enlarge buffer because scanner uses REJECT" );

			}

		if ( num_to_read > YY_READ_BUF_SIZE )
			num_to_read = YY_READ_BUF_SIZE;

		/* Read in more data. */
		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
			yyg->yy_n_chars, num_to_read );

		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
		}

	if ( yyg->yy_n_chars == 0 )
		{
		if ( number_to_move == YY_MORE_ADJ )
			{
			ret_val = EOB_ACT_END_OF_FILE;
			yyrestart( yyin  , yyscanner);
			}

		else
			{
			ret_val = EOB_ACT_LAST_MATCH;
			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
				YY_BUFFER_EOF_PENDING;
			}
		}

	else
		ret_val = EOB_ACT_CONTINUE_SCAN;

	if ((yyg->yy_n_chars + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
		/* Extend the array by 50%, plus the number we really need. */
		int new_size = yyg->yy_n_chars + number_to_move + (yyg->yy_n_chars >> 1);
		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc(
			(void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf, (yy_size_t) new_size , yyscanner );
		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
		/* "- 2" to take care of EOB's */
		YY_CURRENT_BUFFER_LVALUE->yy_buf_size = (int) (new_size - 2);
	}

	yyg->yy_n_chars += number_to_move;
	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] = YY_END_OF_BUFFER_CHAR;
	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;

	yyg->yytext_ptr = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];

	return ret_val;
}

/* yy_get_previous_state - get the state just before the EOB char was reached */

    static yy_state_type yy_get_previous_state (yyscan_t yyscanner)
{
	yy_state_type yy_current_state;
	char *yy_cp;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

	yy_current_state = yyg->yy_start;
	yy_current_state += YY_AT_BOL();

	yyg->yy_state_ptr = yyg->yy_state_buf;
	*yyg->yy_state_ptr++ = yy_current_state;

	for ( yy_cp = yyg->yytext_ptr + YY_MORE_ADJ; yy_cp < yyg->yy_c_buf_p; ++yy_cp )
		{
		YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 66);
		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
			{
			yy_current_state = (int) yy_def[yy_current_state];
			if ( yy_current_state >= 1699 )
				yy_c = yy_meta[yy_c];
			}
		yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
		*yyg->yy_state_ptr++ = yy_current_state;
		}

	return yy_current_state;
}

/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *	next_state = yy_try_NUL_trans( current_state );
 */
    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state , yyscan_t yyscanner)
{
	int yy_is_jam;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner; /* This var may be unused depending upon options. */

	YY_CHAR yy_c = 66;
	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
		{
		yy_current_state = (int) yy_def[yy_current_state];
		if ( yy_current_state >= 1699 )
			yy_c = yy_meta[yy_c];
		}
	yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
	yy_is_jam = (yy_current_state == 1698);
	if ( ! yy_is_jam )
		*yyg->yy_state_ptr++ = yy_current_state;

	(void)yyg;
	return yy_is_jam ? 0 : yy_current_state;
}

#ifndef YY_NO_UNPUT

    static void yyunput (int c, char * yy_bp , yyscan_t yyscanner)
{
	char *yy_cp;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

    yy_cp = yyg->yy_c_buf_p;

	/* undo effects of setting up yytext */
	*yy_cp = yyg->yy_hold_char;

	if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
		{ /* need to shift things up to make room */
		/* +2 for EOB chars. */
		int number_to_move = yyg->yy_n_chars + 2;
		char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
					YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];
		char *source =
				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];

		while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
			*--dest = *--source;

		yy_cp += (int) (dest - source);
		yy_bp += (int) (dest - source);
		YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
			yyg->yy_n_chars = (int) YY_CURRENT_BUFFER_LVALUE->yy_buf_size;

		if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
			YY_FATAL_ERROR( "flex scanner push-back overflow" );
		}

	*--yy_cp = (char) c;

	yyg->yytext_ptr = yy_bp;
	yyg->yy_hold_char = *yy_cp;
	yyg->yy_c_buf_p = yy_cp;
}

#endif

#ifndef YY_NO_INPUT
#ifdef __cplusplus
    static int yyinput (yyscan_t yyscanner)
#else
    static int input  (yyscan_t yyscanner)
#endif

{
	int c;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

	*yyg->yy_c_buf_p = yyg->yy_hold_char;

	if ( *yyg->yy_c_buf_p == YY_END_OF_BUFFER_CHAR )
		{
		/* yy_c_buf_p now points to the character we want to return.
		 * If this occurs *before* the EOB characters, then it's a
		 * valid NUL; if not, then we've hit the end of the buffer.
		 */
		if ( yyg->yy_c_buf_p < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )
			/* This was really a NUL. */
			*yyg->yy_c_buf_p = '\0';

		else
			{ /* need more input */
			int offset = (int) (yyg->yy_c_buf_p - yyg->yytext_ptr);
			++yyg->yy_c_buf_p;

			switch ( yy_get_next_buffer( yyscanner ) )
				{
				case EOB_ACT_LAST_MATCH:
					/* This happens because yy_g_n_b()
					 * sees that we've accumulated a
					 * token and flags that we need to
					 * try matching the token before
					 * proceeding.  But for input(),
					 * there's no matching to consider.
					 * So convert the EOB_ACT_LAST_MATCH
					 * to EOB_ACT_END_OF_FILE.
					 */

					/* Reset buffer status. */
					yyrestart( yyin , yyscanner);

					/*FALLTHROUGH*/

				case EOB_ACT_END_OF_FILE:
					{
					if ( yywrap( yyscanner ) )
						return 0;

					if ( ! yyg->yy_did_buffer_switch_on_eof )
						YY_NEW_FILE;
#ifdef __cplusplus
					return yyinput(yyscanner);
#else
					return input(yyscanner);
#endif
					}

				case EOB_ACT_CONTINUE_SCAN:
					yyg->yy_c_buf_p = yyg->yytext_ptr + offset;
					break;
				}
			}
		}

	c = *(unsigned char *) yyg->yy_c_buf_p;	/* cast for 8-bit char's */
	*yyg->yy_c_buf_p = '\0';	/* preserve yytext */
	yyg->yy_hold_char = *++yyg->yy_c_buf_p;

	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = (c == '\n');

	return c;
}
#endif	/* ifndef YY_NO_INPUT */

/** Immediately switch to a different input stream.
 * @param input_file A readable stream.
 * @param yyscanner The scanner object.
 * @note This function does not reset the start condition to @c INITIAL .
 */
    void yyrestart  (FILE * input_file , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

	if ( ! YY_CURRENT_BUFFER ){
        yyensure_buffer_stack (yyscanner);
		YY_CURRENT_BUFFER_LVALUE =
            yy_create_buffer( yyin, YY_BUF_SIZE , yyscanner);
	}

	yy_init_buffer( YY_CURRENT_BUFFER, input_file , yyscanner);
	yy_load_buffer_state( yyscanner );
}

/** Switch to a different input buffer.
 * @param new_buffer The new input buffer.
 * @param yyscanner The scanner object.
 */
    void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

	/* TODO. We should be able to replace this entire function body
	 * with
	 *		yypop_buffer_state();
	 *		yypush_buffer_state(new_buffer);
     */
	yyensure_buffer_stack (yyscanner);
	if ( YY_CURRENT_BUFFER == new_buffer )
		return;

	if ( YY_CURRENT_BUFFER )
		{
		/* Flush out information for old buffer. */
		*yyg->yy_c_buf_p = yyg->yy_hold_char;
		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = yyg->yy_c_buf_p;
		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
		}

	YY_CURRENT_BUFFER_LVALUE = new_buffer;
	yy_load_buffer_state( yyscanner );

	/* We don't actually know whether we did this switch during
	 * EOF (yywrap()) processing, but the only time this flag
	 * is looked at is after yywrap() is called, so it's safe
	 * to go ahead and always set it.
	 */
	yyg->yy_did_buffer_switch_on_eof = 1;
}

static void yy_load_buffer_state  (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
	yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
	yyg->yytext_ptr = yyg->yy_c_buf_p = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
	yyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
	yyg->yy_hold_char = *yyg->yy_c_buf_p;
}

/** Allocate and initialize an input buffer state.
 * @param file A readable stream.
 * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
 * @param yyscanner The scanner object.
 * @return the allocated buffer state.
 */
    YY_BUFFER_STATE yy_create_buffer  (FILE * file, int  size , yyscan_t yyscanner)
{
	YY_BUFFER_STATE b;
    
	b = (YY_BUFFER_STATE) yyalloc( sizeof( struct yy_buffer_state ) , yyscanner );
	if ( ! b )
		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );

	b->yy_buf_size = size;

	/* yy_ch_buf has to be 2 characters longer than the size given because
	 * we need to put in 2 end-of-buffer characters.
	 */
	b->yy_ch_buf = (char *) yyalloc( (yy_size_t) (b->yy_buf_size + 2) , yyscanner );
	if ( ! b->yy_ch_buf )
		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );

	b->yy_is_our_buffer = 1;

	yy_init_buffer( b, file , yyscanner);

	return b;
}

/** Destroy the buffer.
 * @param b a buffer created with yy_create_buffer()
 * @param yyscanner The scanner object.
 */
    void yy_delete_buffer (YY_BUFFER_STATE  b , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

	if ( ! b )
		return;

	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;

	if ( b->yy_is_our_buffer )
		yyfree( (void *) b->yy_ch_buf , yyscanner );

	yyfree( (void *) b , yyscanner );
}

/* Initializes or reinitializes a buffer.
 * This function is sometimes called more than once on the same buffer,
 * such as during a yyrestart() or at EOF.
 */
    static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file , yyscan_t yyscanner)

{
	int oerrno = errno;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

	yy_flush_buffer( b , yyscanner);

	b->yy_input_file = file;
	b->yy_fill_buffer = 1;

    /* If b is the current buffer, then yy_init_buffer was _probably_
     * called from yyrestart() or through yy_get_next_buffer.
     * In that case, we don't want to reset the lineno or column.
     */
    if (b != YY_CURRENT_BUFFER){
        b->yy_bs_lineno = 1;
        b->yy_bs_column = 0;
    }

        b->yy_is_interactive = 0;
    
	errno = oerrno;
}

/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
 * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
 * @param yyscanner The scanner object.
 */
    void yy_flush_buffer (YY_BUFFER_STATE  b , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
	if ( ! b )
		return;

	b->yy_n_chars = 0;

	/* We always need two end-of-buffer characters.  The first causes
	 * a transition to the end-of-buffer state.  The second causes
	 * a jam in that state.
	 */
	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;

	b->yy_buf_pos = &b->yy_ch_buf[0];

	b->yy_at_bol = 1;
	b->yy_buffer_status = YY_BUFFER_NEW;

	if ( b == YY_CURRENT_BUFFER )
		yy_load_buffer_state( yyscanner );
}

/** Pushes the new state onto the stack. The new state becomes
 *  the current state. This function will allocate the stack
 *  if necessary.
 *  @param new_buffer The new state.
 *  @param yyscanner The scanner object.
 */
void yypush_buffer_state (YY_BUFFER_STATE new_buffer , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
	if (new_buffer == NULL)
		return;

	yyensure_buffer_stack(yyscanner);

	/* This block is copied from yy_switch_to_buffer. */
	if ( YY_CURRENT_BUFFER )
		{
		/* Flush out information for old buffer. */
		*yyg->yy_c_buf_p = yyg->yy_hold_char;
		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = yyg->yy_c_buf_p;
		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
		}

	/* Only push if top exists. Otherwise, replace top. */
	if (YY_CURRENT_BUFFER)
		yyg->yy_buffer_stack_top++;
	YY_CURRENT_BUFFER_LVALUE = new_buffer;

	/* copied from yy_switch_to_buffer. */
	yy_load_buffer_state( yyscanner );
	yyg->yy_did_buffer_switch_on_eof = 1;
}

/** Removes and deletes the top of the stack, if present.
 *  The next element becomes the new top.
 *  @param yyscanner The scanner object.
 */
void yypop_buffer_state (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
	if (!YY_CURRENT_BUFFER)
		return;

	yy_delete_buffer(YY_CURRENT_BUFFER , yyscanner);
	YY_CURRENT_BUFFER_LVALUE = NULL;
	if (yyg->yy_buffer_stack_top > 0)
		--yyg->yy_buffer_stack_top;

	if (YY_CURRENT_BUFFER) {
		yy_load_buffer_state( yyscanner );
		yyg->yy_did_buffer_switch_on_eof = 1;
	}
}

/* Allocates the stack if it does not exist.
 *  Guarantees space for at least one push.
 */
static void yyensure_buffer_stack (yyscan_t yyscanner)
{
	yy_size_t num_to_alloc;
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

	if (!yyg->yy_buffer_stack) {

		/* First allocation is just for 2 elements, since we don't know if this
		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
		 * immediate realloc on the next call.
         */
      num_to_alloc = 1; /* After all that talk, this was set to 1 anyways... */
		yyg->yy_buffer_stack = (struct yy_buffer_state**)yyalloc
								(num_to_alloc * sizeof(struct yy_buffer_state*)
								, yyscanner);
		if ( ! yyg->yy_buffer_stack )
			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );

		memset(yyg->yy_buffer_stack, 0, num_to_alloc * sizeof(struct yy_buffer_state*));

		yyg->yy_buffer_stack_max = num_to_alloc;
		yyg->yy_buffer_stack_top = 0;
		return;
	}

	if (yyg->yy_buffer_stack_top >= (yyg->yy_buffer_stack_max) - 1){

		/* Increase the buffer to prepare for a possible push. */
		yy_size_t grow_size = 8 /* arbitrary grow size */;

		num_to_alloc = yyg->yy_buffer_stack_max + grow_size;
		yyg->yy_buffer_stack = (struct yy_buffer_state**)yyrealloc
								(yyg->yy_buffer_stack,
								num_to_alloc * sizeof(struct yy_buffer_state*)
								, yyscanner);
		if ( ! yyg->yy_buffer_stack )
			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );

		/* zero only the new slots.*/
		memset(yyg->yy_buffer_stack + yyg->yy_buffer_stack_max, 0, grow_size * sizeof(struct yy_buffer_state*));
		yyg->yy_buffer_stack_max = num_to_alloc;
	}
}

/** Setup the input buffer state to scan directly from a user-specified character buffer.
 * @param base the character buffer
 * @param size the size in bytes of the character buffer
 * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size , yyscan_t yyscanner)
{
	YY_BUFFER_STATE b;
    
	if ( size < 2 ||
	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
	     base[size-1] != YY_END_OF_BUFFER_CHAR )
		/* They forgot to leave room for the EOB's. */
		return NULL;

	b = (YY_BUFFER_STATE) yyalloc( sizeof( struct yy_buffer_state ) , yyscanner );
	if ( ! b )
		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );

	b->yy_buf_size = (int) (size - 2);	/* "- 2" to take care of EOB's */
	b->yy_buf_pos = b->yy_ch_buf = base;
	b->yy_is_our_buffer = 0;
	b->yy_input_file = NULL;
	b->yy_n_chars = b->yy_buf_size;
	b->yy_is_interactive = 0;
	b->yy_at_bol = 1;
	b->yy_fill_buffer = 0;
	b->yy_buffer_status = YY_BUFFER_NEW;

	yy_switch_to_buffer( b , yyscanner );

	return b;
}

/** Setup the input buffer state to scan a string. The next call to yylex() will
 * scan from a @e copy of @a str.
 * @param yystr a NUL-terminated string to scan
 * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 * @note If you want to scan bytes that may contain NUL values, then use
 *       yy_scan_bytes() instead.
 */
YY_BUFFER_STATE yy_scan_string (const char * yystr , yyscan_t yyscanner)
{
    
	return yy_scan_bytes( yystr, (int) strlen(yystr) , yyscanner);
}

/** Setup the input buffer state to scan the given bytes. The next call to yylex() will
 * scan from a @e copy of @a bytes.
 * @param yybytes the byte buffer to scan
 * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
 * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE yy_scan_bytes  (const char * yybytes, int  _yybytes_len , yyscan_t yyscanner)
{
	YY_BUFFER_STATE b;
	char *buf;
	yy_size_t n;
	int i;
    
	/* Get memory for full buffer, including space for trailing EOB's. */
	n = (yy_size_t) (_yybytes_len + 2);
	buf = (char *) yyalloc( n , yyscanner );
	if ( ! buf )
		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );

	for ( i = 0; i < _yybytes_len; ++i )
		buf[i] = yybytes[i];

	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;

	b = yy_scan_buffer( buf, n , yyscanner);
	if ( ! b )
		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );

	/* It's okay to grow etc. this buffer, and we should throw it
	 * away when we're done.
	 */
	b->yy_is_our_buffer = 1;

	return b;
}

#ifndef YY_EXIT_FAILURE
#define YY_EXIT_FAILURE 2
#endif

static void yynoreturn yy_fatal_error (const char* msg , yyscan_t yyscanner)
{
	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
	(void)yyg;
	fprintf( stderr, "%s\n", msg );
	exit( YY_EXIT_FAILURE );
}

/* Redefine yyless() so it works in section 3 code. */

#undef yyless
#define yyless(n) \
	do \
		{ \
		/* Undo effects of setting up yytext. */ \
        int yyless_macro_arg = (n); \
        YY_LESS_LINENO(yyless_macro_arg);\
		yytext[yyleng] = yyg->yy_hold_char; \
		yyg->yy_c_buf_p = yytext + yyless_macro_arg; \
		yyg->yy_hold_char = *yyg->yy_c_buf_p; \
		*yyg->yy_c_buf_p = '\0'; \
		yyleng = yyless_macro_arg; \
		} \
	while ( 0 )

/* Accessor  methods (get/set functions) to struct members. */

/** Get the user-defined data for this scanner.
 * @param yyscanner The scanner object.
 */
YY_EXTRA_TYPE yyget_extra  (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    return yyextra;
}

/** Get the current line number.
 * @param yyscanner The scanner object.
 */
int yyget_lineno  (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        if (! YY_CURRENT_BUFFER)
            return 0;
    
    return yylineno;
}

/** Get the current column number.
 * @param yyscanner The scanner object.
 */
int yyget_column  (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        if (! YY_CURRENT_BUFFER)
            return 0;
    
    return yycolumn;
}

/** Get the input stream.
 * @param yyscanner The scanner object.
 */
FILE *yyget_in  (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    return yyin;
}

/** Get the output stream.
 * @param yyscanner The scanner object.
 */
FILE *yyget_out  (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    return yyout;
}

/** Get the length of the current token.
 * @param yyscanner The scanner object.
 */
int yyget_leng  (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    return yyleng;
}

/** Get the current token.
 * @param yyscanner The scanner object.
 */

char *yyget_text  (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    return yytext;
}

/** Set the user-defined data. This data is never touched by the scanner.
 * @param user_defined The data to be associated with this scanner.
 * @param yyscanner The scanner object.
 */
void yyset_extra (YY_EXTRA_TYPE  user_defined , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyextra = user_defined ;
}

/** Set the current line number.
 * @param _line_number line number
 * @param yyscanner The scanner object.
 */
void yyset_lineno (int  _line_number , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        /* lineno is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           YY_FATAL_ERROR( "yyset_lineno called with no buffer" );
    
    yylineno = _line_number;
}

/** Set the current column.
 * @param _column_no column number
 * @param yyscanner The scanner object.
 */
void yyset_column (int  _column_no , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

        /* column is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           YY_FATAL_ERROR( "yyset_column called with no buffer" );
    
    yycolumn = _column_no;
}

/** Set the input stream. This does not discard the current
 * input buffer.
 * @param _in_str A readable stream.
 * @param yyscanner The scanner object.
 * @see yy_switch_to_buffer
 */
void yyset_in (FILE *  _in_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyin = _in_str ;
}

void yyset_out (FILE *  _out_str , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yyout = _out_str ;
}

int yyget_debug  (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    return yy_flex_debug;
}

void yyset_debug (int  _bdebug , yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    yy_flex_debug = _bdebug ;
}

/* Accessor methods for yylval and yylloc */

/* User-visible API */

/* yylex_init is special because it creates the scanner itself, so it is
 * the ONLY reentrant function that doesn't take the scanner as the last argument.
 * That's why we explicitly handle the declaration, instead of using our macros.
 */
int yylex_init(yyscan_t* ptr_yy_globals)
{
    if (ptr_yy_globals == NULL){
        errno = EINVAL;
        return 1;
    }

    *ptr_yy_globals = (yyscan_t) yyalloc ( sizeof( struct yyguts_t ), NULL );

    if (*ptr_yy_globals == NULL){
        errno = ENOMEM;
        return 1;
    }

    /* By setting to 0xAA, we expose bugs in yy_init_globals. Leave at 0x00 for releases. */
    memset(*ptr_yy_globals,0x00,sizeof(struct yyguts_t));

    return yy_init_globals ( *ptr_yy_globals );
}

/* yylex_init_extra has the same functionality as yylex_init, but follows the
 * convention of taking the scanner as the last argument. Note however, that
 * this is a *pointer* to a scanner, as it will be allocated by this call (and
 * is the reason, too, why this function also must handle its own declaration).
 * The user defined value in the first argument will be available to yyalloc in
 * the yyextra field.
 */
int yylex_init_extra( YY_EXTRA_TYPE yy_user_defined, yyscan_t* ptr_yy_globals )
{
    struct yyguts_t dummy_yyguts;

    yyset_extra (yy_user_defined, &dummy_yyguts);

    if (ptr_yy_globals == NULL){
        errno = EINVAL;
        return 1;
    }

    *ptr_yy_globals = (yyscan_t) yyalloc ( sizeof( struct yyguts_t ), &dummy_yyguts );

    if (*ptr_yy_globals == NULL){
        errno = ENOMEM;
        return 1;
    }

    /* By setting to 0xAA, we expose bugs in
    yy_init_globals. Leave at 0x00 for releases. */
    memset(*ptr_yy_globals,0x00,sizeof(struct yyguts_t));

    yyset_extra (yy_user_defined, *ptr_yy_globals);

    return yy_init_globals ( *ptr_yy_globals );
}

static int yy_init_globals (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    /* Initialization is the same as for the non-reentrant scanner.
     * This function is called from yylex_destroy(), so don't allocate here.
     */

    yyg->yy_buffer_stack = NULL;
    yyg->yy_buffer_stack_top = 0;
    yyg->yy_buffer_stack_max = 0;
    yyg->yy_c_buf_p = NULL;
    yyg->yy_init = 0;
    yyg->yy_start = 0;

    yyg->yy_start_stack_ptr = 0;
    yyg->yy_start_stack_depth = 0;
    yyg->yy_start_stack =  NULL;

    yyg->yy_state_buf = 0;
    yyg->yy_state_ptr = 0;
    yyg->yy_full_match = 0;
    yyg->yy_lp = 0;

/* Defined in main.c */
#ifdef YY_STDINIT
    yyin = stdin;
    yyout = stdout;
#else
    yyin = NULL;
    yyout = NULL;
#endif

    /* For future reference: Set errno on error, since we are called by
     * yylex_init()
     */
    return 0;
}

/* yylex_destroy is for both reentrant and non-reentrant scanners. */
int yylex_destroy  (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;

    /* Pop the buffer stack, destroying each element. */
	while(YY_CURRENT_BUFFER){
		yy_delete_buffer( YY_CURRENT_BUFFER , yyscanner );
		YY_CURRENT_BUFFER_LVALUE = NULL;
		yypop_buffer_state(yyscanner);
	}

	/* Destroy the stack itself. */
	yyfree(yyg->yy_buffer_stack , yyscanner);
	yyg->yy_buffer_stack = NULL;

    /* Destroy the start condition stack. */
        yyfree( yyg->yy_start_stack , yyscanner );
        yyg->yy_start_stack = NULL;

    yyfree ( yyg->yy_state_buf , yyscanner);
    yyg->yy_state_buf  = NULL;

    /* Reset the globals. This is important in a non-reentrant scanner so the next time
     * yylex() is called, initialization will occur. */
    yy_init_globals( yyscanner);

    /* Destroy the main struct (reentrant only). */
    yyfree ( yyscanner , yyscanner );
    yyscanner = NULL;
    return 0;
}

/*
 * Internal utility routines.
 */

#ifndef yytext_ptr
static void yy_flex_strncpy (char* s1, const char * s2, int n , yyscan_t yyscanner)
{
	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
	(void)yyg;

	int i;
	for ( i = 0; i < n; ++i )
		s1[i] = s2[i];
}
#endif

#ifdef YY_NEED_STRLEN
static int yy_flex_strlen (const char * s , yyscan_t yyscanner)
{
	int n;
	for ( n = 0; s[n]; ++n )
		;

	return n;
}
#endif

void *yyalloc (yy_size_t  size , yyscan_t yyscanner)
{
	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
	(void)yyg;
	return malloc(size);
}

void *yyrealloc  (void * ptr, yy_size_t  size , yyscan_t yyscanner)
{
	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
	(void)yyg;

	/* The cast to (char *) in the following accommodates both
	 * implementations that use char* generic pointers, and those
	 * that use void* generic pointers.  It works with the latter
	 * because both ANSI C and C++ allow castless assignment from
	 * any pointer type to void*, and deal with argument conversions
	 * as though doing an assignment.
	 */
	return realloc(ptr, size);
}

void yyfree (void * ptr , yyscan_t yyscanner)
{
	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
	(void)yyg;
	free( (char *) ptr );	/* see yyrealloc() for (char *) cast */
}

#define YYTABLES_NAME "yytables"

#line 1911 "/home/vsc/github/doxygen/src/pre.l"


/////////////////////////////////////////////////////////////////////////////////////

static int yyread(yyscan_t yyscanner,char *buf,int max_size)
{
  YY_EXTRA_TYPE state = preYYget_extra(yyscanner);
  int bytesInBuf = static_cast<int>(state->inputBuf->curPos())-state->inputBufPos;
  int bytesToCopy = std::min(max_size,bytesInBuf);
  memcpy(buf,state->inputBuf->data()+state->inputBufPos,bytesToCopy);
  state->inputBufPos+=bytesToCopy;
  return bytesToCopy;
}

static void setFileName(yyscan_t yyscanner,const QCString &name)
{
  YY_EXTRA_TYPE state = preYYget_extra(yyscanner);
  bool ambig;
  FileInfo fi(name.str());
  state->fileName=fi.absFilePath();
  state->yyFileDef=findFileDef(Doxygen::inputNameLinkedMap,state->fileName,ambig);
  if (state->yyFileDef==0) // if this is not an input file check if it is an
                      // include file
  {
    state->yyFileDef=findFileDef(Doxygen::includeNameLinkedMap,state->fileName,ambig);
  }
  //printf("setFileName(%s) state->fileName=%s state->yyFileDef=%p\n",
  //    name,qPrint(state->fileName),state->yyFileDef);
  if (state->yyFileDef && state->yyFileDef->isReference()) state->yyFileDef=0;
  state->insideIDL = getLanguageFromFileName(state->fileName)==SrcLangExt_IDL;
  state->insideCS = getLanguageFromFileName(state->fileName)==SrcLangExt_CSharp;
  state->insideFtn = getLanguageFromFileName(state->fileName)==SrcLangExt_Fortran;
  int isSource = guessSection(state->fileName);
  state->isSource = isSource==Entry::HEADER_SEC || isSource==Entry::SOURCE_SEC;
}

static void incrLevel(yyscan_t yyscanner)
{
  YY_EXTRA_TYPE state = preYYget_extra(yyscanner);
  state->levelGuard.push(false);
  //printf("%s line %d: incrLevel %d\n",qPrint(yyextra->fileName),yyextra->yyLineNr,yyextra->levelGuard.size());
}

static void decrLevel(yyscan_t yyscanner)
{
  YY_EXTRA_TYPE state = preYYget_extra(yyscanner);
  //printf("%s line %d: decrLevel %d\n",qPrint(state->fileName),state->yyLineNr,state->levelGuard.size());
  if (!state->levelGuard.empty())
  {
    state->levelGuard.pop();
  }
  else
  {
    warn(state->fileName,state->yyLineNr,"More #endif's than #if's found.");
  }
}

static bool otherCaseDone(yyscan_t yyscanner)
{
  YY_EXTRA_TYPE state = preYYget_extra(yyscanner);
  if (state->levelGuard.empty())
  {
    warn(state->fileName,state->yyLineNr,"Found an #else without a preceding #if.");
    return TRUE;
  }
  else
  {
    return state->levelGuard.top();
  }
}

static void setCaseDone(yyscan_t yyscanner,bool value)
{
  YY_EXTRA_TYPE state = preYYget_extra(yyscanner);
  state->levelGuard.top()=value;
}


static std::unique_ptr<FileState> checkAndOpenFile(yyscan_t yyscanner,const QCString &fileName,bool &alreadyProcessed)
{
  YY_EXTRA_TYPE state = preYYget_extra(yyscanner);
  alreadyProcessed = FALSE;
  std::unique_ptr<FileState> fs;
  //printf("checkAndOpenFile(%s)\n",qPrint(fileName));
  FileInfo fi(fileName.str());
  if (fi.exists() && fi.isFile())
  {
    const StringVector &exclPatterns = Config_getList(EXCLUDE_PATTERNS);
    if (patternMatch(fi,exclPatterns)) return 0;

    QCString absName = fi.absFilePath();

    // global guard
    if (state->curlyCount==0) // not #include inside { ... }
    {
      std::lock_guard<std::mutex> lock(g_globalDefineMutex);
      if (g_defineManager.alreadyProcessed(absName.str()))
      {
        alreadyProcessed = TRUE;
        //printf("  already included 1\n");
        return 0; // already done
      }
    }
    // check include stack for absName

    alreadyProcessed = std::any_of(
      state->includeStack.begin(),
      state->includeStack.end(),
      [absName](const std::unique_ptr<FileState> &lfs)
        { return lfs->fileName==absName; }
    );

    if (alreadyProcessed)
    {
      //printf("  already included 2\n");
      return 0;
    }
    //printf("#include %s\n",qPrint(absName));

    fs = std::make_unique<FileState>(static_cast<uint32_t>(fi.size())+4096);
    if (!readInputFile(absName,fs->fileBuf))
    { // error
      //printf("  error reading\n");
      fs.reset();
    }
    else
    {
      fs->oldFileBuf    = state->inputBuf;
      fs->oldFileBufPos = state->inputBufPos;
    }
  }
  return fs;
}

static std::unique_ptr<FileState> findFile(yyscan_t yyscanner, const QCString &fileName,bool localInclude,bool &alreadyProcessed)
{
  YY_EXTRA_TYPE state = preYYget_extra(yyscanner);
  //printf("** findFile(%s,%d) state->fileName=%s\n",qPrint(fileName),localInclude,qPrint(state->fileName));
  if (Portable::isAbsolutePath(fileName))
  {
    auto fs = checkAndOpenFile(yyscanner,fileName,alreadyProcessed);
    if (fs)
    {
      setFileName(yyscanner,fileName);
      state->yyLineNr=1;
      return fs;
    }
    else if (alreadyProcessed)
    {
      return nullptr;
    }
  }
  if (localInclude && !state->fileName.isEmpty())
  {
    FileInfo fi(state->fileName.str());
    if (fi.exists())
    {
      QCString absName = QCString(fi.dirPath(TRUE))+"/"+fileName;
      auto fs = checkAndOpenFile(yyscanner,absName,alreadyProcessed);
      if (fs)
      {
        setFileName(yyscanner,absName);
        state->yyLineNr=1;
        return fs;
      }
      else if (alreadyProcessed)
      {
        return nullptr;
      }
    }
  }
  if (state->pathList.empty())
  {
    return nullptr;
  }
  for (auto path : state->pathList)
  {
    std::string absName = (path+"/"+fileName).str();
    //printf("  Looking for %s in %s\n",fileName,path.c_str());
    auto fs = checkAndOpenFile(yyscanner,absName.c_str(),alreadyProcessed);
    if (fs)
    {
      setFileName(yyscanner,absName.c_str());
      state->yyLineNr=1;
      //printf("  -> found it\n");
      return fs;
    }
    else if (alreadyProcessed)
    {
      return nullptr;
    }
  }
  return nullptr;
}

static QCString extractTrailingComment(const QCString &s)
{
  if (s.isEmpty()) return "";
  int i=(int)s.length()-1;
  while (i>=0)
  {
    char c=s[i];
    switch (c)
    {
      case '/':
        {
          i--;
          if (i>=0 && s[i]=='*') // end of a comment block
          {
            i--;
            while (i>0 && !(s[i-1]=='/' && s[i]=='*')) i--;
            if (i==0)
            {
              i++;
            }
            // only /*!< ... */ or /**< ... */ are treated as a comment for the macro name,
            // otherwise the comment is treated as part of the macro definition
            return ((s[i+1]=='*' || s[i+1]=='!') && s[i+2]=='<') ? &s[i-1] : "";
          }
          else
          {
            return "";
          }
        }
        break;
        // whitespace or line-continuation
      case ' ':
      case '\t':
      case '\r':
      case '\n':
      case '\\':
        break;
      default:
        return "";
    }
    i--;
  }
  return "";
}

static int getNextChar(yyscan_t yyscanner,const QCString &expr,QCString *rest,uint32_t &pos);
static int getCurrentChar(yyscan_t yyscanner,const QCString &expr,QCString *rest,uint32_t pos);
static void unputChar(yyscan_t yyscanner,const QCString &expr,QCString *rest,uint32_t &pos,char c);
static bool expandExpression(yyscan_t yyscanner,QCString &expr,QCString *rest,int pos,int level);

static QCString stringize(const QCString &s)
{
  QCString result;
  uint32_t i=0;
  bool inString=FALSE;
  bool inChar=FALSE;
  char c,pc;
  while (i<s.length())
  {
    if (!inString && !inChar)
    {
      while (i<s.length() && !inString && !inChar)
      {
        c=s.at(i++);
        if (c=='"')
        {
          result+="\\\"";
          inString=TRUE;
        }
        else if (c=='\'')
        {
          result+=c;
          inChar=TRUE;
        }
        else
        {
          result+=c;
        }
      }
    }
    else if (inChar)
    {
      while (i<s.length() && inChar)
      {
        c=s.at(i++);
        if (c=='\'')
        {
          result+='\'';
          inChar=FALSE;
        }
        else if (c=='\\')
        {
          result+="\\\\";
        }
        else
        {
          result+=c;
        }
      }
    }
    else
    {
      pc=0;
      while (i<s.length() && inString)
      {
        c=s.at(i++);
        if (c=='"')
        {
          result+="\\\"";
          inString= pc=='\\';
        }
        else if (c=='\\')
          result+="\\\\";
        else
          result+=c;
        pc=c;
      }
    }
  }
  //printf("stringize '%s'->'%s'\n",qPrint(s),qPrint(result));
  return result;
}

/*! Execute all ## operators in expr.
 * If the macro name before or after the operator contains a no-rescan
 * marker (@-) then this is removed (before the concatenated macro name
 * may be expanded again.
 */
static void processConcatOperators(QCString &expr)
{
  if (expr.isEmpty()) return;
  //printf("processConcatOperators: in='%s'\n",qPrint(expr));
  std::string e = expr.str();
  static const reg::Ex r(R"(\s*##\s*)");
  reg::Iterator end;

  size_t i=0;
  for (;;)
  {
    reg::Iterator it(e,r,i);
    if (it!=end)
    {
      const auto &match = *it;
      size_t n = match.position();
      size_t l = match.length();
      //printf("Match: '%s'\n",qPrint(expr.mid(i)));
      if (n+l+1<e.length() && e[static_cast<int>(n+l)]=='@' && expr[static_cast<int>(n+l+1)]=='-')
      {
        // remove no-rescan marker after ID
        l+=2;
      }
      //printf("found '%s'\n",qPrint(expr.mid(n,l)));
      // remove the ## operator and the surrounding whitespace
      e=e.substr(0,n)+e.substr(n+l);
      int k=static_cast<int>(n)-1;
      while (k>=0 && isId(e[k])) k--;
      if (k>0 && e[k]=='-' && e[k-1]=='@')
      {
        // remove no-rescan marker before ID
        e=e.substr(0,k-1)+e.substr(k+1);
        n-=2;
      }
      i=n;
    }
    else
    {
      break;
    }
  }

  expr = e;

  //printf("processConcatOperators: out='%s'\n",qPrint(expr));
}

static void returnCharToStream(yyscan_t yyscanner,char c)
{
  struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
  unput(c);
}

static inline void addTillEndOfString(yyscan_t yyscanner,const QCString &expr,QCString *rest,
                                       uint32_t &pos,char term,QCString &arg)
{
  int cc;
  while ((cc=getNextChar(yyscanner,expr,rest,pos))!=EOF && cc!=0)
  {
    if (cc=='\\') arg+=(char)cc,cc=getNextChar(yyscanner,expr,rest,pos);
    else if (cc==term) return;
    arg+=(char)cc;
  }
}

/*! replaces the function macro \a def whose argument list starts at
 * \a pos in expression \a expr.
 * Notice that this routine may scan beyond the \a expr string if needed.
 * In that case the characters will be read from the input file.
 * The replacement string will be returned in \a result and the
 * length of the (unexpanded) argument list is stored in \a len.
 */
static bool replaceFunctionMacro(yyscan_t yyscanner,const QCString &expr,QCString *rest,int pos,int &len,const Define *def,QCString &result,int level)
{
  YY_EXTRA_TYPE state = preYYget_extra(yyscanner);
  //printf(">replaceFunctionMacro(expr='%s',rest='%s',pos=%d,def='%s') level=%d\n",qPrint(expr),rest ? qPrint(*rest) : 0,pos,qPrint(def->name),state->levelGuard.size());
  uint32_t j=pos;
  len=0;
  result.resize(0);
  int cc;
  while ((cc=getCurrentChar(yyscanner,expr,rest,j))!=EOF && cc!='\n' && isspace(cc))
  {
    len++;
    getNextChar(yyscanner,expr,rest,j);
  }
  if (cc!='(')
  {
    unputChar(yyscanner,expr,rest,j,' ');
    return FALSE;
  }
  getNextChar(yyscanner,expr,rest,j); // eat the '(' character

  std::map<std::string,std::string> argTable;  // list of arguments
  QCString arg;
  int argCount=0;
  bool done=FALSE;

  // PHASE 1: read the macro arguments
  if (def->nargs==0)
  {
    while ((cc=getNextChar(yyscanner,expr,rest,j))!=EOF && cc!=0)
    {
      char c = (char)cc;
      if (c==')') break;
    }
  }
  else
  {
    while (!done && (argCount<def->nargs || def->varArgs) &&
        ((cc=getNextChar(yyscanner,expr,rest,j))!=EOF && cc!=0)
          )
    {
      char c=(char)cc;
      if (c=='(') // argument is a function => search for matching )
      {
        int lvl=1;
        arg+=c;
        //char term='\0';
        while ((cc=getNextChar(yyscanner,expr,rest,j))!=EOF && cc!=0)
        {
          c=(char)cc;
          //printf("processing %c: term=%c (%d)\n",c,term,term);
          if (c=='\'' || c=='\"') // skip ('s and )'s inside strings
          {
            arg+=c;
            addTillEndOfString(yyscanner,expr,rest,j,c,arg);
          }
          if (c==')')
          {
            lvl--;
            arg+=c;
            if (lvl==0) break;
          }
          else if (c=='(')
          {
            lvl++;
            arg+=c;
          }
          else
            arg+=c;
        }
      }
      else if (c==')' || c==',') // last or next argument found
      {
        if (c==',' && argCount==def->nargs-1 && def->varArgs)
        {
          arg=arg.stripWhiteSpace();
          arg+=',';
        }
        else
        {
          QCString argKey;
          argKey.sprintf("@%d",argCount++); // key name
          arg=arg.stripWhiteSpace();
          // add argument to the lookup table
          argTable.emplace(toStdString(argKey), toStdString(arg));
          arg.resize(0);
          if (c==')') // end of the argument list
          {
            done=TRUE;
          }
        }
      }
      else if (c=='\"') // append literal strings
      {
        arg+=c;
        bool found=FALSE;
        while (!found && (cc=getNextChar(yyscanner,expr,rest,j))!=EOF && cc!=0)
        {
          found = cc=='"';
          if (cc=='\\')
          {
            c=(char)cc;
            arg+=c;
            if ((cc=getNextChar(yyscanner,expr,rest,j))==EOF || cc==0) break;
          }
          c=(char)cc;
          arg+=c;
        }
      }
      else if (c=='\'') // append literal characters
      {
        arg+=c;
        bool found=FALSE;
        while (!found && (cc=getNextChar(yyscanner,expr,rest,j))!=EOF && cc!=0)
        {
          found = cc=='\'';
          if (cc=='\\')
          {
            c=(char)cc;
            arg+=c;
            if ((cc=getNextChar(yyscanner,expr,rest,j))==EOF || cc==0) break;
          }
          c=(char)cc;
          arg+=c;
        }
      }
      else if (c=='/') // possible start of a comment
      {
        char prevChar = '\0';
        arg+=c;
        if ((cc=getCurrentChar(yyscanner,expr,rest,j)) == '*') // we have a comment
        {
          while ((cc=getNextChar(yyscanner,expr,rest,j))!=EOF && cc!=0)
          {
            c=(char)cc;
            arg+=c;
            if (c == '/' && prevChar == '*') break; // we have an end of comment
            prevChar = c;
          }
        }
      }
      else // append other characters
      {
        arg+=c;
      }
    }
  }

  // PHASE 2: apply the macro function
  if (argCount==def->nargs || // same number of arguments
      (argCount>=def->nargs-1 && def->varArgs)) // variadic macro with at least as many
                                                // params as the non-variadic part (see bug731985)
  {
    uint32_t k=0;
    // substitution of all formal arguments
    QCString resExpr;
    const QCString d=def->definition.stripWhiteSpace();
    //printf("Macro definition: '%s'\n",qPrint(d));
    bool inString=FALSE;
    while (k<d.length())
    {
      if (d.at(k)=='@') // maybe a marker, otherwise an escaped @
      {
        if (d.at(k+1)=='@') // escaped @ => copy it (is unescaped later)
        {
          k+=2;
          resExpr+="@@"; // we unescape these later
        }
        else if (d.at(k+1)=='-') // no-rescan marker
        {
          k+=2;
          resExpr+="@-";
        }
        else // argument marker => read the argument number
        {
          QCString key="@";
          bool hash=FALSE;
          int l=k-1;
          // search for ## backward
          if (l>=0 && d.at(l)=='"') l--;
          while (l>=0 && d.at(l)==' ') l--;
          if (l>0 && d.at(l)=='#' && d.at(l-1)=='#') hash=TRUE;
          k++;
          // scan the number
          while (k<d.length() && d.at(k)>='0' && d.at(k)<='9') key+=d.at(k++);
          if (!hash)
          {
            // search for ## forward
            l=k;
            if (l<(int)d.length() && d.at(l)=='"') l++;
            while (l<(int)d.length() && d.at(l)==' ') l++;
            if (l<(int)d.length()-1 && d.at(l)=='#' && d.at(l+1)=='#') hash=TRUE;
          }
          //printf("request key %s result %s\n",qPrint(key),argTable[key]->data());
          auto it = argTable.find(key.str());
          if (it!=argTable.end())
          {
            QCString substArg = it->second.c_str();
            //printf("substArg='%s'\n",qPrint(substArg));
            // only if no ## operator is before or after the argument
            // marker we do macro expansion.
            if (!hash)
            {
              expandExpression(yyscanner,substArg,0,0,level+1);
            }
            if (inString)
            {
              //printf("'%s'=stringize('%s')\n",qPrint(stringize(*subst)),subst->data());

              // if the marker is inside a string (because a # was put
              // before the macro name) we must escape " and \ characters
              resExpr+=stringize(substArg);
            }
            else
            {
              if (hash && substArg.isEmpty())
              {
                resExpr+="@E"; // empty argument will be remove later on
              }
              else if (state->nospaces)
              {
                resExpr+=substArg;
              }
              else
              {
                resExpr+=" "+substArg+" ";
              }
            }
          }
        }
      }
      else // no marker, just copy
      {
        if (!inString && d.at(k)=='\"')
        {
          inString=TRUE; // entering a literal string
        }
        else if (inString && d.at(k)=='\"' && (d.at(k-1)!='\\' || d.at(k-2)=='\\'))
        {
          inString=FALSE; // leaving a literal string
        }
        resExpr+=d.at(k++);
      }
    }
    len=j-pos;
    result=resExpr;
    //printf("<replaceFunctionMacro(expr='%s',rest='%s',pos=%d,def='%s',result='%s') level=%d return=TRUE\n",qPrint(expr),rest ? qPrint(*rest) : 0,pos,qPrint(def->name),qPrint(result),state->levelGuard.size());
    return TRUE;
  }
  //printf("<replaceFunctionMacro(expr='%s',rest='%s',pos=%d,def='%s',result='%s') level=%d return=FALSE\n",qPrint(expr),rest ? qPrint(*rest) : 0,pos,qPrint(def->name),qPrint(result),state->levelGuard.size());
  return FALSE;
}


/*! returns the next identifier in string \a expr by starting at position \a p.
 * The position of the identifier is returned (or -1 if nothing is found)
 * and \a l is its length. Any quoted strings are skipping during the search.
 */
static int getNextId(const QCString &expr,int p,int *l)
{
  int n;
  while (p<(int)expr.length())
  {
    char c=expr.at(p++);
    if (isdigit(c)) // skip number
    {
      while (p<(int)expr.length() && isId(expr.at(p))) p++;
    }
    else if (isalpha(c) || c=='_') // read id
    {
      n=p-1;
      while (p<(int)expr.length() && isId(expr.at(p))) p++;
      *l=p-n;
      return n;
    }
    else if (c=='"') // skip string
    {
      char ppc=0,pc=c;
      if (p<(int)expr.length()) c=expr.at(p);
      while (p<(int)expr.length() && (c!='"' || (pc=='\\' && ppc!='\\')))
        // continue as long as no " is found, but ignoring \", but not \\"
      {
        ppc=pc;
        pc=c;
        c=expr.at(p);
        p++;
      }
      if (p<(int)expr.length()) ++p; // skip closing quote
    }
    else if (c=='/') // skip C Comment
    {
      //printf("Found C comment at p=%d\n",p);
      char pc=c;
      if (p<(int)expr.length())
      {
        c=expr.at(p);
        if (c=='*')  // Start of C comment
        {
          p++;
          while (p<(int)expr.length() && !(pc=='*' && c=='/'))
          {
            pc=c;
            c=expr.at(p++);
          }
        }
      }
      //printf("Found end of C comment at p=%d\n",p);
    }
  }
  return -1;
}

#define MAX_EXPANSION_DEPTH 50

/*! performs recursive macro expansion on the string \a expr
 *  starting at position \a pos.
 *  May read additional characters from the input while re-scanning!
 */
static bool expandExpression(yyscan_t yyscanner,QCString &expr,QCString *rest,int pos,int level)
{
  struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
  YY_EXTRA_TYPE state = preYYget_extra(yyscanner);
  //printf(">expandExpression(expr='%s',rest='%s',pos=%d,level=%d)\n",qPrint(expr),rest ? qPrint(*rest) : "", pos, level);
  if (expr.isEmpty())
  {
    //printf("<expandExpression: empty\n");
    return TRUE;
  }
  if (state->expanded.find(expr.str())!=state->expanded.end() &&
      level>MAX_EXPANSION_DEPTH) // check for too deep recursive expansions
  {
    //printf("<expandExpression: already expanded expr='%s'\n",qPrint(expr));
    return FALSE;
  }
  else
  {
    state->expanded.insert(expr.str());
  }
  QCString macroName;
  QCString expMacro;
  bool definedTest=FALSE;
  int i=pos,l,p,len=0;
  int startPos = pos;
  int samePosCount=0;
  while ((p=getNextId(expr,i,&l))!=-1) // search for an macro name
  {
    bool replaced=FALSE;
    macroName=expr.mid(p,l);
    //printf(" p=%d macroName=%s\n",p,qPrint(macroName));
    if (p<2 || !(expr.at(p-2)=='@' && expr.at(p-1)=='-')) // no-rescan marker?
    {
      if (state->expandedDict.find(macroName.str())==state->expandedDict.end()) // expand macro
      {
        Define *def=isDefined(yyscanner,macroName);
        // In case EXPAND_ONLY_PREDEF is enabled prevent expansion unless the macro was explicitly
        // predefined
        if (yyextra->expandOnlyPredef && def && !def->isPredefined) def=nullptr;
        if (macroName=="defined")
        {
          //printf("found defined inside macro definition '%s'\n",qPrint(expr.right(expr.length()-p)));
          definedTest=TRUE;
        }
        else if (definedTest) // macro name was found after defined
        {
          if (def) expMacro = " 1 "; else expMacro = " 0 ";
          replaced=TRUE;
          len=l;
          definedTest=FALSE;
        }
        else if (def && def->nargs==-1) // simple macro
        {
          // substitute the definition of the macro
          //printf("macro '%s'->'%s'\n",qPrint(macroName),qPrint(def->definition));
          if (state->nospaces)
          {
            expMacro=def->definition.stripWhiteSpace();
          }
          else
          {
            expMacro=" "+def->definition.stripWhiteSpace()+" ";
          }
          //expMacro=def->definition.stripWhiteSpace();
          replaced=TRUE;
          len=l;
          //printf("simple macro expansion='%s'->'%s'\n",qPrint(macroName),qPrint(expMacro));
        }
        else if (def && def->nargs>=0) // function macro
        {
          //printf(" >>>> call replaceFunctionMacro expr='%s'\n",qPrint(expr));
          replaced=replaceFunctionMacro(yyscanner,expr,rest,p+l,len,def,expMacro,level);
          //printf(" <<<< call replaceFunctionMacro: replaced=%d\n",replaced);
          len+=l;
        }
        //printf(" macroName='%s' expMacro='%s' replaced=%d\n",qPrint(macroName),qPrint(expMacro),replaced);

        if (replaced) // expand the macro and rescan the expression
        {
          //printf(" replacing '%s'->'%s'\n",expr.mid(p,qPrint(len)),qPrint(expMacro));
          QCString resultExpr=expMacro;
          QCString restExpr=expr.right(expr.length()-len-p);
          processConcatOperators(resultExpr);
          //printf(" macroName=%s restExpr='%s' def->nonRecursive=%d\n",qPrint(macroName),qPrint(restExpr),def->nonRecursive);
          bool expanded=false;
          if (def && !def->nonRecursive)
          {
            state->expandedDict.emplace(toStdString(macroName),def);
            expanded = expandExpression(yyscanner,resultExpr,&restExpr,0,level+1);
            state->expandedDict.erase(toStdString(macroName));
          }
          else if (def && def->nonRecursive)
          {
            expanded = true;
          }
          if (expanded)
          {
            expr=expr.left(p)+resultExpr+restExpr;
            //printf(" new expression: '%s' old i=%d new i=%d\n",qPrint(expr),i,p);
            i=p;
          }
          else
          {
            expr=expr.left(p)+"@-"+expr.right(expr.length()-p);
            i=p+l+2;
          }
        }
        else // move to the next macro name
        {
          //printf(" moving to the next macro old i=%d new i=%d\n",i,p+l);
          i=p+l;
        }
      }
      else // move to the next macro name
      {
        expr=expr.left(p)+"@-"+expr.right(expr.length()-p);
        //printf("macro already expanded, moving to the next macro expr=%s\n",qPrint(expr));
        i=p+l+2;
        //i=p+l;
      }
      // check for too many inplace expansions without making progress
      if (i==startPos)
      {
        samePosCount++;
      }
      else
      {
        startPos=i;
        samePosCount=0;
      }
      if (samePosCount>MAX_EXPANSION_DEPTH)
      {
        break;
      }
    }
    else // no re-scan marker found, skip the macro name
    {
      //printf("skipping marked macro\n");
      i=p+l;
    }
  }
  //printf("<expandExpression(expr='%s',rest='%s',pos=%d,level=%d)\n",qPrint(expr),rest ? qPrint(*rest) : "", pos,level);
  return TRUE;
}

/*! @brief Process string or character literal.
 *
 * \a inputStr should point to the start of a string or character literal.
 * the routine will return a pointer to just after the end of the literal
 * the character making up the literal will be added to \a result.
 */
static const char *processUntilMatchingTerminator(const char *inputStr,QCString &result)
{
  if (inputStr==0) return inputStr;
  char term = *inputStr; // capture start character of the literal
  if (term!='\'' && term!='"') return inputStr; // not a valid literal
  char c=term;
  // output start character
  result+=c;
  inputStr++;
  while ((c=*inputStr)) // while inside the literal
  {
    if (c==term) // found end marker of the literal
    {
      // output end character and stop
      result+=c;
      inputStr++;
      break;
    }
    else if (c=='\\') // escaped character, process next character
                      // as well without checking for end marker.
    {
      result+=c;
      inputStr++;
      c=*inputStr;
      if (c==0) break; // unexpected end of string after escape character
    }
    result+=c;
    inputStr++;
  }
  return inputStr;
}

/*! replaces all occurrences of @@@@ in \a s by @@
 *  and removes all occurrences of @@E.
 *  All identifiers found are replaced by 0L
 */
static QCString removeIdsAndMarkers(const QCString &s)
{
  static const std::vector<std::string> signs = { "signed", "unsigned" };
  struct TypeInfo { std::string name; size_t size; };
  static const std::vector<TypeInfo> types = {
    { "short int",     sizeof(short int)     },
    { "long long int", sizeof(long long int) },
    { "long int",      sizeof(long int)      },
    { "long long",     sizeof(long long)     },
    { "long double",   sizeof(long double)   },
    { "int",           sizeof(int)           },
    { "short",         sizeof(short)         },
    { "bool",          sizeof(bool)          },
    { "long",          sizeof(long)          },
    { "char",          sizeof(char)          },
    { "float",         sizeof(float)         },
    { "double",        sizeof(double)        },
  };

  // Check if string p starts with basic types ending with a ')', such as 'signed long)' or ' float )'
  // and return the pointer just past the ')' and the size of the type as a tuple.
  // If the pattern is not found the tuple (nullptr,0) is returned.
  auto process_cast_or_sizeof = [](const char *p) -> std::pair<const char *,size_t>
  {
    const char *q = p;
    while (*q==' ' || *q=='\t') q++;
    bool found=false;
    size_t size = sizeof(int); // '(signed)' or '(unsigned)' is an int type
    for (const auto &sgn : signs)
    {
      if (qstrncmp(q,sgn.c_str(),sgn.length())==0) { q+=sgn.length(); found=true; }
    }
    if (!found || *q==' ' || *q=='\t' || *q==')') // continue searching
    {
      while (*q==' ' || *q=='\t') q++;
      for (const auto &t : types)
      {
        if (qstrncmp(q,t.name.c_str(),t.name.length())==0)
        {
          q += t.name.length();
          size = t.size;
          break;
        }
      }
      while (*q==' ' || *q=='\t') q++;
      if (*q==')') return std::make_pair(++q,size);
    }
    return std::make_pair(nullptr,0);
  };

  //printf("removeIdsAndMarkers(%s)\n",qPrint(s));
  if (s.isEmpty()) return s;
  const char *p=s.data();
  char c;
  bool inNum=FALSE;
  QCString result;
  if (p)
  {
    while ((c=*p))
    {
      if (c=='(') // potential cast, ignore it
      {
        const char *q = process_cast_or_sizeof(p+1).first;
        //printf("potential cast:\nin:  %s\nout: %s\n",p,q);
        if (q)
        {
          p=q;
          continue;
        }
      }
      else if (c=='s' && qstrncmp(p,"sizeof",6)==0) // sizeof(...)
      {
        const char *q = p+6;
        while (*q==' ' || *q=='\t') q++;
        if (*q=='(')
        {
          auto r = process_cast_or_sizeof(q+1);
          //printf("sizeof:\nin:  %s\nout: %zu%s\n--> sizeof=%zu\n",p,r.second,r.first,r.second);
          if (r.first)
          {
            result+=QCString().setNum(r.second);
            p=r.first;
            continue;
          }
        }
      }

      if (c=='@') // replace @@ with @ and remove @E
      {
        if (*(p+1)=='@')
        {
          result+=c;
        }
        else if (*(p+1)=='E')
        {
          // skip
        }
        p+=2;
      }
      else if (isdigit(c)) // number
      {
        result+=c;
        p++;
        inNum=TRUE;
      }
      else if (c=='\'') // quoted character
      {
        p = processUntilMatchingTerminator(p,result);
      }
      else if (c=='d' && !inNum) // identifier starting with a 'd'
      {
        if (qstrncmp(p,"defined ",8)==0 || qstrncmp(p,"defined(",8)==0)
                   // defined keyword
        {
          p+=7; // skip defined
        }
        else
        {
          result+="0L";
          p++;
          while ((c=*p) && isId(c)) p++;
        }
      }
      else if ((isalpha(c) || c=='_') && !inNum) // replace identifier with 0L
      {
        result+="0L";
        p++;
        while ((c=*p) && isId(c)) p++;
        while ((c=*p) && isspace((uint8_t)c)) p++;
        if (*p=='(') // undefined function macro
        {
          p++;
          int count=1;
          while ((c=*p++))
          {
            if (c=='(') count++;
            else if (c==')')
            {
              count--;
              if (count==0) break;
            }
            else if (c=='/')
            {
              char pc=c;
              c=*++p;
              if (c=='*') // start of C comment
              {
                while (*p && !(pc=='*' && c=='/')) // search end of comment
                {
                  pc=c;
                  c=*++p;
                }
                p++;
              }
            }
          }
        }
      }
      else if (c=='/') // skip C comments
      {
        char pc=c;
        c=*++p;
        if (c=='*') // start of C comment
        {
          while (*p && !(pc=='*' && c=='/')) // search end of comment
          {
            pc=c;
            c=*++p;
          }
          p++;
        }
        else // oops, not comment but division
        {
          result+=pc;
          goto nextChar;
        }
      }
      else
      {
nextChar:
        result+=c;
        char lc=(char)tolower(c);
        if (!isId(lc) && lc!='.' /*&& lc!='-' && lc!='+'*/) inNum=FALSE;
        p++;
      }
    }
  }
  //printf("removeIdsAndMarkers(%s)=%s\n",s,qPrint(result));
  return result;
}

/*! replaces all occurrences of @@ in \a s by @
 *  \par assumption:
 *   \a s only contains pairs of @@'s
 */
static QCString removeMarkers(const QCString &s)
{
  if (s.isEmpty()) return s;
  const char *p=s.data();
  char c;
  QCString result;
  if (p)
  {
    while ((c=*p))
    {
      switch(c)
      {
        case '@': // replace @@ with @
          {
            if (*(p+1)=='@')
            {
              result+=c;
            }
            p+=2;
          }
          break;
        case '/': // skip C comments
          {
            result+=c;
            char pc=c;
            c=*++p;
            if (c=='*') // start of C comment
            {
              while (*p && !(pc=='*' && c=='/')) // search end of comment
              {
                if (*p=='@' && *(p+1)=='@')
                  result+=c,p++;
                else
                  result+=c;
                pc=c;
                c=*++p;
              }
              if (*p) result+=c,p++;
            }
          }
          break;
        case '"': // skip string literals
        case '\'': // skip char literals
          p = processUntilMatchingTerminator(p,result);
          break;
        default:
          {
            result+=c;
            p++;
          }
          break;
      }
    }
  }
  //printf("RemoveMarkers(%s)=%s\n",s,qPrint(result));
  return result;
}

/*! compute the value of the expression in string \a expr.
 *  If needed the function may read additional characters from the input.
 */

static bool computeExpression(yyscan_t yyscanner,const QCString &expr)
{
  YY_EXTRA_TYPE state = preYYget_extra(yyscanner);
  QCString e=expr;
  QCString ee=expr;
  ee = removeMarkers(ee);
  state->expanded.clear();
  expandExpression(yyscanner,e,0,0,0);
  //printf("after expansion '%s'\n",qPrint(e));
  e = removeIdsAndMarkers(e);
  if (e.isEmpty()) return FALSE;
  //printf("parsing '%s'\n",qPrint(e));
  return state->constExpParser.parse(state->fileName.data(),state->yyLineNr,e.str(),ee.str());
}

/*! expands the macro definition in \a name
 *  If needed the function may read additional characters from the input
 */

static QCString expandMacro(yyscan_t yyscanner,const QCString &name)
{
  YY_EXTRA_TYPE state = preYYget_extra(yyscanner);
  QCString n=name;
  state->expanded.clear();
  expandExpression(yyscanner,n,0,0,0);
  n=removeMarkers(n);
  //printf("expandMacro '%s'->'%s'\n",qPrint(name),qPrint(n));
  return n;
}

static void addDefine(yyscan_t yyscanner)
{
  YY_EXTRA_TYPE state = preYYget_extra(yyscanner);
  Define def;
  def.name       = state->defName;
  def.definition = state->defText.stripWhiteSpace();
  def.nargs      = state->defArgs;
  def.fileName   = state->fileName;
  def.fileDef    = state->yyFileDef;
  def.lineNr     = state->yyLineNr-state->yyMLines;
  def.columnNr   = state->yyColNr;
  def.varArgs    = state->defVarArgs;
  //printf("newDefine: %s %s file: %s\n",qPrint(def.name),qPrint(def.definition),
  //    def.fileDef ? qPrint(def.fileDef->name()) : qPrint(def.fileName));
  //printf("newDefine: '%s'->'%s'\n",qPrint(def.name),qPrint(def.definition));
  if (!def.name.isEmpty() &&
      Doxygen::expandAsDefinedSet.find(def.name.str())!=Doxygen::expandAsDefinedSet.end())
  {
    def.isPredefined=TRUE;
    def.expandAsDefined=TRUE;
  }
  auto it = state->localDefines.find(def.name.str());
  if (it!=state->localDefines.end()) // redefine
  {
    state->localDefines.erase(it);
  }
  state->localDefines.insert(std::make_pair(def.name.str(),def));
}

static void addMacroDefinition(yyscan_t yyscanner)
{
  YY_EXTRA_TYPE state = preYYget_extra(yyscanner);
  if (state->skip) return; // do not add this define as it is inside a
                      // conditional section (cond command) that is disabled.

  Define define;
  define.fileName = state->fileName;
  define.lineNr   = state->yyLineNr - state->yyMLines;
  define.columnNr = state->yyColNr;
  define.name     = state->defName;
  define.args     = state->defArgsStr;
  define.fileDef  = state->inputFileDef;

  QCString litText = state->defLitText;
  int l=litText.find('\n');
  if (l>0 && litText.left(l).stripWhiteSpace()=="\\")
  {
    // strip first line if it only contains a slash
    litText = litText.right(litText.length()-l-1);
  }
  else if (l>0)
  {
    // align the items on the first line with the items on the second line
    int k=l+1;
    const char *p=litText.data()+k;
    char c;
    while ((c=*p++) && (c==' ' || c=='\t')) k++;
    litText=litText.mid(l+1,k-l-1)+litText.stripWhiteSpace();
  }
  QCString litTextStripped = state->defLitText.stripWhiteSpace();
  if (litTextStripped.contains('\n')>=1)
  {
    define.definition = litText;
  }
  else
  {
    define.definition = litTextStripped;
  }
  {
    state->macroDefinitions.push_back(define);
  }
}

static inline void outputChar(yyscan_t yyscanner,char c)
{
  YY_EXTRA_TYPE state = preYYget_extra(yyscanner);
  if (state->includeStack.empty() || state->curlyCount>0) state->outputBuf->addChar(c);
}

static inline void outputArray(yyscan_t yyscanner,const char *a,yy_size_t len)
{
  YY_EXTRA_TYPE state = preYYget_extra(yyscanner);
  if (state->includeStack.empty() || state->curlyCount>0) state->outputBuf->addArray(a,static_cast<uint32_t>(len));
}

static inline void outputString(yyscan_t yyscanner,const QCString &a)
{
  YY_EXTRA_TYPE state = preYYget_extra(yyscanner);
  if (state->includeStack.empty() || state->curlyCount>0) state->outputBuf->addArray(a.data(),a.length());
}

static inline void outputSpace(yyscan_t yyscanner,char c)
{
  if (c=='\t') outputChar(yyscanner,'\t');
  else outputChar(yyscanner,' ');
}

static inline void outputSpaces(yyscan_t yyscanner,char *s)
{
  const char *p=s;
  char c;
  while ((c=*p++))
  {
    if (c=='\t') outputChar(yyscanner,'\t');
    else outputChar(yyscanner,' ');
  }
}

static inline void extraSpacing(yyscan_t yyscanner)
{
  struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
  if (!yyextra->defContinue) return;
  for (int i=0; i< (int)yyleng; i++)
  {
    if (yytext[i] == '\t')
      yyextra->defExtraSpacing+='\t';
    else
      yyextra->defExtraSpacing+=' ';
  }
}

static void determineBlockName(yyscan_t yyscanner)
{
  struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
  yyextra->fenceSize=0;
  char c=0;
  if (yytext[1]=='f' && ((c=yytext[2])=='[' || c=='{' || c=='(' || c=='$'))
  {
    switch (c)
    {
      case '[': yyextra->blockName="]"; break;
      case '{': yyextra->blockName="}"; break;
      case '(': yyextra->blockName=")"; break;
      case '$': yyextra->blockName="$"; break;
      default: break;
    }
    yyextra->blockName=yyextra->blockName.stripWhiteSpace();
  }
  else
  {
    QCString bn=&yytext[1];
    if (bn=="startuml")
    {
      yyextra->blockName="uml";
    }
    else
    {
      int i = bn.find('{'); // for \code{.c}
      if (i!=-1) bn=bn.left(i);
      yyextra->blockName=bn.stripWhiteSpace();
    }
  }
}

static QCString determineAbsoluteIncludeName(const QCString &curFile,const QCString &incFileName)
{
  bool searchIncludes = Config_getBool(SEARCH_INCLUDES);
  QCString absIncFileName = incFileName;
  FileInfo fi(curFile.str());
  if (fi.exists())
  {
    QCString absName = QCString(fi.dirPath(TRUE))+"/"+incFileName;
    FileInfo fi2(absName.str());
    if (fi2.exists())
    {
      absIncFileName=fi2.absFilePath();
    }
    else if (searchIncludes) // search in INCLUDE_PATH as well
    {
      const StringVector &includePath = Config_getList(INCLUDE_PATH);
      for (const auto &incPath : includePath)
      {
        FileInfo fi3(incPath);
        if (fi3.exists() && fi3.isDir())
        {
          absName = QCString(fi3.absFilePath())+"/"+incFileName;
          //printf("trying absName=%s\n",qPrint(absName));
          FileInfo fi4(absName.str());
          if (fi4.exists())
          {
            absIncFileName=fi4.absFilePath();
            break;
          }
          //printf( "absIncFileName = %s\n", qPrint(absIncFileName) );
        }
      }
    }
    //printf( "absIncFileName = %s\n", qPrint(absIncFileName) );
  }
  return absIncFileName;
}

static void readIncludeFile(yyscan_t yyscanner,const QCString &inc)
{
  AUTO_TRACE("inc={}",inc);
  YY_EXTRA_TYPE state = preYYget_extra(yyscanner);
  uint32_t i=0;

  // find the start of the include file name
  while (i<inc.length() &&
         (inc.at(i)==' ' || inc.at(i)=='"' || inc.at(i)=='<')
        ) i++;
  uint32_t s=i;

  // was it a local include?
  bool localInclude = s>0 && inc.at(s-1)=='"';

  // find the end of the include file name
  while (i<inc.length() && inc.at(i)!='"' && inc.at(i)!='>') i++;

  if (s<inc.length() && i>s) // valid include file name found
  {
    // extract include path+name
    QCString incFileName=inc.mid(s,i-s).stripWhiteSpace();
    if (incFileName.endsWith(".exe") || incFileName.endsWith(".dll") || incFileName.endsWith(".tlb"))
    {
      // skip imported binary files (e.g. M$ type libraries)
      return;
    }

    QCString oldFileName = state->fileName;
    FileDef *oldFileDef  = state->yyFileDef;
    int oldLineNr        = state->yyLineNr;
    //printf("Searching for '%s'\n",qPrint(incFileName));

    QCString absIncFileName = determineAbsoluteIncludeName(state->fileName,incFileName);

    // findFile will overwrite state->yyFileDef if found
    std::unique_ptr<FileState> fs;
    bool alreadyProcessed = FALSE;
    //printf("calling findFile(%s)\n",qPrint(incFileName));
    if ((fs=findFile(yyscanner,incFileName,localInclude,alreadyProcessed))) // see if the include file can be found
    {
      {
        std::lock_guard<std::mutex> lock(g_globalDefineMutex);
        g_defineManager.addInclude(oldFileName.str(),absIncFileName.str());
      }

      //printf("Found include file!\n");
      if (Debug::isFlagSet(Debug::Preprocessor))
      {
        for (i=0;i<state->includeStack.size();i++)
        {
          Debug::print(Debug::Preprocessor,0,"  ");
        }
        Debug::print(Debug::Preprocessor,0,"#include %s: parsing...\n",qPrint(incFileName));
      }

      if (state->includeStack.empty() && oldFileDef)
      {
        PreIncludeInfo *ii = state->includeRelations.find(absIncFileName);
        if (ii==0)
        {
          bool ambig;
          FileDef *incFd = findFileDef(Doxygen::inputNameLinkedMap,absIncFileName,ambig);
          state->includeRelations.add(
              absIncFileName,
              oldFileDef,
              ambig?nullptr:incFd,
              incFileName,
              localInclude,
              state->isImported
              );
        }
      }

      struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
      fs->bufState = YY_CURRENT_BUFFER;
      fs->lineNr   = oldLineNr;
      fs->fileName = oldFileName;
      fs->curlyCount = state->curlyCount;
      state->curlyCount = 0;
      // push the state on the stack
      FileState *fs_ptr = fs.get();
      state->includeStack.push_back(std::move(fs));
      // set the scanner to the include file

      // Deal with file changes due to
      // #include's within { .. } blocks
      QCString lineStr(state->fileName.length()+20);
      lineStr.sprintf("# 1 \"%s\" 1\n",qPrint(state->fileName));
      outputString(yyscanner,lineStr);

      AUTO_TRACE_ADD("Switching to include file {}",incFileName);
      state->expectGuard=TRUE;
      state->inputBuf   = &fs_ptr->fileBuf;
      state->inputBufPos=0;
      yy_switch_to_buffer(yy_create_buffer(0, YY_BUF_SIZE, yyscanner),yyscanner);
    }
    else
    {
      if (alreadyProcessed) // if this header was already process we can just copy the stored macros
                           // in the local context
      {
        std::lock_guard<std::mutex> lock(g_globalDefineMutex);
        g_defineManager.addInclude(state->fileName.str(),absIncFileName.str());
        g_defineManager.retrieve(absIncFileName.str(),state->contextDefines);
      }

      if (state->includeStack.empty() && oldFileDef)
      {
        PreIncludeInfo *ii = state->includeRelations.find(absIncFileName);
        if (ii==0)
        {
          bool ambig;
          FileDef *incFd = findFileDef(Doxygen::inputNameLinkedMap,absIncFileName,ambig);
          ii = state->includeRelations.add(absIncFileName,
              oldFileDef,
              ambig?0:incFd,
              incFileName,
              localInclude,
              state->isImported
              );
        }
      }

      if (Debug::isFlagSet(Debug::Preprocessor))
      {
        for (i=0;i<state->includeStack.size();i++)
        {
          Debug::print(Debug::Preprocessor,0,"  ");
        }
        if (alreadyProcessed)
        {
          Debug::print(Debug::Preprocessor,0,"#include %s: already processed! skipping...\n",qPrint(incFileName));
        }
        else
        {
          Debug::print(Debug::Preprocessor,0,"#include %s: not found! skipping...\n",qPrint(incFileName));
        }
        //printf("error: include file %s not found\n",yytext);
      }
      if (state->curlyCount>0 && !alreadyProcessed) // failed to find #include inside { ... }
      {
        warn(state->fileName,state->yyLineNr,"include file %s not found, perhaps you forgot to add its directory to INCLUDE_PATH?",qPrint(incFileName));
      }
    }
  }
}

/* ----------------------------------------------------------------- */

static void startCondSection(yyscan_t yyscanner,const QCString &sectId)
{
  YY_EXTRA_TYPE state = preYYget_extra(yyscanner);
  //printf("startCondSection: skip=%d stack=%d\n",state->skip,state->condStack.size());
  CondParser prs;
  bool expResult = prs.parse(state->fileName.data(),state->yyLineNr,sectId.data());
  state->condStack.emplace(std::make_unique<preYY_CondCtx>(state->yyLineNr,sectId,state->skip));
  if (!expResult)
  {
    state->skip=TRUE;
  }
  //printf("  expResult=%d skip=%d\n",expResult,state->skip);
}

static void endCondSection(yyscan_t yyscanner)
{
  YY_EXTRA_TYPE state = preYYget_extra(yyscanner);
  if (state->condStack.empty())
  {
    warn(state->fileName,state->yyLineNr,"the \\endcond does not have a corresponding \\cond in this file");
    state->skip=FALSE;
  }
  else
  {
    const std::unique_ptr<preYY_CondCtx> &ctx = state->condStack.top();
    state->skip=ctx->skip;
    state->condStack.pop();
  }
  //printf("endCondSection: skip=%d stack=%d\n",state->skip,state->condStack.count());
}

static void forceEndCondSection(yyscan_t yyscanner)
{
  YY_EXTRA_TYPE state = preYYget_extra(yyscanner);
  while (!state->condStack.empty())
  {
    state->condStack.pop();
  }
  state->skip=FALSE;
}

static QCString escapeAt(const QCString &text)
{
  QCString result;
  if (!text.isEmpty())
  {
    char c;
    const char *p=text.data();
    while ((c=*p++))
    {
      if (c=='@') result+="@@"; else result+=c;
    }
  }
  return result;
}

static char resolveTrigraph(char c)
{
  switch (c)
  {
    case '=': return '#';
    case '/': return '\\';
    case '\'': return '^';
    case '(': return '[';
    case ')': return ']';
    case '!': return '|';
    case '<': return '{';
    case '>': return '}';
    case '-': return '~';
  }
  return '?';
}

/*@ ----------------------------------------------------------------------------
 */

static int getNextChar(yyscan_t yyscanner,const QCString &expr,QCString *rest,uint32_t &pos)
{
  //printf("getNextChar(%s,%s,%d)\n",qPrint(expr),rest ? rest->data() : 0,pos);
  if (pos<expr.length())
  {
    //printf("%c=expr()\n",expr.at(pos));
    return expr.at(pos++);
  }
  else if (rest && !rest->isEmpty())
  {
    int cc=rest->at(0);
    *rest=rest->right(rest->length()-1);
    //printf("%c=rest\n",cc);
    return cc;
  }
  else
  {
    int cc=yyinput(yyscanner);
    //printf("%d=yyinput() %d\n",cc,EOF);
    return cc;
  }
}

static int getCurrentChar(yyscan_t yyscanner,const QCString &expr,QCString *rest,uint32_t pos)
{
  //printf("getCurrentChar(%s,%s,%d)\n",qPrint(expr),rest ? rest->data() : 0,pos);
  if (pos<expr.length())
  {
    //printf("%c=expr()\n",expr.at(pos));
    return expr.at(pos);
  }
  else if (rest && !rest->isEmpty())
  {
    int cc=rest->at(0);
    //printf("%c=rest\n",cc);
    return cc;
  }
  else
  {
    int cc=yyinput(yyscanner);
    returnCharToStream(yyscanner,(char)cc);
    //printf("%c=yyinput()\n",cc);
    return cc;
  }
}

static void unputChar(yyscan_t yyscanner,const QCString &expr,QCString *rest,uint32_t &pos,char c)
{
  //printf("unputChar(%s,%s,%d,%c)\n",qPrint(expr),rest ? rest->data() : 0,pos,c);
  if (pos<expr.length())
  {
    pos++;
  }
  else if (rest)
  {
    //printf("Prepending to rest!\n");
    char cs[2];cs[0]=c;cs[1]='\0';
    rest->prepend(cs);
  }
  else
  {
    //unput(c);
    returnCharToStream(yyscanner,c);
  }
  //printf("result: unputChar(%s,%s,%d,%c)\n",qPrint(expr),rest ? rest->data() : 0,pos,c);
}

/** Returns a reference to a Define object given its name or 0 if the Define does
 *  not exist.
 */
static Define *isDefined(yyscan_t yyscanner,const QCString &name)
{
  YY_EXTRA_TYPE state = preYYget_extra(yyscanner);

  bool undef = false;
  auto findDefine = [&undef,&name](DefineMap &map)
  {
    Define *d=0;
    auto it = map.find(name.str());
    if (it!=map.end())
    {
      d = &it->second;
      if (d->undef)
      {
        undef=true;
        d=0;
      }
    }
    return d;
  };

  Define *def = findDefine(state->localDefines);
  if (def==0 && !undef)
  {
    def = findDefine(state->contextDefines);
  }
  return def;
}

static void initPredefined(yyscan_t yyscanner,const QCString &fileName)
{
  YY_EXTRA_TYPE state = preYYget_extra(yyscanner);

  // add predefined macros
  const StringVector &predefList = Config_getList(PREDEFINED);
  for (const auto &ds : predefList)
  {
    size_t i_equals=ds.find('=');
    size_t i_obrace=ds.find('(');
    size_t i_cbrace=ds.find(')');
    bool nonRecursive = i_equals!=std::string::npos && i_equals>0 && ds[i_equals-1]==':';

    if ((i_obrace==0) || (i_equals==0) || (i_equals==1 && ds[i_equals-1]==':'))
    {
      continue; // no define name
    }

    if (i_obrace<i_equals && i_cbrace<i_equals &&
        i_obrace!=std::string::npos && i_cbrace!=std::string::npos &&
        i_obrace<i_cbrace
       ) // predefined function macro definition
    {
      static const reg::Ex reId(R"(\a\w*)");
      std::map<std::string,int> argMap;
      std::string args  = ds.substr(i_obrace+1,i_cbrace-i_obrace-1); // part between ( and )
      bool   hasVarArgs = args.find("...")!=std::string::npos;
      //printf("predefined function macro '%s'\n",ds.c_str());
      int count = 0;
      reg::Iterator arg_it(args,reId,0);
      reg::Iterator arg_end;
      // gather the formal arguments in a dictionary
      for (; arg_it!=arg_end; ++arg_it)
      {
        argMap.emplace(arg_it->str(),count++);
      }
      if (hasVarArgs) // add the variable argument if present
      {
        argMap.emplace("__VA_ARGS__",count++);
      }

      // strip definition part
      std::string definition;
      std::string in=ds.substr(i_equals+1);
      reg::Iterator re_it(in,reId);
      reg::Iterator re_end;
      size_t i=0;
      // substitute all occurrences of formal arguments by their
      // corresponding markers
      for (; re_it!=re_end; ++re_it)
      {
        const auto &match = *re_it;
        size_t pi = match.position();
        size_t l  = match.length();
        if (pi>i) definition+=in.substr(i,pi-i);

        auto it = argMap.find(match.str());
        if (it!=argMap.end())
        {
          int argIndex = it->second;
          QCString marker;
          marker.sprintf(" @%d ",argIndex);
          definition+=marker.str();
        }
        else
        {
          definition+=match.str();
        }
        i=pi+l;
      }
      definition+=in.substr(i);

      // add define definition to the dictionary of defines for this file
      std::string dname = ds.substr(0,i_obrace);
      if (!dname.empty())
      {
        Define def;
        def.name         = dname;
        def.definition   = definition;
        def.nargs        = count;
        def.isPredefined = TRUE;
        def.nonRecursive = nonRecursive;
        def.fileDef      = state->yyFileDef;
        def.fileName     = fileName;
        def.varArgs      = hasVarArgs;
        state->contextDefines.insert(std::make_pair(def.name.str(),def));

        //printf("#define '%s' '%s' #nargs=%d hasVarArgs=%d\n",
        //  qPrint(def.name),qPrint(def.definition),def.nargs,def.varArgs);
      }
    }
    else if (!ds.empty()) // predefined non-function macro definition
    {
      //printf("predefined normal macro '%s'\n",ds.c_str());
      Define def;
      if (i_equals==std::string::npos) // simple define without argument
      {
        def.name = ds;
        def.definition = "1"; // substitute occurrences by 1 (true)
      }
      else // simple define with argument
      {
        int ine=static_cast<int>(i_equals) - (nonRecursive ? 1 : 0);
        def.name = ds.substr(0,ine);
        def.definition = ds.substr(i_equals+1);
      }
      if (!def.name.isEmpty())
      {
        def.nargs = -1;
        def.isPredefined = TRUE;
        def.nonRecursive = nonRecursive;
        def.fileDef      = state->yyFileDef;
        def.fileName     = fileName;
        state->contextDefines.insert(std::make_pair(def.name.str(),def));
      }
    }
  }
}

///////////////////////////////////////////////////////////////////////////////////////////////

struct Preprocessor::Private
{
  yyscan_t yyscanner;
  preYY_state state;
};

void Preprocessor::addSearchDir(const QCString &dir)
{
  YY_EXTRA_TYPE state = preYYget_extra(p->yyscanner);
  FileInfo fi(dir.str());
  if (fi.isDir()) state->pathList.push_back(fi.absFilePath());
}

Preprocessor::Preprocessor() : p(std::make_unique<Private>())
{
  preYYlex_init_extra(&p->state,&p->yyscanner);
  addSearchDir(".");
}

Preprocessor::~Preprocessor()
{
  preYYlex_destroy(p->yyscanner);
}

void Preprocessor::processFile(const QCString &fileName,BufStr &input,BufStr &output)
{
  AUTO_TRACE("fileName={}",fileName);
  yyscan_t yyscanner = p->yyscanner;
  YY_EXTRA_TYPE state = preYYget_extra(p->yyscanner);
  struct yyguts_t *yyg = (struct yyguts_t*)p->yyscanner;

#ifdef FLEX_DEBUG
  preYYset_debug(Debug::isFlagSet(Debug::Lex_pre)?1:0,yyscanner);
#endif

  DebugLex debugLex(Debug::Lex_pre, __FILE__, qPrint(fileName));
  size_t orgOffset=output.curPos();
  //printf("##########################\n%s\n####################\n",
  //    qPrint(input));

  state->macroExpansion = Config_getBool(MACRO_EXPANSION);
  state->expandOnlyPredef = Config_getBool(EXPAND_ONLY_PREDEF);
  state->skip=FALSE;
  state->curlyCount=0;
  state->nospaces=FALSE;
  state->inputBuf=&input;
  state->inputBufPos=0;
  state->outputBuf=&output;
  state->includeStack.clear();
  state->expandedDict.clear();
  state->contextDefines.clear();
  while (!state->condStack.empty()) state->condStack.pop();

  setFileName(yyscanner,fileName);

  state->inputFileDef = state->yyFileDef;
  //yyextra->defineManager.startContext(state->fileName);

  initPredefined(yyscanner,fileName);

  state->yyLineNr = 1;
  state->yyColNr  = 1;
  state->ifcount  = 0;

  BEGIN( Start );

  state->expectGuard = guessSection(fileName)==Entry::HEADER_SEC;
  state->guardName.resize(0);
  state->lastGuardName.resize(0);
  state->guardExpr.resize(0);

  preYYlex(yyscanner);

  while (!state->condStack.empty())
  {
    const std::unique_ptr<preYY_CondCtx> &ctx = state->condStack.top();
    QCString sectionInfo = " ";
    if (ctx->sectionId!=" ") sectionInfo.sprintf(" with label '%s' ",qPrint(ctx->sectionId.stripWhiteSpace()));
    warn(fileName,ctx->lineNr,"Conditional section%sdoes not have "
        "a corresponding \\endcond command within this file.",qPrint(sectionInfo));
    state->condStack.pop();
  }
  // make sure we don't extend a \cond with missing \endcond over multiple files (see bug 624829)
  forceEndCondSection(yyscanner);

  if (Debug::isFlagSet(Debug::Preprocessor))
  {
    std::lock_guard<std::mutex> lock(g_debugMutex);
    char *orgPos=output.data()+orgOffset;
    char *newPos=output.data()+output.curPos();
    Debug::print(Debug::Preprocessor,0,"Preprocessor output of %s (size: %d bytes):\n",qPrint(fileName),newPos-orgPos);
    int line=1;
    Debug::print(Debug::Preprocessor,0,"---------\n");
    if (!Debug::isFlagSet(Debug::NoLineNo)) Debug::print(Debug::Preprocessor,0,"00001 ");
    while (orgPos<newPos)
    {
      putchar(*orgPos);
      if (*orgPos=='\n' && !Debug::isFlagSet(Debug::NoLineNo)) Debug::print(Debug::Preprocessor,0,"%05d ",++line);
      orgPos++;
    }
    Debug::print(Debug::Preprocessor,0,"\n---------\n");
    if (yyextra->contextDefines.size()>0)
    {
      Debug::print(Debug::Preprocessor,0,"Macros accessible in this file (%s):\n", qPrint(fileName));
      Debug::print(Debug::Preprocessor,0,"---------\n");
      for (auto &kv : yyextra->contextDefines)
      {
        Debug::print(Debug::Preprocessor,0,"%s ",qPrint(kv.second.name));
      }
      for (auto &kv : yyextra->localDefines)
      {
        Debug::print(Debug::Preprocessor,0,"%s ",qPrint(kv.second.name));
      }
      Debug::print(Debug::Preprocessor,0,"\n---------\n");
    }
    else
    {
      Debug::print(Debug::Preprocessor,0,"No macros accessible in this file (%s).\n", qPrint(fileName));
    }
  }

  {
    std::lock_guard<std::mutex> lock(g_updateGlobals);
    for (const auto &inc : state->includeRelations)
    {
      if (inc->fromFileDef)
      {
        inc->fromFileDef->addIncludeDependency(inc->toFileDef,inc->includeName,inc->local,inc->imported);
      }
      if (inc->toFileDef && inc->fromFileDef)
      {
        inc->toFileDef->addIncludedByDependency(inc->fromFileDef,inc->fromFileDef->docName(),inc->local,inc->imported);
      }
    }
    // add the macro definition for this file to the global map
    Doxygen::macroDefinitions.emplace(std::make_pair(state->fileName.str(),std::move(state->macroDefinitions)));
  }

  //yyextra->defineManager.endContext();
}

#if USE_STATE2STRING
#include "pre.l.h"
#endif


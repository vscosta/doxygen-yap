diff --git a/CMakeLists.txt b/CMakeLists.txt
index 4c55859e..d123095f 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -14,15 +14,7 @@
 cmake_minimum_required(VERSION 2.8.12)
 project(doxygen)
 
-option(build_wizard    "Build the GUI frontend for doxygen." OFF)
-option(build_app       "Example showing how to embed doxygen in an application." OFF)
-option(build_xmlparser "Example showing how to parse doxygen's XML output." OFF)
-option(build_search    "Build external search tools (doxysearch and doxyindexer)" OFF)
-option(build_doc       "Build user manual" OFF)
-option(use_sqlite3     "Add support for sqlite3 output [experimental]." OFF)
-option(use_libclang    "Add support for libclang parsing." OFF)
-option(win_static      "Link with /MT in stead of /MD on windows" OFF)
-option(english_only    "Only compile in support for the English language" OFF)
+option(build_wizard    "Build the GUI frontend for doxygen." O)
 option(force_qt4       "Forces doxywizard to build using Qt4 even if Qt5 is installed" OFF)
 
 list(APPEND CMAKE_MODULE_PATH "${CMAKE_SOURCE_DIR}/cmake")
@@ -55,13 +47,13 @@ if (WIN32)
     add_definitions(-DLIBICONV_STATIC -D_CRT_SECURE_NO_WARNINGS)
 endif()
 
-if ("${CMAKE_GENERATOR}" MATCHES "Ninja") 
+if ("${CMAKE_GENERATOR}" MATCHES "Ninja")
   set(LEX_FLAGS )
   set(YACC_FLAGS )
-else ("${CMAKE_GENERATOR}" MATCHES "Ninja") 
+else ("${CMAKE_GENERATOR}" MATCHES "Ninja")
   set(LEX_FLAGS $(LEX_FLAGS))
   set(YACC_FLAGS $(YACC_FLAGS))
-endif ("${CMAKE_GENERATOR}" MATCHES "Ninja") 
+endif ("${CMAKE_GENERATOR}" MATCHES "Ninja")
 
 find_program(DOT NAMES dot)
 find_package(PythonInterp REQUIRED)
@@ -77,7 +69,7 @@ find_package(Iconv REQUIRED)
 include_directories(${ICONV_INCLUDE_DIR})
 
 
-#set(DOXYDOCS ${CMAKE_SOURCE_DIR}/doc CACHE INTERNAL "Path to doxygen docs")
+set(DOXYDOCS ${CMAKE_SOURCE_DIR}/doc CACHE INTERNAL "Path to doxygen docs")
 set(DOXYDOCS ${PROJECT_BINARY_DIR}/doc)
 set(ENV{DOXYGEN_DOCDIR} ${DOXYDOCS})
 set(GENERATED_SRC "${CMAKE_BINARY_DIR}/generated_src" CACHE INTERNAL "Stores generated files")
diff --git a/addon/doxywizard/CMakeLists.txt b/addon/doxywizard/CMakeLists.txt
index 82079715..9e0c0123 100644
--- a/addon/doxywizard/CMakeLists.txt
+++ b/addon/doxywizard/CMakeLists.txt
@@ -110,6 +110,7 @@ qt_use_modules(doxywizard Core Gui Widgets Xml)
 target_link_libraries(doxywizard
 ${QT_LIBRARIES} ${QT_QTMAIN_LIBRARY}
 )
+  set_target_properties(doxywizard OUTPUT_NAME doxywizard-yap)
 
 install(TARGETS doxywizard DESTINATION bin)
 
diff --git a/src/context.cpp b/src/context.cpp
index 9a792688..6baf4114 100644
--- a/src/context.cpp
+++ b/src/context.cpp
@@ -16,45 +16,45 @@
 #include <assert.h>
 #include <qdir.h>
 
-#include "arguments.h"
-#include "classlist.h"
-#include "config.h"
 #include "context.h"
-#include "diagram.h"
-#include "dirdef.h"
-#include "docparser.h"
-#include "dot.h"
+#include "config.h"
+#include "index.h"
+#include "classlist.h"
 #include "doxygen.h"
-#include "example.h"
+#include "namespacedef.h"
 #include "filedef.h"
-#include "filename.h"
-#include "groupdef.h"
+#include "pagedef.h"
 #include "groupdef.h"
-#include "htmldocvisitor.h"
+#include "util.h"
+#include "version.h"
+#include "language.h"
+#include "message.h"
+#include "vhdldocgen.h"
+#include "filename.h"
+#include "dirdef.h"
+#include "docparser.h"
 #include "htmlgen.h"
+#include "htmldocvisitor.h"
 #include "htmlhelp.h"
-#include "index.h"
-#include "language.h"
-#include "latexdocvisitor.h"
 #include "latexgen.h"
+#include "latexdocvisitor.h"
+#include "dot.h"
+#include "diagram.h"
+#include "example.h"
 #include "membername.h"
-#include "message.h"
-#include "namespacedef.h"
-#include "pagedef.h"
 #include "parserintf.h"
 #include "portable.h"
-#include "resourcemgr.h"
+#include "arguments.h"
+#include "groupdef.h"
 #include "searchindex.h"
-#include "util.h"
-#include "version.h"
-#include "vhdldocgen.h"
+#include "resourcemgr.h"
 
-// TODO: pass the current file to Dot*::writeGraph, so the user can put dot
-// graphs in other
+// TODO: pass the current file to Dot*::writeGraph, so the user can put dot graphs in other
 //       files as well
 
-enum ContextOutputFormat {
-  ContextOutputFormat_Unspecified = 0,
+enum ContextOutputFormat
+{
+  ContextOutputFormat_Unspecified=0,
   ContextOutputFormat_Html,
   ContextOutputFormat_Latex,
   ContextOutputFormat_Rtf,
@@ -64,251 +64,301 @@ enum ContextOutputFormat {
   ContextOutputFormat_TagFile
 };
 
-struct ContextGlobals {
-  int dynSectionId;
-  QCString outputDir;
+struct ContextGlobals
+{
+  int                 dynSectionId;
+  QCString            outputDir;
   ContextOutputFormat outputFormat;
 } g_globals;
 
 /** @brief Scoped smart pointer */
-template <class T> class ScopedPtr {
-private:
-  T *m_ptr;
-  ScopedPtr(const ScopedPtr &);
-  ScopedPtr &operator=(const ScopedPtr &);
-  void operator==(const ScopedPtr &) const;
-  void operator!=(const ScopedPtr &) const;
-
-public:
-  typedef T Type;
-  explicit ScopedPtr(T *p = 0) : m_ptr(p) {}
-  ~ScopedPtr() { delete m_ptr; };
-  T &operator*() const { return *m_ptr; }
-  T *operator->() const { return m_ptr; }
-  T *get() const { return m_ptr; }
-  operator bool() const { return m_ptr != 0; }
-  void reset(T *p = 0) {
-    if (p != m_ptr) {
-      delete m_ptr;
-      m_ptr = p;
-    }
-  }
+template<class T> class ScopedPtr
+{
+  private:
+    T *m_ptr;
+    ScopedPtr(const ScopedPtr &);
+    ScopedPtr &operator=(const ScopedPtr &);
+    void operator==(const ScopedPtr &) const;
+    void operator!=(const ScopedPtr &) const;
+
+  public:
+    typedef T Type;
+    explicit ScopedPtr(T *p=0) : m_ptr(p) {}
+    ~ScopedPtr() { delete m_ptr; };
+    T &operator*() const { return *m_ptr; }
+    T *operator->() const { return m_ptr; }
+    T *get() const { return m_ptr; }
+    operator bool() const { return m_ptr!=0; }
+    void reset(T *p=0) { if (p!=m_ptr) { delete m_ptr; m_ptr = p; } }
 };
 
 /** @brief Reference counting smart pointer */
-template <class T> class SharedPtr {
-private:
-  T *m_ptr;
-  SharedPtr(const SharedPtr &);
-  SharedPtr &operator=(const SharedPtr &p);
-  void operator==(const SharedPtr &) const;
-  void operator!=(const SharedPtr &) const;
-
-public:
-  typedef T Type;
-  explicit SharedPtr(T *p = 0) : m_ptr(p) {
-    if (m_ptr)
-      m_ptr->addRef();
-  }
-  ~SharedPtr() {
-    if (m_ptr)
-      m_ptr->release();
-  };
-  T &operator*() const { return *m_ptr; }
-  T *operator->() const { return m_ptr; }
-  T *get() const { return m_ptr; }
-  operator bool() const { return m_ptr != 0; }
-  void reset(T *p = 0) {
-    if (p)
-      p->addRef();
-    if (m_ptr)
-      m_ptr->release();
-    m_ptr = p;
-  }
+template<class T> class SharedPtr
+{
+  private:
+    T *m_ptr;
+    SharedPtr(const SharedPtr &);
+    SharedPtr &operator=(const SharedPtr &p);
+    void operator==(const SharedPtr &) const;
+    void operator!=(const SharedPtr &) const;
+
+  public:
+    typedef T Type;
+    explicit SharedPtr(T *p=0) : m_ptr(p) { if (m_ptr) m_ptr->addRef(); }
+    ~SharedPtr() { if (m_ptr) m_ptr->release(); };
+    T &operator*() const { return *m_ptr; }
+    T *operator->() const { return m_ptr; }
+    T *get() const { return m_ptr; }
+    operator bool() const { return m_ptr!=0; }
+    void reset(T *p=0)
+    {
+      if (p) p->addRef();
+      if (m_ptr) m_ptr->release();
+      m_ptr = p;
+    }
 };
 
 /** @brief Template List iterator support */
-class GenericConstIterator : public TemplateListIntf::ConstIterator {
-public:
-  GenericConstIterator(const QList<TemplateVariant> &list) : m_it(list) {}
-  virtual ~GenericConstIterator() {}
-  void toFirst() { m_it.toFirst(); }
-  void toLast() { m_it.toLast(); }
-  void toNext() {
-    if (m_it.current())
-      ++m_it;
-  }
-  void toPrev() {
-    if (m_it.current())
-      --m_it;
-  }
-  bool current(TemplateVariant &v) const {
-    if (m_it.current()) {
-      v = *m_it.current();
-      return TRUE;
-    } else {
-      v = TemplateVariant();
-      return FALSE;
+class GenericConstIterator : public TemplateListIntf::ConstIterator
+{
+  public:
+    GenericConstIterator(const QList<TemplateVariant> &list)
+      : m_it(list) { }
+    virtual ~GenericConstIterator() {}
+    void toFirst()
+    {
+      m_it.toFirst();
     }
-  }
-
-private:
-  QListIterator<TemplateVariant> m_it;
+    void toLast()
+    {
+      m_it.toLast();
+    }
+    void toNext()
+    {
+      if (m_it.current()) ++m_it;
+    }
+    void toPrev()
+    {
+      if (m_it.current()) --m_it;
+    }
+    bool current(TemplateVariant &v) const
+    {
+      if (m_it.current())
+      {
+        v = *m_it.current();
+        return TRUE;
+      }
+      else
+      {
+        v = TemplateVariant();
+        return FALSE;
+      }
+    }
+  private:
+    QListIterator<TemplateVariant> m_it;
 };
 
 //------------------------------------------------------------------------
 
 /** @brief standard template list implementation */
-class GenericNodeListContext : public TemplateListIntf {
-public:
-  GenericNodeListContext() : m_refCount(0) { m_children.setAutoDelete(TRUE); }
-  static GenericNodeListContext *alloc() { return new GenericNodeListContext; }
-
-  // TemplateListIntf methods
-  int count() const { return (int)m_children.count(); }
-  TemplateVariant at(int index) const {
-    TemplateVariant result;
-    if (index >= 0 && index < count()) {
-      result = *m_children.at(index);
-    }
-    return result;
-  }
-  TemplateListIntf::ConstIterator *createIterator() const {
-    return new GenericConstIterator(m_children);
-  }
+class GenericNodeListContext : public TemplateListIntf
+{
+  public:
+    GenericNodeListContext() : m_refCount(0)
+    {
+      m_children.setAutoDelete(TRUE);
+    }
+    static GenericNodeListContext *alloc()
+    {
+      return new GenericNodeListContext;
+    }
 
-  void append(const TemplateVariant &ctn) {
-    m_children.append(new TemplateVariant(ctn));
-  }
-  bool isEmpty() const { return m_children.isEmpty(); }
-  int addRef() { return ++m_refCount; }
-  int release() {
-    int count = --m_refCount;
-    if (count <= 0) {
-      delete this;
-    }
-    return count;
-  }
+    // TemplateListIntf methods
+    int count() const
+    {
+      return (int)m_children.count();
+    }
+    TemplateVariant at(int index) const
+    {
+      TemplateVariant result;
+      if (index>=0 && index<count())
+      {
+        result = *m_children.at(index);
+      }
+      return result;
+    }
+    TemplateListIntf::ConstIterator *createIterator() const
+    {
+      return new GenericConstIterator(m_children);
+    }
 
-private:
-  mutable QList<TemplateVariant> m_children;
-  int m_refCount;
+    void append(const TemplateVariant &ctn)
+    {
+      m_children.append(new TemplateVariant(ctn));
+    }
+    bool isEmpty() const
+    {
+      return m_children.isEmpty();
+    }
+    int addRef()
+    {
+      return ++m_refCount;
+    }
+    int release()
+    {
+      int count = --m_refCount;
+      if (count<=0)
+      {
+        delete this;
+      }
+      return count;
+    }
+  private:
+    mutable QList<TemplateVariant> m_children;
+    int m_refCount;
 };
 
 //------------------------------------------------------------------------
 
 /** @brief Helper class to map a property name to a handler member function */
-template <typename T> class PropertyMapper {
-private:
-  struct PropertyFuncIntf {
-    virtual ~PropertyFuncIntf() {}
-    virtual TemplateVariant operator()(const T *obj) const = 0;
-  };
-  struct PropertyFunc : public PropertyFuncIntf {
-    typedef TemplateVariant (T::*Handler)() const;
-    PropertyFunc(Handler h) : handler(h) {}
-    TemplateVariant operator()(const T *obj) const { return (obj->*handler)(); }
-    Handler handler;
-  };
-
-public:
-  PropertyMapper() : m_map(63) { m_map.setAutoDelete(TRUE); }
-
-  /** Add a property to the map
-   *  @param[in] name   The name of the property to add.
-   *  @param[in] obj    The object handling access to the property.
-   *  @param[in] handle The method to call when the property is accessed.
-   */
-  void addProperty(const char *name, typename PropertyFunc::Handler handle) {
-    if (m_map.find(name)) {
-      err("Error: adding property '%s' more than once", name);
-    } else {
-      m_map.insert(name, new PropertyFunc(handle));
+template<typename T>
+class PropertyMapper
+{
+  private:
+    struct PropertyFuncIntf
+    {
+      virtual ~PropertyFuncIntf() {}
+      virtual TemplateVariant operator()(const T *obj) const = 0;
+    };
+    struct PropertyFunc : public PropertyFuncIntf
+    {
+      typedef TemplateVariant (T::*Handler)() const;
+      PropertyFunc(Handler h) : handler(h) {}
+      TemplateVariant operator()(const T *obj) const
+      {
+        return (obj->*handler)();
+      }
+      Handler handler;
+    };
+
+  public:
+    PropertyMapper() : m_map(63) { m_map.setAutoDelete(TRUE); }
+
+    /** Add a property to the map
+     *  @param[in] name   The name of the property to add.
+     *  @param[in] obj    The object handling access to the property.
+     *  @param[in] handle The method to call when the property is accessed.
+     */
+    void addProperty(const char *name,typename PropertyFunc::Handler handle)
+    {
+      if (m_map.find(name))
+      {
+        err("Error: adding property '%s' more than once",name);
+      }
+      else
+      {
+        m_map.insert(name,new PropertyFunc(handle));
+      }
     }
-  }
 
-  /** Gets the value of a property.
-   *  @param[in] name The name of the property.
-   *  @returns A variant representing the properties value or an
-   *  invalid variant if it was not found.
-   */
-  TemplateVariant get(const T *obj, const char *name) const {
-    // printf("PropertyMapper::get(%s)\n",name);
-    TemplateVariant result;
-    PropertyFuncIntf *func = m_map.find(name);
-    if (func) {
-      result = (*func)(obj);
-    }
-    return result;
-  }
+    /** Gets the value of a property.
+     *  @param[in] name The name of the property.
+     *  @returns A variant representing the properties value or an
+     *  invalid variant if it was not found.
+     */
+    TemplateVariant get(const T *obj,const char *name) const
+    {
+      //printf("PropertyMapper::get(%s)\n",name);
+      TemplateVariant result;
+      PropertyFuncIntf *func = m_map.find(name);
+      if (func)
+      {
+        result = (*func)(obj);
+      }
+      return result;
+    }
 
-private:
-  QDict<PropertyFuncIntf> m_map;
+  private:
+    QDict<PropertyFuncIntf> m_map;
 };
 
+
 //------------------------------------------------------------------------
 
 //%% struct Config : configuration options
 //%% {
-class ConfigContext::Private {
-public:
-  Private() { m_cachedLists.setAutoDelete(TRUE); }
-  virtual ~Private() {}
-  TemplateVariant fetchList(const QCString &name, const QStrList *list) {
-    TemplateVariant *v = m_cachedLists.find(name);
-    if (v == 0) {
-      TemplateList *tlist = TemplateList::alloc();
-      m_cachedLists.insert(name, new TemplateVariant(tlist));
-      QStrListIterator li(*list);
-      char *s;
-      for (li.toFirst(); (s = li.current()); ++li) {
-        tlist->append(s);
-      }
-      return tlist;
-    } else {
-      return *v;
+class ConfigContext::Private
+{
+  public:
+    Private() { m_cachedLists.setAutoDelete(TRUE); }
+    virtual ~Private() { }
+    TemplateVariant fetchList(const QCString &name,const QStrList *list)
+    {
+      TemplateVariant *v = m_cachedLists.find(name);
+      if (v==0)
+      {
+        TemplateList *tlist = TemplateList::alloc();
+        m_cachedLists.insert(name,new TemplateVariant(tlist));
+        QStrListIterator li(*list);
+        char *s;
+        for (li.toFirst();(s=li.current());++li)
+        {
+          tlist->append(s);
+        }
+        return tlist;
+      }
+      else
+      {
+        return *v;
+      }
     }
-  }
-
-private:
-  QDict<TemplateVariant> m_cachedLists;
+  private:
+    QDict<TemplateVariant> m_cachedLists;
 };
 //%% }
 
-ConfigContext::ConfigContext() : RefCountedContext("ConfigContext") {
+ConfigContext::ConfigContext() : RefCountedContext("ConfigContext")
+{
   p = new Private;
 }
 
-ConfigContext::~ConfigContext() { delete p; }
+ConfigContext::~ConfigContext()
+{
+  delete p;
+}
 
-TemplateVariant ConfigContext::get(const char *name) const {
+TemplateVariant ConfigContext::get(const char *name) const
+{
   TemplateVariant result;
-  if (name) {
+  if (name)
+  {
     const ConfigValues::Info *option = ConfigValues::instance().get(name);
-    if (option) {
-      switch (option->type) {
-      case ConfigValues::Info::Bool: {
-        bool b =
-            ConfigValues::instance().*((ConfigValues::InfoBool *)option)->item;
-        return TemplateVariant(b);
-      }
-      case ConfigValues::Info::Int: {
-        int i =
-            ConfigValues::instance().*((ConfigValues::InfoInt *)option)->item;
-        return TemplateVariant(i);
-      }
-      case ConfigValues::Info::String: {
-        QCString s = ConfigValues::instance().*
-                     ((ConfigValues::InfoString *)option)->item;
-        return TemplateVariant(s);
-      }
-      case ConfigValues::Info::List: {
-        const QStrList &l =
-            ConfigValues::instance().*((ConfigValues::InfoList *)option)->item;
-        return p->fetchList(name, &l);
-      }
-      default:
-        break;
+    if (option)
+    {
+      switch (option->type)
+      {
+        case ConfigValues::Info::Bool:
+          {
+            bool b = ConfigValues::instance().*((ConfigValues::InfoBool*)option)->item;
+            return TemplateVariant(b);
+          }
+        case ConfigValues::Info::Int:
+          {
+            int i = ConfigValues::instance().*((ConfigValues::InfoInt*)option)->item;
+            return TemplateVariant(i);
+          }
+        case ConfigValues::Info::String:
+          {
+            QCString s = ConfigValues::instance().*((ConfigValues::InfoString*)option)->item;
+            return TemplateVariant(s);
+          }
+        case ConfigValues::Info::List:
+          {
+            const QStrList &l = ConfigValues::instance().*((ConfigValues::InfoList*)option)->item;
+            return p->fetchList(name,&l);
+          }
+        default:
+          break;
       }
     }
   }
@@ -319,295 +369,232 @@ TemplateVariant ConfigContext::get(const char *name) const {
 
 //%% struct Doxygen: global information
 //%% {
-class DoxygenContext::Private {
-public:
-  TemplateVariant version() const { return versionString; }
-  TemplateVariant date() const { return dateToString(TRUE); }
-  TemplateVariant maxJaxCodeFile() const { return m_cache.maxJaxCodeFile; }
-  Private() {
-    static bool init = FALSE;
-    if (!init) {
-      //%% string version
-      s_inst.addProperty("version", &Private::version);
-      //%% string date
-      s_inst.addProperty("date", &Private::date);
-      //%% string maxJaxCodeFile
-      s_inst.addProperty("mathJaxCodeFile", &Private::maxJaxCodeFile);
-      init = TRUE;
+class DoxygenContext::Private
+{
+  public:
+    TemplateVariant version() const
+    {
+      return versionString;
     }
-  }
-  TemplateVariant get(const char *n) const { return s_inst.get(this, n); }
-
-private:
-  struct Cachable {
-    Cachable() {
-      maxJaxCodeFile = fileToString(Config_getString(MATHJAX_CODEFILE));
+    TemplateVariant date() const
+    {
+      return dateToString(TRUE);
+    }
+    TemplateVariant maxJaxCodeFile() const
+    {
+      return m_cache.maxJaxCodeFile;
+    }
+    Private()
+    {
+      static bool init=FALSE;
+      if (!init)
+      {
+        //%% string version
+        s_inst.addProperty("version",         &Private::version);
+        //%% string date
+        s_inst.addProperty("date",            &Private::date);
+        //%% string maxJaxCodeFile
+        s_inst.addProperty("mathJaxCodeFile", &Private::maxJaxCodeFile);
+        init=TRUE;
+      }
+    }
+    TemplateVariant get(const char *n) const
+    {
+      return s_inst.get(this,n);
     }
-    QCString maxJaxCodeFile;
-  };
-  mutable Cachable m_cache;
-  static PropertyMapper<DoxygenContext::Private> s_inst;
+  private:
+    struct Cachable
+    {
+      Cachable() { maxJaxCodeFile=fileToString(Config_getString(MATHJAX_CODEFILE)); }
+      QCString maxJaxCodeFile;
+    };
+    mutable Cachable m_cache;
+    static PropertyMapper<DoxygenContext::Private> s_inst;
 };
 //%% }
 
 PropertyMapper<DoxygenContext::Private> DoxygenContext::Private::s_inst;
 //                                (PropertyMapper<DoxygenContext::Private>::instance());
 
-DoxygenContext::DoxygenContext() : RefCountedContext("DoxygenContext") {
+DoxygenContext::DoxygenContext() : RefCountedContext("DoxygenContext")
+{
   p = new Private;
 }
 
-DoxygenContext::~DoxygenContext() { delete p; }
+DoxygenContext::~DoxygenContext()
+{
+  delete p;
+}
 
-TemplateVariant DoxygenContext::get(const char *n) const { return p->get(n); }
+TemplateVariant DoxygenContext::get(const char *n) const
+{
+  return p->get(n);
+}
 
 //------------------------------------------------------------------------
 
 //%% struct Translator: translation methods
 //%% {
-class TranslateContext::Private {
-public:
-  TemplateVariant
-  handleGeneratedAt(const QValueList<TemplateVariant> &args) const {
-    if (args.count() == 2) {
-      return theTranslator->trGeneratedAt(args[0].toString(),
-                                          args[1].toString());
-    } else {
-      err("tr.generateAt should take two arguments, got %d!\n", args.count());
-    }
-    return TemplateVariant();
-  }
-  TemplateVariant
-  handleInheritanceDiagramFor(const QValueList<TemplateVariant> &args) const {
-    if (args.count() == 1) {
-      return theTranslator->trClassDiagram(args[0].toString());
-    } else {
-      err("tr.inheritanceDiagramFor should take one argument, got %d!\n",
-          args.count());
-    }
-    return TemplateVariant();
-  }
-  TemplateVariant
-  handleCollaborationDiagramFor(const QValueList<TemplateVariant> &args) const {
-    if (args.count() == 1) {
-      return theTranslator->trCollaborationDiagram(args[0].toString());
-    } else {
-      err("tr.collaborationDiagramFor should take one argument, got %d!\n",
-          args.count());
-    }
-    return TemplateVariant();
-  }
-  TemplateVariant
-  handleDirDependencyGraphFor(const QValueList<TemplateVariant> &args) const {
-    if (args.count() == 1) {
-      return theTranslator->trDirDepGraph(args[0].toString());
-    } else {
-      err("tr.dirDependencyGraphFor should take one argument, got %d!\n",
-          args.count());
-    }
-    return TemplateVariant();
-  }
-  TemplateVariant
-  handleInheritsList(const QValueList<TemplateVariant> &args) const {
-    if (args.count() == 1) {
-      return theTranslator->trInheritsList(args[0].toInt());
-    } else {
-      err("tr.inheritsList should take one integer argument, got %d!\n",
-          args.count());
-    }
-    return TemplateVariant();
-  }
-  TemplateVariant
-  handleInheritedByList(const QValueList<TemplateVariant> &args) const {
-    if (args.count() == 1) {
-      return theTranslator->trInheritedByList(args[0].toInt());
-    } else {
-      err("tr.inheritedByList should take one integer argument, got %d!\n",
-          args.count());
-    }
-    return TemplateVariant();
-  }
-  TemplateVariant
-  handleWriteList(const QValueList<TemplateVariant> &args) const {
-    if (args.count() == 1) {
-      return theTranslator->trWriteList(args[0].toInt());
-    } else {
-      err("tr.*List should take one integer argument, got %d!\n", args.count());
-    }
-    return TemplateVariant();
-  }
-  TemplateVariant
-  handleImplementedBy(const QValueList<TemplateVariant> &args) const {
-    if (args.count() == 1) {
-      return theTranslator->trImplementedInList(args[0].toInt());
-    } else {
-      err("tr.implementedBy should take one integer argument, got %d!\n",
-          args.count());
-    }
-    return TemplateVariant();
-  }
-  TemplateVariant
-  handleReimplementedBy(const QValueList<TemplateVariant> &args) const {
-    if (args.count() == 1) {
-      return theTranslator->trReimplementedInList(args[0].toInt());
-    } else {
-      err("tr.reimplementedBy should take one integer argument, got %d!\n",
-          args.count());
-    }
-    return TemplateVariant();
-  }
-  TemplateVariant
-  handleSourceRefs(const QValueList<TemplateVariant> &args) const {
-    if (args.count() == 1) {
-      return theTranslator->trReferences() + " " +
-             theTranslator->trWriteList(args[0].toInt()) + ".";
-    } else {
-      err("tr.sourceRefs should take one integer argument, got %d\n",
-          args.count());
-    }
-    return TemplateVariant();
-  }
-  TemplateVariant
-  handleSourceRefBys(const QValueList<TemplateVariant> &args) const {
-    if (args.count() == 1) {
-      return theTranslator->trReferencedBy() + " " +
-             theTranslator->trWriteList(args[0].toInt()) + ".";
-    } else {
-      err("tr.sourceRefBys should take one integer argument, got %d\n",
-          args.count());
-    }
-    return TemplateVariant();
-  }
-  TemplateVariant
-  handleIncludeDependencyGraph(const QValueList<TemplateVariant> &args) const {
-    if (args.count() == 1) {
-      return theTranslator->trInclDepGraph(args[0].toString());
-    } else {
-      err("tr.includeDependencyGraph should take one string argument, got %d\n",
-          args.count());
-    }
-    return TemplateVariant();
-  }
-
-  TemplateVariant generatedBy() const { return theTranslator->trGeneratedBy(); }
-  TemplateVariant generatedAt() const {
-    return TemplateVariant::Delegate::fromMethod<Private,
-                                                 &Private::handleGeneratedAt>(
-        this);
-  }
-  TemplateVariant inheritanceDiagramFor() const {
-    return TemplateVariant::Delegate::fromMethod<
-        Private, &Private::handleInheritanceDiagramFor>(this);
-  }
-  TemplateVariant collaborationDiagramFor() const {
-    return TemplateVariant::Delegate::fromMethod<
-        Private, &Private::handleCollaborationDiagramFor>(this);
-  }
-  TemplateVariant dirDependencyGraphFor() const {
-    return TemplateVariant::Delegate::fromMethod<
-        Private, &Private::handleDirDependencyGraphFor>(this);
-  }
-  TemplateVariant search() const { return theTranslator->trSearch(); }
-  TemplateVariant mainPage() const { return theTranslator->trMainPage(); }
-  TemplateVariant classes() const {
-    return theTranslator->trClasses();
-    // TODO: VHDL: trVhdlType(VhdlDocGen::ENTITY,FALSE)
-    // TODO: Fortran: trDataTypes()
-  }
-  TemplateVariant classList() const { return theTranslator->trCompoundList(); }
-  TemplateVariant classListDescription() const {
-    return theTranslator->trCompoundListDescription();
-  }
-  TemplateVariant classIndex() const {
-    return theTranslator->trCompoundIndex();
-  }
-  TemplateVariant namespaceIndex() const {
-    return theTranslator->trNamespaceIndex();
-  }
-  TemplateVariant classHierarchy() const {
-    return theTranslator->trClassHierarchy();
-  }
-  TemplateVariant classMembers() const {
-    return theTranslator->trCompoundMembers();
-  }
-  TemplateVariant modules() const { return theTranslator->trModules(); }
-  TemplateVariant moduleIndex() const { return theTranslator->trModuleIndex(); }
-  TemplateVariant namespaces() const {
-    if (m_javaOpt || m_vhdlOpt) {
-      return theTranslator->trPackages();
-    } else if (m_fortranOpt) {
-      return theTranslator->trModules();
-    } else {
-      return theTranslator->trNamespaces();
-    }
-  }
-  TemplateVariant files() const { return theTranslator->trFile(TRUE, FALSE); }
-  TemplateVariant fileIndex() const { return theTranslator->trFileIndex(); }
-  TemplateVariant pages() const { return theTranslator->trRelatedPages(); }
-  TemplateVariant examples() const { return theTranslator->trExamples(); }
-  TemplateVariant namespaceList() const {
-    if (m_javaOpt || m_vhdlOpt) {
-      return theTranslator->trPackages();
-    } else if (m_fortranOpt) {
-      return theTranslator->trModulesList();
-    } else {
-      return theTranslator->trNamespaceList();
-    }
-  }
-  TemplateVariant namespaceMembers() const {
-    if (m_javaOpt || m_vhdlOpt) {
-      return theTranslator->trPackageMembers();
-    } else if (m_fortranOpt) {
-      return theTranslator->trModulesMembers();
-    } else {
-      return theTranslator->trNamespaceMembers();
-    }
-  }
-  TemplateVariant moduleDocumentation() const {
-    return theTranslator->trModuleDocumentation();
-  }
-  TemplateVariant fileDocumentation() const {
-    return theTranslator->trFileDocumentation();
-  }
-  TemplateVariant fileList() const { return theTranslator->trFileList(); }
-  TemplateVariant fileMembers() const { return theTranslator->trFileMembers(); }
-  TemplateVariant fileMembersDescription() const {
-    static bool extractAll = Config_getBool(EXTRACT_ALL);
-    return theTranslator->trFileMembersDescription(extractAll);
-  }
-  TemplateVariant namespaceMembersDescription() const {
-    static bool extractAll = Config_getBool(EXTRACT_ALL);
-    return theTranslator->trNamespaceMemberDescription(extractAll);
-  }
-  TemplateVariant classHierarchyDescription() const {
-    return theTranslator->trClassHierarchyDescription();
-  }
-  TemplateVariant gotoGraphicalHierarchy() const {
-    return theTranslator->trGotoGraphicalHierarchy();
-  }
-  TemplateVariant gotoTextualHierarchy() const {
-    return theTranslator->trGotoTextualHierarchy();
-  }
-  TemplateVariant classMembersDescription() const {
-    static bool extractAll = Config_getBool(EXTRACT_ALL);
-    static bool fortranOpt = Config_getBool(OPTIMIZE_FOR_FORTRAN);
-    if (fortranOpt) {
-      return theTranslator->trCompoundMembersDescriptionFortran(extractAll);
-    } else {
-      return theTranslator->trCompoundMembersDescription(extractAll);
-    }
-
-
+class TranslateContext::Private
+{
+  public:
 
-    TemplateVariant generatedBy() const
+    TemplateVariant handleGeneratedAt(const QValueList<TemplateVariant> &args) const
     {
-      return theTranslator->trGeneratedBy();
+      if (args.count()==2)
+      {
+        return theTranslator->trGeneratedAt(args[0].toString(),args[1].toString());
+      }
+      else
+      {
+        err("tr.generateAt should take two arguments, got %d!\n",args.count());
+      }
+      return TemplateVariant();
     }
-    TemplateVariant generatedAt() const
+    TemplateVariant handleInheritanceDiagramFor(const QValueList<TemplateVariant> &args) const
     {
-      return TemplateVariant::Delegate::fromMethod<Private,&Private::handleGeneratedAt>(this);
-    }
-    TemplateVariant inheritanceDiagramFor() const
+      if (args.count()==1)
+      {
+        return theTranslator->trClassDiagram(args[0].toString());
+      }
+      else
+      {
+        err("tr.inheritanceDiagramFor should take one argument, got %d!\n",args.count());
+      }
+      return TemplateVariant();
+    }
+    TemplateVariant handleCollaborationDiagramFor(const QValueList<TemplateVariant> &args) const
+    {
+      if (args.count()==1)
+      {
+        return theTranslator->trCollaborationDiagram(args[0].toString());
+      }
+      else
+      {
+        err("tr.collaborationDiagramFor should take one argument, got %d!\n",args.count());
+      }
+      return TemplateVariant();
+    }
+    TemplateVariant handleDirDependencyGraphFor(const QValueList<TemplateVariant> &args) const
+    {
+      if (args.count()==1)
+      {
+        return theTranslator->trDirDepGraph(args[0].toString());
+      }
+      else
+      {
+        err("tr.dirDependencyGraphFor should take one argument, got %d!\n",args.count());
+      }
+      return TemplateVariant();
+    }
+    TemplateVariant handleInheritsList(const QValueList<TemplateVariant> &args) const
+    {
+      if (args.count()==1)
+      {
+        return theTranslator->trInheritsList(args[0].toInt());
+      }
+      else
+      {
+        err("tr.inheritsList should take one integer argument, got %d!\n",args.count());
+      }
+      return TemplateVariant();
+    }
+    TemplateVariant handleInheritedByList(const QValueList<TemplateVariant> &args) const
+    {
+      if (args.count()==1)
+      {
+        return theTranslator->trInheritedByList(args[0].toInt());
+      }
+      else
+      {
+        err("tr.inheritedByList should take one integer argument, got %d!\n",args.count());
+      }
+      return TemplateVariant();
+    }
+    TemplateVariant handleWriteList(const QValueList<TemplateVariant> &args) const
+    {
+      if (args.count()==1)
+      {
+        return theTranslator->trWriteList(args[0].toInt());
+      }
+      else
+      {
+        err("tr.*List should take one integer argument, got %d!\n",args.count());
+      }
+      return TemplateVariant();
+    }
+    TemplateVariant handleImplementedBy(const QValueList<TemplateVariant> &args) const
+    {
+      if (args.count()==1)
+      {
+        return theTranslator->trImplementedInList(args[0].toInt());
+      }
+      else
+      {
+        err("tr.implementedBy should take one integer argument, got %d!\n",args.count());
+      }
+      return TemplateVariant();
+    }
+    TemplateVariant handleReimplementedBy(const QValueList<TemplateVariant> &args) const
+    {
+      if (args.count()==1)
+      {
+        return theTranslator->trReimplementedInList(args[0].toInt());
+      }
+      else
+      {
+        err("tr.reimplementedBy should take one integer argument, got %d!\n",args.count());
+      }
+      return TemplateVariant();
+    }
+    TemplateVariant handleSourceRefs(const QValueList<TemplateVariant> &args) const
+    {
+      if (args.count()==1)
+      {
+        return theTranslator->trReferences()+" "+theTranslator->trWriteList(args[0].toInt())+".";
+      }
+      else
+      {
+        err("tr.sourceRefs should take one integer argument, got %d\n",args.count());
+      }
+      return TemplateVariant();
+    }
+    TemplateVariant handleSourceRefBys(const QValueList<TemplateVariant> &args) const
+    {
+      if (args.count()==1)
+      {
+        return theTranslator->trReferencedBy()+" "+theTranslator->trWriteList(args[0].toInt())+".";
+      }
+      else
+      {
+        err("tr.sourceRefBys should take one integer argument, got %d\n",args.count());
+      }
+      return TemplateVariant();
+    }
+    TemplateVariant handleIncludeDependencyGraph(const QValueList<TemplateVariant> &args) const
+    {
+      if (args.count()==1)
+      {
+        return theTranslator->trInclDepGraph(args[0].toString());
+      }
+      else
+      {
+        err("tr.includeDependencyGraph should take one string argument, got %d\n",args.count());
+      }
+      return TemplateVariant();
+    }
+
+
+
+    TemplateVariant generatedBy() const
+    {
+      return theTranslator->trGeneratedBy();
+    }
+    TemplateVariant generatedAt() const
+    {
+      return TemplateVariant::Delegate::fromMethod<Private,&Private::handleGeneratedAt>(this);
+    }
+    TemplateVariant inheritanceDiagramFor() const
     {
       return TemplateVariant::Delegate::fromMethod<Private,&Private::handleInheritanceDiagramFor>(this);
     }
@@ -1532,6 +1519,7 @@ class DefinitionContext
         case SrcLangExt_Cpp:      result="cpp";      break;
         case SrcLangExt_JS:       result="js";       break;
         case SrcLangExt_Python:   result="python";   break;
+        case SrcLangExt_Prolog:   result="prolog";   break;
         case SrcLangExt_Fortran:  result="fortran";  break;
         case SrcLangExt_VHDL:     result="vhdl";     break;
         case SrcLangExt_XML:      result="xml";      break;
@@ -2924,1629 +2912,1024 @@ class NamespaceContext::Private : public DefinitionContext<NamespaceContext::Pri
 };
 //%% }
 
-PropertyMapper<TranslateContext::Private> TranslateContext::Private::s_inst;
-
-TranslateContext::TranslateContext() : RefCountedContext("TranslateContext") {
-  p = new Private;
-}
-
-TranslateContext::~TranslateContext() { delete p; }
-
-TemplateVariant TranslateContext::get(const char *n) const { return p->get(n); }
+PropertyMapper<NamespaceContext::Private> NamespaceContext::Private::s_inst;
 
-static TemplateVariant parseDoc(Definition *def, const QCString &file, int line,
-                                const QCString &relPath, const QCString &docStr,
-                                bool isBrief) {
-  TemplateVariant result;
-  DocRoot *root = validatingParseDoc(file, line, def, 0, docStr, TRUE, FALSE, 0,
-                                     isBrief, FALSE);
-  QGString docs;
-  {
-    FTextStream ts(&docs);
-    switch (g_globals.outputFormat) {
-    case ContextOutputFormat_Html: {
-      HtmlCodeGenerator codeGen(ts, relPath);
-      HtmlDocVisitor visitor(ts, codeGen, def);
-      root->accept(&visitor);
-    } break;
-    case ContextOutputFormat_Latex: {
-      LatexCodeGenerator codeGen(ts, relPath, file);
-      LatexDocVisitor visitor(ts, codeGen, def->getDefFileExtension(), FALSE);
-      root->accept(&visitor);
-    } break;
-    // TODO: support other generators
-    default:
-      err("context.cpp: output format not yet supported");
-      break;
-    }
-  }
-  bool isEmpty = root->isEmpty();
-  if (isEmpty)
-    result = "";
-  else
-    result = TemplateVariant(docs, TRUE);
-  delete root;
-  return result;
+NamespaceContext::NamespaceContext(NamespaceDef *nd) : RefCountedContext("NamespaceContext")
+{
+  p = new Private(nd);
 }
 
-static TemplateVariant parseCode(MemberDef *md, const QCString &scopeName,
-                                 const QCString &relPath, const QCString &code,
-                                 int startLine = -1, int endLine = -1,
-                                 bool showLineNumbers = FALSE) {
-  ParserInterface *pIntf =
-      Doxygen::parserManager->getParser(md->getDefFileExtension());
-  pIntf->resetCodeParserState();
-  QGString s;
-  FTextStream t(&s);
-  switch (g_globals.outputFormat) {
-  case ContextOutputFormat_Html: {
-    HtmlCodeGenerator codeGen(t, relPath);
-    pIntf->parseCode(codeGen, scopeName, code, md->getLanguage(), FALSE, 0,
-                     md->getBodyDef(), startLine, endLine, TRUE, md,
-                     showLineNumbers, md);
-  } break;
-  case ContextOutputFormat_Latex: {
-    LatexCodeGenerator codeGen(t, relPath, md->docFile());
-    pIntf->parseCode(codeGen, scopeName, code, md->getLanguage(), FALSE, 0,
-                     md->getBodyDef(), startLine, endLine, TRUE, md,
-                     showLineNumbers, md);
-  } break;
-  // TODO: support other generators
-  default:
-    err("context.cpp: output format not yet supported");
-    break;
-  }
-  return TemplateVariant(s.data(), TRUE);
+NamespaceContext::~NamespaceContext()
+{
+  delete p;
 }
 
-static TemplateVariant parseCode(FileDef *fd, const QCString &relPath) {
-  static bool filterSourceFiles = Config_getBool(FILTER_SOURCE_FILES);
-  ParserInterface *pIntf =
-      Doxygen::parserManager->getParser(fd->getDefFileExtension());
-  pIntf->resetCodeParserState();
-  QGString s;
-  FTextStream t(&s);
-  switch (g_globals.outputFormat) {
-  case ContextOutputFormat_Html: {
-    HtmlCodeGenerator codeGen(t, relPath);
-    pIntf->parseCode(
-        codeGen, 0,
-        fileToString(fd->absFilePath(), filterSourceFiles, TRUE), // the sources
-        fd->getLanguage(),                                        // lang
-        FALSE, // isExampleBlock
-        0,     // exampleName
-        fd,    // fileDef
-        -1,    // startLine
-        -1,    // endLine
-        FALSE, // inlineFragment
-        0,     // memberDef
-        TRUE,  // showLineNumbers
-        0,     // searchCtx
-        TRUE   // collectXRefs, TODO: should become FALSE
-        );
-  } break;
-  case ContextOutputFormat_Latex: {
-    LatexCodeGenerator codeGen(t, relPath, fd->docFile());
-    pIntf->parseCode(
-        codeGen, 0,
-        fileToString(fd->absFilePath(), filterSourceFiles, TRUE), // the sources
-        fd->getLanguage(),                                        // lang
-        FALSE, // isExampleBlock
-        0,     // exampleName
-        fd,    // fileDef
-        -1,    // startLine
-        -1,    // endLine
-        FALSE, // inlineFragment
-        0,     // memberDef
-        TRUE,  // showLineNumbers
-        0,     // searchCtx
-        TRUE   // collectXRefs, TODO: should become FALSE
-        );
-  } break;
-  // TODO: support other generators
-  default:
-    err("context.cpp: output format not yet supported");
-    break;
-  }
-  return TemplateVariant(s.data(), TRUE);
+TemplateVariant NamespaceContext::get(const char *n) const
+{
+  return p->get(n);
 }
 
 //------------------------------------------------------------------------
 
-//%% struct Symbol: shared info for all symbols
+//%% struct File(Symbol): file information
 //%% {
-template <typename T> class DefinitionContext {
-public:
-  DefinitionContext(Definition *d) : m_def(d) { assert(d != 0); }
-  void addBaseProperties(PropertyMapper<T> &inst) {
-    //%% string name: the name of the symbol
-    inst.addProperty("name", &DefinitionContext::name);
-    //%% string bareName: the bare name of the symbol with scope info
-    inst.addProperty("bareName", &DefinitionContext::bareName);
-    //%% string relPath: the relative path to the root of the output
-    //(CREATE_SUBDIRS)
-    inst.addProperty("relPath", &DefinitionContext::relPath);
-    //%% string fileName: the file name of the output file associated with the
-    //symbol (without extension)
-    inst.addProperty("fileName", &DefinitionContext::fileName);
-    //%% string anchor: anchor within the page
-    inst.addProperty("anchor", &DefinitionContext::anchor);
-    //%% string details: the detailed documentation for this symbol
-    inst.addProperty("details", &DefinitionContext::details);
-    //%% string brief: the brief description for this symbol
-    inst.addProperty("brief", &DefinitionContext::brief);
-    //%% string inbodyDocs: the documentation found in the body
-    inst.addProperty("inbodyDocs", &DefinitionContext::inbodyDocs);
-    //%% string sourceFileName: the file name of the source file (without
-    //extension)
-    inst.addProperty("sourceFileName", &DefinitionContext::sourceFileName);
-    //%% bool isLinkable: can the symbol be linked to?
-    inst.addProperty("isLinkable", &DefinitionContext::isLinkable);
-    //%% bool isLinkableInProject: can the symbol be linked within this project?
-    inst.addProperty("isLinkableInProject",
-                     &DefinitionContext::isLinkableInProject);
-    //%% int dynSectionId: identifier that can be used for collapsable sections
-    inst.addProperty("dynSectionId", &DefinitionContext::dynSectionId);
-    //%% string language: the programming language in which the symbol is
-    //written
-    inst.addProperty("language", &DefinitionContext::language);
-    //%% string sourceDef: A link to the source definition
-    inst.addProperty("sourceDef", &DefinitionContext::sourceDef);
-    //%% list[Definition] navigationPath: Breadcrumb navigation path to this
-    //item
-    inst.addProperty("navigationPath", &DefinitionContext::navigationPath);
-    //%% string kind: Kind of compound object: class, namespace, module,
-    //package, page, dir
-    inst.addProperty("compoundKind", &DefinitionContext::compoundKind);
-    //%% bool isReference: is this definition imported via a tag file
-    inst.addProperty("isReference", &DefinitionContext::isReference);
-    //%% string externalReference: the link to the element in the remote
-    //documentation
-    inst.addProperty("externalReference",
-                     &DefinitionContext::externalReference);
-  }
-  TemplateVariant fileName() const { return m_def->getOutputFileBase(); }
-  TemplateVariant anchor() const { return m_def->anchor(); }
-  TemplateVariant sourceFileName() const { return m_def->getSourceFileBase(); }
-  TemplateVariant isLinkable() const { return m_def->isLinkable(); }
-  TemplateVariant isLinkableInProject() const {
-    return m_def->isLinkableInProject();
-  }
-  TemplateVariant name() const { return m_def->displayName(TRUE); }
-  TemplateVariant bareName() const { return m_def->displayName(FALSE); }
-  QCString relPathAsString() const {
-    static bool createSubdirs = Config_getBool(CREATE_SUBDIRS);
-    return createSubdirs ? QCString("../../") : QCString("");
-  }
-  virtual TemplateVariant relPath() const { return relPathAsString(); }
-  TemplateVariant details() const {
-    Cachable &cache = getCache();
-    if (!cache.details || g_globals.outputFormat != cache.detailsOutputFormat) {
-      cache.details.reset(new TemplateVariant(
-          parseDoc(m_def, m_def->docFile(), m_def->docLine(), relPathAsString(),
-                   m_def->documentation(), FALSE)));
-      cache.detailsOutputFormat = g_globals.outputFormat;
-    }
-    return *cache.details;
-  }
-  TemplateVariant brief() const {
-    Cachable &cache = getCache();
-    if (!cache.brief || g_globals.outputFormat != cache.briefOutputFormat) {
-      if (m_def->hasBriefDescription()) {
-        cache.brief.reset(new TemplateVariant(
-            parseDoc(m_def, m_def->briefFile(), m_def->briefLine(),
-                     relPathAsString(), m_def->briefDescription(), TRUE)));
-        cache.briefOutputFormat = g_globals.outputFormat;
-      } else {
-        cache.brief.reset(new TemplateVariant(""));
-      }
-    }
-    return *cache.brief;
-  }
-  TemplateVariant inbodyDocs() const {
-    Cachable &cache = getCache();
-    if (!cache.inbodyDocs ||
-        g_globals.outputFormat != cache.inbodyDocsOutputFormat) {
-      if (!m_def->inbodyDocumentation().isEmpty()) {
-        cache.inbodyDocs.reset(new TemplateVariant(
-            parseDoc(m_def, m_def->inbodyFile(), m_def->inbodyLine(),
-                     relPathAsString(), m_def->inbodyDocumentation(), FALSE)));
-        cache.inbodyDocsOutputFormat = g_globals.outputFormat;
-      } else {
-        cache.inbodyDocs.reset(new TemplateVariant(""));
-      }
-    }
-    return *cache.inbodyDocs;
-  }
-  TemplateVariant dynSectionId() const { return g_globals.dynSectionId; }
-  TemplateVariant language() const {
-    SrcLangExt lang = m_def->getLanguage();
-    QCString result = "unknown";
-    switch (lang) {
-    case SrcLangExt_Unknown:
-      break;
-    case SrcLangExt_IDL:
-      result = "idl";
-      break;
-    case SrcLangExt_Java:
-      result = "java";
-      break;
-    case SrcLangExt_CSharp:
-      result = "csharp";
-      break;
-    case SrcLangExt_D:
-      result = "d";
-      break;
-    case SrcLangExt_PHP:
-      result = "php";
-      break;
-    case SrcLangExt_ObjC:
-      result = "objc";
-      break;
-    case SrcLangExt_Cpp:
-      result = "cpp";
-      break;
-    case SrcLangExt_JS:
-      result = "js";
-      break;
-    case SrcLangExt_Prolog:
-      result = "prolog";
-      break;
-    case SrcLangExt_Python:
-      result = "python";
-      break;
-    case SrcLangExt_Fortran:
-      result = "fortran";
-      break;
-    case SrcLangExt_VHDL:
-      result = "vhdl";
-      break;
-    case SrcLangExt_XML:
-      result = "xml";
-      break;
-    case SrcLangExt_Tcl:
-      result = "tcl";
-      break;
-    case SrcLangExt_Markdown:
-      result = "markdown";
-      break;
+class FileContext::Private : public DefinitionContext<FileContext::Private>
+{
+  public:
+    Private(FileDef *fd) : DefinitionContext<FileContext::Private>(fd) , m_fileDef(fd)
+    {
+      if (fd==0) abort();
+      static bool init=FALSE;
+      if (!init)
+      {
+        addBaseProperties(s_inst);
+        s_inst.addProperty("title",                     &Private::title);
+        s_inst.addProperty("highlight",                 &Private::highlight);
+        s_inst.addProperty("subhighlight",              &Private::subHighlight);
+        s_inst.addProperty("versionInfo",               &Private::versionInfo);
+        s_inst.addProperty("includeList",               &Private::includeList);
+        s_inst.addProperty("hasIncludeGraph",           &Private::hasIncludeGraph);
+        s_inst.addProperty("hasIncludedByGraph",        &Private::hasIncludedByGraph);
+        s_inst.addProperty("includeGraph",              &Private::includeGraph);
+        s_inst.addProperty("includedByGraph",           &Private::includedByGraph);
+        s_inst.addProperty("hasDetails",                &Private::hasDetails);
+        s_inst.addProperty("hasSourceFile",             &Private::hasSourceFile);
+        s_inst.addProperty("sources",                   &Private::sources);
+        s_inst.addProperty("version",                   &Private::version);
+        s_inst.addProperty("classes",                   &Private::classes);
+        s_inst.addProperty("namespaces",                &Private::namespaces);
+        s_inst.addProperty("constantgroups",            &Private::constantgroups);
+        s_inst.addProperty("macros",                    &Private::macros);
+        s_inst.addProperty("typedefs",                  &Private::typedefs);
+        s_inst.addProperty("enums",                     &Private::enums);
+        s_inst.addProperty("functions",                 &Private::functions);
+        s_inst.addProperty("variables",                 &Private::variables);
+        s_inst.addProperty("memberGroups",              &Private::memberGroups);
+        s_inst.addProperty("detailedMacros",            &Private::detailedMacros);
+        s_inst.addProperty("detailedTypedefs",          &Private::detailedTypedefs);
+        s_inst.addProperty("detailedEnums",             &Private::detailedEnums);
+        s_inst.addProperty("detailedFunctions",         &Private::detailedFunctions);
+        s_inst.addProperty("detailedVariables",         &Private::detailedVariables);
+        s_inst.addProperty("inlineClasses",             &Private::inlineClasses);
+        s_inst.addProperty("compoundType",              &Private::compoundType);
+        init=TRUE;
+      }
+      if (!fd->cookie()) { fd->setCookie(new FileContext::Private::Cachable(fd)); }
     }
-    return result;
-  }
-  TemplateVariant compoundKind() const {
-    QCString result = "unspecified";
-    switch (m_def->definitionType()) {
-    case DefinitionIntf::TypeClass:
-      result = "class";
-      break;
-    case DefinitionIntf::TypeFile:
-      result = "file";
-      break;
-    case DefinitionIntf::TypeNamespace:
-      result = "namespace";
-      break;
-    case DefinitionIntf::TypeGroup:
-      result = "module";
-      break;
-    case DefinitionIntf::TypePackage:
-      result = "package";
-      break;
-    case DefinitionIntf::TypePage:
-      result = "page";
-      break;
-    case DefinitionIntf::TypeDir:
-      result = "dir";
-      break;
-    case DefinitionIntf::TypeMember: // fall through
-    case DefinitionIntf::TypeSymbolList:
-      break;
+    virtual ~Private() {}
+    TemplateVariant get(const char *n) const
+    {
+      return s_inst.get(this,n);
     }
-    return result;
-  }
-  TemplateVariant sourceDef() const {
-    Cachable &cache = getCache();
-    if (cache.sourceDef->count() == 2) {
-      return cache.sourceDef.get();
-    } else {
-      return FALSE;
+    TemplateVariant title() const
+    {
+      return m_fileDef->title();
     }
-  }
-  void fillPath(Definition *def, TemplateList *list) const {
-    Definition *outerScope = def->getOuterScope();
-    Definition::DefType type = def->definitionType();
-    if (outerScope && outerScope != Doxygen::globalScope) {
-      fillPath(outerScope, list);
-    } else if (type == Definition::TypeFile &&
-               ((const FileDef *)def)->getDirDef()) {
-      fillPath(((const FileDef *)def)->getDirDef(), list);
-    }
-    list->append(NavPathElemContext::alloc(def));
-  }
-  TemplateVariant navigationPath() const {
-    Cachable &cache = getCache();
-    if (!cache.navPath) {
-      TemplateList *list = TemplateList::alloc();
-      if (m_def->getOuterScope() &&
-          m_def->getOuterScope() != Doxygen::globalScope) {
-        fillPath(m_def->getOuterScope(), list);
-      } else if (m_def->definitionType() == Definition::TypeFile &&
-                 ((const FileDef *)m_def)->getDirDef()) {
-        fillPath(((const FileDef *)m_def)->getDirDef(), list);
-      }
-      cache.navPath.reset(list);
-    }
-    return cache.navPath.get();
-  }
-  TemplateVariant isReference() const { return m_def->isReference(); }
-  TemplateVariant externalReference() const {
-    return m_def->externalReference(relPathAsString());
-  }
-
-protected:
-  struct Cachable : public Definition::Cookie {
-    Cachable(Definition *def)
-        : detailsOutputFormat(ContextOutputFormat_Unspecified),
-          briefOutputFormat(ContextOutputFormat_Unspecified),
-          inbodyDocsOutputFormat(ContextOutputFormat_Unspecified) {
-      sourceDef.reset(TemplateList::alloc());
-      lineLink.reset(TemplateStruct::alloc());
-      fileLink.reset(TemplateStruct::alloc());
-
-      if (def && !def->getSourceFileBase().isEmpty()) {
-        lineLink->set("text", def->getStartBodyLine());
-        lineLink->set("isLinkable", TRUE);
-        lineLink->set("fileName", def->getSourceFileBase());
-        lineLink->set("anchor", def->getSourceAnchor());
-        lineLink->set("isReference", FALSE);
-        lineLink->set("externalReference", "");
-        if (def->definitionType() == Definition::TypeFile) {
-          fileLink->set("text", def->name());
-        } else if (def->getBodyDef()) {
-          fileLink->set("text", def->getBodyDef()->name());
-        } else {
-          fileLink->set("text", def->displayName(TRUE));
-        }
-        fileLink->set("isLinkable", TRUE);
-        fileLink->set("fileName", def->getSourceFileBase());
-        fileLink->set("anchor", QCString());
-        fileLink->set("isReference", FALSE);
-        fileLink->set("externalReference", "");
-        sourceDef->append(lineLink.get());
-        sourceDef->append(fileLink.get());
-      }
-    }
-    ScopedPtr<TemplateVariant> details;
-    ContextOutputFormat detailsOutputFormat;
-    ScopedPtr<TemplateVariant> brief;
-    ContextOutputFormat briefOutputFormat;
-    ScopedPtr<TemplateVariant> inbodyDocs;
-    ContextOutputFormat inbodyDocsOutputFormat;
-    SharedPtr<TemplateList> navPath;
-    SharedPtr<TemplateList> sourceDef;
-    SharedPtr<TemplateStruct> fileLink;
-    SharedPtr<TemplateStruct> lineLink;
-  };
-
-private:
-  Cachable &getCache() const {
-    Cachable *c = static_cast<Cachable *>(m_def->cookie());
-    assert(c != 0);
-    return *c;
-  }
-  Definition *m_def;
-};
-//%% }
-
-//------------------------------------------------------------------------
-
-//%% struct IncludeInfo: include file information
-//%% {
-class IncludeInfoContext::Private {
-public:
-  Private(const IncludeInfo *info, SrcLangExt lang)
-      : m_info(info), m_lang(lang) {
-    static bool init = FALSE;
-    if (!init) {
-      s_inst.addProperty("file", &Private::file);
-      s_inst.addProperty("name", &Private::name);
-      s_inst.addProperty("isImport", &Private::isImport);
-      s_inst.addProperty("isLocal", &Private::isLocal);
-      init = TRUE;
+    TemplateVariant highlight() const
+    {
+      return TemplateVariant("files");
     }
-  }
-  TemplateVariant get(const char *n) const { return s_inst.get(this, n); }
-  TemplateVariant isLocal() const {
-    bool isIDLorJava = m_lang == SrcLangExt_IDL || m_lang == SrcLangExt_Java;
-    return m_info->local || isIDLorJava;
-  }
-  TemplateVariant isImport() const {
-    return m_info->imported || m_lang == SrcLangExt_ObjC;
-  }
-  TemplateVariant file() const {
-    if (!m_fileContext && m_info && m_info->fileDef) {
-      m_fileContext.reset(FileContext::alloc(m_info->fileDef));
+    TemplateVariant subHighlight() const
+    {
+      return TemplateVariant("");
     }
-    if (m_fileContext) {
-      return m_fileContext.get();
-    } else {
-      return FALSE;
+    TemplateVariant versionInfo() const
+    {
+      return m_fileDef->getVersion();
     }
-  }
-  TemplateVariant name() const { return m_info->includeName; }
-
-private:
-  const IncludeInfo *m_info;
-  mutable SharedPtr<FileContext> m_fileContext;
-  SrcLangExt m_lang;
-  static PropertyMapper<IncludeInfoContext::Private> s_inst;
-};
-
-PropertyMapper<IncludeInfoContext::Private> IncludeInfoContext::Private::s_inst;
-
-IncludeInfoContext::IncludeInfoContext(const IncludeInfo *info, SrcLangExt lang)
-    : RefCountedContext("IncludeContext") {
-  p = new Private(info, lang);
-}
-
-IncludeInfoContext::~IncludeInfoContext() { delete p; }
-
-TemplateVariant IncludeInfoContext::get(const char *n) const {
-  return p->get(n);
-}
-//%% }
-
-//------------------------------------------------------------------------
-
-//%% list IncludeInfoList[Class] : list of nested classes
-class IncludeInfoListContext::Private : public GenericNodeListContext {
-public:
-  Private(const QList<IncludeInfo> &list, SrcLangExt lang) {
-    QListIterator<IncludeInfo> li(list);
-    IncludeInfo *ii;
-    for (li.toFirst(); (ii = li.current()); ++li) {
-      if (!ii->indirect) {
-        append(IncludeInfoContext::alloc(ii, lang));
+    TemplateVariant includeList() const
+    {
+      Cachable &cache = getCache();
+      if (!cache.includeInfoList && m_fileDef->includeFileList())
+      {
+        cache.includeInfoList.reset(IncludeInfoListContext::alloc(
+              *m_fileDef->includeFileList(),m_fileDef->getLanguage()));
+      }
+      if (cache.includeInfoList)
+      {
+        return cache.includeInfoList.get();
+      }
+      else
+      {
+        return TemplateVariant(FALSE);
       }
     }
-  }
-};
-
-IncludeInfoListContext::IncludeInfoListContext(const QList<IncludeInfo> &list,
-                                               SrcLangExt lang)
-    : RefCountedContext("IncludeListContext") {
-  p = new Private(list, lang);
-}
-
-IncludeInfoListContext::~IncludeInfoListContext() { delete p; }
-
-// TemplateListIntf
-int IncludeInfoListContext::count() const { return p->count(); }
-
-TemplateVariant IncludeInfoListContext::at(int index) const {
-  return p->at(index);
-}
-
-TemplateListIntf::ConstIterator *
-IncludeInfoListContext::createIterator() const {
-  return p->createIterator();
-}
-
-//------------------------------------------------------------------------
-
-//%% struct Class(Symbol): class information
-//%% {
-class ClassContext::Private : public DefinitionContext<ClassContext::Private> {
-public:
-  Private(ClassDef *cd)
-      : DefinitionContext<ClassContext::Private>(cd), m_classDef(cd) {
-    static bool init = FALSE;
-    if (!init) {
-      addBaseProperties(s_inst);
-      s_inst.addProperty("title", &Private::title);
-      s_inst.addProperty("highlight", &Private::highlight);
-      s_inst.addProperty("subhighlight", &Private::subHighlight);
-      s_inst.addProperty("hasDetails", &Private::hasDetails);
-      s_inst.addProperty("generatedFromFiles", &Private::generatedFromFiles);
-      s_inst.addProperty("usedFiles", &Private::usedFiles);
-      s_inst.addProperty("hasInheritanceDiagram",
-                         &Private::hasInheritanceDiagram);
-      s_inst.addProperty("inheritanceDiagram", &Private::inheritanceDiagram);
-      s_inst.addProperty("hasCollaborationDiagram",
-                         &Private::hasCollaborationDiagram);
-      s_inst.addProperty("collaborationDiagram",
-                         &Private::collaborationDiagram);
-      s_inst.addProperty("includeInfo", &Private::includeInfo);
-      s_inst.addProperty("inherits", &Private::inherits);
-      s_inst.addProperty("inheritedBy", &Private::inheritedBy);
-      s_inst.addProperty("unoIDLServices", &Private::unoIDLServices);
-      s_inst.addProperty("unoIDLInterfaces", &Private::unoIDLInterfaces);
-      s_inst.addProperty("signals", &Private::signals);
-      s_inst.addProperty("publicTypes", &Private::publicTypes);
-      s_inst.addProperty("publicMethods", &Private::publicMethods);
-      s_inst.addProperty("publicStaticMethods", &Private::publicStaticMethods);
-      s_inst.addProperty("publicAttributes", &Private::publicAttributes);
-      s_inst.addProperty("publicStaticAttributes",
-                         &Private::publicStaticAttributes);
-      s_inst.addProperty("publicSlots", &Private::publicSlots);
-      s_inst.addProperty("protectedTypes", &Private::protectedTypes);
-      s_inst.addProperty("protectedMethods", &Private::protectedMethods);
-      s_inst.addProperty("protectedStaticMethods",
-                         &Private::protectedStaticMethods);
-      s_inst.addProperty("protectedAttributes", &Private::protectedAttributes);
-      s_inst.addProperty("protectedStaticAttributes",
-                         &Private::protectedStaticAttributes);
-      s_inst.addProperty("protectedSlots", &Private::protectedSlots);
-      s_inst.addProperty("privateTypes", &Private::privateTypes);
-      s_inst.addProperty("privateMethods", &Private::privateMethods);
-      s_inst.addProperty("privateStaticMethods",
-                         &Private::privateStaticMethods);
-      s_inst.addProperty("privateAttributes", &Private::privateAttributes);
-      s_inst.addProperty("privateStaticAttributes",
-                         &Private::privateStaticAttributes);
-      s_inst.addProperty("privateSlots", &Private::privateSlots);
-      s_inst.addProperty("packageTypes", &Private::packageTypes);
-      s_inst.addProperty("packageMethods", &Private::packageMethods);
-      s_inst.addProperty("packageStaticMethods",
-                         &Private::packageStaticMethods);
-      s_inst.addProperty("packageAttributes", &Private::packageAttributes);
-      s_inst.addProperty("packageStaticAttributes",
-                         &Private::packageStaticAttributes);
-      s_inst.addProperty("properties", &Private::properties);
-      s_inst.addProperty("events", &Private::events);
-      s_inst.addProperty("friends", &Private::friends);
-      s_inst.addProperty("related", &Private::related);
-      s_inst.addProperty("detailedTypedefs", &Private::detailedTypedefs);
-      s_inst.addProperty("detailedEnums", &Private::detailedEnums);
-      s_inst.addProperty("detailedServices", &Private::detailedServices);
-      s_inst.addProperty("detailedInterfaces", &Private::detailedInterfaces);
-      s_inst.addProperty("detailedConstructors",
-                         &Private::detailedConstructors);
-      s_inst.addProperty("detailedMethods", &Private::detailedMethods);
-      s_inst.addProperty("detailedRelated", &Private::detailedRelated);
-      s_inst.addProperty("detailedVariables", &Private::detailedVariables);
-      s_inst.addProperty("detailedProperties", &Private::detailedProperties);
-      s_inst.addProperty("detailedEvents", &Private::detailedEvents);
-      s_inst.addProperty("classes", &Private::classes);
-      s_inst.addProperty("innerClasses", &Private::innerClasses);
-      s_inst.addProperty("compoundType", &Private::compoundType);
-      s_inst.addProperty("templateDecls", &Private::templateDecls);
-      s_inst.addProperty("typeConstraints", &Private::typeConstraints);
-      s_inst.addProperty("examples", &Private::examples);
-      s_inst.addProperty("members", &Private::members);
-      s_inst.addProperty("allMembersList", &Private::allMembersList);
-      s_inst.addProperty("allMembersFileName", &Private::allMembersFileName);
-      s_inst.addProperty("memberGroups", &Private::memberGroups);
-      s_inst.addProperty("additionalInheritedMembers",
-                         &Private::additionalInheritedMembers);
-      s_inst.addProperty("isSimple", &Private::isSimple);
-      s_inst.addProperty("categoryOf", &Private::categoryOf);
-      init = TRUE;
-    }
-    if (!cd->cookie()) {
-      cd->setCookie(new ClassContext::Private::Cachable(cd));
+    DotInclDepGraph *getIncludeGraph() const
+    {
+      Cachable &cache = getCache();
+      if (!cache.includeGraph)
+      {
+        cache.includeGraph.reset(new DotInclDepGraph(m_fileDef,FALSE));
+      }
+      return cache.includeGraph.get();
     }
-  }
-  virtual ~Private() {}
-  TemplateVariant get(const char *n) const { return s_inst.get(this, n); }
-  TemplateVariant title() const { return TemplateVariant(m_classDef->title()); }
-  TemplateVariant highlight() const { return TemplateVariant("classes"); }
-  TemplateVariant subHighlight() const { return TemplateVariant(""); }
-  TemplateVariant hasDetails() const {
-    return m_classDef->hasDetailedDescription();
-  }
-  TemplateVariant generatedFromFiles() const {
-    return m_classDef->generatedFromFiles();
-  }
-  TemplateVariant usedFiles() const {
-    Cachable &cache = getCache();
-    if (!cache.usedFiles) {
-      cache.usedFiles.reset(UsedFilesContext::alloc(m_classDef));
-    }
-    return cache.usedFiles.get();
-  }
-  DotClassGraph *getClassGraph() const {
-    Cachable &cache = getCache();
-    if (!cache.classGraph) {
-      cache.classGraph.reset(
-          new DotClassGraph(m_classDef, DotNode::Inheritance));
-    }
-    return cache.classGraph.get();
-  }
-  int numInheritanceNodes() const {
-    Cachable &cache = getCache();
-    if (cache.inheritanceNodes == -1) {
-      cache.inheritanceNodes = m_classDef->countInheritanceNodes();
+    TemplateVariant hasIncludeGraph() const
+    {
+      static bool haveDot = Config_getBool(HAVE_DOT);
+      DotInclDepGraph *incGraph = getIncludeGraph();
+      return (haveDot && !incGraph->isTooBig() && !incGraph->isTrivial());
     }
-    return cache.inheritanceNodes > 0;
-  }
-  TemplateVariant hasInheritanceDiagram() const {
-    bool result = FALSE;
-    static bool haveDot = Config_getBool(HAVE_DOT);
-    static bool classDiagrams = Config_getBool(CLASS_DIAGRAMS);
-    static bool classGraph = Config_getBool(CLASS_GRAPH);
-    if (haveDot && (classDiagrams || classGraph)) {
-      DotClassGraph *cg = getClassGraph();
-      result = !cg->isTrivial() && !cg->isTooBig();
-    } else if (classDiagrams) {
-      result = numInheritanceNodes() > 0;
-    }
-    return result;
-  }
-  TemplateVariant inheritanceDiagram() const {
-    QGString result;
-    static bool haveDot = Config_getBool(HAVE_DOT);
-    static bool classDiagrams = Config_getBool(CLASS_DIAGRAMS);
-    static bool classGraph = Config_getBool(CLASS_GRAPH);
-    if (haveDot && (classDiagrams || classGraph)) {
-      DotClassGraph *cg = getClassGraph();
-      FTextStream t(&result);
-      switch (g_globals.outputFormat) {
-      case ContextOutputFormat_Html: {
-        cg->writeGraph(t, GOF_BITMAP, EOF_Html, g_globals.outputDir,
-                       g_globals.outputDir + portable_pathSeparator() +
-                           m_classDef->getOutputFileBase() +
-                           Doxygen::htmlFileExtension,
-                       relPathAsString(), TRUE, TRUE, g_globals.dynSectionId);
-      } break;
-      case ContextOutputFormat_Latex: {
-        cg->writeGraph(t, GOF_EPS, EOF_LaTeX, g_globals.outputDir,
-                       g_globals.outputDir + portable_pathSeparator() +
-                           m_classDef->getOutputFileBase() + ".tex",
-                       relPathAsString(), TRUE, TRUE, g_globals.dynSectionId);
-      } break;
-      // TODO: support other generators
-      default:
-        err("context.cpp: output format not yet supported");
-        break;
+    TemplateVariant includeGraph() const
+    {
+      static bool haveDot = Config_getBool(HAVE_DOT);
+      QGString result;
+      if (haveDot)
+      {
+        DotInclDepGraph *cg = getIncludeGraph();
+        FTextStream t(&result);
+        switch (g_globals.outputFormat)
+        {
+          case ContextOutputFormat_Html:
+            {
+              cg->writeGraph(t,GOF_BITMAP,EOF_Html,
+                  g_globals.outputDir,
+                  g_globals.outputDir+portable_pathSeparator()+m_fileDef->getOutputFileBase()+Doxygen::htmlFileExtension,
+                  relPathAsString(),TRUE,g_globals.dynSectionId
+                  );
+            }
+            break;
+          case ContextOutputFormat_Latex:
+            {
+              cg->writeGraph(t,GOF_EPS,EOF_LaTeX,
+                  g_globals.outputDir,
+                  g_globals.outputDir+portable_pathSeparator()+m_fileDef->getOutputFileBase()+".tex",
+                  relPathAsString(),TRUE,g_globals.dynSectionId
+                  );
+            }
+            break;
+            // TODO: support other generators
+          default:
+            err("context.cpp: output format not yet supported");
+            break;
+        }
+        g_globals.dynSectionId++;
       }
-      g_globals.dynSectionId++;
-    } else if (classDiagrams) {
-      ClassDiagram d(m_classDef);
-      FTextStream t(&result);
-      switch (g_globals.outputFormat) {
-      case ContextOutputFormat_Html: {
-        QCString name = convertToHtml(m_classDef->displayName());
-        t << "<div class=\"center\">" << endl;
-        t << "<img src=\"";
-        t << relPathAsString() << m_classDef->getOutputFileBase();
-        t << ".png\" usemap=\"#" << convertToId(name) << "_map\" alt=\"\"/>"
-          << endl;
-        t << "<map id=\"" << convertToId(name) << "_map\" name=\"" << name
-          << "_map\">" << endl;
-        d.writeImage(t, g_globals.outputDir, relPathAsString(),
-                     m_classDef->getOutputFileBase());
-        t << "</div>";
-      } break;
-      case ContextOutputFormat_Latex: {
-        d.writeFigure(t, g_globals.outputDir, m_classDef->getOutputFileBase());
-      } break;
-      // TODO: support other generators
-      default:
-        err("context.cpp: output format not yet supported");
-        break;
+      return TemplateVariant(result.data(),TRUE);
+    }
+    DotInclDepGraph *getIncludedByGraph() const
+    {
+      Cachable &cache = getCache();
+      if (!cache.includedByGraph)
+      {
+        cache.includedByGraph.reset(new DotInclDepGraph(m_fileDef,TRUE));
       }
-      g_globals.dynSectionId++;
+      return cache.includedByGraph.get();
     }
-    return TemplateVariant(result.data(), TRUE);
-  }
-  DotClassGraph *getCollaborationGraph() const {
-    Cachable &cache = getCache();
-    if (!cache.collaborationGraph) {
-      cache.collaborationGraph.reset(
-          new DotClassGraph(m_classDef, DotNode::Collaboration));
+    TemplateVariant hasIncludedByGraph() const
+    {
+      static bool haveDot = Config_getBool(HAVE_DOT);
+      DotInclDepGraph *incGraph = getIncludedByGraph();
+      return (haveDot && !incGraph->isTooBig() && !incGraph->isTrivial());
     }
-    return cache.collaborationGraph.get();
-  }
-  TemplateVariant hasCollaborationDiagram() const {
-    static bool haveDot = Config_getBool(HAVE_DOT);
-    return haveDot && !getCollaborationGraph()->isTrivial();
-  }
-  TemplateVariant collaborationDiagram() const {
-    static bool haveDot = Config_getBool(HAVE_DOT);
-    QGString result;
-    if (haveDot) {
-      DotClassGraph *cg = getCollaborationGraph();
-      FTextStream t(&result);
-      switch (g_globals.outputFormat) {
-      case ContextOutputFormat_Html: {
-        cg->writeGraph(t, GOF_BITMAP, EOF_Html, g_globals.outputDir,
-                       g_globals.outputDir + portable_pathSeparator() +
-                           m_classDef->getOutputFileBase() +
-                           Doxygen::htmlFileExtension,
-                       relPathAsString(), TRUE, TRUE, g_globals.dynSectionId);
-      } break;
-      case ContextOutputFormat_Latex: {
-        cg->writeGraph(t, GOF_EPS, EOF_LaTeX, g_globals.outputDir,
-                       g_globals.outputDir + portable_pathSeparator() +
-                           m_classDef->getOutputFileBase() + ".tex",
-                       relPathAsString(), TRUE, TRUE, g_globals.dynSectionId);
-      } break;
-      // TODO: support other generators
-      default:
-        err("context.cpp: output format not yet supported");
-        break;
+    TemplateVariant includedByGraph() const
+    {
+      static bool haveDot = Config_getBool(HAVE_DOT);
+      QGString result;
+      if (haveDot)
+      {
+        DotInclDepGraph *cg = getIncludedByGraph();
+        FTextStream t(&result);
+        switch (g_globals.outputFormat)
+        {
+          case ContextOutputFormat_Html:
+            {
+              cg->writeGraph(t,GOF_BITMAP,EOF_Html,
+                  g_globals.outputDir,
+                  g_globals.outputDir+portable_pathSeparator()+m_fileDef->getOutputFileBase()+Doxygen::htmlFileExtension,
+                  relPathAsString(),TRUE,g_globals.dynSectionId
+                  );
+            }
+            break;
+          case ContextOutputFormat_Latex:
+            {
+              cg->writeGraph(t,GOF_EPS,EOF_LaTeX,
+                  g_globals.outputDir,
+                  g_globals.outputDir+portable_pathSeparator()+m_fileDef->getOutputFileBase()+".tex",
+                  relPathAsString(),TRUE,g_globals.dynSectionId
+                  );
+            }
+            break;
+            // TODO: support other generators
+          default:
+            err("context.cpp: output format not yet supported");
+            break;
+        }
+        g_globals.dynSectionId++;
       }
-      g_globals.dynSectionId++;
+      return TemplateVariant(result.data(),TRUE);
     }
-    return TemplateVariant(result.data(), TRUE);
-  }
-
-  TemplateVariant includeInfo() const {
-    Cachable &cache = getCache();
-    if (!cache.includeInfo && m_classDef->includeInfo()) {
-      cache.includeInfo.reset(IncludeInfoContext::alloc(
-          m_classDef->includeInfo(), m_classDef->getLanguage()));
+    TemplateVariant hasDetails() const
+    {
+      return m_fileDef->hasDetailedDescription();
     }
-    if (cache.includeInfo) {
-      return cache.includeInfo.get();
-    } else {
-      return TemplateVariant(FALSE);
+    TemplateVariant hasSourceFile() const
+    {
+      return m_fileDef->generateSourceFile();
     }
-  }
-  TemplateVariant inherits() const {
-    Cachable &cache = getCache();
-    if (!cache.inheritsList) {
-      cache.inheritsList.reset(
-          InheritanceListContext::alloc(m_classDef->baseClasses(), TRUE));
+    TemplateVariant sources() const
+    {
+      Cachable &cache = getCache();
+      if (!cache.sources)
+      {
+        if (m_fileDef->generateSourceFile())
+        {
+          cache.sources.reset(new TemplateVariant(parseCode(m_fileDef,relPathAsString())));
+        }
+        else
+        {
+          cache.sources.reset(new TemplateVariant(""));
+        }
+      }
+      return *cache.sources;
     }
-    return cache.inheritsList.get();
-  }
-  TemplateVariant inheritedBy() const {
-    Cachable &cache = getCache();
-    if (!cache.inheritedByList) {
-      cache.inheritedByList.reset(
-          InheritanceListContext::alloc(m_classDef->subClasses(), FALSE));
+    TemplateVariant version() const
+    {
+      return m_fileDef->fileVersion();
     }
-    return cache.inheritedByList.get();
-  }
-  TemplateVariant getMemberList(SharedPtr<MemberListInfoContext> &list,
-                                MemberListType type, const char *title,
-                                bool detailed = FALSE) const {
-    if (!list) {
-      MemberList *ml = m_classDef->getMemberList(type);
-      if (ml) {
-        list.reset(MemberListInfoContext::alloc(m_classDef, relPathAsString(),
-                                                ml, title, ""));
-      }
-    }
-    if (list) {
-      return list.get();
-    } else {
-      return TemplateVariant(FALSE);
+    TemplateVariant classes() const
+    {
+      Cachable &cache = getCache();
+      if (!cache.classes)
+      {
+        TemplateList *classList = TemplateList::alloc();
+        if (m_fileDef->getClassSDict())
+        {
+          ClassSDict::Iterator sdi(*m_fileDef->getClassSDict());
+          ClassDef *cd;
+          for (sdi.toFirst();(cd=sdi.current());++sdi)
+          {
+            if (cd->visibleInParentsDeclList())
+            {
+              classList->append(ClassContext::alloc(cd));
+            }
+          }
+        }
+        cache.classes.reset(classList);
+      }
+      return cache.classes.get();
     }
-  }
-  TemplateVariant unoIDLServices() const {
-    return getMemberList(getCache().unoIDLServices, MemberListType_services,
-                         theTranslator->trServices());
-  }
-  TemplateVariant unoIDLInterfaces() const {
-    return getMemberList(getCache().unoIDLInterfaces, MemberListType_interfaces,
-                         theTranslator->trInterfaces());
-  }
-  TemplateVariant signals() const {
-    return getMemberList(getCache().signals, MemberListType_signals,
-                         theTranslator->trSignals());
-  }
-  TemplateVariant publicTypes() const {
-    return getMemberList(getCache().publicTypes, MemberListType_pubTypes,
-                         theTranslator->trPublicTypes());
-  }
-  TemplateVariant publicMethods() const {
-    return getMemberList(getCache().publicMethods, MemberListType_pubMethods,
-                         m_classDef->getLanguage() == SrcLangExt_ObjC
-                             ? theTranslator->trInstanceMethods()
-                             : (m_classDef->getLanguage() == SrcLangExt_Prolog
-                                    ? theTranslator->trInstanceMethods()
-                                    : theTranslator->trPublicMembers()));
-  }
-  TemplateVariant publicStaticMethods() const {
-    return getMemberList(getCache().publicStaticMethods,
-                         MemberListType_pubStaticMethods,
-                         m_classDef->getLanguage() == SrcLangExt_ObjC
-                             ? theTranslator->trClassMethods()
-                             : theTranslator->trStaticPublicMembers());
-  }
-  TemplateVariant publicAttributes() const {
-    return getMemberList(getCache().publicAttributes, MemberListType_pubAttribs,
-                         theTranslator->trPublicAttribs());
-  }
-  TemplateVariant publicStaticAttributes() const {
-    return getMemberList(getCache().publicStaticAttributes,
-                         MemberListType_pubStaticAttribs,
-                         theTranslator->trStaticPublicAttribs());
-  }
-  TemplateVariant publicSlots() const {
-    return getMemberList(getCache().publicSlots, MemberListType_pubSlots,
-                         theTranslator->trPublicSlots());
-  }
-  TemplateVariant protectedTypes() const {
-    return getMemberList(getCache().protectedTypes, MemberListType_proTypes,
-                         theTranslator->trProtectedTypes());
-  }
-  TemplateVariant protectedMethods() const {
-    return getMemberList(getCache().protectedMethods, MemberListType_proMethods,
-                         theTranslator->trProtectedMembers());
-  }
-  TemplateVariant protectedStaticMethods() const {
-    return getMemberList(getCache().protectedStaticMethods,
-                         MemberListType_proStaticMethods,
-                         theTranslator->trStaticProtectedMembers());
-  }
-  TemplateVariant protectedAttributes() const {
-    return getMemberList(getCache().protectedAttributes,
-                         MemberListType_proAttribs,
-                         theTranslator->trProtectedAttribs());
-  }
-  TemplateVariant protectedStaticAttributes() const {
-    return getMemberList(getCache().protectedStaticAttributes,
-                         MemberListType_proStaticAttribs,
-                         theTranslator->trStaticProtectedAttribs());
-  }
-  TemplateVariant protectedSlots() const {
-    return getMemberList(getCache().protectedSlots, MemberListType_proSlots,
-                         theTranslator->trProtectedSlots());
-  }
-  TemplateVariant privateTypes() const {
-    return getMemberList(getCache().privateTypes, MemberListType_priTypes,
-                         theTranslator->trPrivateTypes());
-  }
-  TemplateVariant privateSlots() const {
-    return getMemberList(getCache().privateSlots, MemberListType_priSlots,
-                         theTranslator->trPrivateSlots());
-  }
-  TemplateVariant privateMethods() const {
-    return getMemberList(getCache().privateMethods, MemberListType_priMethods,
-                         theTranslator->trPrivateMembers());
-  }
-  TemplateVariant privateStaticMethods() const {
-    return getMemberList(getCache().privateStaticMethods,
-                         MemberListType_priStaticMethods,
-                         theTranslator->trStaticPrivateMembers());
-  }
-  TemplateVariant privateAttributes() const {
-    return getMemberList(getCache().privateAttributes,
-                         MemberListType_priAttribs,
-                         theTranslator->trPrivateAttribs());
-  }
-  TemplateVariant privateStaticAttributes() const {
-    return getMemberList(getCache().privateStaticAttributes,
-                         MemberListType_priStaticAttribs,
-                         theTranslator->trStaticPrivateAttribs());
-  }
-  TemplateVariant packageTypes() const {
-    return getMemberList(getCache().packageTypes, MemberListType_pacTypes,
-                         theTranslator->trPackageTypes());
-  }
-  TemplateVariant packageMethods() const {
-    return getMemberList(getCache().packageMethods, MemberListType_pacMethods,
-                         theTranslator->trPackageMembers());
-  }
-  TemplateVariant packageStaticMethods() const {
-    return getMemberList(getCache().packageStaticMethods,
-                         MemberListType_pacStaticMethods,
-                         theTranslator->trStaticPackageMembers());
-  }
-  TemplateVariant packageAttributes() const {
-    return getMemberList(getCache().packageAttributes,
-                         MemberListType_pacAttribs,
-                         theTranslator->trPackageAttribs());
-  }
-  TemplateVariant packageStaticAttributes() const {
-    return getMemberList(getCache().packageStaticAttributes,
-                         MemberListType_pacStaticAttribs,
-                         theTranslator->trStaticPackageAttribs());
-  }
-  TemplateVariant properties() const {
-    return getMemberList(getCache().properties, MemberListType_properties,
-                         theTranslator->trProperties());
-  }
-  TemplateVariant events() const {
-    return getMemberList(getCache().events, MemberListType_events,
-                         theTranslator->trEvents());
-  }
-  TemplateVariant friends() const {
-    return getMemberList(getCache().friends, MemberListType_friends,
-                         theTranslator->trFriends());
-  }
-  TemplateVariant related() const {
-    return getMemberList(getCache().related, MemberListType_related,
-                         theTranslator->trRelatedFunctions());
-  }
-  TemplateVariant detailedTypedefs() const {
-    return getMemberList(getCache().detailedTypedefs,
-                         MemberListType_typedefMembers,
-                         theTranslator->trMemberTypedefDocumentation(), TRUE);
-  }
-  TemplateVariant detailedEnums() const {
-    return getMemberList(getCache().detailedEnums, MemberListType_enumMembers,
-                         theTranslator->trMemberEnumerationDocumentation(),
-                         TRUE);
-  }
-  TemplateVariant detailedServices() const {
-    return getMemberList(getCache().detailedServices,
-                         MemberListType_serviceMembers,
-                         theTranslator->trServices(), TRUE);
-  }
-  TemplateVariant detailedInterfaces() const {
-    return getMemberList(getCache().detailedInterfaces,
-                         MemberListType_interfaceMembers,
-                         theTranslator->trInterfaces(), TRUE);
-  }
-  TemplateVariant detailedConstructors() const {
-    return getMemberList(getCache().detailedConstructors,
-                         MemberListType_constructors,
-                         theTranslator->trConstructorDocumentation(), TRUE);
-  }
-  TemplateVariant detailedMethods() const {
-    return getMemberList(getCache().detailedMethods,
-                         MemberListType_functionMembers,
-                         theTranslator->trMemberFunctionDocumentation(), TRUE);
-  }
-  TemplateVariant detailedClauses() const {
-    return getMemberList(getCache().detailedClauses,
-                         MemberListType_clauseMembers,
-                         theTranslator->trInstanceMethods(), TRUE);
-  }
-  TemplateVariant detailedRelated() const {
-    return getMemberList(getCache().detailedRelated,
-                         MemberListType_relatedMembers,
-                         theTranslator->trRelatedFunctionDocumentation(), TRUE);
-  }
-  TemplateVariant detailedVariables() const {
-    return getMemberList(getCache().detailedVariables,
-                         MemberListType_variableMembers,
-                         theTranslator->trMemberDataDocumentation(), TRUE);
-  }
-  TemplateVariant detailedProperties() const {
-    return getMemberList(getCache().detailedProperties,
-                         MemberListType_propertyMembers,
-                         theTranslator->trPropertyDocumentation(), TRUE);
-  }
-  TemplateVariant detailedEvents() const {
-    return getMemberList(getCache().detailedEvents, MemberListType_eventMembers,
-                         theTranslator->trEventDocumentation(), TRUE);
-  }
-  TemplateVariant classes() const {
-    Cachable &cache = getCache();
-    if (!cache.classes) {
-      TemplateList *classList = TemplateList::alloc();
-      if (m_classDef->getClassSDict()) {
-        ClassSDict::Iterator sdi(*m_classDef->getClassSDict());
-        ClassDef *cd;
-        for (sdi.toFirst(); (cd = sdi.current()); ++sdi) {
-          if (cd->visibleInParentsDeclList()) {
-            classList->append(ClassContext::alloc(cd));
+    TemplateVariant namespaces() const
+    {
+      Cachable &cache = getCache();
+      if (!cache.namespaces)
+      {
+        TemplateList *namespaceList = TemplateList::alloc();
+        if (m_fileDef->getNamespaceSDict())
+        {
+          NamespaceSDict::Iterator sdi(*m_fileDef->getNamespaceSDict());
+          NamespaceDef *nd;
+          for (sdi.toFirst();(nd=sdi.current());++sdi)
+          {
+            if (nd->isLinkable() && !nd->isConstantGroup())
+            {
+              namespaceList->append(NamespaceContext::alloc(nd));
+            }
           }
         }
+        cache.namespaces.reset(namespaceList);
       }
-      cache.classes.reset(classList);
+      return cache.namespaces.get();
     }
-    return cache.classes.get();
-  }
-  TemplateVariant innerClasses() const {
-    Cachable &cache = getCache();
-    if (!cache.innerClasses) {
-      TemplateList *classList = TemplateList::alloc();
-      if (m_classDef->getClassSDict()) {
-        ClassSDict::Iterator sdi(*m_classDef->getClassSDict());
-        ClassDef *cd;
-        for (sdi.toFirst(); (cd = sdi.current()); ++sdi) {
-          if (cd->name().find('@') == -1 && cd->isLinkableInProject() &&
-              cd->isEmbeddedInOuterScope() && cd->partOfGroups() == 0) {
-            classList->append(ClassContext::alloc(cd));
+    TemplateVariant constantgroups() const
+    {
+      Cachable &cache = getCache();
+      if (!cache.constantgroups)
+      {
+        TemplateList *namespaceList = TemplateList::alloc();
+        if (m_fileDef->getNamespaceSDict())
+        {
+          NamespaceSDict::Iterator sdi(*m_fileDef->getNamespaceSDict());
+          NamespaceDef *nd;
+          for (sdi.toFirst();(nd=sdi.current());++sdi)
+          {
+            if (nd->isLinkable() && nd->isConstantGroup())
+            {
+              namespaceList->append(NamespaceContext::alloc(nd));
+            }
           }
         }
+        cache.constantgroups.reset(namespaceList);
       }
-      cache.innerClasses.reset(classList);
+      return cache.constantgroups.get();
     }
-    return cache.innerClasses.get();
-  }
-  TemplateVariant compoundType() const {
-    return m_classDef->compoundTypeString();
-  }
-  void addTemplateDecls(Definition *d, TemplateList *tl) const {
-    if (d->definitionType() == Definition::TypeClass) {
-      Definition *parent = d->getOuterScope();
-      if (parent) {
-        addTemplateDecls(parent, tl);
+    TemplateVariant getMemberList(SharedPtr<MemberListInfoContext> &list,
+                                  MemberListType type,const char *title,bool detailed=FALSE) const
+    {
+      if (!list)
+      {
+        MemberList *ml = m_fileDef->getMemberList(type);
+        if (ml)
+        {
+          list.reset(MemberListInfoContext::alloc(m_fileDef,relPathAsString(),ml,title,""));
+        }
       }
-      ClassDef *cd = (ClassDef *)d;
-      if (cd->templateArguments()) {
-        ArgumentListContext *al = ArgumentListContext::alloc(
-            cd->templateArguments(), cd, relPathAsString());
-        // since a TemplateVariant does take ownership of the object, we add it
-        // a separate list just to be able to delete it and avoid a memory leak
-        tl->append(al);
+      if (list)
+      {
+        return list.get();
       }
-    }
-  }
-  void addExamples(TemplateList *list) const {
-    if (m_classDef->hasExamples()) {
-      ExampleSDict::Iterator it(*m_classDef->exampleList());
-      Example *ex;
-      for (it.toFirst(); (ex = it.current()); ++it) {
-        TemplateStruct *s = TemplateStruct::alloc();
-        s->set("text", ex->name);
-        s->set("isLinkable", TRUE);
-        s->set("anchor", ex->anchor);
-        s->set("fileName", ex->file);
-        s->set("isReference", FALSE);
-        s->set("externalReference", "");
-        list->append(s);
+      else
+      {
+        return TemplateVariant(FALSE);
       }
     }
-  }
-  TemplateVariant templateDecls() const {
-    Cachable &cache = getCache();
-    if (!cache.templateDecls) {
-      TemplateList *tl = TemplateList::alloc();
-      addTemplateDecls(m_classDef, tl);
-      cache.templateDecls.reset(tl);
-    }
-    return cache.templateDecls.get();
-  }
-  TemplateVariant typeConstraints() const {
-    if (m_classDef->typeConstraints()) {
-      Cachable &cache = getCache();
-      if (!cache.typeConstraints && m_classDef->typeConstraints()) {
-        cache.typeConstraints.reset(ArgumentListContext::alloc(
-            m_classDef->typeConstraints(), m_classDef, relPathAsString()));
-      }
-      return cache.typeConstraints.get();
+    TemplateVariant macros() const
+    {
+      return getMemberList(getCache().macros,MemberListType_decDefineMembers,theTranslator->trDefines());
     }
-    return FALSE;
-  }
-  TemplateVariant examples() const {
-    Cachable &cache = getCache();
-    if (!cache.examples) {
-      TemplateList *exampleList = TemplateList::alloc();
-      addExamples(exampleList);
-      cache.examples.reset(exampleList);
-    }
-    return cache.examples.get();
-  }
-  void addMembers(ClassDef *cd, MemberListType lt) const {
-    MemberList *ml = cd->getMemberList(lt);
-    if (ml) {
+    TemplateVariant typedefs() const
+    {
+      return getMemberList(getCache().typedefs,MemberListType_decTypedefMembers,theTranslator->trTypedefs());
+    }
+    TemplateVariant enums() const
+    {
+      return getMemberList(getCache().enums,MemberListType_decEnumMembers,theTranslator->trEnumerations());
+    }
+    TemplateVariant functions() const
+    {
+      QCString title = theTranslator->trFunctions();
+      SrcLangExt lang = m_fileDef->getLanguage();
+      if (lang==SrcLangExt_Fortran) title=theTranslator->trSubprograms();
+      else if (lang==SrcLangExt_VHDL) title=VhdlDocGen::trFunctionAndProc();
+      return getMemberList(getCache().functions,MemberListType_decFuncMembers,title);
+    }
+    TemplateVariant variables() const
+    {
+      return getMemberList(getCache().variables,MemberListType_decVarMembers,theTranslator->trVariables());
+    }
+    TemplateVariant memberGroups() const
+    {
       Cachable &cache = getCache();
-      MemberListIterator li(*ml);
-      const MemberDef *md;
-      for (li.toFirst(); (md = li.current()); ++li) {
-        if (md->isBriefSectionVisible()) {
-          cache.allMembers.append(md);
+      if (!cache.memberGroups)
+      {
+        if (m_fileDef->getMemberGroupSDict())
+        {
+          cache.memberGroups.reset(MemberGroupListContext::alloc(m_fileDef,relPathAsString(),m_fileDef->getMemberGroupSDict(),m_fileDef->subGrouping()));
+        }
+        else
+        {
+          cache.memberGroups.reset(MemberGroupListContext::alloc());
         }
       }
+      return cache.memberGroups.get();
     }
-  }
-  TemplateVariant members() const {
-    Cachable &cache = getCache();
-    if (!cache.members) {
-      addMembers(m_classDef, MemberListType_pubTypes);
-      addMembers(m_classDef, MemberListType_services);
-      addMembers(m_classDef, MemberListType_interfaces);
-      addMembers(m_classDef, MemberListType_pubSlots);
-      addMembers(m_classDef, MemberListType_signals);
-      addMembers(m_classDef, MemberListType_pubMethods);
-      addMembers(m_classDef, MemberListType_pubStaticMethods);
-      addMembers(m_classDef, MemberListType_pubAttribs);
-      addMembers(m_classDef, MemberListType_pubStaticAttribs);
-      addMembers(m_classDef, MemberListType_proTypes);
-      addMembers(m_classDef, MemberListType_proSlots);
-      addMembers(m_classDef, MemberListType_proMethods);
-      addMembers(m_classDef, MemberListType_proStaticMethods);
-      addMembers(m_classDef, MemberListType_proAttribs);
-      addMembers(m_classDef, MemberListType_proStaticAttribs);
-      addMembers(m_classDef, MemberListType_pacTypes);
-      addMembers(m_classDef, MemberListType_pacMethods);
-      addMembers(m_classDef, MemberListType_pacStaticMethods);
-      addMembers(m_classDef, MemberListType_pacAttribs);
-      addMembers(m_classDef, MemberListType_pacStaticAttribs);
-      addMembers(m_classDef, MemberListType_properties);
-      addMembers(m_classDef, MemberListType_events);
-      addMembers(m_classDef, MemberListType_priTypes);
-      addMembers(m_classDef, MemberListType_priSlots);
-      addMembers(m_classDef, MemberListType_priMethods);
-      addMembers(m_classDef, MemberListType_priStaticMethods);
-      addMembers(m_classDef, MemberListType_priAttribs);
-      addMembers(m_classDef, MemberListType_priStaticAttribs);
-      addMembers(m_classDef, MemberListType_related);
-      cache.members.reset(MemberListContext::alloc(&cache.allMembers));
-    }
-    return cache.members.get();
-  }
-  TemplateVariant allMembersList() const {
-    Cachable &cache = getCache();
-    if (!cache.allMembersList) {
-      if (m_classDef->memberNameInfoSDict()) {
-        AllMembersListContext *ml =
-            AllMembersListContext::alloc(m_classDef->memberNameInfoSDict());
-        cache.allMembersList.reset(ml);
-      } else {
-        cache.allMembersList.reset(AllMembersListContext::alloc());
-      }
-    }
-    return cache.allMembersList.get();
-  }
-  TemplateVariant allMembersFileName() const {
-    return m_classDef->getMemberListFileName();
-  }
-  TemplateVariant memberGroups() const {
-    Cachable &cache = getCache();
-    if (!cache.memberGroups) {
-      if (m_classDef->getMemberGroupSDict()) {
-        cache.memberGroups.reset(MemberGroupListContext::alloc(
-            m_classDef, relPathAsString(), m_classDef->getMemberGroupSDict(),
-            m_classDef->subGrouping()));
-      } else {
-        cache.memberGroups.reset(MemberGroupListContext::alloc());
-      }
-    }
-    return cache.memberGroups.get();
-  }
-  TemplateVariant additionalInheritedMembers() const {
-    Cachable &cache = getCache();
-    if (!cache.additionalInheritedMembers) {
-      InheritedMemberInfoListContext *ctx =
-          InheritedMemberInfoListContext::alloc();
-      ctx->addMemberList(m_classDef, MemberListType_pubTypes,
-                         theTranslator->trPublicTypes());
-      ctx->addMemberList(m_classDef, MemberListType_services,
-                         theTranslator->trServices());
-      ctx->addMemberList(m_classDef, MemberListType_interfaces,
-                         theTranslator->trInterfaces());
-      ctx->addMemberList(m_classDef, MemberListType_pubSlots,
-                         theTranslator->trPublicSlots());
-      ctx->addMemberList(m_classDef, MemberListType_signals,
-                         theTranslator->trSignals());
-      ctx->addMemberList(m_classDef, MemberListType_pubMethods,
-                         m_classDef->getLanguage() == SrcLangExt_ObjC
-                             ? theTranslator->trInstanceMethods()
-                             : (m_classDef->getLanguage() == SrcLangExt_Prolog
-                                    ? theTranslator->trInstanceMethods()
-                                    : theTranslator->trPublicMembers()));
-      ctx->addMemberList(m_classDef, MemberListType_pubStaticMethods,
-                         m_classDef->getLanguage() == SrcLangExt_ObjC
-                             ? theTranslator->trClassMethods()
-                             : theTranslator->trStaticPublicMembers());
-      ctx->addMemberList(m_classDef, MemberListType_pubAttribs,
-                         theTranslator->trPublicAttribs());
-      ctx->addMemberList(m_classDef, MemberListType_pubStaticAttribs,
-                         theTranslator->trStaticPublicAttribs());
-      ctx->addMemberList(m_classDef, MemberListType_proTypes,
-                         theTranslator->trProtectedTypes());
-      ctx->addMemberList(m_classDef, MemberListType_proSlots,
-                         theTranslator->trProtectedSlots());
-      ctx->addMemberList(m_classDef, MemberListType_proMethods,
-                         theTranslator->trProtectedMembers());
-      ctx->addMemberList(m_classDef, MemberListType_proStaticMethods,
-                         theTranslator->trStaticProtectedMembers());
-      ctx->addMemberList(m_classDef, MemberListType_proAttribs,
-                         theTranslator->trProtectedAttribs());
-      ctx->addMemberList(m_classDef, MemberListType_proStaticAttribs,
-                         theTranslator->trStaticProtectedAttribs());
-      ctx->addMemberList(m_classDef, MemberListType_pacTypes,
-                         theTranslator->trPackageTypes());
-      ctx->addMemberList(m_classDef, MemberListType_pacMethods,
-                         theTranslator->trPackageMembers());
-      ctx->addMemberList(m_classDef, MemberListType_pacStaticMethods,
-                         theTranslator->trStaticPackageMembers());
-      ctx->addMemberList(m_classDef, MemberListType_pacAttribs,
-                         theTranslator->trPackageAttribs());
-      ctx->addMemberList(m_classDef, MemberListType_pacStaticAttribs,
-                         theTranslator->trStaticPackageAttribs());
-      ctx->addMemberList(m_classDef, MemberListType_properties,
-                         theTranslator->trProperties());
-      ctx->addMemberList(m_classDef, MemberListType_events,
-                         theTranslator->trEvents());
-      ctx->addMemberList(m_classDef, MemberListType_priTypes,
-                         theTranslator->trPrivateTypes());
-      ctx->addMemberList(m_classDef, MemberListType_priSlots,
-                         theTranslator->trPrivateSlots());
-      ctx->addMemberList(m_classDef, MemberListType_priMethods,
-                         theTranslator->trPrivateMembers());
-      ctx->addMemberList(m_classDef, MemberListType_priStaticMethods,
-                         theTranslator->trStaticPrivateMembers());
-      ctx->addMemberList(m_classDef, MemberListType_priAttribs,
-                         theTranslator->trPrivateAttribs());
-      ctx->addMemberList(m_classDef, MemberListType_priStaticAttribs,
-                         theTranslator->trStaticPrivateAttribs());
-      ctx->addMemberList(m_classDef, MemberListType_related,
-                         theTranslator->trRelatedFunctions());
-      cache.additionalInheritedMembers.reset(ctx);
-    }
-    return cache.additionalInheritedMembers.get();
-  }
-  TemplateVariant isSimple() const { return m_classDef->isSimple(); }
-  TemplateVariant categoryOf() const {
-    Cachable &cache = getCache();
-    if (!cache.categoryOf && m_classDef->categoryOf()) {
-      cache.categoryOf.reset(ClassContext::alloc(m_classDef->categoryOf()));
-    }
-    if (cache.categoryOf) {
-      return cache.categoryOf.get();
-    } else {
-      return TemplateVariant(FALSE);
+    TemplateVariant detailedMacros() const
+    {
+      return getMemberList(getCache().detailedMacros,MemberListType_docDefineMembers,theTranslator->trDefineDocumentation());
+    }
+    TemplateVariant detailedTypedefs() const
+    {
+      return getMemberList(getCache().detailedTypedefs,MemberListType_docTypedefMembers,theTranslator->trTypedefDocumentation());
+    }
+    TemplateVariant detailedEnums() const
+    {
+      return getMemberList(getCache().detailedEnums,MemberListType_docEnumMembers,theTranslator->trEnumerationTypeDocumentation());
+    }
+    TemplateVariant detailedFunctions() const
+    {
+      QCString title = theTranslator->trFunctionDocumentation();
+      SrcLangExt lang = m_fileDef->getLanguage();
+      if (lang==SrcLangExt_Fortran) title=theTranslator->trSubprogramDocumentation();
+      return getMemberList(getCache().detailedFunctions,MemberListType_docFuncMembers,title);
+    }
+    TemplateVariant detailedVariables() const
+    {
+      return getMemberList(getCache().detailedVariables,MemberListType_docVarMembers,theTranslator->trVariableDocumentation());
+    }
+    TemplateVariant inlineClasses() const
+    {
+      Cachable &cache = getCache();
+      if (!cache.inlineClasses)
+      {
+        TemplateList *classList = TemplateList::alloc();
+        if (m_fileDef->getClassSDict())
+        {
+          ClassSDict::Iterator sdi(*m_fileDef->getClassSDict());
+          ClassDef *cd;
+          for (sdi.toFirst();(cd=sdi.current());++sdi)
+          {
+            if (cd->name().find('@')==-1 &&
+                cd->isLinkableInProject() &&
+                cd->isEmbeddedInOuterScope() &&
+                cd->partOfGroups()==0)
+            {
+              classList->append(ClassContext::alloc(cd));
+            }
+          }
+        }
+        cache.inlineClasses.reset(classList);
+      }
+      return cache.inlineClasses.get();
+    }
+    TemplateVariant compoundType() const
+    {
+      return theTranslator->trFile(FALSE,TRUE);
     }
-  }
 
-private:
-  ClassDef *m_classDef;
-  struct Cachable : public DefinitionContext<ClassContext::Private>::Cachable {
-    Cachable(ClassDef *cd)
-        : DefinitionContext<ClassContext::Private>::Cachable(cd),
-          inheritanceNodes(-1) {}
-    SharedPtr<IncludeInfoContext> includeInfo;
-    SharedPtr<InheritanceListContext> inheritsList;
-    SharedPtr<InheritanceListContext> inheritedByList;
-    ScopedPtr<DotClassGraph> classGraph;
-    ScopedPtr<DotClassGraph> collaborationGraph;
-    SharedPtr<TemplateList> classes;
-    SharedPtr<TemplateList> innerClasses;
-    SharedPtr<MemberListInfoContext> publicTypes;
-    SharedPtr<MemberListInfoContext> publicMethods;
-    SharedPtr<MemberListInfoContext> publicStaticMethods;
-    SharedPtr<MemberListInfoContext> publicAttributes;
-    SharedPtr<MemberListInfoContext> publicStaticAttributes;
-    SharedPtr<MemberListInfoContext> publicSlots;
-    SharedPtr<MemberListInfoContext> protectedTypes;
-    SharedPtr<MemberListInfoContext> protectedMethods;
-    SharedPtr<MemberListInfoContext> protectedStaticMethods;
-    SharedPtr<MemberListInfoContext> protectedAttributes;
-    SharedPtr<MemberListInfoContext> protectedStaticAttributes;
-    SharedPtr<MemberListInfoContext> protectedSlots;
-    SharedPtr<MemberListInfoContext> privateTypes;
-    SharedPtr<MemberListInfoContext> privateMethods;
-    SharedPtr<MemberListInfoContext> privateStaticMethods;
-    SharedPtr<MemberListInfoContext> privateAttributes;
-    SharedPtr<MemberListInfoContext> privateStaticAttributes;
-    SharedPtr<MemberListInfoContext> privateSlots;
-    SharedPtr<MemberListInfoContext> packageTypes;
-    SharedPtr<MemberListInfoContext> packageMethods;
-    SharedPtr<MemberListInfoContext> packageStaticMethods;
-    SharedPtr<MemberListInfoContext> packageAttributes;
-    SharedPtr<MemberListInfoContext> packageStaticAttributes;
-    SharedPtr<MemberListInfoContext> unoIDLServices;
-    SharedPtr<MemberListInfoContext> unoIDLInterfaces;
-    SharedPtr<MemberListInfoContext> signals;
-    SharedPtr<MemberListInfoContext> properties;
-    SharedPtr<MemberListInfoContext> events;
-    SharedPtr<MemberListInfoContext> friends;
-    SharedPtr<MemberListInfoContext> related;
-    SharedPtr<MemberListInfoContext> detailedTypedefs;
-    SharedPtr<MemberListInfoContext> detailedEnums;
-    SharedPtr<MemberListInfoContext> detailedServices;
-    SharedPtr<MemberListInfoContext> detailedClauses;
-    SharedPtr<MemberListInfoContext> detailedInterfaces;
-    SharedPtr<MemberListInfoContext> detailedConstructors;
-    SharedPtr<MemberListInfoContext> detailedMethods;
-    SharedPtr<MemberListInfoContext> detailedRelated;
-    SharedPtr<MemberListInfoContext> detailedVariables;
-    SharedPtr<MemberListInfoContext> detailedProperties;
-    SharedPtr<MemberListInfoContext> detailedEvents;
-    SharedPtr<MemberGroupListContext> memberGroups;
-    SharedPtr<AllMembersListContext> allMembersList;
-    SharedPtr<ArgumentListContext> typeConstraints;
-    SharedPtr<TemplateList> examples;
-    SharedPtr<TemplateList> templateDecls;
-    SharedPtr<InheritedMemberInfoListContext> additionalInheritedMembers;
-    SharedPtr<MemberListContext> members;
-    SharedPtr<UsedFilesContext> usedFiles;
-    SharedPtr<TemplateList> exampleList;
-    SharedPtr<ClassContext> categoryOf;
-    int inheritanceNodes;
-    MemberList allMembers;
-  };
-  Cachable &getCache() const {
-    Cachable *c = static_cast<Cachable *>(m_classDef->cookie());
-    assert(c != 0);
-    return *c;
-  }
-  static PropertyMapper<ClassContext::Private> s_inst;
+  private:
+    FileDef *m_fileDef;
+    struct Cachable : public DefinitionContext<FileContext::Private>::Cachable
+    {
+      Cachable(FileDef *fd) : DefinitionContext<FileContext::Private>::Cachable(fd) {}
+      SharedPtr<IncludeInfoListContext>     includeInfoList;
+      ScopedPtr<DotInclDepGraph>            includeGraph;
+      ScopedPtr<DotInclDepGraph>            includedByGraph;
+      ScopedPtr<TemplateVariant>            sources;
+      SharedPtr<TemplateList>               classes;
+      SharedPtr<TemplateList>               namespaces;
+      SharedPtr<TemplateList>               constantgroups;
+      SharedPtr<MemberListInfoContext>      macros;
+      SharedPtr<MemberListInfoContext>      typedefs;
+      SharedPtr<MemberListInfoContext>      enums;
+      SharedPtr<MemberListInfoContext>      functions;
+      SharedPtr<MemberListInfoContext>      variables;
+      SharedPtr<MemberGroupListContext>     memberGroups;
+      SharedPtr<MemberListInfoContext>      detailedMacros;
+      SharedPtr<MemberListInfoContext>      detailedTypedefs;
+      SharedPtr<MemberListInfoContext>      detailedEnums;
+      SharedPtr<MemberListInfoContext>      detailedFunctions;
+      SharedPtr<MemberListInfoContext>      detailedVariables;
+      SharedPtr<TemplateList>               inlineClasses;
+    };
+    Cachable &getCache() const
+    {
+      Cachable *c = static_cast<Cachable*>(m_fileDef->cookie());
+      assert(c!=0);
+      return *c;
+    }
+    static PropertyMapper<FileContext::Private> s_inst;
 };
 //%% }
 
-PropertyMapper<ClassContext::Private> ClassContext::Private::s_inst;
+PropertyMapper<FileContext::Private> FileContext::Private::s_inst;
 
-ClassContext::ClassContext(ClassDef *cd) : RefCountedContext("ClassContext") {
-  // printf("ClassContext::ClassContext(%s)\n",cd?cd->name().data():"<none>");
-  p = new Private(cd);
+FileContext::FileContext(FileDef *fd) : RefCountedContext("FileContext")
+{
+  p = new Private(fd);
 }
 
-ClassContext::~ClassContext() { delete p; }
+FileContext::~FileContext()
+{
+  delete p;
+}
 
-TemplateVariant ClassContext::get(const char *n) const { return p->get(n); }
+TemplateVariant FileContext::get(const char *n) const
+{
+  return p->get(n);
+}
 
 //------------------------------------------------------------------------
 
-//%% struct Namespace(Symbol): namespace information
+//%% struct Dir(Symbol): directory information
 //%% {
-class NamespaceContext::Private
-    : public DefinitionContext<NamespaceContext::Private> {
-public:
-  Private(NamespaceDef *nd)
-      : DefinitionContext<NamespaceContext::Private>(nd), m_namespaceDef(nd) {
-    static bool init = FALSE;
-    if (!init) {
-      addBaseProperties(s_inst);
-      s_inst.addProperty("title", &Private::title);
-      s_inst.addProperty("highlight", &Private::highlight);
-      s_inst.addProperty("subhighlight", &Private::subHighlight);
-      s_inst.addProperty("compoundType", &Private::compoundType);
-      s_inst.addProperty("hasDetails", &Private::hasDetails);
-      s_inst.addProperty("classes", &Private::classes);
-      s_inst.addProperty("namespaces", &Private::namespaces);
-      s_inst.addProperty("constantgroups", &Private::constantgroups);
-      s_inst.addProperty("typedefs", &Private::typedefs);
-      s_inst.addProperty("enums", &Private::enums);
-      s_inst.addProperty("functions", &Private::functions);
-      s_inst.addProperty("variables", &Private::variables);
-      s_inst.addProperty("memberGroups", &Private::memberGroups);
-      s_inst.addProperty("detailedTypedefs", &Private::detailedTypedefs);
-      s_inst.addProperty("detailedEnums", &Private::detailedEnums);
-      s_inst.addProperty("detailedFunctions", &Private::detailedFunctions);
-      s_inst.addProperty("detailedVariables", &Private::detailedVariables);
-      s_inst.addProperty("inlineClasses", &Private::inlineClasses);
-      init = TRUE;
-    }
-    if (!nd->cookie()) {
-      nd->setCookie(new NamespaceContext::Private::Cachable(nd));
+class DirContext::Private : public DefinitionContext<DirContext::Private>
+{
+  public:
+    Private(DirDef *dd) : DefinitionContext<DirContext::Private>(dd) , m_dirDef(dd)
+    {
+      static bool init=FALSE;
+      if (!init)
+      {
+        addBaseProperties(s_inst);
+        s_inst.addProperty("title",         &Private::title);
+        s_inst.addProperty("highlight",     &Private::highlight);
+        s_inst.addProperty("subhighlight",  &Private::subHighlight);
+        s_inst.addProperty("dirName",       &Private::dirName);
+        s_inst.addProperty("dirs",          &Private::dirs);
+        s_inst.addProperty("files",         &Private::files);
+        s_inst.addProperty("hasDetails",    &Private::hasDetails);
+        s_inst.addProperty("hasDirGraph",   &Private::hasDirGraph);
+        s_inst.addProperty("dirGraph",      &Private::dirGraph);
+        s_inst.addProperty("compoundType",  &Private::compoundType);
+        init=TRUE;
+      }
+      if (!dd->cookie()) { dd->setCookie(new DirContext::Private::Cachable(dd)); }
     }
-  }
-  virtual ~Private() {}
-  TemplateVariant get(const char *n) const { return s_inst.get(this, n); }
-  TemplateVariant title() const {
-    return TemplateVariant(m_namespaceDef->title());
-  }
-  TemplateVariant highlight() const { return TemplateVariant("namespaces"); }
-  TemplateVariant subHighlight() const { return TemplateVariant(""); }
-  TemplateVariant compoundType() const {
-    return m_namespaceDef->compoundTypeString();
-  }
-  TemplateVariant hasDetails() const {
-    return m_namespaceDef->hasDetailedDescription();
-  }
-  TemplateVariant classes() const {
-    Cachable &cache = getCache();
-    if (!cache.classes) {
-      TemplateList *classList = TemplateList::alloc();
-      if (m_namespaceDef->getClassSDict()) {
-        ClassSDict::Iterator sdi(*m_namespaceDef->getClassSDict());
-        ClassDef *cd;
-        for (sdi.toFirst(); (cd = sdi.current()); ++sdi) {
-          if (cd->visibleInParentsDeclList()) {
-            classList->append(ClassContext::alloc(cd));
-          }
+    virtual ~Private() {}
+    TemplateVariant get(const char *n) const
+    {
+      return s_inst.get(this,n);
+    }
+    TemplateVariant title() const
+    {
+      return TemplateVariant(m_dirDef->shortTitle());
+    }
+    TemplateVariant highlight() const
+    {
+      return TemplateVariant("files");
+    }
+    TemplateVariant subHighlight() const
+    {
+      return TemplateVariant("");
+    }
+    TemplateVariant dirName() const
+    {
+      return TemplateVariant(m_dirDef->shortName());
+    }
+    TemplateVariant dirs() const
+    {
+      Cachable &cache = getCache();
+      if (!cache.dirs)
+      {
+        cache.dirs.reset(TemplateList::alloc());
+        const DirList &subDirs = m_dirDef->subDirs();
+        QListIterator<DirDef> it(subDirs);
+        DirDef *dd;
+        for (it.toFirst();(dd=it.current());++it)
+        {
+          DirContext *dc = new DirContext(dd);
+          cache.dirs->append(dc);
         }
       }
-      cache.classes.reset(classList);
+      return cache.dirs.get();
     }
-    return cache.classes.get();
-  }
-  TemplateVariant namespaces() const {
-    Cachable &cache = getCache();
-    if (!cache.namespaces) {
-      TemplateList *namespaceList = TemplateList::alloc();
-      if (m_namespaceDef->getNamespaceSDict()) {
-        NamespaceSDict::Iterator sdi(*m_namespaceDef->getNamespaceSDict());
-        NamespaceDef *nd;
-        for (sdi.toFirst(); (nd = sdi.current()); ++sdi) {
-          if (nd->isLinkable() && !nd->isConstantGroup()) {
-            namespaceList->append(NamespaceContext::alloc(nd));
+    TemplateVariant files() const
+    {
+      Cachable &cache = getCache();
+      if (!cache.files)
+      {
+        cache.files.reset(TemplateList::alloc());
+        FileList *files = m_dirDef->getFiles();
+        if (files)
+        {
+          QListIterator<FileDef> it(*files);
+          FileDef *fd;
+          for (it.toFirst();(fd=it.current());++it)
+          {
+            FileContext *fc = FileContext::alloc(fd);
+            cache.files->append(fc);
           }
         }
       }
-      cache.namespaces.reset(namespaceList);
+      return cache.files.get();
     }
-    return cache.namespaces.get();
-  }
-  TemplateVariant constantgroups() const {
-    Cachable &cache = getCache();
-    if (!cache.constantgroups) {
-      TemplateList *namespaceList = TemplateList::alloc();
-      if (m_namespaceDef->getNamespaceSDict()) {
-        NamespaceSDict::Iterator sdi(*m_namespaceDef->getNamespaceSDict());
-        NamespaceDef *nd;
-        for (sdi.toFirst(); (nd = sdi.current()); ++sdi) {
-          if (nd->isLinkable() && nd->isConstantGroup()) {
-            namespaceList->append(NamespaceContext::alloc(nd));
-          }
-        }
+    TemplateVariant hasDetails() const
+    {
+      return m_dirDef->hasDetailedDescription();
+    }
+    TemplateVariant compoundType() const
+    {
+      return theTranslator->trDir(FALSE,TRUE);
+    }
+    TemplateVariant relPath() const
+    {
+      return "";
+    }
+    DotDirDeps *getDirDepsGraph() const
+    {
+      Cachable &cache = getCache();
+      if (!cache.dirDepsGraph)
+      {
+        cache.dirDepsGraph.reset(new DotDirDeps(m_dirDef));
       }
-      cache.constantgroups.reset(namespaceList);
+      return cache.dirDepsGraph.get();
     }
-    return cache.constantgroups.get();
-  }
-  TemplateVariant getMemberList(SharedPtr<MemberListInfoContext> &list,
-                                MemberListType type, const char *title,
-                                bool detailed = FALSE) const {
-    if (!list) {
-      MemberList *ml = m_namespaceDef->getMemberList(type);
-      if (ml) {
-        list.reset(MemberListInfoContext::alloc(
-            m_namespaceDef, relPathAsString(), ml, title, ""));
-      }
-    }
-    if (list) {
-      return list.get();
-    } else {
-      return TemplateVariant(FALSE);
+    TemplateVariant hasDirGraph() const
+    {
+      bool result=FALSE;
+      static bool haveDot  = Config_getBool(HAVE_DOT);
+      static bool dirGraph = Config_getBool(DIRECTORY_GRAPH);
+      if (haveDot && dirGraph)
+      {
+        DotDirDeps *graph = getDirDepsGraph();
+        result = !graph->isTrivial();
+      }
+      return result;
     }
-  }
-  TemplateVariant typedefs() const {
-    return getMemberList(getCache().typedefs, MemberListType_decTypedefMembers,
-                         theTranslator->trTypedefs());
-  }
-  TemplateVariant enums() const {
-    return getMemberList(getCache().enums, MemberListType_decEnumMembers,
-                         theTranslator->trEnumerations());
-  }
-  TemplateVariant functions() const {
-    QCString title = theTranslator->trFunctions();
-    SrcLangExt lang = m_namespaceDef->getLanguage();
-    if (lang == SrcLangExt_Fortran)
-      title = theTranslator->trSubprograms();
-    else if (lang == SrcLangExt_VHDL)
-      title = VhdlDocGen::trFunctionAndProc();
-    return getMemberList(getCache().functions, MemberListType_decFuncMembers,
-                         title);
-  }
-  TemplateVariant variables() const {
-    return getMemberList(getCache().variables, MemberListType_decVarMembers,
-                         theTranslator->trVariables());
-  }
-  TemplateVariant memberGroups() const {
-    Cachable &cache = getCache();
-    if (!cache.memberGroups) {
-      if (m_namespaceDef->getMemberGroupSDict()) {
-        cache.memberGroups.reset(
-            MemberGroupListContext::alloc(m_namespaceDef, relPathAsString(),
-                                          m_namespaceDef->getMemberGroupSDict(),
-                                          m_namespaceDef->subGrouping()));
-      } else {
-        cache.memberGroups.reset(MemberGroupListContext::alloc());
-      }
-    }
-    return cache.memberGroups.get();
-  }
-  TemplateVariant detailedTypedefs() const {
-    return getMemberList(getCache().detailedTypedefs,
-                         MemberListType_docTypedefMembers,
-                         theTranslator->trTypedefDocumentation());
-  }
-  TemplateVariant detailedEnums() const {
-    return getMemberList(getCache().detailedEnums,
-                         MemberListType_docEnumMembers,
-                         theTranslator->trEnumerationTypeDocumentation());
-  }
-  TemplateVariant detailedFunctions() const {
-    QCString title = theTranslator->trFunctionDocumentation();
-    SrcLangExt lang = m_namespaceDef->getLanguage();
-    if (lang == SrcLangExt_Fortran)
-      title = theTranslator->trSubprogramDocumentation();
-    return getMemberList(getCache().detailedFunctions,
-                         MemberListType_docFuncMembers, title);
-  }
-  TemplateVariant detailedVariables() const {
-    return getMemberList(getCache().detailedVariables,
-                         MemberListType_docVarMembers,
-                         theTranslator->trVariableDocumentation());
-  }
-  TemplateVariant inlineClasses() const {
-    Cachable &cache = getCache();
-    if (!cache.inlineClasses) {
-      TemplateList *classList = TemplateList::alloc();
-      if (m_namespaceDef->getClassSDict()) {
-        ClassSDict::Iterator sdi(*m_namespaceDef->getClassSDict());
-        ClassDef *cd;
-        for (sdi.toFirst(); (cd = sdi.current()); ++sdi) {
-          if (cd->name().find('@') == -1 && cd->isLinkableInProject() &&
-              cd->isEmbeddedInOuterScope() && cd->partOfGroups() == 0) {
-            classList->append(ClassContext::alloc(cd));
-          }
+    TemplateVariant dirGraph() const
+    {
+      QGString result;
+      static bool haveDot  = Config_getBool(HAVE_DOT);
+      static bool dirGraph = Config_getBool(DIRECTORY_GRAPH);
+      if (haveDot && dirGraph)
+      {
+        DotDirDeps *graph = getDirDepsGraph();
+        FTextStream t(&result);
+        switch (g_globals.outputFormat)
+        {
+          case ContextOutputFormat_Html:
+            {
+              graph->writeGraph(t,GOF_BITMAP,
+                                EOF_Html,
+                                g_globals.outputDir,
+                                g_globals.outputDir+portable_pathSeparator()+m_dirDef->getOutputFileBase()+Doxygen::htmlFileExtension,
+                                relPathAsString(),
+                                TRUE,
+                                g_globals.dynSectionId,
+                                FALSE);
+            }
+            break;
+          case ContextOutputFormat_Latex:
+            {
+              graph->writeGraph(t,GOF_EPS,
+                                EOF_LaTeX,
+                                g_globals.outputDir,
+                                g_globals.outputDir+portable_pathSeparator()+m_dirDef->getOutputFileBase()+".tex",
+                                relPathAsString(),
+                                TRUE,
+                                g_globals.dynSectionId,
+                                FALSE);
+            }
+            break;
+            // TODO: support other generators
+          default:
+            err("context.cpp: output format not yet supported");
+            break;
         }
+        g_globals.dynSectionId++;
       }
-      cache.inlineClasses.reset(classList);
+      return TemplateVariant(result.data(),TRUE);
     }
-    return cache.inlineClasses.get();
-  }
 
-private:
-  NamespaceDef *m_namespaceDef;
-  struct Cachable
-      : public DefinitionContext<NamespaceContext::Private>::Cachable {
-    Cachable(NamespaceDef *nd)
-        : DefinitionContext<NamespaceContext::Private>::Cachable(nd) {}
-    SharedPtr<TemplateList> classes;
-    SharedPtr<TemplateList> namespaces;
-    SharedPtr<TemplateList> constantgroups;
-    SharedPtr<MemberListInfoContext> typedefs;
-    SharedPtr<MemberListInfoContext> enums;
-    SharedPtr<MemberListInfoContext> functions;
-    SharedPtr<MemberListInfoContext> variables;
-    SharedPtr<MemberGroupListContext> memberGroups;
-    SharedPtr<MemberListInfoContext> detailedTypedefs;
-    SharedPtr<MemberListInfoContext> detailedEnums;
-    SharedPtr<MemberListInfoContext> detailedFunctions;
-    SharedPtr<MemberListInfoContext> detailedVariables;
-    SharedPtr<TemplateList> inlineClasses;
-  };
-  Cachable &getCache() const {
-    Cachable *c = static_cast<Cachable *>(m_namespaceDef->cookie());
-    assert(c != 0);
-    return *c;
-  }
-  static PropertyMapper<NamespaceContext::Private> s_inst;
+  private:
+    DirDef *m_dirDef;
+    struct Cachable : public DefinitionContext<DirContext::Private>::Cachable
+    {
+      Cachable(DirDef *dd) : DefinitionContext<DirContext::Private>::Cachable(dd) {}
+      SharedPtr<TemplateList>  dirs;
+      SharedPtr<TemplateList>  files;
+      ScopedPtr<DotDirDeps>    dirDepsGraph;
+    };
+    Cachable &getCache() const
+    {
+      Cachable *c = static_cast<Cachable*>(m_dirDef->cookie());
+      assert(c!=0);
+      return *c;
+    }
+    static PropertyMapper<DirContext::Private> s_inst;
 };
 //%% }
 
-PropertyMapper<NamespaceContext::Private> NamespaceContext::Private::s_inst;
+PropertyMapper<DirContext::Private> DirContext::Private::s_inst;
 
-NamespaceContext::NamespaceContext(NamespaceDef *nd)
-    : RefCountedContext("NamespaceContext") {
-  p = new Private(nd);
+DirContext::DirContext(DirDef *fd) : RefCountedContext("DirContext")
+{
+  p = new Private(fd);
 }
 
+DirContext::~DirContext()
+{
+  delete p;
+}
 
-//%% struct Member(Symbol): member information
+TemplateVariant DirContext::get(const char *n) const
+{
+  return p->get(n);
+}
+
+//------------------------------------------------------------------------
+
+//%% struct Page(Symbol): page information
 //%% {
-class MemberContext::Private : public DefinitionContext<MemberContext::Private>
+class PageContext::Private : public DefinitionContext<PageContext::Private>
 {
   public:
-    Private(MemberDef *md) : DefinitionContext<MemberContext::Private>(md) , m_memberDef(md)
+    Private(PageDef *pd,bool isMainPage,bool isExample)
+      : DefinitionContext<PageContext::Private>(pd) , m_pageDef(pd), m_isMainPage(isMainPage),
+        m_isExample(isExample)
     {
       static bool init=FALSE;
       if (!init)
       {
         addBaseProperties(s_inst);
-        s_inst.addProperty("isSignal",            &Private::isSignal);
-        s_inst.addProperty("isSlot",              &Private::isSlot);
-        s_inst.addProperty("isVariable",          &Private::isVariable);
-        s_inst.addProperty("isEnumeration",       &Private::isEnumeration);
-        s_inst.addProperty("isEnumValue",         &Private::isEnumValue);
-        s_inst.addProperty("isTypedef",           &Private::isTypedef);
-        s_inst.addProperty("isFunction",          &Private::isFunction);
-        s_inst.addProperty("isFunctionPtr",       &Private::isFunctionPtr);
-        s_inst.addProperty("isDefine",            &Private::isDefine);
-        s_inst.addProperty("isFriend",            &Private::isFriend);
-        s_inst.addProperty("isProperty",          &Private::isProperty);
-        s_inst.addProperty("isEvent",             &Private::isEvent);
-        s_inst.addProperty("isRelated",           &Private::isRelated);
-        s_inst.addProperty("isForeign",           &Private::isForeign);
-        s_inst.addProperty("isStatic",            &Private::isStatic);
-        s_inst.addProperty("isInline",            &Private::isInline);
-        s_inst.addProperty("isExplicit",          &Private::isExplicit);
-        s_inst.addProperty("isMutable",           &Private::isMutable);
-        s_inst.addProperty("isGettable",          &Private::isGettable);
-        s_inst.addProperty("isPrivateGettable",   &Private::isPrivateGettable);
-        s_inst.addProperty("isProtectedGettable", &Private::isProtectedGettable);
-        s_inst.addProperty("isSettable",          &Private::isSettable);
-        s_inst.addProperty("isPrivateSettable",   &Private::isPrivateSettable);
-        s_inst.addProperty("isProtectedSettable", &Private::isProtectedSettable);
-        s_inst.addProperty("isReadable",          &Private::isReadable);
-        s_inst.addProperty("isWritable",          &Private::isWritable);
-        s_inst.addProperty("isAddable",           &Private::isAddable);
-        s_inst.addProperty("isRemovable",         &Private::isRemovable);
-        s_inst.addProperty("isRaisable",          &Private::isRaisable);
-        s_inst.addProperty("isFinal",             &Private::isFinal);
-        s_inst.addProperty("isAbstract",          &Private::isAbstract);
-        s_inst.addProperty("isOverride",          &Private::isOverride);
-        s_inst.addProperty("isInitonly",          &Private::isInitonly);
-        s_inst.addProperty("isOptional",          &Private::isOptional);
-        s_inst.addProperty("isRequired",          &Private::isRequired);
-        s_inst.addProperty("isNonAtomic",         &Private::isNonAtomic);
-        s_inst.addProperty("isCopy",              &Private::isCopy);
-        s_inst.addProperty("isAssign",            &Private::isAssign);
-        s_inst.addProperty("isRetain",            &Private::isRetain);
-        s_inst.addProperty("isWeak",              &Private::isWeak);
-        s_inst.addProperty("isStrong",            &Private::isStrong);
-        s_inst.addProperty("isUnretained",        &Private::isUnretained);
-        s_inst.addProperty("isNew",               &Private::isNew);
-        s_inst.addProperty("isSealed",            &Private::isSealed);
-        s_inst.addProperty("isImplementation",    &Private::isImplementation);
-        s_inst.addProperty("isExternal",          &Private::isExternal);
-        s_inst.addProperty("isAlias",             &Private::isAlias);
-        s_inst.addProperty("isDefault",           &Private::isDefault);
-        s_inst.addProperty("isDelete",            &Private::isDelete);
+        s_inst.addProperty("title",       &Private::title);
+        s_inst.addProperty("highlight",   &Private::highlight);
+        s_inst.addProperty("subhighlight",&Private::subHighlight);
+        s_inst.addProperty("example",     &Private::example);
+        init=TRUE;
+      }
+      if (!pd->cookie()) { pd->setCookie(new PageContext::Private::Cachable(pd)); }
+    }
+    virtual ~Private() {}
+    TemplateVariant get(const char *n) const
+    {
+      return s_inst.get(this,n);
+    }
+    TemplateVariant title() const
+    {
+      if (m_isMainPage)
+      {
+        if (mainPageHasTitle())
+        {
+          return m_pageDef->title();
+        }
+        else
+        {
+          return theTranslator->trMainPage();
+        }
+      }
+      else if (m_isExample)
+      {
+        return m_pageDef->name();
+      }
+      else
+      {
+        return m_pageDef->title();
+      }
+    }
+    TemplateVariant relPath() const
+    {
+      if (m_isMainPage)
+      {
+        return "";
+      }
+      else
+      {
+        return DefinitionContext<PageContext::Private>::relPath();
+      }
+    }
+    TemplateVariant highlight() const
+    {
+      if (m_isMainPage)
+      {
+        return "main";
+      }
+      else
+      {
+        return "pages";
+      }
+    }
+    TemplateVariant subHighlight() const
+    {
+      return "";
+    }
+    TemplateVariant example() const
+    {
+      if (m_isExample)
+      {
+        Cachable &cache = getCache();
+        if (!cache.example || g_globals.outputFormat!=cache.exampleOutputFormat)
+        {
+          cache.example.reset(new TemplateVariant(
+                parseDoc(m_pageDef,m_pageDef->docFile(),m_pageDef->docLine(),
+                  relPathAsString(),"\\include "+m_pageDef->name(),FALSE)));
+          cache.exampleOutputFormat = g_globals.outputFormat;
+        }
+        return *cache.example;
+      }
+      else
+      {
+        return TemplateVariant("");
+      }
+    }
+  private:
+    PageDef *m_pageDef;
+    struct Cachable : public DefinitionContext<PageContext::Private>::Cachable
+    {
+      Cachable(PageDef *pd) : DefinitionContext<PageContext::Private>::Cachable(pd),
+                              exampleOutputFormat(ContextOutputFormat_Unspecified) { }
+      ScopedPtr<TemplateVariant> example;
+      ContextOutputFormat        exampleOutputFormat;
+    };
+    Cachable &getCache() const
+    {
+      Cachable *c = static_cast<Cachable*>(m_pageDef->cookie());
+      assert(c!=0);
+      return *c;
+    }
+    bool m_isMainPage;
+    bool m_isExample;
+    static PropertyMapper<PageContext::Private> s_inst;
+};
+//%% }
+
+PropertyMapper<PageContext::Private> PageContext::Private::s_inst;
+
+PageContext::PageContext(PageDef *pd,bool isMainPage,bool isExample) : RefCountedContext("PageContext")
+{
+  p = new Private(pd,isMainPage,isExample);
+}
+
+PageContext::~PageContext()
+{
+  delete p;
+}
+
+TemplateVariant PageContext::get(const char *n) const
+{
+  return p->get(n);
+}
+
+//------------------------------------------------------------------------
+
+class TextGeneratorHtml : public TextGeneratorIntf
+{
+  public:
+    TextGeneratorHtml(FTextStream &ts,const QCString &relPath)
+       : m_ts(ts), m_relPath(relPath) {}
+    void writeString(const char *s,bool keepSpaces) const
+    {
+      if (s==0) return;
+      if (keepSpaces)
+      {
+        const char *p=s;
+        char c;
+        while ((c=*p++))
+        {
+          switch(c)
+          {
+            case '<':  m_ts << "&lt;"; break;
+            case '>':  m_ts << "&gt;"; break;
+            case '\'': m_ts << "&#39;"; break;
+            case '"':  m_ts << "&quot;"; break;
+            case '&':  m_ts << "&amp;"; break;
+            case ' ':  m_ts << "&#160;"; break;
+          }
+        }
+      }
+      else
+      {
+        m_ts << convertToHtml(s);
+      }
+    }
+
+    void writeBreak(int indent) const
+    {
+      m_ts << "<br />";
+      for (int i=0;i<indent;i++)
+      {
+        m_ts << "&#160;";
+      }
+    }
+
+    void writeLink(const char *ref,const char *f,
+                   const char *anchor,const char *name
+                  ) const
+    {
+      if (ref)
+      {
+        m_ts << "<a class=\"elRef\" ";
+        m_ts << externalLinkTarget() << externalRef(m_relPath,ref,FALSE);
+      }
+      else
+      {
+        m_ts << "<a class=\"el\" ";
+      }
+      m_ts << "href=\"";
+      m_ts << externalRef(m_relPath,ref,TRUE);
+      if (f) m_ts << f << Doxygen::htmlFileExtension;
+      if (anchor) m_ts << "#" << anchor;
+      m_ts << "\">";
+      m_ts << convertToHtml(name);
+      m_ts << "</a>";
+    }
+
+  private:
+    FTextStream &m_ts;
+    QCString m_relPath;
+};
+
+//------------------------------------------------------------------------
+
+class TextGeneratorLatex : public TextGeneratorIntf
+{
+  public:
+    TextGeneratorLatex(FTextStream &ts) : m_ts(ts) {}
+    void writeString(const char *s,bool keepSpaces) const
+    {
+      if (s==0) return;
+      m_ts << convertToLaTeX(s,FALSE,keepSpaces);
+    }
+    void writeBreak(int indent) const
+    {
+      m_ts << "\\\\*\n";
+      for (int i=0;i<indent;i++)
+      {
+        m_ts << "~";
+      }
+    }
+    void writeLink(const char *ref,const char *f,
+                   const char *anchor,const char *text
+                  ) const
+    {
+      static bool pdfHyperlinks = Config_getBool(PDF_HYPERLINKS);
+      if (!ref && pdfHyperlinks)
+      {
+        m_ts << "\\hyperlink{";
+        if (f) m_ts << stripPath(f);
+        if (f && anchor) m_ts << "_";
+        if (anchor) m_ts << anchor;
+        m_ts << "}{";
+        filterLatexString(m_ts,text);
+        m_ts << "}";
+      }
+      else
+      {
+        m_ts << "{\\bf ";
+        filterLatexString(m_ts,text);
+        m_ts << "}";
+      }
+    }
+
+  private:
+    FTextStream &m_ts;
+};
+
+//------------------------------------------------------------------------
+
+class TextGeneratorFactory
+{
+  public:
+    static TextGeneratorFactory *instance()
+    {
+      static TextGeneratorFactory *instance = 0;
+      if (instance==0) instance = new TextGeneratorFactory;
+      return instance;
+    }
+    TextGeneratorIntf *create(FTextStream &ts,const QCString &relPath)
+    {
+      switch (g_globals.outputFormat)
+      {
+        case ContextOutputFormat_Html:
+          return new TextGeneratorHtml(ts,relPath);
+        case ContextOutputFormat_Latex:
+          return new TextGeneratorLatex(ts);
+        default:
+          break;
+      }
+      return 0;
+    }
+  private:
+    TextGeneratorFactory() {}
+    virtual ~TextGeneratorFactory() {}
+};
+
+TemplateVariant createLinkedText(Definition *def,const QCString &relPath,const QCString &text)
+{
+  QGString s;
+  FTextStream ts(&s);
+  TextGeneratorIntf *tg = TextGeneratorFactory::instance()->create(ts,relPath);
+  if (tg)
+  {
+    linkifyText(*tg,def->getOuterScope(),def->getBodyDef(),def,text);
+    delete tg;
+    return TemplateVariant(s.data(),TRUE);
+  }
+  else
+  {
+    return text;
+  }
+}
+
+//%% struct Member(Symbol): member information
+//%% {
+class MemberContext::Private : public DefinitionContext<MemberContext::Private>
+{
+  public:
+    Private(MemberDef *md) : DefinitionContext<MemberContext::Private>(md) , m_memberDef(md)
+    {
+      static bool init=FALSE;
+      if (!init)
+      {
+        addBaseProperties(s_inst);
+        s_inst.addProperty("isSignal",            &Private::isSignal);
+        s_inst.addProperty("isSlot",              &Private::isSlot);
+        s_inst.addProperty("isVariable",          &Private::isVariable);
+        s_inst.addProperty("isEnumeration",       &Private::isEnumeration);
+        s_inst.addProperty("isEnumValue",         &Private::isEnumValue);
+        s_inst.addProperty("isTypedef",           &Private::isTypedef);
+        s_inst.addProperty("isFunction",          &Private::isFunction);
+        s_inst.addProperty("isFunctionPtr",       &Private::isFunctionPtr);
+        s_inst.addProperty("isDefine",            &Private::isDefine);
+        s_inst.addProperty("isFriend",            &Private::isFriend);
+        s_inst.addProperty("isProperty",          &Private::isProperty);
+        s_inst.addProperty("isEvent",             &Private::isEvent);
+        s_inst.addProperty("isRelated",           &Private::isRelated);
+        s_inst.addProperty("isForeign",           &Private::isForeign);
+        s_inst.addProperty("isStatic",            &Private::isStatic);
+        s_inst.addProperty("isInline",            &Private::isInline);
+        s_inst.addProperty("isExplicit",          &Private::isExplicit);
+        s_inst.addProperty("isMutable",           &Private::isMutable);
+        s_inst.addProperty("isGettable",          &Private::isGettable);
+        s_inst.addProperty("isPrivateGettable",   &Private::isPrivateGettable);
+        s_inst.addProperty("isProtectedGettable", &Private::isProtectedGettable);
+        s_inst.addProperty("isSettable",          &Private::isSettable);
+        s_inst.addProperty("isPrivateSettable",   &Private::isPrivateSettable);
+        s_inst.addProperty("isProtectedSettable", &Private::isProtectedSettable);
+        s_inst.addProperty("isReadable",          &Private::isReadable);
+        s_inst.addProperty("isWritable",          &Private::isWritable);
+        s_inst.addProperty("isAddable",           &Private::isAddable);
+        s_inst.addProperty("isRemovable",         &Private::isRemovable);
+        s_inst.addProperty("isRaisable",          &Private::isRaisable);
+        s_inst.addProperty("isFinal",             &Private::isFinal);
+        s_inst.addProperty("isAbstract",          &Private::isAbstract);
+        s_inst.addProperty("isOverride",          &Private::isOverride);
+        s_inst.addProperty("isInitonly",          &Private::isInitonly);
+        s_inst.addProperty("isOptional",          &Private::isOptional);
+        s_inst.addProperty("isRequired",          &Private::isRequired);
+        s_inst.addProperty("isNonAtomic",         &Private::isNonAtomic);
+        s_inst.addProperty("isCopy",              &Private::isCopy);
+        s_inst.addProperty("isAssign",            &Private::isAssign);
+        s_inst.addProperty("isRetain",            &Private::isRetain);
+        s_inst.addProperty("isWeak",              &Private::isWeak);
+        s_inst.addProperty("isStrong",            &Private::isStrong);
+        s_inst.addProperty("isUnretained",        &Private::isUnretained);
+        s_inst.addProperty("isNew",               &Private::isNew);
+        s_inst.addProperty("isSealed",            &Private::isSealed);
+        s_inst.addProperty("isImplementation",    &Private::isImplementation);
+        s_inst.addProperty("isExternal",          &Private::isExternal);
+        s_inst.addProperty("isAlias",             &Private::isAlias);
+        s_inst.addProperty("isDefault",           &Private::isDefault);
+        s_inst.addProperty("isDelete",            &Private::isDelete);
         s_inst.addProperty("isNoExcept",          &Private::isNoExcept);
         s_inst.addProperty("isAttribute",         &Private::isAttribute);
         s_inst.addProperty("isUNOProperty",       &Private::isUNOProperty);
@@ -4618,3115 +4001,2887 @@ class MemberContext::Private : public DefinitionContext<MemberContext::Private>
         init=TRUE;
       }
       if (!md->cookie()) { md->setCookie(new MemberContext::Private::Cachable(md)); }
->>>>>>> 5f01f783e2387a5d44ad70fbff5365aa0e5df938
-
-TemplateVariant NamespaceContext::get(const char *n) const { return p->get(n); }
-
-//------------------------------------------------------------------------
 
-//%% struct File(Symbol): file information
-//%% {
-class FileContext::Private : public DefinitionContext<FileContext::Private> {
-public:
-  Private(FileDef *fd)
-      : DefinitionContext<FileContext::Private>(fd), m_fileDef(fd) {
-    if (fd == 0)
-      abort();
-    static bool init = FALSE;
-    if (!init) {
-      addBaseProperties(s_inst);
-      s_inst.addProperty("title", &Private::title);
-      s_inst.addProperty("highlight", &Private::highlight);
-      s_inst.addProperty("subhighlight", &Private::subHighlight);
-      s_inst.addProperty("versionInfo", &Private::versionInfo);
-      s_inst.addProperty("includeList", &Private::includeList);
-      s_inst.addProperty("hasIncludeGraph", &Private::hasIncludeGraph);
-      s_inst.addProperty("hasIncludedByGraph", &Private::hasIncludedByGraph);
-      s_inst.addProperty("includeGraph", &Private::includeGraph);
-      s_inst.addProperty("includedByGraph", &Private::includedByGraph);
-      s_inst.addProperty("hasDetails", &Private::hasDetails);
-      s_inst.addProperty("hasSourceFile", &Private::hasSourceFile);
-      s_inst.addProperty("sources", &Private::sources);
-      s_inst.addProperty("version", &Private::version);
-      s_inst.addProperty("classes", &Private::classes);
-      s_inst.addProperty("namespaces", &Private::namespaces);
-      s_inst.addProperty("constantgroups", &Private::constantgroups);
-      s_inst.addProperty("macros", &Private::macros);
-      s_inst.addProperty("typedefs", &Private::typedefs);
-      s_inst.addProperty("enums", &Private::enums);
-      s_inst.addProperty("functions", &Private::functions);
-      s_inst.addProperty("variables", &Private::variables);
-      s_inst.addProperty("memberGroups", &Private::memberGroups);
-      s_inst.addProperty("detailedMacros", &Private::detailedMacros);
-      s_inst.addProperty("detailedTypedefs", &Private::detailedTypedefs);
-      s_inst.addProperty("detailedEnums", &Private::detailedEnums);
-      s_inst.addProperty("detailedFunctions", &Private::detailedFunctions);
-      s_inst.addProperty("detailedVariables", &Private::detailedVariables);
-      s_inst.addProperty("inlineClasses", &Private::inlineClasses);
-      s_inst.addProperty("compoundType", &Private::compoundType);
-      init = TRUE;
-    }
-    if (!fd->cookie()) {
-      fd->setCookie(new FileContext::Private::Cachable(fd));
+      Cachable &cache = getCache();
+      cache.propertyAttrs.reset(TemplateList::alloc());
+      if (md && md->isProperty())
+      {
+        if (md->isGettable())           cache.propertyAttrs->append("get");
+        if (md->isPrivateGettable())    cache.propertyAttrs->append("private get");
+        if (md->isProtectedGettable())  cache.propertyAttrs->append("protected get");
+        if (md->isSettable())           cache.propertyAttrs->append("set");
+        if (md->isPrivateSettable())    cache.propertyAttrs->append("private set");
+        if (md->isProtectedSettable())  cache.propertyAttrs->append("protected set");
+      }
+      cache.eventAttrs.reset(TemplateList::alloc());
+      if (md && md->isEvent())
+      {
+        if (md->isAddable())   cache.eventAttrs->append("add");
+        if (md->isRemovable()) cache.eventAttrs->append("remove");
+        if (md->isRaisable())  cache.eventAttrs->append("raise");
+      }
     }
-  }
-  virtual ~Private() {}
-  TemplateVariant get(const char *n) const { return s_inst.get(this, n); }
-  TemplateVariant title() const { return m_fileDef->title(); }
-  TemplateVariant highlight() const { return TemplateVariant("files"); }
-  TemplateVariant subHighlight() const { return TemplateVariant(""); }
-  TemplateVariant versionInfo() const { return m_fileDef->getVersion(); }
-  TemplateVariant includeList() const {
-    Cachable &cache = getCache();
-    if (!cache.includeInfoList && m_fileDef->includeFileList()) {
-      cache.includeInfoList.reset(IncludeInfoListContext::alloc(
-          *m_fileDef->includeFileList(), m_fileDef->getLanguage()));
-    }
-    if (cache.includeInfoList) {
-      return cache.includeInfoList.get();
-    } else {
-      return TemplateVariant(FALSE);
+    virtual ~Private() {}
+    TemplateVariant get(const char *n) const
+    {
+      return s_inst.get(this,n);
     }
-  }
-  DotInclDepGraph *getIncludeGraph() const {
-    Cachable &cache = getCache();
-    if (!cache.includeGraph) {
-      cache.includeGraph.reset(new DotInclDepGraph(m_fileDef, FALSE));
+    TemplateVariant fieldType() const
+    {
+      return createLinkedText(m_memberDef,relPathAsString(),m_memberDef->fieldType());
     }
-    return cache.includeGraph.get();
-  }
-  TemplateVariant hasIncludeGraph() const {
-    static bool haveDot = Config_getBool(HAVE_DOT);
-    DotInclDepGraph *incGraph = getIncludeGraph();
-    return (haveDot && !incGraph->isTooBig() && !incGraph->isTrivial());
-  }
-  TemplateVariant includeGraph() const {
-    static bool haveDot = Config_getBool(HAVE_DOT);
-    QGString result;
-    if (haveDot) {
-      DotInclDepGraph *cg = getIncludeGraph();
-      FTextStream t(&result);
-      switch (g_globals.outputFormat) {
-      case ContextOutputFormat_Html: {
-        cg->writeGraph(t, GOF_BITMAP, EOF_Html, g_globals.outputDir,
-                       g_globals.outputDir + portable_pathSeparator() +
-                           m_fileDef->getOutputFileBase() +
-                           Doxygen::htmlFileExtension,
-                       relPathAsString(), TRUE, g_globals.dynSectionId);
-      } break;
-      case ContextOutputFormat_Latex: {
-        cg->writeGraph(t, GOF_EPS, EOF_LaTeX, g_globals.outputDir,
-                       g_globals.outputDir + portable_pathSeparator() +
-                           m_fileDef->getOutputFileBase() + ".tex",
-                       relPathAsString(), TRUE, g_globals.dynSectionId);
-      } break;
-      // TODO: support other generators
-      default:
-        err("context.cpp: output format not yet supported");
-        break;
+    TemplateVariant declType() const
+    {
+      Cachable &cache = getCache();
+      if (!cache.declTypeParsed)
+      {
+        cache.declType=createLinkedText(m_memberDef,relPathAsString(),m_memberDef->getDeclType());
+        cache.declTypeParsed = TRUE;
+        return cache.declType;
       }
-      g_globals.dynSectionId++;
-    }
-    return TemplateVariant(result.data(), TRUE);
-  }
-  DotInclDepGraph *getIncludedByGraph() const {
-    Cachable &cache = getCache();
-    if (!cache.includedByGraph) {
-      cache.includedByGraph.reset(new DotInclDepGraph(m_fileDef, TRUE));
-    }
-    return cache.includedByGraph.get();
-  }
-  TemplateVariant hasIncludedByGraph() const {
-    static bool haveDot = Config_getBool(HAVE_DOT);
-    DotInclDepGraph *incGraph = getIncludedByGraph();
-    return (haveDot && !incGraph->isTooBig() && !incGraph->isTrivial());
-  }
-  TemplateVariant includedByGraph() const {
-    static bool haveDot = Config_getBool(HAVE_DOT);
-    QGString result;
-    if (haveDot) {
-      DotInclDepGraph *cg = getIncludedByGraph();
-      FTextStream t(&result);
-      switch (g_globals.outputFormat) {
-      case ContextOutputFormat_Html: {
-        cg->writeGraph(t, GOF_BITMAP, EOF_Html, g_globals.outputDir,
-                       g_globals.outputDir + portable_pathSeparator() +
-                           m_fileDef->getOutputFileBase() +
-                           Doxygen::htmlFileExtension,
-                       relPathAsString(), TRUE, g_globals.dynSectionId);
-      } break;
-      case ContextOutputFormat_Latex: {
-        cg->writeGraph(t, GOF_EPS, EOF_LaTeX, g_globals.outputDir,
-                       g_globals.outputDir + portable_pathSeparator() +
-                           m_fileDef->getOutputFileBase() + ".tex",
-                       relPathAsString(), TRUE, g_globals.dynSectionId);
-      } break;
-      // TODO: support other generators
-      default:
-        err("context.cpp: output format not yet supported");
-        break;
+      else
+      {
+        return cache.declType;
       }
-      g_globals.dynSectionId++;
     }
-    return TemplateVariant(result.data(), TRUE);
-  }
-  TemplateVariant hasDetails() const {
-    return m_fileDef->hasDetailedDescription();
-  }
-  TemplateVariant hasSourceFile() const {
-    return m_fileDef->generateSourceFile();
-  }
-  TemplateVariant sources() const {
-    Cachable &cache = getCache();
-    if (!cache.sources) {
-      if (m_fileDef->generateSourceFile()) {
-        cache.sources.reset(
-            new TemplateVariant(parseCode(m_fileDef, relPathAsString())));
-      } else {
-        cache.sources.reset(new TemplateVariant(""));
+    TemplateVariant declArgs() const
+    {
+      Cachable &cache = getCache();
+      if (!cache.declArgsParsed)
+      {
+        cache.declArgs=createLinkedText(m_memberDef,relPathAsString(),m_memberDef->argsString());
+        cache.declArgsParsed = TRUE;
+        return cache.declArgs;
+      }
+      else
+      {
+        return cache.declArgs;
       }
     }
-    return *cache.sources;
-  }
-  TemplateVariant version() const { return m_fileDef->fileVersion(); }
-  TemplateVariant classes() const {
-    Cachable &cache = getCache();
-    if (!cache.classes) {
-      TemplateList *classList = TemplateList::alloc();
-      if (m_fileDef->getClassSDict()) {
-        ClassSDict::Iterator sdi(*m_fileDef->getClassSDict());
-        ClassDef *cd;
-        for (sdi.toFirst(); (cd = sdi.current()); ++sdi) {
-          if (cd->visibleInParentsDeclList()) {
-            classList->append(ClassContext::alloc(cd));
+    TemplateVariant exception() const
+    {
+      return createLinkedText(m_memberDef,relPathAsString(),m_memberDef->excpString());
+    }
+    TemplateVariant bitfields() const
+    {
+      return createLinkedText(m_memberDef,relPathAsString(),m_memberDef->bitfieldString());
+    }
+    TemplateVariant isStatic() const
+    {
+      return m_memberDef->isStatic();
+    }
+    TemplateVariant isObjCMethod() const
+    {
+      return m_memberDef->isObjCMethod();
+    }
+    TemplateVariant isObjCProperty() const
+    {
+      return m_memberDef->isObjCProperty();
+    }
+    TemplateVariant isImplementation() const
+    {
+      return m_memberDef->isImplementation();
+    }
+    TemplateVariant isSignal() const
+    {
+      return m_memberDef->isSignal();
+    }
+    TemplateVariant isSlot() const
+    {
+      return m_memberDef->isSlot();
+    }
+    TemplateVariant isTypedef() const
+    {
+      return m_memberDef->isTypedef();
+    }
+    TemplateVariant isFunction() const
+    {
+      return m_memberDef->isFunction();
+    }
+    TemplateVariant isFunctionPtr() const
+    {
+      return m_memberDef->isFunctionPtr();
+    }
+    TemplateVariant isFriend() const
+    {
+      return m_memberDef->isFriend();
+    }
+    TemplateVariant isForeign() const
+    {
+      return m_memberDef->isForeign();
+    }
+    TemplateVariant isEvent() const
+    {
+      return m_memberDef->isEvent();
+    }
+    TemplateVariant isInline() const
+    {
+      return m_memberDef->isInline();
+    }
+    TemplateVariant isExplicit() const
+    {
+      return m_memberDef->isExplicit();
+    }
+    TemplateVariant isMutable() const
+    {
+      return m_memberDef->isMutable();
+    }
+    TemplateVariant isGettable() const
+    {
+      return m_memberDef->isGettable();
+    }
+    TemplateVariant isPrivateGettable() const
+    {
+      return m_memberDef->isPrivateGettable();
+    }
+    TemplateVariant isProtectedGettable() const
+    {
+      return m_memberDef->isProtectedGettable();
+    }
+    TemplateVariant isSettable() const
+    {
+      return m_memberDef->isSettable();
+    }
+    TemplateVariant isPrivateSettable() const
+    {
+      return m_memberDef->isPrivateSettable();
+    }
+    TemplateVariant isProtectedSettable() const
+    {
+      return m_memberDef->isProtectedSettable();
+    }
+    TemplateVariant isReadable() const
+    {
+      return m_memberDef->isReadable();
+    }
+    TemplateVariant isWritable() const
+    {
+      return m_memberDef->isWritable();
+    }
+    TemplateVariant isAddable() const
+    {
+      return m_memberDef->isAddable();
+    }
+    TemplateVariant isRemovable() const
+    {
+      return m_memberDef->isRemovable();
+    }
+    TemplateVariant isRaisable() const
+    {
+      return m_memberDef->isRaisable();
+    }
+    TemplateVariant isFinal() const
+    {
+      return m_memberDef->isFinal();
+    }
+    TemplateVariant isAbstract() const
+    {
+      return m_memberDef->isAbstract();
+    }
+    TemplateVariant isOverride() const
+    {
+      return m_memberDef->isOverride();
+    }
+    TemplateVariant isInitonly() const
+    {
+      return m_memberDef->isInitonly();
+    }
+    TemplateVariant isOptional() const
+    {
+      return m_memberDef->isOptional();
+    }
+    TemplateVariant isRequired() const
+    {
+      return m_memberDef->isRequired();
+    }
+    TemplateVariant isNonAtomic() const
+    {
+      return m_memberDef->isNonAtomic();
+    }
+    TemplateVariant isCopy() const
+    {
+      return m_memberDef->isCopy();
+    }
+    TemplateVariant isAssign() const
+    {
+      return m_memberDef->isAssign();
+    }
+    TemplateVariant isRetain() const
+    {
+      return m_memberDef->isRetain();
+    }
+    TemplateVariant isWeak() const
+    {
+      return m_memberDef->isWeak();
+    }
+    TemplateVariant isStrong() const
+    {
+      return m_memberDef->isStrong();
+    }
+    TemplateVariant isUnretained() const
+    {
+      return m_memberDef->isUnretained();
+    }
+    TemplateVariant isNew() const
+    {
+      return m_memberDef->isNew();
+    }
+    TemplateVariant isSealed() const
+    {
+      return m_memberDef->isSealed();
+    }
+    TemplateVariant isExternal() const
+    {
+      return m_memberDef->isExternal();
+    }
+    TemplateVariant isAlias() const
+    {
+      return m_memberDef->isAlias();
+    }
+    TemplateVariant isDefault() const
+    {
+      return m_memberDef->isDefault();
+    }
+    TemplateVariant isDelete() const
+    {
+      return m_memberDef->isDelete();
+    }
+    TemplateVariant isNoExcept() const
+    {
+      return m_memberDef->isNoExcept();
+    }
+    TemplateVariant isAttribute() const
+    {
+      return m_memberDef->isAttribute();
+    }
+    TemplateVariant isUNOProperty() const
+    {
+      return m_memberDef->isUNOProperty();
+    }
+    TemplateVariant isReadonly() const
+    {
+      return m_memberDef->isReadonly();
+    }
+    TemplateVariant isBound() const
+    {
+      return m_memberDef->isBound();
+    }
+    TemplateVariant isConstrained() const
+    {
+      return m_memberDef->isConstrained();
+    }
+    TemplateVariant isTransient() const
+    {
+      return m_memberDef->isTransient();
+    }
+    TemplateVariant isMaybeVoid() const
+    {
+      return m_memberDef->isMaybeVoid();
+    }
+    TemplateVariant isMaybeDefault() const
+    {
+      return m_memberDef->isMaybeDefault();
+    }
+    TemplateVariant isMaybeAmbiguous() const
+    {
+      return m_memberDef->isMaybeAmbiguous();
+    }
+    TemplateVariant isPublished() const
+    {
+      return m_memberDef->isPublished();
+    }
+    TemplateVariant isTemplateSpecialization() const
+    {
+      return m_memberDef->isTemplateSpecialization();
+    }
+    TemplateVariant isProperty() const
+    {
+      return m_memberDef->isProperty();
+    }
+    TemplateVariant isEnumValue() const
+    {
+      return m_memberDef->isEnumValue();
+    }
+    TemplateVariant isVariable() const
+    {
+      return m_memberDef->isVariable();
+    }
+    TemplateVariant isEnumeration() const
+    {
+      return m_memberDef->isEnumerate();
+    }
+    TemplateVariant hasDetails() const
+    {
+      return m_memberDef->isDetailedSectionLinkable();
+    }
+    TemplateVariant initializer() const
+    {
+      return createLinkedText(m_memberDef,relPathAsString(),m_memberDef->initializer());
+    }
+    TemplateVariant initializerAsCode() const
+    {
+      Cachable &cache = getCache();
+      if (!cache.initializerParsed)
+      {
+        QCString scopeName;
+        if (m_memberDef->getClassDef())
+        {
+          scopeName = m_memberDef->getClassDef()->name();
+        }
+        else if (m_memberDef->getNamespaceDef())
+        {
+          scopeName = m_memberDef->getNamespaceDef()->name();
+        }
+        cache.initializer = parseCode(m_memberDef,scopeName,relPathAsString(),
+                                        m_memberDef->initializer());
+        cache.initializerParsed = TRUE;
+      }
+      return cache.initializer;
+    }
+    TemplateVariant isDefine() const
+    {
+      return m_memberDef->isDefine();
+    }
+    TemplateVariant isAnonymous() const
+    {
+      QCString name = m_memberDef->name();
+      return !name.isEmpty() && name.at(0)=='@';
+    }
+    TemplateVariant anonymousType() const
+    {
+      Cachable &cache = getCache();
+      if (!cache.anonymousType)
+      {
+        ClassDef *cd = m_memberDef->getClassDefOfAnonymousType();
+        if (cd)
+        {
+          cache.anonymousType.reset(ClassContext::alloc(cd));
+        }
+      }
+      if (cache.anonymousType)
+      {
+        return cache.anonymousType.get();
+      }
+      else
+      {
+        return FALSE;
+      }
+    }
+    TemplateVariant anonymousMember() const
+    {
+      Cachable &cache = getCache();
+      if (!cache.anonymousMember)
+      {
+        MemberDef *md = m_memberDef->fromAnonymousMember();
+        if (md)
+        {
+          cache.anonymousMember.reset(MemberContext::alloc(md));
+        }
+      }
+      if (cache.anonymousMember)
+      {
+        return cache.anonymousMember.get();
+      }
+      else
+      {
+        return FALSE;
+      }
+    }
+    TemplateVariant isRelated() const
+    {
+      return m_memberDef->isRelated();
+    }
+    TemplateVariant enumBaseType() const
+    {
+      return m_memberDef->enumBaseType();
+    }
+    TemplateVariant hasOneLineInitializer() const
+    {
+      return m_memberDef->hasOneLineInitializer();
+    }
+    TemplateVariant hasMultiLineInitializer() const
+    {
+      return m_memberDef->hasMultiLineInitializer();
+    }
+    TemplateVariant enumValues() const
+    {
+      Cachable &cache = getCache();
+      if (!cache.enumValues)
+      {
+        MemberList *ml = m_memberDef->enumFieldList();
+        if (ml)
+        {
+          cache.enumValues.reset(MemberListContext::alloc(ml));
+        }
+        else
+        {
+          cache.enumValues.reset(MemberListContext::alloc());
+        }
+      }
+      return cache.enumValues.get();
+    }
+    TemplateVariant templateArgs() const
+    {
+      Cachable &cache = getCache();
+      if (!cache.templateArgs && m_memberDef->templateArguments())
+      {
+        cache.templateArgs.reset(ArgumentListContext::alloc(m_memberDef->templateArguments(),m_memberDef,relPathAsString()));
+      }
+      if (cache.templateArgs)
+      {
+        return cache.templateArgs.get();
+      }
+      else
+      {
+        return TemplateVariant(FALSE);
+      }
+    }
+    TemplateVariant templateAlias() const
+    {
+      if (m_memberDef->isAlias())
+      {
+        return createLinkedText(m_memberDef,relPathAsString(),
+                                QCString(" = ")+m_memberDef->typeString());
+      }
+      return "";
+    }
+    TemplateVariant propertyAttrs() const
+    {
+      return getCache().propertyAttrs.get();
+    }
+    TemplateVariant eventAttrs() const
+    {
+      return getCache().eventAttrs.get();
+    }
+    TemplateVariant getClass() const
+    {
+      Cachable &cache = getCache();
+      if (!cache.classDef && m_memberDef->getClassDef())
+      {
+        cache.classDef.reset(ClassContext::alloc(m_memberDef->getClassDef()));
+      }
+      if (cache.classDef)
+      {
+        return cache.classDef.get();
+      }
+      else
+      {
+        return TemplateVariant(FALSE);
+      }
+    }
+    TemplateVariant category() const
+    {
+      Cachable &cache = getCache();
+      if (!cache.category && m_memberDef->category())
+      {
+        cache.category.reset(ClassContext::alloc(m_memberDef->category()));
+      }
+      if (cache.category)
+      {
+        return cache.category.get();
+      }
+      else
+      {
+        return TemplateVariant(FALSE);
+      }
+    }
+    TemplateVariant categoryRelation() const
+    {
+      Cachable &cache = getCache();
+      if (!cache.categoryRelation && m_memberDef->categoryRelation())
+      {
+        cache.categoryRelation.reset(MemberContext::alloc(m_memberDef->categoryRelation()));
+      }
+      if (cache.categoryRelation)
+      {
+        return cache.categoryRelation.get();
+      }
+      else
+      {
+        return TemplateVariant(FALSE);
+      }
+    }
+    TemplateVariant getFile() const
+    {
+      Cachable &cache = getCache();
+      if (!cache.fileDef && m_memberDef->getFileDef())
+      {
+        cache.fileDef.reset(FileContext::alloc(m_memberDef->getFileDef()));
+      }
+      if (cache.fileDef)
+      {
+        return cache.fileDef.get();
+      }
+      else
+      {
+        return TemplateVariant(FALSE);
+      }
+    }
+    TemplateVariant getNamespace() const
+    {
+      Cachable &cache = getCache();
+      if (!cache.namespaceDef && m_memberDef->getNamespaceDef())
+      {
+        cache.namespaceDef.reset(NamespaceContext::alloc(m_memberDef->getNamespaceDef()));
+      }
+      if (cache.namespaceDef)
+      {
+        return cache.namespaceDef.get();
+      }
+      else
+      {
+        return TemplateVariant(FALSE);
+      }
+    }
+    TemplateVariant definition() const
+    {
+      return createLinkedText(m_memberDef,relPathAsString(),
+                              m_memberDef->displayDefinition());
+    }
+    ArgumentList *getDefArgList() const
+    {
+      return (m_memberDef->isDocsForDefinition()) ?
+              m_memberDef->argumentList() : m_memberDef->declArgumentList();
+    }
+    TemplateVariant parameters() const
+    {
+      Cachable &cache = getCache();
+      if (!cache.arguments)
+      {
+        ArgumentList *defArgList = getDefArgList();
+        if (defArgList && !m_memberDef->isProperty())
+        {
+          cache.arguments.reset(ArgumentListContext::alloc(defArgList,m_memberDef,relPathAsString()));
+        }
+        else
+        {
+          cache.arguments.reset(ArgumentListContext::alloc());
+        }
+      }
+      return cache.arguments.get();
+    }
+    TemplateVariant hasParameters() const
+    {
+      return getDefArgList()!=0;
+    }
+    TemplateVariant hasConstQualifier() const
+    {
+      ArgumentList *al = getDefArgList();
+      return al ? al->constSpecifier : FALSE;
+    }
+    TemplateVariant hasVolatileQualifier() const
+    {
+      ArgumentList *al = getDefArgList();
+      return al ? al->volatileSpecifier : FALSE;
+    }
+    TemplateVariant hasRefQualifierLValue() const
+    {
+      ArgumentList *al = getDefArgList();
+      return al ? al->refQualifier==RefQualifierLValue : FALSE;
+    }
+    TemplateVariant hasRefQualifierRValue() const
+    {
+      ArgumentList *al = getDefArgList();
+      return al ? al->refQualifier==RefQualifierRValue : FALSE;
+    }
+    TemplateVariant trailingReturnType() const
+    {
+      ArgumentList *al = getDefArgList();
+      if (al && !al->trailingReturnType.isEmpty())
+      {
+        return createLinkedText(m_memberDef,relPathAsString(),
+                                al->trailingReturnType);
+      }
+      else
+      {
+        return "";
+      }
+    }
+    TemplateVariant extraTypeChars() const
+    {
+      return m_memberDef->extraTypeChars();
+    }
+    void addTemplateDecls(TemplateList *tl) const
+    {
+      ClassDef *cd=m_memberDef->getClassDef();
+      if (m_memberDef->definitionTemplateParameterLists())
+      {
+        QListIterator<ArgumentList> ali(*m_memberDef->definitionTemplateParameterLists());
+        ArgumentList *tal;
+        for (ali.toFirst();(tal=ali.current());++ali)
+        {
+          if (tal->count()>0)
+          {
+            ArgumentListContext *al = ArgumentListContext::alloc(tal,m_memberDef,relPathAsString());
+            tl->append(al);
+          }
+        }
+      }
+      else
+      {
+        if (cd && !m_memberDef->isRelated() && !m_memberDef->isTemplateSpecialization())
+        {
+          QList<ArgumentList> tempParamLists;
+          cd->getTemplateParameterLists(tempParamLists);
+          //printf("#tempParamLists=%d\n",tempParamLists.count());
+          QListIterator<ArgumentList> ali(tempParamLists);
+          ArgumentList *tal;
+          for (ali.toFirst();(tal=ali.current());++ali)
+          {
+            if (tal->count()>0)
+            {
+              ArgumentListContext *al = ArgumentListContext::alloc(tal,m_memberDef,relPathAsString());
+              tl->append(al);
+            }
+          }
+        }
+        if (m_memberDef->templateArguments()) // function template prefix
+        {
+          ArgumentListContext *al = ArgumentListContext::alloc(
+              m_memberDef->templateArguments(),m_memberDef,relPathAsString());
+          tl->append(al);
+        }
+      }
+    }
+    TemplateVariant templateDecls() const
+    {
+      Cachable &cache = getCache();
+      if (!cache.templateDecls)
+      {
+        TemplateList *tl = TemplateList::alloc();
+        addTemplateDecls(tl);
+        cache.templateDecls.reset(tl);
+      }
+      return cache.templateDecls.get();
+    }
+    TemplateVariant labels() const
+    {
+      Cachable &cache = getCache();
+      if (!cache.labels)
+      {
+        QStrList sl;
+        m_memberDef->getLabels(sl,m_memberDef->getOuterScope());
+        TemplateList *tl = TemplateList::alloc();
+        if (sl.count()>0)
+        {
+          QStrListIterator it(sl);
+          for (;it.current();++it)
+          {
+            tl->append(*it);
           }
         }
+        cache.labels.reset(tl);
       }
-      cache.classes.reset(classList);
+      return cache.labels.get();
+    }
+    TemplateVariant paramDocs() const
+    {
+      Cachable &cache = getCache();
+      if (!cache.paramDocs)
+      {
+        if (m_memberDef->argumentList() && m_memberDef->argumentList()->hasDocumentation())
+        {
+          QCString paramDocs;
+          ArgumentListIterator ali(*m_memberDef->argumentList());
+          Argument *a;
+          // convert the parameter documentation into a list of @param commands
+          for (ali.toFirst();(a=ali.current());++ali)
+          {
+            if (a->hasDocumentation())
+            {
+              QCString direction = extractDirection(a->docs);
+              paramDocs+="@param"+direction+" "+a->name+" "+a->docs;
+            }
+          }
+          cache.paramDocs.reset(new TemplateVariant(parseDoc(m_memberDef,
+                                           m_memberDef->docFile(),m_memberDef->docLine(),
+                                           relPathAsString(),paramDocs,FALSE)));
+        }
+        else
+        {
+          cache.paramDocs.reset(new TemplateVariant(""));
+        }
+      }
+      return *cache.paramDocs;
+    }
+    TemplateVariant implements() const
+    {
+      Cachable &cache = getCache();
+      if (!cache.implements)
+      {
+        MemberDef *md = m_memberDef->reimplements();
+        cache.implements.reset(TemplateList::alloc());
+        if (md)
+        {
+          ClassDef *cd = md->getClassDef();
+          if (cd && (md->virtualness()==Pure || cd->compoundType()==ClassDef::Interface))
+          {
+            MemberContext *mc = MemberContext::alloc(md);
+            cache.implements->append(mc);
+          }
+        }
+      }
+      return cache.implements.get();
+    }
+    TemplateVariant reimplements() const
+    {
+      Cachable &cache = getCache();
+      if (!cache.reimplements)
+      {
+        MemberDef *md = m_memberDef->reimplements();
+        cache.reimplements.reset(TemplateList::alloc());
+        if (md)
+        {
+          ClassDef *cd = md->getClassDef();
+          if (cd && md->virtualness()!=Pure && cd->compoundType()!=ClassDef::Interface)
+          {
+            MemberContext *mc = MemberContext::alloc(md);
+            cache.reimplements->append(mc);
+          }
+        }
+      }
+      return cache.reimplements.get();
+    }
+    TemplateVariant implementedBy() const
+    {
+      Cachable &cache = getCache();
+      if (!cache.implementedBy)
+      {
+        MemberList *ml = m_memberDef->reimplementedBy();
+        cache.implementedBy.reset(TemplateList::alloc());
+        if (ml)
+        {
+          MemberListIterator mli(*ml);
+          MemberDef *md=0;
+          for (mli.toFirst();(md=mli.current());++mli)
+          {
+            ClassDef *cd = md->getClassDef();
+            if (cd && (md->virtualness()==Pure || cd->compoundType()==ClassDef::Interface))
+            {
+              MemberContext *mc = new MemberContext(md);
+              cache.implementedBy->append(mc);
+            }
+          }
+        }
+      }
+      return cache.implementedBy.get();
+    }
+    TemplateVariant reimplementedBy() const
+    {
+      Cachable &cache = getCache();
+      if (!cache.reimplementedBy)
+      {
+        cache.reimplementedBy.reset(TemplateList::alloc());
+        MemberList *ml = m_memberDef->reimplementedBy();
+        if (ml)
+        {
+          MemberListIterator mli(*ml);
+          MemberDef *md=0;
+          for (mli.toFirst();(md=mli.current());++mli)
+          {
+            ClassDef *cd = md->getClassDef();
+            if (cd && md->virtualness()!=Pure && cd->compoundType()!=ClassDef::Interface)
+            {
+              MemberContext *mc = new MemberContext(md);
+              cache.reimplementedBy->append(mc);
+            }
+          }
+        }
+      }
+      return cache.reimplementedBy.get();
+    }
+    void addExamples(TemplateList *list) const
+    {
+      if (m_memberDef->hasExamples())
+      {
+        ExampleSDict::Iterator it(*m_memberDef->getExamples());
+        Example *ex;
+        for (it.toFirst();(ex=it.current());++it)
+        {
+          TemplateStruct *s = TemplateStruct::alloc();
+          s->set("text",ex->name);
+          s->set("isLinkable",TRUE);
+          s->set("anchor",ex->anchor);
+          s->set("fileName",ex->file);
+          s->set("isReference",FALSE);
+          s->set("externalReference","");
+          list->append(s);
+        }
+      }
+    }
+    TemplateVariant examples() const
+    {
+      Cachable &cache = getCache();
+      if (!cache.examples)
+      {
+        TemplateList *exampleList = TemplateList::alloc();
+        addExamples(exampleList);
+        cache.examples.reset(exampleList);
+      }
+      return cache.examples.get();
+    }
+    TemplateVariant typeConstraints() const
+    {
+      Cachable &cache = getCache();
+      if (!cache.typeConstraints && m_memberDef->typeConstraints())
+      {
+        cache.typeConstraints.reset(ArgumentListContext::alloc(m_memberDef->typeConstraints(),m_memberDef,relPathAsString()));
+      }
+      else
+      {
+        cache.typeConstraints.reset(ArgumentListContext::alloc());
+      }
+      return cache.typeConstraints.get();
+    }
+    TemplateVariant functionQualifier() const
+    {
+      if (!m_memberDef->isObjCMethod() &&
+          (m_memberDef->isFunction()  || m_memberDef->isSlot() ||
+           m_memberDef->isPrototype() || m_memberDef->isSignal()
+          )
+         )
+      {
+        return "()";
+      }
+      else
+      {
+        return "";
+      }
+    }
+    TemplateVariant sourceRefs() const
+    {
+      Cachable &cache = getCache();
+      if (!cache.sourceRefs)
+      {
+        cache.sourceRefs.reset(MemberListContext::alloc(m_memberDef->getReferencesMembers(),TRUE));
+      }
+      return cache.sourceRefs.get();
+    }
+    TemplateVariant sourceRefBys() const
+    {
+      Cachable &cache = getCache();
+      if (!cache.sourceRefBys)
+      {
+        cache.sourceRefBys.reset(MemberListContext::alloc(m_memberDef->getReferencedByMembers(),TRUE));
+      }
+      return cache.sourceRefBys.get();
+    }
+    TemplateVariant hasSources() const
+    {
+      return TemplateVariant(m_memberDef->hasSources());
     }
-    return cache.classes.get();
-  }
-  TemplateVariant namespaces() const {
-    Cachable &cache = getCache();
-    if (!cache.namespaces) {
-      TemplateList *namespaceList = TemplateList::alloc();
-      if (m_fileDef->getNamespaceSDict()) {
-        NamespaceSDict::Iterator sdi(*m_fileDef->getNamespaceSDict());
-        NamespaceDef *nd;
-        for (sdi.toFirst(); (nd = sdi.current()); ++sdi) {
-          if (nd->isLinkable() && !nd->isConstantGroup()) {
-            namespaceList->append(NamespaceContext::alloc(nd));
+    TemplateVariant sourceCode() const
+    {
+      Cachable &cache = getCache();
+      if (!cache.sourceCodeParsed)
+      {
+        QCString codeFragment;
+        FileDef *fd   = m_memberDef->getBodyDef();
+        int startLine = m_memberDef->getStartBodyLine();
+        int endLine   = m_memberDef->getEndBodyLine();
+        if (fd && readCodeFragment(fd->absFilePath(),
+              startLine,endLine,codeFragment)
+           )
+        {
+          QCString scopeName;
+          if (m_memberDef->getClassDef())
+          {
+            scopeName = m_memberDef->getClassDef()->name();
+          }
+          else if (m_memberDef->getNamespaceDef())
+          {
+            scopeName = m_memberDef->getNamespaceDef()->name();
           }
+          cache.sourceCode = parseCode(m_memberDef,scopeName,relPathAsString(),codeFragment,startLine,endLine,TRUE);
+          cache.sourceCodeParsed = TRUE;
         }
       }
-      cache.namespaces.reset(namespaceList);
+      return cache.sourceCode;
     }
-    return cache.namespaces.get();
-  }
-  TemplateVariant constantgroups() const {
-    Cachable &cache = getCache();
-    if (!cache.constantgroups) {
-      TemplateList *namespaceList = TemplateList::alloc();
-      if (m_fileDef->getNamespaceSDict()) {
-        NamespaceSDict::Iterator sdi(*m_fileDef->getNamespaceSDict());
-        NamespaceDef *nd;
-        for (sdi.toFirst(); (nd = sdi.current()); ++sdi) {
-          if (nd->isLinkable() && nd->isConstantGroup()) {
-            namespaceList->append(NamespaceContext::alloc(nd));
-          }
-        }
+    DotCallGraph *getCallGraph() const
+    {
+      Cachable &cache = getCache();
+      if (!cache.callGraph)
+      {
+        cache.callGraph.reset(new DotCallGraph(m_memberDef,FALSE));
       }
-      cache.constantgroups.reset(namespaceList);
+      return cache.callGraph.get();
     }
-    return cache.constantgroups.get();
-  }
-  TemplateVariant getMemberList(SharedPtr<MemberListInfoContext> &list,
-                                MemberListType type, const char *title,
-                                bool detailed = FALSE) const {
-    if (!list) {
-      MemberList *ml = m_fileDef->getMemberList(type);
-      if (ml) {
-        list.reset(MemberListInfoContext::alloc(m_fileDef, relPathAsString(),
-                                                ml, title, ""));
-      }
-    }
-    if (list) {
-      return list.get();
-    } else {
+    TemplateVariant hasCallGraph() const
+    {
+      static bool haveDot = Config_getBool(HAVE_DOT);
+      if (m_memberDef->hasCallGraph() && haveDot &&
+          (m_memberDef->isFunction() || m_memberDef->isSlot() || m_memberDef->isSignal()))
+      {
+        DotCallGraph *cg = getCallGraph();
+        return !cg->isTooBig() && !cg->isTrivial();
+      }
       return TemplateVariant(FALSE);
     }
-  }
-  TemplateVariant macros() const {
-    return getMemberList(getCache().macros, MemberListType_decDefineMembers,
-                         theTranslator->trDefines());
-  }
-  TemplateVariant typedefs() const {
-    return getMemberList(getCache().typedefs, MemberListType_decTypedefMembers,
-                         theTranslator->trTypedefs());
-  }
-  TemplateVariant enums() const {
-    return getMemberList(getCache().enums, MemberListType_decEnumMembers,
-                         theTranslator->trEnumerations());
-  }
-  TemplateVariant functions() const {
-    QCString title = theTranslator->trFunctions();
-    SrcLangExt lang = m_fileDef->getLanguage();
-    if (lang == SrcLangExt_Fortran)
-      title = theTranslator->trSubprograms();
-    else if (lang == SrcLangExt_VHDL)
-      title = VhdlDocGen::trFunctionAndProc();
-    return getMemberList(getCache().functions, MemberListType_decFuncMembers,
-                         title);
-  }
-  TemplateVariant variables() const {
-    return getMemberList(getCache().variables, MemberListType_decVarMembers,
-                         theTranslator->trVariables());
-  }
-  TemplateVariant memberGroups() const {
-    Cachable &cache = getCache();
-    if (!cache.memberGroups) {
-      if (m_fileDef->getMemberGroupSDict()) {
-        cache.memberGroups.reset(MemberGroupListContext::alloc(
-            m_fileDef, relPathAsString(), m_fileDef->getMemberGroupSDict(),
-            m_fileDef->subGrouping()));
-      } else {
-        cache.memberGroups.reset(MemberGroupListContext::alloc());
-      }
-    }
-    return cache.memberGroups.get();
-  }
-  TemplateVariant detailedMacros() const {
-    return getMemberList(getCache().detailedMacros,
-                         MemberListType_docDefineMembers,
-                         theTranslator->trDefineDocumentation());
-  }
-  TemplateVariant detailedTypedefs() const {
-    return getMemberList(getCache().detailedTypedefs,
-                         MemberListType_docTypedefMembers,
-                         theTranslator->trTypedefDocumentation());
-  }
-  TemplateVariant detailedEnums() const {
-    return getMemberList(getCache().detailedEnums,
-                         MemberListType_docEnumMembers,
-                         theTranslator->trEnumerationTypeDocumentation());
-  }
-  TemplateVariant detailedFunctions() const {
-    QCString title = theTranslator->trFunctionDocumentation();
-    SrcLangExt lang = m_fileDef->getLanguage();
-    if (lang == SrcLangExt_Fortran)
-      title = theTranslator->trSubprogramDocumentation();
-    return getMemberList(getCache().detailedFunctions,
-                         MemberListType_docFuncMembers, title);
-  }
-  TemplateVariant detailedVariables() const {
-    return getMemberList(getCache().detailedVariables,
-                         MemberListType_docVarMembers,
-                         theTranslator->trVariableDocumentation());
-  }
-  TemplateVariant inlineClasses() const {
-    Cachable &cache = getCache();
-    if (!cache.inlineClasses) {
-      TemplateList *classList = TemplateList::alloc();
-      if (m_fileDef->getClassSDict()) {
-        ClassSDict::Iterator sdi(*m_fileDef->getClassSDict());
-        ClassDef *cd;
-        for (sdi.toFirst(); (cd = sdi.current()); ++sdi) {
-          if (cd->name().find('@') == -1 && cd->isLinkableInProject() &&
-              cd->isEmbeddedInOuterScope() && cd->partOfGroups() == 0) {
-            classList->append(ClassContext::alloc(cd));
-          }
+    TemplateVariant callGraph() const
+    {
+      if (hasCallGraph().toBool())
+      {
+        DotCallGraph *cg = getCallGraph();
+        QGString result;
+        FTextStream t(&result);
+        switch (g_globals.outputFormat)
+        {
+          case ContextOutputFormat_Html:
+            {
+              cg->writeGraph(t,GOF_BITMAP,EOF_Html,
+                  g_globals.outputDir,
+                  g_globals.outputDir+portable_pathSeparator()+m_memberDef->getOutputFileBase()+Doxygen::htmlFileExtension,
+                  relPathAsString(),TRUE,g_globals.dynSectionId
+                  );
+            }
+            break;
+          case ContextOutputFormat_Latex:
+            {
+              cg->writeGraph(t,GOF_EPS,EOF_LaTeX,
+                  g_globals.outputDir,
+                  g_globals.outputDir+portable_pathSeparator()+m_memberDef->getOutputFileBase()+".tex",
+                  relPathAsString(),TRUE,g_globals.dynSectionId
+                  );
+            }
+            break;
+            // TODO: support other generators
+          default:
+            err("context.cpp: output format not yet supported");
+            break;
         }
+        g_globals.dynSectionId++;
+        return TemplateVariant(result.data(),TRUE);
+      }
+      else
+      {
+        return TemplateVariant("");
       }
-      cache.inlineClasses.reset(classList);
     }
-    return cache.inlineClasses.get();
-  }
-  TemplateVariant compoundType() const {
-    return theTranslator->trFile(FALSE, TRUE);
-  }
-
-private:
-  FileDef *m_fileDef;
-  struct Cachable : public DefinitionContext<FileContext::Private>::Cachable {
-    Cachable(FileDef *fd)
-        : DefinitionContext<FileContext::Private>::Cachable(fd) {}
-    SharedPtr<IncludeInfoListContext> includeInfoList;
-    ScopedPtr<DotInclDepGraph> includeGraph;
-    ScopedPtr<DotInclDepGraph> includedByGraph;
-    ScopedPtr<TemplateVariant> sources;
-    SharedPtr<TemplateList> classes;
-    SharedPtr<TemplateList> namespaces;
-    SharedPtr<TemplateList> constantgroups;
-    SharedPtr<MemberListInfoContext> macros;
-    SharedPtr<MemberListInfoContext> typedefs;
-    SharedPtr<MemberListInfoContext> enums;
-    SharedPtr<MemberListInfoContext> functions;
-    SharedPtr<MemberListInfoContext> variables;
-    SharedPtr<MemberGroupListContext> memberGroups;
-    SharedPtr<MemberListInfoContext> detailedMacros;
-    SharedPtr<MemberListInfoContext> detailedTypedefs;
-    SharedPtr<MemberListInfoContext> detailedEnums;
-    SharedPtr<MemberListInfoContext> detailedFunctions;
-    SharedPtr<MemberListInfoContext> detailedVariables;
-    SharedPtr<TemplateList> inlineClasses;
-  };
-  Cachable &getCache() const {
-    Cachable *c = static_cast<Cachable *>(m_fileDef->cookie());
-    assert(c != 0);
-    return *c;
-  }
-  static PropertyMapper<FileContext::Private> s_inst;
-};
-//%% }
-
-PropertyMapper<FileContext::Private> FileContext::Private::s_inst;
-
-FileContext::FileContext(FileDef *fd) : RefCountedContext("FileContext") {
-  p = new Private(fd);
-}
-
-FileContext::~FileContext() { delete p; }
-
-TemplateVariant FileContext::get(const char *n) const { return p->get(n); }
-
-//------------------------------------------------------------------------
-
-//%% struct Dir(Symbol): directory information
-//%% {
-class DirContext::Private : public DefinitionContext<DirContext::Private> {
-public:
-  Private(DirDef *dd)
-      : DefinitionContext<DirContext::Private>(dd), m_dirDef(dd) {
-    static bool init = FALSE;
-    if (!init) {
-      addBaseProperties(s_inst);
-      s_inst.addProperty("title", &Private::title);
-      s_inst.addProperty("highlight", &Private::highlight);
-      s_inst.addProperty("subhighlight", &Private::subHighlight);
-      s_inst.addProperty("dirName", &Private::dirName);
-      s_inst.addProperty("dirs", &Private::dirs);
-      s_inst.addProperty("files", &Private::files);
-      s_inst.addProperty("hasDetails", &Private::hasDetails);
-      s_inst.addProperty("hasDirGraph", &Private::hasDirGraph);
-      s_inst.addProperty("dirGraph", &Private::dirGraph);
-      s_inst.addProperty("compoundType", &Private::compoundType);
-      init = TRUE;
-    }
-    if (!dd->cookie()) {
-      dd->setCookie(new DirContext::Private::Cachable(dd));
+    DotCallGraph *getCallerGraph() const
+    {
+      Cachable &cache = getCache();
+      if (!cache.callerGraph)
+      {
+        cache.callerGraph.reset(new DotCallGraph(m_memberDef,TRUE));
+      }
+      return cache.callerGraph.get();
     }
-  }
-  virtual ~Private() {}
-  TemplateVariant get(const char *n) const { return s_inst.get(this, n); }
-  TemplateVariant title() const {
-    return TemplateVariant(m_dirDef->shortTitle());
-  }
-  TemplateVariant highlight() const { return TemplateVariant("files"); }
-  TemplateVariant subHighlight() const { return TemplateVariant(""); }
-  TemplateVariant dirName() const {
-    return TemplateVariant(m_dirDef->shortName());
-  }
-  TemplateVariant dirs() const {
-    Cachable &cache = getCache();
-    if (!cache.dirs) {
-      cache.dirs.reset(TemplateList::alloc());
-      const DirList &subDirs = m_dirDef->subDirs();
-      QListIterator<DirDef> it(subDirs);
-      DirDef *dd;
-      for (it.toFirst(); (dd = it.current()); ++it) {
-        DirContext *dc = new DirContext(dd);
-        cache.dirs->append(dc);
+    TemplateVariant hasCallerGraph() const
+    {
+      static bool haveDot = Config_getBool(HAVE_DOT);
+      if (m_memberDef->hasCallerGraph() && haveDot &&
+          (m_memberDef->isFunction() || m_memberDef->isSlot() || m_memberDef->isSignal()))
+      {
+        DotCallGraph *cg = getCallerGraph();
+        return !cg->isTooBig() && !cg->isTrivial();
       }
+      return TemplateVariant(FALSE);
     }
-    return cache.dirs.get();
-  }
-  TemplateVariant files() const {
-    Cachable &cache = getCache();
-    if (!cache.files) {
-      cache.files.reset(TemplateList::alloc());
-      FileList *files = m_dirDef->getFiles();
-      if (files) {
-        QListIterator<FileDef> it(*files);
-        FileDef *fd;
-        for (it.toFirst(); (fd = it.current()); ++it) {
-          FileContext *fc = FileContext::alloc(fd);
-          cache.files->append(fc);
+    TemplateVariant callerGraph() const
+    {
+      if (hasCallerGraph().toBool())
+      {
+        DotCallGraph *cg = getCallerGraph();
+        QGString result;
+        FTextStream t(&result);
+        switch (g_globals.outputFormat)
+        {
+          case ContextOutputFormat_Html:
+            {
+              cg->writeGraph(t,GOF_BITMAP,EOF_Html,
+                  g_globals.outputDir,
+                  g_globals.outputDir+portable_pathSeparator()+m_memberDef->getOutputFileBase()+Doxygen::htmlFileExtension,
+                  relPathAsString(),TRUE,g_globals.dynSectionId
+                  );
+            }
+            break;
+          case ContextOutputFormat_Latex:
+            {
+              cg->writeGraph(t,GOF_EPS,EOF_LaTeX,
+                  g_globals.outputDir,
+                  g_globals.outputDir+portable_pathSeparator()+m_memberDef->getOutputFileBase()+".tex",
+                  relPathAsString(),TRUE,g_globals.dynSectionId
+                  );
+            }
+            break;
+            // TODO: support other generators
+          default:
+            err("context.cpp: output format not yet supported");
+            break;
         }
+        g_globals.dynSectionId++;
+        return TemplateVariant(result.data(),TRUE);
+      }
+      else
+      {
+        return TemplateVariant("");
       }
     }
-    return cache.files.get();
-  }
-  TemplateVariant hasDetails() const {
-    return m_dirDef->hasDetailedDescription();
-  }
-  TemplateVariant compoundType() const {
-    return theTranslator->trDir(FALSE, TRUE);
-  }
-  TemplateVariant relPath() const { return ""; }
-  DotDirDeps *getDirDepsGraph() const {
-    Cachable &cache = getCache();
-    if (!cache.dirDepsGraph) {
-      cache.dirDepsGraph.reset(new DotDirDeps(m_dirDef));
+    TemplateVariant type() const
+    {
+      return m_memberDef->typeString();
     }
-    return cache.dirDepsGraph.get();
-  }
-  TemplateVariant hasDirGraph() const {
-    bool result = FALSE;
-    static bool haveDot = Config_getBool(HAVE_DOT);
-    static bool dirGraph = Config_getBool(DIRECTORY_GRAPH);
-    if (haveDot && dirGraph) {
-      DotDirDeps *graph = getDirDepsGraph();
-      result = !graph->isTrivial();
-    }
-    return result;
-  }
-  TemplateVariant dirGraph() const {
-    QGString result;
-    static bool haveDot = Config_getBool(HAVE_DOT);
-    static bool dirGraph = Config_getBool(DIRECTORY_GRAPH);
-    if (haveDot && dirGraph) {
-      DotDirDeps *graph = getDirDepsGraph();
-      FTextStream t(&result);
-      switch (g_globals.outputFormat) {
-      case ContextOutputFormat_Html: {
-        graph->writeGraph(
-            t, GOF_BITMAP, EOF_Html, g_globals.outputDir,
-            g_globals.outputDir + portable_pathSeparator() +
-                m_dirDef->getOutputFileBase() + Doxygen::htmlFileExtension,
-            relPathAsString(), TRUE, g_globals.dynSectionId, FALSE);
-      } break;
-      case ContextOutputFormat_Latex: {
-        graph->writeGraph(t, GOF_EPS, EOF_LaTeX, g_globals.outputDir,
-                          g_globals.outputDir + portable_pathSeparator() +
-                              m_dirDef->getOutputFileBase() + ".tex",
-                          relPathAsString(), TRUE, g_globals.dynSectionId,
-                          FALSE);
-      } break;
-      // TODO: support other generators
-      default:
-        err("context.cpp: output format not yet supported");
-        break;
+    TemplateVariant handleDetailsVisibleFor(const QValueList<TemplateVariant> &args) const
+    {
+      if (args.count()==1)
+      {
+        return m_memberDef->isDetailedSectionVisible(args[0].toString()=="module",args[0].toString()=="file");
+      }
+      else
+      {
+        err(".detailsVisibleFor should take one string argument, got %d\n",args.count());
       }
-      g_globals.dynSectionId++;
+      return TemplateVariant();
     }
-    return TemplateVariant(result.data(), TRUE);
-  }
-
-private:
-  DirDef *m_dirDef;
-  struct Cachable : public DefinitionContext<DirContext::Private>::Cachable {
-    Cachable(DirDef *dd)
-        : DefinitionContext<DirContext::Private>::Cachable(dd) {}
-    SharedPtr<TemplateList> dirs;
-    SharedPtr<TemplateList> files;
-    ScopedPtr<DotDirDeps> dirDepsGraph;
-  };
-  Cachable &getCache() const {
-    Cachable *c = static_cast<Cachable *>(m_dirDef->cookie());
-    assert(c != 0);
-    return *c;
-  }
-  static PropertyMapper<DirContext::Private> s_inst;
-};
-//%% }
-
-PropertyMapper<DirContext::Private> DirContext::Private::s_inst;
-
-DirContext::DirContext(DirDef *fd) : RefCountedContext("DirContext") {
-  p = new Private(fd);
-}
-
-DirContext::~DirContext() { delete p; }
-
-TemplateVariant DirContext::get(const char *n) const { return p->get(n); }
-
-//------------------------------------------------------------------------
-
-//%% struct Page(Symbol): page information
-//%% {
-class PageContext::Private : public DefinitionContext<PageContext::Private> {
-public:
-  Private(PageDef *pd, bool isMainPage, bool isExample)
-      : DefinitionContext<PageContext::Private>(pd), m_pageDef(pd),
-        m_isMainPage(isMainPage), m_isExample(isExample) {
-    static bool init = FALSE;
-    if (!init) {
-      addBaseProperties(s_inst);
-      s_inst.addProperty("title", &Private::title);
-      s_inst.addProperty("highlight", &Private::highlight);
-      s_inst.addProperty("subhighlight", &Private::subHighlight);
-      s_inst.addProperty("example", &Private::example);
-      init = TRUE;
-    }
-    if (!pd->cookie()) {
-      pd->setCookie(new PageContext::Private::Cachable(pd));
+    TemplateVariant detailsVisibleFor() const
+    {
+      return TemplateVariant::Delegate::fromMethod<Private,&Private::handleDetailsVisibleFor>(this);
     }
-  }
-  virtual ~Private() {}
-  TemplateVariant get(const char *n) const { return s_inst.get(this, n); }
-  TemplateVariant title() const {
-    if (m_isMainPage) {
-      if (mainPageHasTitle()) {
-        return m_pageDef->title();
-      } else {
-        return theTranslator->trMainPage();
+    TemplateVariant handleNameWithContextFor(const QValueList<TemplateVariant> &args) const
+    {
+      if (args.count()==1)
+      {
+        SrcLangExt lang = m_memberDef->getLanguage();
+        QCString n = m_memberDef->name();
+        QCString ctx = args[0].toString();
+        QCString sep = getLanguageSpecificSeparator(lang,TRUE);
+        if (m_memberDef->getEnumScope() && m_memberDef->livesInsideEnum())
+        {
+          n.prepend(m_memberDef->getEnumScope()->displayName()+sep);
+        }
+        if (ctx=="module" && m_memberDef->getClassDef() && !m_memberDef->isRelated())
+        {
+          n.prepend(m_memberDef->getClassDef()->displayName()+sep);
+        }
+        else if ((ctx=="module" || ctx=="file") && m_memberDef->getNamespaceDef())
+        {
+          n.prepend(m_memberDef->getNamespaceDef()->displayName()+sep);
+        }
+        return n;
       }
-    } else if (m_isExample) {
-      return m_pageDef->name();
-    } else {
-      return m_pageDef->title();
-    }
-  }
-  TemplateVariant relPath() const {
-    if (m_isMainPage) {
-      return "";
-    } else {
-      return DefinitionContext<PageContext::Private>::relPath();
+      else
+      {
+        err(".nameWithContextFor should take one string argument, got %d\n",args.count());
+      }
+      return TemplateVariant();
     }
-  }
-  TemplateVariant highlight() const {
-    if (m_isMainPage) {
-      return "main";
-    } else {
-      return "pages";
+    TemplateVariant nameWithContextFor() const
+    {
+      return TemplateVariant::Delegate::fromMethod<Private,&Private::handleNameWithContextFor>(this);
     }
-  }
-  TemplateVariant subHighlight() const { return ""; }
-  TemplateVariant example() const {
-    if (m_isExample) {
-      Cachable &cache = getCache();
-      if (!cache.example ||
-          g_globals.outputFormat != cache.exampleOutputFormat) {
-        cache.example.reset(new TemplateVariant(parseDoc(
-            m_pageDef, m_pageDef->docFile(), m_pageDef->docLine(),
-            relPathAsString(), "\\include " + m_pageDef->name(), FALSE)));
-        cache.exampleOutputFormat = g_globals.outputFormat;
-      }
-      return *cache.example;
-    } else {
-      return TemplateVariant("");
+  private:
+    MemberDef *m_memberDef;
+    struct Cachable : public DefinitionContext<MemberContext::Private>::Cachable
+    {
+      Cachable(MemberDef *md) : DefinitionContext<MemberContext::Private>::Cachable(md),
+                                initializerParsed(FALSE), sourceCodeParsed(FALSE),
+                                declArgsParsed(FALSE), declTypeParsed(FALSE) { }
+      SharedPtr<ArgumentListContext> templateArgs;
+      SharedPtr<ArgumentListContext> arguments;
+      SharedPtr<MemberListContext>   enumValues;
+      SharedPtr<FileContext>         fileDef;
+      SharedPtr<NamespaceContext>    namespaceDef;
+      SharedPtr<ClassContext>        category;
+      SharedPtr<MemberContext>       categoryRelation;
+      SharedPtr<ClassContext>        classDef;
+      SharedPtr<ClassContext>        anonymousType;
+      SharedPtr<TemplateList>        templateDecls;
+      ScopedPtr<TemplateVariant>     paramDocs;
+      SharedPtr<TemplateList>        implements;
+      SharedPtr<TemplateList>        reimplements;
+      SharedPtr<TemplateList>        implementedBy;
+      SharedPtr<MemberListContext>   sourceRefs;
+      SharedPtr<MemberListContext>   sourceRefBys;
+      ScopedPtr<DotCallGraph>        callGraph;
+      ScopedPtr<DotCallGraph>        callerGraph;
+      SharedPtr<MemberContext>       anonymousMember;
+      SharedPtr<TemplateList>        reimplementedBy;
+      SharedPtr<TemplateList>        labels;
+      TemplateVariant                initializer;
+      bool                           initializerParsed;
+      TemplateVariant                sourceCode;
+      bool                           sourceCodeParsed;
+      TemplateVariant                declArgs;
+      bool                           declArgsParsed;
+      TemplateVariant                declType;
+      bool                           declTypeParsed;
+      SharedPtr<TemplateList>        examples;
+      SharedPtr<TemplateList>        exampleList;
+      SharedPtr<ArgumentListContext> typeConstraints;
+      SharedPtr<TemplateList>        propertyAttrs;
+      SharedPtr<TemplateList>        eventAttrs;
+    };
+    Cachable &getCache() const
+    {
+      Cachable *c = static_cast<Cachable*>(m_memberDef->cookie());
+      assert(c!=0);
+      return *c;
     }
-  }
-
-private:
-  PageDef *m_pageDef;
-  struct Cachable : public DefinitionContext<PageContext::Private>::Cachable {
-    Cachable(PageDef *pd)
-        : DefinitionContext<PageContext::Private>::Cachable(pd),
-          exampleOutputFormat(ContextOutputFormat_Unspecified) {}
-    ScopedPtr<TemplateVariant> example;
-    ContextOutputFormat exampleOutputFormat;
-  };
-  Cachable &getCache() const {
-    Cachable *c = static_cast<Cachable *>(m_pageDef->cookie());
-    assert(c != 0);
-    return *c;
-  }
-  bool m_isMainPage;
-  bool m_isExample;
-  static PropertyMapper<PageContext::Private> s_inst;
+    static PropertyMapper<MemberContext::Private> s_inst;
 };
 //%% }
 
-PropertyMapper<PageContext::Private> PageContext::Private::s_inst;
+PropertyMapper<MemberContext::Private> MemberContext::Private::s_inst;
 
-PageContext::PageContext(PageDef *pd, bool isMainPage, bool isExample)
-    : RefCountedContext("PageContext") {
-  p = new Private(pd, isMainPage, isExample);
+MemberContext::MemberContext(MemberDef *md) : RefCountedContext("MemberContext")
+{
+  p = new Private(md);
 }
 
-PageContext::~PageContext() { delete p; }
-
-TemplateVariant PageContext::get(const char *n) const { return p->get(n); }
-
-//------------------------------------------------------------------------
-
-class TextGeneratorHtml : public TextGeneratorIntf {
-public:
-  TextGeneratorHtml(FTextStream &ts, const QCString &relPath)
-      : m_ts(ts), m_relPath(relPath) {}
-  void writeString(const char *s, bool keepSpaces) const {
-    if (s == 0)
-      return;
-    if (keepSpaces) {
-      const char *p = s;
-      char c;
-      while ((c = *p++)) {
-        switch (c) {
-        case '<':
-          m_ts << "&lt;";
-          break;
-        case '>':
-          m_ts << "&gt;";
-          break;
-        case '\'':
-          m_ts << "&#39;";
-          break;
-        case '"':
-          m_ts << "&quot;";
-          break;
-        case '&':
-          m_ts << "&amp;";
-          break;
-        case ' ':
-          m_ts << "&#160;";
-          break;
-        }
-      }
-    } else {
-      m_ts << convertToHtml(s);
-    }
-  }
-
-  void writeBreak(int indent) const {
-    m_ts << "<br />";
-    for (int i = 0; i < indent; i++) {
-      m_ts << "&#160;";
-    }
-  }
-
-  void writeLink(const char *ref, const char *f, const char *anchor,
-                 const char *name) const {
-    if (ref) {
-      m_ts << "<a class=\"elRef\" ";
-      m_ts << externalLinkTarget() << externalRef(m_relPath, ref, FALSE);
-    } else {
-      m_ts << "<a class=\"el\" ";
-    }
-    m_ts << "href=\"";
-    m_ts << externalRef(m_relPath, ref, TRUE);
-    if (f)
-      m_ts << f << Doxygen::htmlFileExtension;
-    if (anchor)
-      m_ts << "#" << anchor;
-    m_ts << "\">";
-    m_ts << convertToHtml(name);
-    m_ts << "</a>";
-  }
-
-private:
-  FTextStream &m_ts;
-  QCString m_relPath;
-};
-
-//------------------------------------------------------------------------
+MemberContext::~MemberContext()
+{
+  delete p;
+}
 
-class TextGeneratorLatex : public TextGeneratorIntf {
-public:
-  TextGeneratorLatex(FTextStream &ts) : m_ts(ts) {}
-  void writeString(const char *s, bool keepSpaces) const {
-    if (s == 0)
-      return;
-    m_ts << convertToLaTeX(s, FALSE, keepSpaces);
-  }
-  void writeBreak(int indent) const {
-    m_ts << "\\\\*\n";
-    for (int i = 0; i < indent; i++) {
-      m_ts << "~";
-    }
-  }
-  void writeLink(const char *ref, const char *f, const char *anchor,
-                 const char *text) const {
-    static bool pdfHyperlinks = Config_getBool(PDF_HYPERLINKS);
-    if (!ref && pdfHyperlinks) {
-      m_ts << "\\hyperlink{";
-      if (f)
-        m_ts << stripPath(f);
-      if (f && anchor)
-        m_ts << "_";
-      if (anchor)
-        m_ts << anchor;
-      m_ts << "}{";
-      filterLatexString(m_ts, text);
-      m_ts << "}";
-    } else {
-      m_ts << "{\\bf ";
-      filterLatexString(m_ts, text);
-      m_ts << "}";
-    }
-  }
+TemplateVariant MemberContext::get(const char *n) const
+{
+  return p->get(n);
+}
 
-private:
-  FTextStream &m_ts;
-};
 
 //------------------------------------------------------------------------
 
-class TextGeneratorFactory {
-public:
-  static TextGeneratorFactory *instance() {
-    static TextGeneratorFactory *instance = 0;
-    if (instance == 0)
-      instance = new TextGeneratorFactory;
-    return instance;
-  }
-  TextGeneratorIntf *create(FTextStream &ts, const QCString &relPath) {
-    switch (g_globals.outputFormat) {
-    case ContextOutputFormat_Html:
-      return new TextGeneratorHtml(ts, relPath);
-    case ContextOutputFormat_Latex:
-      return new TextGeneratorLatex(ts);
-    default:
-      break;
-    }
-    return 0;
-  }
-
-private:
-  TextGeneratorFactory() {}
-  virtual ~TextGeneratorFactory() {}
-};
-
-TemplateVariant createLinkedText(Definition *def, const QCString &relPath,
-                                 const QCString &text) {
-  QGString s;
-  FTextStream ts(&s);
-  TextGeneratorIntf *tg = TextGeneratorFactory::instance()->create(ts, relPath);
-  if (tg) {
-    linkifyText(*tg, def->getOuterScope(), def->getBodyDef(), def, text);
-    delete tg;
-    return TemplateVariant(s.data(), TRUE);
-  } else {
-    return text;
-  }
-}
-
-//%% struct Member(Symbol): member information
+//%% struct Module(Symbol): group information
 //%% {
-class MemberContext::Private
-    : public DefinitionContext<MemberContext::Private> {
-public:
-  Private(MemberDef *md)
-      : DefinitionContext<MemberContext::Private>(md), m_memberDef(md) {
-    static bool init = FALSE;
-    if (!init) {
-      addBaseProperties(s_inst);
-      s_inst.addProperty("isSignal", &Private::isSignal);
-      s_inst.addProperty("isSlot", &Private::isSlot);
-      s_inst.addProperty("isVariable", &Private::isVariable);
-      s_inst.addProperty("isEnumeration", &Private::isEnumeration);
-      s_inst.addProperty("isEnumValue", &Private::isEnumValue);
-      s_inst.addProperty("isTypedef", &Private::isTypedef);
-      s_inst.addProperty("isFunction", &Private::isFunction);
-      s_inst.addProperty("isFunctionPtr", &Private::isFunctionPtr);
-      s_inst.addProperty("isDefine", &Private::isDefine);
-      s_inst.addProperty("isFriend", &Private::isFriend);
-      s_inst.addProperty("isProperty", &Private::isProperty);
-      s_inst.addProperty("isEvent", &Private::isEvent);
-      s_inst.addProperty("isRelated", &Private::isRelated);
-      s_inst.addProperty("isForeign", &Private::isForeign);
-      s_inst.addProperty("isStatic", &Private::isStatic);
-      s_inst.addProperty("isInline", &Private::isInline);
-      s_inst.addProperty("isExplicit", &Private::isExplicit);
-      s_inst.addProperty("isMutable", &Private::isMutable);
-      s_inst.addProperty("isGettable", &Private::isGettable);
-      s_inst.addProperty("isPrivateGettable", &Private::isPrivateGettable);
-      s_inst.addProperty("isProtectedGettable", &Private::isProtectedGettable);
-      s_inst.addProperty("isSettable", &Private::isSettable);
-      s_inst.addProperty("isPrivateSettable", &Private::isPrivateSettable);
-      s_inst.addProperty("isProtectedSettable", &Private::isProtectedSettable);
-      s_inst.addProperty("isReadable", &Private::isReadable);
-      s_inst.addProperty("isWritable", &Private::isWritable);
-      s_inst.addProperty("isAddable", &Private::isAddable);
-      s_inst.addProperty("isRemovable", &Private::isRemovable);
-      s_inst.addProperty("isRaisable", &Private::isRaisable);
-      s_inst.addProperty("isFinal", &Private::isFinal);
-      s_inst.addProperty("isAbstract", &Private::isAbstract);
-      s_inst.addProperty("isOverride", &Private::isOverride);
-      s_inst.addProperty("isInitonly", &Private::isInitonly);
-      s_inst.addProperty("isOptional", &Private::isOptional);
-      s_inst.addProperty("isRequired", &Private::isRequired);
-      s_inst.addProperty("isNonAtomic", &Private::isNonAtomic);
-      s_inst.addProperty("isCopy", &Private::isCopy);
-      s_inst.addProperty("isAssign", &Private::isAssign);
-      s_inst.addProperty("isRetain", &Private::isRetain);
-      s_inst.addProperty("isWeak", &Private::isWeak);
-      s_inst.addProperty("isStrong", &Private::isStrong);
-      s_inst.addProperty("isUnretained", &Private::isUnretained);
-      s_inst.addProperty("isNew", &Private::isNew);
-      s_inst.addProperty("isSealed", &Private::isSealed);
-      s_inst.addProperty("isImplementation", &Private::isImplementation);
-      s_inst.addProperty("isExternal", &Private::isExternal);
-      s_inst.addProperty("isAlias", &Private::isAlias);
-      s_inst.addProperty("isDefault", &Private::isDefault);
-      s_inst.addProperty("isDelete", &Private::isDelete);
-      s_inst.addProperty("isNoExcept", &Private::isNoExcept);
-      s_inst.addProperty("isAttribute", &Private::isAttribute);
-      s_inst.addProperty("isUNOProperty", &Private::isUNOProperty);
-      s_inst.addProperty("isReadonly", &Private::isReadonly);
-      s_inst.addProperty("isBound", &Private::isBound);
-      s_inst.addProperty("isConstrained", &Private::isConstrained);
-      s_inst.addProperty("isTransient", &Private::isTransient);
-      s_inst.addProperty("isMaybeVoid", &Private::isMaybeVoid);
-      s_inst.addProperty("isMaybeDefault", &Private::isMaybeDefault);
-      s_inst.addProperty("isMaybeAmbiguous", &Private::isMaybeAmbiguous);
-      s_inst.addProperty("isPublished", &Private::isPublished);
-      s_inst.addProperty("isTemplateSpecialization",
-                         &Private::isTemplateSpecialization);
-      s_inst.addProperty("isObjCMethod", &Private::isObjCMethod);
-      s_inst.addProperty("isObjCProperty", &Private::isObjCProperty);
-      s_inst.addProperty("isAnonymous", &Private::isAnonymous);
-      s_inst.addProperty("hasParameters", &Private::hasParameters);
-      s_inst.addProperty("declType", &Private::declType);
-      s_inst.addProperty("declArgs", &Private::declArgs);
-      s_inst.addProperty("anonymousType", &Private::anonymousType);
-      s_inst.addProperty("anonymousMember", &Private::anonymousMember);
-      s_inst.addProperty("hasDetails", &Private::hasDetails);
-      s_inst.addProperty("exception", &Private::exception);
-      s_inst.addProperty("bitfields", &Private::bitfields);
-      s_inst.addProperty("initializer", &Private::initializer);
-      s_inst.addProperty("initializerAsCode", &Private::initializerAsCode);
-      s_inst.addProperty("hasOneLineInitializer",
-                         &Private::hasOneLineInitializer);
-      s_inst.addProperty("hasMultiLineInitializer",
-                         &Private::hasMultiLineInitializer);
-      s_inst.addProperty("templateArgs", &Private::templateArgs);
-      s_inst.addProperty("templateAlias", &Private::templateAlias);
-      s_inst.addProperty("propertyAttrs", &Private::propertyAttrs);
-      s_inst.addProperty("eventAttrs", &Private::eventAttrs);
-      s_inst.addProperty("category", &Private::category);
-      s_inst.addProperty("categoryRelation", &Private::categoryRelation);
-      s_inst.addProperty("class", &Private::getClass);
-      s_inst.addProperty("file", &Private::getFile);
-      s_inst.addProperty("namespace", &Private::getNamespace);
-      s_inst.addProperty("definition", &Private::definition);
-      s_inst.addProperty("parameters", &Private::parameters);
-      s_inst.addProperty("hasConstQualifier", &Private::hasConstQualifier);
-      s_inst.addProperty("hasVolatileQualifier",
-                         &Private::hasVolatileQualifier);
-      s_inst.addProperty("trailingReturnType", &Private::trailingReturnType);
-      s_inst.addProperty("extraTypeChars", &Private::extraTypeChars);
-      s_inst.addProperty("templateDecls", &Private::templateDecls);
-      s_inst.addProperty("labels", &Private::labels);
-      s_inst.addProperty("enumBaseType", &Private::enumBaseType);
-      s_inst.addProperty("enumValues", &Private::enumValues);
-      s_inst.addProperty("paramDocs", &Private::paramDocs);
-      s_inst.addProperty("reimplements", &Private::reimplements);
-      s_inst.addProperty("implements", &Private::implements);
-      s_inst.addProperty("reimplementedBy", &Private::reimplementedBy);
-      s_inst.addProperty("implementedBy", &Private::implementedBy);
-      s_inst.addProperty("examples", &Private::examples);
-      s_inst.addProperty("typeConstraints", &Private::typeConstraints);
-      s_inst.addProperty("functionQualifier", &Private::functionQualifier);
-      s_inst.addProperty("sourceRefs", &Private::sourceRefs);
-      s_inst.addProperty("sourceRefBys", &Private::sourceRefBys);
-      s_inst.addProperty("hasSources", &Private::hasSources);
-      s_inst.addProperty("sourceCode", &Private::sourceCode);
-      s_inst.addProperty("hasCallGraph", &Private::hasCallGraph);
-      s_inst.addProperty("callGraph", &Private::callGraph);
-      s_inst.addProperty("hasCallerGraph", &Private::hasCallerGraph);
-      s_inst.addProperty("callerGraph", &Private::callerGraph);
-      s_inst.addProperty("fieldType", &Private::fieldType);
-      s_inst.addProperty("type", &Private::type);
-      s_inst.addProperty("detailsVisibleFor", &Private::detailsVisibleFor);
-      s_inst.addProperty("nameWithContextFor", &Private::nameWithContextFor);
-      init = TRUE;
-    }
-    if (!md->cookie()) {
-      md->setCookie(new MemberContext::Private::Cachable(md));
-    }
-
-    Cachable &cache = getCache();
-    cache.propertyAttrs.reset(TemplateList::alloc());
-    if (md && md->isProperty()) {
-      if (md->isGettable())
-        cache.propertyAttrs->append("get");
-      if (md->isPrivateGettable())
-        cache.propertyAttrs->append("private get");
-      if (md->isProtectedGettable())
-        cache.propertyAttrs->append("protected get");
-      if (md->isSettable())
-        cache.propertyAttrs->append("set");
-      if (md->isPrivateSettable())
-        cache.propertyAttrs->append("private set");
-      if (md->isProtectedSettable())
-        cache.propertyAttrs->append("protected set");
-    }
-    cache.eventAttrs.reset(TemplateList::alloc());
-    if (md && md->isEvent()) {
-      if (md->isAddable())
-        cache.eventAttrs->append("add");
-      if (md->isRemovable())
-        cache.eventAttrs->append("remove");
-      if (md->isRaisable())
-        cache.eventAttrs->append("raise");
+class ModuleContext::Private : public DefinitionContext<ModuleContext::Private>
+{
+  public:
+    Private(GroupDef *gd) : DefinitionContext<ModuleContext::Private>(gd) , m_groupDef(gd)
+    {
+      static bool init=FALSE;
+      if (!init)
+      {
+        addBaseProperties(s_inst);
+        s_inst.addProperty("title",                     &Private::title);
+        s_inst.addProperty("highlight",                 &Private::highlight);
+        s_inst.addProperty("subhighlight",              &Private::subHighlight);
+        s_inst.addProperty("hasGroupGraph",             &Private::hasGroupGraph);
+        s_inst.addProperty("groupGraph",                &Private::groupGraph);
+        s_inst.addProperty("hasDetails",                &Private::hasDetails);
+        s_inst.addProperty("modules",                   &Private::modules);
+        s_inst.addProperty("dirs",                      &Private::dirs);
+        s_inst.addProperty("files",                     &Private::files);
+        s_inst.addProperty("namespaces",                &Private::namespaces);
+        s_inst.addProperty("classes",                   &Private::classes);
+        s_inst.addProperty("constantgroups",            &Private::constantgroups);
+        s_inst.addProperty("examples",                  &Private::examples);
+        s_inst.addProperty("macros",                    &Private::macros);
+        s_inst.addProperty("typedefs",                  &Private::typedefs);
+        s_inst.addProperty("enums",                     &Private::enums);
+        s_inst.addProperty("enumvalues",                &Private::enumValues);
+        s_inst.addProperty("functions",                 &Private::functions);
+        s_inst.addProperty("variables",                 &Private::variables);
+        s_inst.addProperty("signals",                   &Private::signals);
+        s_inst.addProperty("publicSlots",               &Private::publicSlots);
+        s_inst.addProperty("protectedSlots",            &Private::protectedSlots);
+        s_inst.addProperty("privateSlots",              &Private::privateSlots);
+        s_inst.addProperty("events",                    &Private::events);
+        s_inst.addProperty("properties",                &Private::properties);
+        s_inst.addProperty("friends",                   &Private::friends);
+        s_inst.addProperty("memberGroups",              &Private::memberGroups);
+        s_inst.addProperty("detailedMacros",            &Private::detailedMacros);
+        s_inst.addProperty("detailedTypedefs",          &Private::detailedTypedefs);
+        s_inst.addProperty("detailedEnums",             &Private::detailedEnums);
+        s_inst.addProperty("detailedEnumValues",        &Private::detailedEnumValues);
+        s_inst.addProperty("detailedFunctions",         &Private::detailedFunctions);
+        s_inst.addProperty("detailedVariables",         &Private::detailedVariables);
+        s_inst.addProperty("detailedSignals",           &Private::detailedSignals);
+        s_inst.addProperty("detailedPublicSlots",       &Private::detailedPublicSlots);
+        s_inst.addProperty("detailedProtectedSlots",    &Private::detailedProtectedSlots);
+        s_inst.addProperty("detailedPrivateSlots",      &Private::detailedPrivateSlots);
+        s_inst.addProperty("detailedEvents",            &Private::detailedEvents);
+        s_inst.addProperty("detailedProperties",        &Private::detailedProperties);
+        s_inst.addProperty("detailedFriends",           &Private::detailedFriends);
+        s_inst.addProperty("inlineClasses",             &Private::inlineClasses);
+        s_inst.addProperty("compoundType",              &Private::compoundType);
+        init=TRUE;
+      }
+      if (!gd->cookie()) { gd->setCookie(new ModuleContext::Private::Cachable(gd)); }
     }
-  }
-  virtual ~Private() {}
-  TemplateVariant get(const char *n) const { return s_inst.get(this, n); }
-  TemplateVariant fieldType() const {
-    return createLinkedText(m_memberDef, relPathAsString(),
-                            m_memberDef->fieldType());
-  }
-  TemplateVariant declType() const {
-    Cachable &cache = getCache();
-    if (!cache.declTypeParsed) {
-      cache.declType = createLinkedText(m_memberDef, relPathAsString(),
-                                        m_memberDef->getDeclType());
-      cache.declTypeParsed = TRUE;
-      return cache.declType;
-    } else {
-      return cache.declType;
+    virtual ~Private() {}
+    TemplateVariant get(const char *n) const
+    {
+      return s_inst.get(this,n);
     }
-  }
-  TemplateVariant declArgs() const {
-    Cachable &cache = getCache();
-    if (!cache.declArgsParsed) {
-      cache.declArgs = createLinkedText(m_memberDef, relPathAsString(),
-                                        m_memberDef->argsString());
-      cache.declArgsParsed = TRUE;
-      return cache.declArgs;
-    } else {
-      return cache.declArgs;
+    TemplateVariant title() const
+    {
+      return TemplateVariant(m_groupDef->groupTitle());
     }
-  }
-  TemplateVariant exception() const {
-    return createLinkedText(m_memberDef, relPathAsString(),
-                            m_memberDef->excpString());
-  }
-  TemplateVariant bitfields() const {
-    return createLinkedText(m_memberDef, relPathAsString(),
-                            m_memberDef->bitfieldString());
-  }
-  TemplateVariant isStatic() const { return m_memberDef->isStatic(); }
-  TemplateVariant isObjCMethod() const { return m_memberDef->isObjCMethod(); }
-  TemplateVariant isObjCProperty() const {
-    return m_memberDef->isObjCProperty();
-  }
-  TemplateVariant isImplementation() const {
-    return m_memberDef->isImplementation();
-  }
-  TemplateVariant isSignal() const { return m_memberDef->isSignal(); }
-  TemplateVariant isSlot() const { return m_memberDef->isSlot(); }
-  TemplateVariant isTypedef() const { return m_memberDef->isTypedef(); }
-  TemplateVariant isFunction() const { return m_memberDef->isFunction(); }
-  TemplateVariant isFunctionPtr() const { return m_memberDef->isFunctionPtr(); }
-  TemplateVariant isFriend() const { return m_memberDef->isFriend(); }
-  TemplateVariant isForeign() const { return m_memberDef->isForeign(); }
-  TemplateVariant isEvent() const { return m_memberDef->isEvent(); }
-  TemplateVariant isInline() const { return m_memberDef->isInline(); }
-  TemplateVariant isExplicit() const { return m_memberDef->isExplicit(); }
-  TemplateVariant isMutable() const { return m_memberDef->isMutable(); }
-  TemplateVariant isGettable() const { return m_memberDef->isGettable(); }
-  TemplateVariant isPrivateGettable() const {
-    return m_memberDef->isPrivateGettable();
-  }
-  TemplateVariant isProtectedGettable() const {
-    return m_memberDef->isProtectedGettable();
-  }
-  TemplateVariant isSettable() const { return m_memberDef->isSettable(); }
-  TemplateVariant isPrivateSettable() const {
-    return m_memberDef->isPrivateSettable();
-  }
-  TemplateVariant isProtectedSettable() const {
-    return m_memberDef->isProtectedSettable();
-  }
-  TemplateVariant isReadable() const { return m_memberDef->isReadable(); }
-  TemplateVariant isWritable() const { return m_memberDef->isWritable(); }
-  TemplateVariant isAddable() const { return m_memberDef->isAddable(); }
-  TemplateVariant isRemovable() const { return m_memberDef->isRemovable(); }
-  TemplateVariant isRaisable() const { return m_memberDef->isRaisable(); }
-  TemplateVariant isFinal() const { return m_memberDef->isFinal(); }
-  TemplateVariant isAbstract() const { return m_memberDef->isAbstract(); }
-  TemplateVariant isOverride() const { return m_memberDef->isOverride(); }
-  TemplateVariant isInitonly() const { return m_memberDef->isInitonly(); }
-  TemplateVariant isOptional() const { return m_memberDef->isOptional(); }
-  TemplateVariant isRequired() const { return m_memberDef->isRequired(); }
-  TemplateVariant isNonAtomic() const { return m_memberDef->isNonAtomic(); }
-  TemplateVariant isCopy() const { return m_memberDef->isCopy(); }
-  TemplateVariant isAssign() const { return m_memberDef->isAssign(); }
-  TemplateVariant isRetain() const { return m_memberDef->isRetain(); }
-  TemplateVariant isWeak() const { return m_memberDef->isWeak(); }
-  TemplateVariant isStrong() const { return m_memberDef->isStrong(); }
-  TemplateVariant isUnretained() const { return m_memberDef->isUnretained(); }
-  TemplateVariant isNew() const { return m_memberDef->isNew(); }
-  TemplateVariant isSealed() const { return m_memberDef->isSealed(); }
-  TemplateVariant isExternal() const { return m_memberDef->isExternal(); }
-  TemplateVariant isAlias() const { return m_memberDef->isAlias(); }
-  TemplateVariant isDefault() const { return m_memberDef->isDefault(); }
-  TemplateVariant isDelete() const { return m_memberDef->isDelete(); }
-  TemplateVariant isNoExcept() const { return m_memberDef->isNoExcept(); }
-  TemplateVariant isAttribute() const { return m_memberDef->isAttribute(); }
-  TemplateVariant isUNOProperty() const { return m_memberDef->isUNOProperty(); }
-  TemplateVariant isReadonly() const { return m_memberDef->isReadonly(); }
-  TemplateVariant isBound() const { return m_memberDef->isBound(); }
-  TemplateVariant isConstrained() const { return m_memberDef->isConstrained(); }
-  TemplateVariant isTransient() const { return m_memberDef->isTransient(); }
-  TemplateVariant isMaybeVoid() const { return m_memberDef->isMaybeVoid(); }
-  TemplateVariant isMaybeDefault() const {
-    return m_memberDef->isMaybeDefault();
-  }
-  TemplateVariant isMaybeAmbiguous() const {
-    return m_memberDef->isMaybeAmbiguous();
-  }
-  TemplateVariant isPublished() const { return m_memberDef->isPublished(); }
-  TemplateVariant isTemplateSpecialization() const {
-    return m_memberDef->isTemplateSpecialization();
-  }
-  TemplateVariant isProperty() const { return m_memberDef->isProperty(); }
-  TemplateVariant isEnumValue() const { return m_memberDef->isEnumValue(); }
-  TemplateVariant isVariable() const { return m_memberDef->isVariable(); }
-  TemplateVariant isEnumeration() const { return m_memberDef->isEnumerate(); }
-  TemplateVariant hasDetails() const {
-    return m_memberDef->isDetailedSectionLinkable();
-  }
-  TemplateVariant initializer() const {
-    return createLinkedText(m_memberDef, relPathAsString(),
-                            m_memberDef->initializer());
-  }
-  TemplateVariant initializerAsCode() const {
-    Cachable &cache = getCache();
-    if (!cache.initializerParsed) {
-      QCString scopeName;
-      if (m_memberDef->getClassDef()) {
-        scopeName = m_memberDef->getClassDef()->name();
-      } else if (m_memberDef->getNamespaceDef()) {
-        scopeName = m_memberDef->getNamespaceDef()->name();
-      }
-      cache.initializer = parseCode(m_memberDef, scopeName, relPathAsString(),
-                                    m_memberDef->initializer());
-      cache.initializerParsed = TRUE;
-    }
-    return cache.initializer;
-  }
-  TemplateVariant isDefine() const { return m_memberDef->isDefine(); }
-  TemplateVariant isAnonymous() const {
-    QCString name = m_memberDef->name();
-    return !name.isEmpty() && name.at(0) == '@';
-  }
-  TemplateVariant anonymousType() const {
-    Cachable &cache = getCache();
-    if (!cache.anonymousType) {
-      ClassDef *cd = m_memberDef->getClassDefOfAnonymousType();
-      if (cd) {
-        cache.anonymousType.reset(ClassContext::alloc(cd));
-      }
+    TemplateVariant highlight() const
+    {
+      return TemplateVariant("modules");
     }
-    if (cache.anonymousType) {
-      return cache.anonymousType.get();
-    } else {
-      return FALSE;
+    TemplateVariant subHighlight() const
+    {
+      return TemplateVariant("");
     }
-  }
-  TemplateVariant anonymousMember() const {
-    Cachable &cache = getCache();
-    if (!cache.anonymousMember) {
-      MemberDef *md = m_memberDef->fromAnonymousMember();
-      if (md) {
-        cache.anonymousMember.reset(MemberContext::alloc(md));
+    DotGroupCollaboration *getGroupGraph() const
+    {
+      Cachable &cache = getCache();
+      if (!cache.groupGraph)
+      {
+        cache.groupGraph.reset(new DotGroupCollaboration(m_groupDef));
       }
+      return cache.groupGraph.get();
     }
-    if (cache.anonymousMember) {
-      return cache.anonymousMember.get();
-    } else {
-      return FALSE;
-    }
-  }
-  TemplateVariant isRelated() const { return m_memberDef->isRelated(); }
-  TemplateVariant enumBaseType() const { return m_memberDef->enumBaseType(); }
-  TemplateVariant hasOneLineInitializer() const {
-    return m_memberDef->hasOneLineInitializer();
-  }
-  TemplateVariant hasMultiLineInitializer() const {
-    return m_memberDef->hasMultiLineInitializer();
-  }
-  TemplateVariant enumValues() const {
-    Cachable &cache = getCache();
-    if (!cache.enumValues) {
-      MemberList *ml = m_memberDef->enumFieldList();
-      if (ml) {
-        cache.enumValues.reset(MemberListContext::alloc(ml));
-      } else {
-        cache.enumValues.reset(MemberListContext::alloc());
+    TemplateVariant hasGroupGraph() const
+    {
+      bool result=FALSE;
+      static bool haveDot     = Config_getBool(HAVE_DOT);
+      static bool groupGraphs = Config_getBool(GROUP_GRAPHS);
+      if (haveDot && groupGraphs)
+      {
+        DotGroupCollaboration *graph = getGroupGraph();
+        result = !graph->isTrivial();
       }
+      return result;
     }
-    return cache.enumValues.get();
-  }
-  TemplateVariant templateArgs() const {
-    Cachable &cache = getCache();
-    if (!cache.templateArgs && m_memberDef->templateArguments()) {
-      cache.templateArgs.reset(ArgumentListContext::alloc(
-          m_memberDef->templateArguments(), m_memberDef, relPathAsString()));
-    }
-    if (cache.templateArgs) {
-      return cache.templateArgs.get();
-    } else {
-      return TemplateVariant(FALSE);
-    }
-  }
-  TemplateVariant templateAlias() const {
-    if (m_memberDef->isAlias()) {
-      return createLinkedText(m_memberDef, relPathAsString(),
-                              QCString(" = ") + m_memberDef->typeString());
-    }
-    return "";
-  }
-  TemplateVariant propertyAttrs() const {
-    return getCache().propertyAttrs.get();
-  }
-  TemplateVariant eventAttrs() const { return getCache().eventAttrs.get(); }
-  TemplateVariant getClass() const {
-    Cachable &cache = getCache();
-    if (!cache.classDef && m_memberDef->getClassDef()) {
-      cache.classDef.reset(ClassContext::alloc(m_memberDef->getClassDef()));
-    }
-    if (cache.classDef) {
-      return cache.classDef.get();
-    } else {
-      return TemplateVariant(FALSE);
-    }
-  }
-  TemplateVariant category() const {
-    Cachable &cache = getCache();
-    if (!cache.category && m_memberDef->category()) {
-      cache.category.reset(ClassContext::alloc(m_memberDef->category()));
-    }
-    if (cache.category) {
-      return cache.category.get();
-    } else {
-      return TemplateVariant(FALSE);
-    }
-  }
-  TemplateVariant categoryRelation() const {
-    Cachable &cache = getCache();
-    if (!cache.categoryRelation && m_memberDef->categoryRelation()) {
-      cache.categoryRelation.reset(
-          MemberContext::alloc(m_memberDef->categoryRelation()));
-    }
-    if (cache.categoryRelation) {
-      return cache.categoryRelation.get();
-    } else {
-      return TemplateVariant(FALSE);
-    }
-  }
-  TemplateVariant getFile() const {
-    Cachable &cache = getCache();
-    if (!cache.fileDef && m_memberDef->getFileDef()) {
-      cache.fileDef.reset(FileContext::alloc(m_memberDef->getFileDef()));
-    }
-    if (cache.fileDef) {
-      return cache.fileDef.get();
-    } else {
-      return TemplateVariant(FALSE);
-    }
-    TemplateVariant hasRefQualifierLValue() const
+    TemplateVariant groupGraph() const
     {
-      ArgumentList *al = getDefArgList();
-      return al ? al->refQualifier==RefQualifierLValue : FALSE;
+      QGString result;
+      static bool haveDot     = Config_getBool(HAVE_DOT);
+      static bool groupGraphs = Config_getBool(GROUP_GRAPHS);
+      if (haveDot && groupGraphs)
+      {
+        DotGroupCollaboration *graph = getGroupGraph();
+        FTextStream t(&result);
+        switch (g_globals.outputFormat)
+        {
+          case ContextOutputFormat_Html:
+            {
+              graph->writeGraph(t,GOF_BITMAP,
+                                EOF_Html,
+                                g_globals.outputDir,
+                                g_globals.outputDir+portable_pathSeparator()+m_groupDef->getOutputFileBase()+Doxygen::htmlFileExtension,
+                                relPathAsString(),
+                                TRUE,
+                                g_globals.dynSectionId);
+            }
+            break;
+          case ContextOutputFormat_Latex:
+            {
+              graph->writeGraph(t,GOF_EPS,
+                                EOF_LaTeX,
+                                g_globals.outputDir,
+                                g_globals.outputDir+portable_pathSeparator()+m_groupDef->getOutputFileBase()+".tex",
+                                relPathAsString(),
+                                TRUE,
+                                g_globals.dynSectionId);
+            }
+            break;
+            // TODO: support other generators
+          default:
+            err("context.cpp: output format not yet supported");
+            break;
+        }
+        g_globals.dynSectionId++;
+      }
+      return TemplateVariant(result.data(),TRUE);
     }
-    TemplateVariant hasRefQualifierRValue() const
+    TemplateVariant hasDetails() const
     {
-      ArgumentList *al = getDefArgList();
-      return al ? al->refQualifier==RefQualifierRValue : FALSE;
+      return m_groupDef->hasDetailedDescription();
     }
-    TemplateVariant trailingReturnType() const
+    TemplateVariant modules() const
     {
-      ArgumentList *al = getDefArgList();
-      if (al && !al->trailingReturnType.isEmpty())
+      Cachable &cache = getCache();
+      if (!cache.modules)
       {
-        return createLinkedText(m_memberDef,relPathAsString(),
-                                al->trailingReturnType);
+        TemplateList *moduleList = TemplateList::alloc();
+        if (m_groupDef->getSubGroups())
+        {
+          GroupListIterator gli(*m_groupDef->getSubGroups());
+          GroupDef *gd;
+          for (gli.toFirst();(gd=gli.current());++gli)
+          {
+            if (gd->isVisible())
+            {
+              moduleList->append(ModuleContext::alloc(gd));
+            }
+          }
+        }
+        cache.modules.reset(moduleList);
       }
-      else
+      return cache.modules.get();
+    }
+    TemplateVariant examples() const
+    {
+      Cachable &cache = getCache();
+      if (!cache.examples)
       {
-        return "";
+        TemplateList *exampleList = TemplateList::alloc();
+        if (m_groupDef->getExamples())
+        {
+          PageSDict::Iterator eli(*m_groupDef->getExamples());
+          PageDef *ex;
+          for (eli.toFirst();(ex=eli.current());++eli)
+          {
+            exampleList->append(PageContext::alloc(ex,FALSE,TRUE));
+          }
+        }
+        cache.examples.reset(exampleList);
       }
+      return cache.examples.get();
     }
-  }
-  TemplateVariant definition() const {
-    return createLinkedText(m_memberDef, relPathAsString(),
-                            m_memberDef->displayDefinition());
-  }
-  ArgumentList *getDefArgList() const {
-    return (m_memberDef->isDocsForDefinition())
-               ? m_memberDef->argumentList()
-               : m_memberDef->declArgumentList();
-  }
-  TemplateVariant parameters() const {
-    Cachable &cache = getCache();
-    if (!cache.arguments) {
-      ArgumentList *defArgList = getDefArgList();
-      if (defArgList && !m_memberDef->isProperty()) {
-        cache.arguments.reset(ArgumentListContext::alloc(
-            defArgList, m_memberDef, relPathAsString()));
-      } else {
-        cache.arguments.reset(ArgumentListContext::alloc());
-      }
-    }
-    return cache.arguments.get();
-  }
-  TemplateVariant hasParameters() const { return getDefArgList() != 0; }
-  TemplateVariant hasConstQualifier() const {
-    ArgumentList *al = getDefArgList();
-    return al ? al->constSpecifier : FALSE;
-  }
-  TemplateVariant hasVolatileQualifier() const {
-    ArgumentList *al = getDefArgList();
-    return al ? al->volatileSpecifier : FALSE;
-  }
-  TemplateVariant trailingReturnType() const {
-    ArgumentList *al = getDefArgList();
-    if (al && !al->trailingReturnType.isEmpty()) {
-      return createLinkedText(m_memberDef, relPathAsString(),
-                              al->trailingReturnType);
-    } else {
-      return "";
-    }
-  }
-  TemplateVariant extraTypeChars() const {
-    return m_memberDef->extraTypeChars();
-  }
-  void addTemplateDecls(TemplateList *tl) const {
-    ClassDef *cd = m_memberDef->getClassDef();
-    if (m_memberDef->definitionTemplateParameterLists()) {
-      QListIterator<ArgumentList> ali(
-          *m_memberDef->definitionTemplateParameterLists());
-      ArgumentList *tal;
-      for (ali.toFirst(); (tal = ali.current()); ++ali) {
-        if (tal->count() > 0) {
-          ArgumentListContext *al =
-              ArgumentListContext::alloc(tal, m_memberDef, relPathAsString());
-          tl->append(al);
+    TemplateVariant pages() const
+    {
+      Cachable &cache = getCache();
+      if (!cache.pages)
+      {
+        TemplateList *pageList = TemplateList::alloc();
+        if (m_groupDef->getExamples())
+        {
+          PageSDict::Iterator eli(*m_groupDef->getPages());
+          PageDef *ex;
+          for (eli.toFirst();(ex=eli.current());++eli)
+          {
+            pageList->append(PageContext::alloc(ex,FALSE,TRUE));
+          }
         }
+        cache.pages.reset(pageList);
       }
-    } else {
-      if (cd && !m_memberDef->isRelated() &&
-          !m_memberDef->isTemplateSpecialization()) {
-        QList<ArgumentList> tempParamLists;
-        cd->getTemplateParameterLists(tempParamLists);
-        // printf("#tempParamLists=%d\n",tempParamLists.count());
-        QListIterator<ArgumentList> ali(tempParamLists);
-        ArgumentList *tal;
-        for (ali.toFirst(); (tal = ali.current()); ++ali) {
-          if (tal->count() > 0) {
-            ArgumentListContext *al =
-                ArgumentListContext::alloc(tal, m_memberDef, relPathAsString());
-            tl->append(al);
+      return cache.pages.get();
+    }
+    TemplateVariant dirs() const
+    {
+      Cachable &cache = getCache();
+      if (!cache.dirs)
+      {
+        TemplateList *dirList = TemplateList::alloc();
+        if (m_groupDef->getDirs())
+        {
+          QListIterator<DirDef> it(*m_groupDef->getDirs());
+          DirDef *dd;
+          for (it.toFirst();(dd=it.current());++it)
+          {
+            dirList->append(DirContext::alloc(dd));
           }
         }
+        cache.dirs.reset(dirList);
       }
-      if (m_memberDef->templateArguments()) // function template prefix
+      return cache.dirs.get();
+    }
+    TemplateVariant files() const
+    {
+      Cachable &cache = getCache();
+      if (!cache.files)
       {
-        ArgumentListContext *al = ArgumentListContext::alloc(
-            m_memberDef->templateArguments(), m_memberDef, relPathAsString());
-        tl->append(al);
+        TemplateList *fileList = TemplateList::alloc();
+        if (m_groupDef->getFiles())
+        {
+          QListIterator<FileDef> it(*m_groupDef->getFiles());
+          FileDef *fd;
+          for (it.toFirst();(fd=it.current());++it)
+          {
+            fileList->append(FileContext::alloc(fd));
+          }
+        }
+        cache.files.reset(fileList);
       }
+      return cache.files.get();
     }
-  }
-  TemplateVariant templateDecls() const {
-    Cachable &cache = getCache();
-    if (!cache.templateDecls) {
-      TemplateList *tl = TemplateList::alloc();
-      addTemplateDecls(tl);
-      cache.templateDecls.reset(tl);
-    }
-    return cache.templateDecls.get();
-  }
-  TemplateVariant labels() const {
-    Cachable &cache = getCache();
-    if (!cache.labels) {
-      QStrList sl;
-      m_memberDef->getLabels(sl, m_memberDef->getOuterScope());
-      TemplateList *tl = TemplateList::alloc();
-      if (sl.count() > 0) {
-        QStrListIterator it(sl);
-        for (; it.current(); ++it) {
-          tl->append(*it);
+    TemplateVariant classes() const
+    {
+      Cachable &cache = getCache();
+      if (!cache.classes)
+      {
+        TemplateList *classList = TemplateList::alloc();
+        if (m_groupDef->getClasses())
+        {
+          ClassSDict::Iterator sdi(*m_groupDef->getClasses());
+          ClassDef *cd;
+          for (sdi.toFirst();(cd=sdi.current());++sdi)
+          {
+            if (cd->visibleInParentsDeclList())
+            {
+              classList->append(ClassContext::alloc(cd));
+            }
+          }
         }
+        cache.classes.reset(classList);
       }
-      cache.labels.reset(tl);
+      return cache.classes.get();
     }
-    return cache.labels.get();
-  }
-  TemplateVariant paramDocs() const {
-    Cachable &cache = getCache();
-    if (!cache.paramDocs) {
-      if (m_memberDef->argumentList() &&
-          m_memberDef->argumentList()->hasDocumentation()) {
-        QCString paramDocs;
-        ArgumentListIterator ali(*m_memberDef->argumentList());
-        Argument *a;
-        // convert the parameter documentation into a list of @param commands
-        for (ali.toFirst(); (a = ali.current()); ++ali) {
-          if (a->hasDocumentation()) {
-            QCString direction = extractDirection(a->docs);
-            paramDocs += "@param" + direction + " " + a->name + " " + a->docs;
+    TemplateVariant namespaces() const
+    {
+      Cachable &cache = getCache();
+      if (!cache.namespaces)
+      {
+        TemplateList *namespaceList = TemplateList::alloc();
+        if (m_groupDef->getNamespaces())
+        {
+          NamespaceSDict::Iterator sdi(*m_groupDef->getNamespaces());
+          NamespaceDef *nd;
+          for (sdi.toFirst();(nd=sdi.current());++sdi)
+          {
+            if (nd->isLinkable() && !nd->isConstantGroup())
+            {
+              namespaceList->append(NamespaceContext::alloc(nd));
+            }
           }
         }
-        cache.paramDocs.reset(new TemplateVariant(parseDoc(
-            m_memberDef, m_memberDef->docFile(), m_memberDef->docLine(),
-            relPathAsString(), paramDocs, FALSE)));
-      } else {
-        cache.paramDocs.reset(new TemplateVariant(""));
+        cache.namespaces.reset(namespaceList);
       }
+      return cache.namespaces.get();
     }
-    return *cache.paramDocs;
-  }
-  TemplateVariant implements() const {
-    Cachable &cache = getCache();
-    if (!cache.implements) {
-      MemberDef *md = m_memberDef->reimplements();
-      cache.implements.reset(TemplateList::alloc());
-      if (md) {
-        ClassDef *cd = md->getClassDef();
-        if (cd && (md->virtualness() == Pure ||
-                   cd->compoundType() == ClassDef::Interface)) {
-          MemberContext *mc = MemberContext::alloc(md);
-          cache.implements->append(mc);
+    TemplateVariant constantgroups() const
+    {
+      Cachable &cache = getCache();
+      if (!cache.constantgroups)
+      {
+        TemplateList *namespaceList = TemplateList::alloc();
+        if (m_groupDef->getNamespaces())
+        {
+          NamespaceSDict::Iterator sdi(*m_groupDef->getNamespaces());
+          NamespaceDef *nd;
+          for (sdi.toFirst();(nd=sdi.current());++sdi)
+          {
+            if (nd->isLinkable() && nd->isConstantGroup())
+            {
+              namespaceList->append(NamespaceContext::alloc(nd));
+            }
+          }
         }
+        cache.constantgroups.reset(namespaceList);
       }
+      return cache.constantgroups.get();
     }
-    return cache.implements.get();
-  }
-  TemplateVariant reimplements() const {
-    Cachable &cache = getCache();
-    if (!cache.reimplements) {
-      MemberDef *md = m_memberDef->reimplements();
-      cache.reimplements.reset(TemplateList::alloc());
-      if (md) {
-        ClassDef *cd = md->getClassDef();
-        if (cd && md->virtualness() != Pure &&
-            cd->compoundType() != ClassDef::Interface) {
-          MemberContext *mc = MemberContext::alloc(md);
-          cache.reimplements->append(mc);
+
+    TemplateVariant getMemberList(SharedPtr<MemberListInfoContext> &list,
+                                  MemberListType type,const char *title,bool detailed=FALSE) const
+    {
+      if (!list)
+      {
+        MemberList *ml = m_groupDef->getMemberList(type);
+        if (ml)
+        {
+          list.reset(MemberListInfoContext::alloc(m_groupDef,relPathAsString(),ml,title,""));
         }
       }
+      if (list)
+      {
+        return list.get();
+      }
+      else
+      {
+        return TemplateVariant(FALSE);
+      }
+    }
+    TemplateVariant macros() const
+    {
+      return getMemberList(getCache().macros,MemberListType_decDefineMembers,theTranslator->trDefines());
+    }
+    TemplateVariant typedefs() const
+    {
+      return getMemberList(getCache().typedefs,MemberListType_decTypedefMembers,theTranslator->trTypedefs());
+    }
+    TemplateVariant enums() const
+    {
+      return getMemberList(getCache().enums,MemberListType_decEnumMembers,theTranslator->trEnumerations());
+    }
+    TemplateVariant enumValues() const
+    {
+      return getMemberList(getCache().enums,MemberListType_decEnumValMembers,theTranslator->trEnumerationValues());
+    }
+    TemplateVariant functions() const
+    {
+      QCString title = theTranslator->trFunctions();
+      SrcLangExt lang = m_groupDef->getLanguage();
+      if (lang==SrcLangExt_Fortran) title=theTranslator->trSubprograms();
+      else if (lang==SrcLangExt_VHDL) title=VhdlDocGen::trFunctionAndProc();
+      return getMemberList(getCache().functions,MemberListType_decFuncMembers,title);
+    }
+    TemplateVariant variables() const
+    {
+      return getMemberList(getCache().variables,MemberListType_decVarMembers,theTranslator->trVariables());
     }
-    return cache.reimplements.get();
-  }
-  TemplateVariant implementedBy() const {
-    Cachable &cache = getCache();
-    if (!cache.implementedBy) {
-      MemberList *ml = m_memberDef->reimplementedBy();
-      cache.implementedBy.reset(TemplateList::alloc());
-      if (ml) {
-        MemberListIterator mli(*ml);
-        MemberDef *md = 0;
-        for (mli.toFirst(); (md = mli.current()); ++mli) {
-          ClassDef *cd = md->getClassDef();
-          if (cd && (md->virtualness() == Pure ||
-                     cd->compoundType() == ClassDef::Interface)) {
-            MemberContext *mc = new MemberContext(md);
-            cache.implementedBy->append(mc);
-          }
-        }
-      }
+    TemplateVariant signals() const
+    {
+      return getMemberList(getCache().signals,MemberListType_signals,theTranslator->trSignals());
     }
-    return cache.implementedBy.get();
-  }
-  TemplateVariant reimplementedBy() const {
-    Cachable &cache = getCache();
-    if (!cache.reimplementedBy) {
-      cache.reimplementedBy.reset(TemplateList::alloc());
-      MemberList *ml = m_memberDef->reimplementedBy();
-      if (ml) {
-        MemberListIterator mli(*ml);
-        MemberDef *md = 0;
-        for (mli.toFirst(); (md = mli.current()); ++mli) {
-          ClassDef *cd = md->getClassDef();
-          if (cd && md->virtualness() != Pure &&
-              cd->compoundType() != ClassDef::Interface) {
-            MemberContext *mc = new MemberContext(md);
-            cache.reimplementedBy->append(mc);
-          }
-        }
-      }
+    TemplateVariant publicSlots() const
+    {
+      return getMemberList(getCache().publicSlots,MemberListType_pubSlots,theTranslator->trPublicSlots());
     }
-    return cache.reimplementedBy.get();
-  }
-  void addExamples(TemplateList *list) const {
-    if (m_memberDef->hasExamples()) {
-      ExampleSDict::Iterator it(*m_memberDef->getExamples());
-      Example *ex;
-      for (it.toFirst(); (ex = it.current()); ++it) {
-        TemplateStruct *s = TemplateStruct::alloc();
-        s->set("text", ex->name);
-        s->set("isLinkable", TRUE);
-        s->set("anchor", ex->anchor);
-        s->set("fileName", ex->file);
-        s->set("isReference", FALSE);
-        s->set("externalReference", "");
-        list->append(s);
-      }
+    TemplateVariant protectedSlots() const
+    {
+      return getMemberList(getCache().protectedSlots,MemberListType_proSlots,theTranslator->trProtectedSlots());
     }
-  }
-  TemplateVariant examples() const {
-    Cachable &cache = getCache();
-    if (!cache.examples) {
-      TemplateList *exampleList = TemplateList::alloc();
-      addExamples(exampleList);
-      cache.examples.reset(exampleList);
-    }
-    return cache.examples.get();
-  }
-  TemplateVariant typeConstraints() const {
-    Cachable &cache = getCache();
-    if (!cache.typeConstraints && m_memberDef->typeConstraints()) {
-      cache.typeConstraints.reset(ArgumentListContext::alloc(
-          m_memberDef->typeConstraints(), m_memberDef, relPathAsString()));
-    } else {
-      cache.typeConstraints.reset(ArgumentListContext::alloc());
-    }
-    return cache.typeConstraints.get();
-  }
-  TemplateVariant functionQualifier() const {
-    if (!m_memberDef->isObjCMethod() &&
-        (m_memberDef->isFunction() || m_memberDef->isSlot() ||
-         m_memberDef->isPrototype() || m_memberDef->isSignal())) {
-      return "()";
-    } else {
-      return "";
+    TemplateVariant privateSlots() const
+    {
+      return getMemberList(getCache().privateSlots,MemberListType_priSlots,theTranslator->trPrivateSlots());
     }
-  }
-  TemplateVariant sourceRefs() const {
-    Cachable &cache = getCache();
-    if (!cache.sourceRefs) {
-      cache.sourceRefs.reset(
-          MemberListContext::alloc(m_memberDef->getReferencesMembers(), TRUE));
+    TemplateVariant events() const
+    {
+      return getMemberList(getCache().events,MemberListType_events,theTranslator->trEvents());
     }
-    return cache.sourceRefs.get();
-  }
-  TemplateVariant sourceRefBys() const {
-    Cachable &cache = getCache();
-    if (!cache.sourceRefBys) {
-      cache.sourceRefBys.reset(MemberListContext::alloc(
-          m_memberDef->getReferencedByMembers(), TRUE));
+    TemplateVariant properties() const
+    {
+      return getMemberList(getCache().properties,MemberListType_properties,theTranslator->trProperties());
     }
-    return cache.sourceRefBys.get();
-  }
-  TemplateVariant hasSources() const {
-    return TemplateVariant(m_memberDef->hasSources());
-  }
-  TemplateVariant sourceCode() const {
-    Cachable &cache = getCache();
-    if (!cache.sourceCodeParsed) {
-      QCString codeFragment;
-      FileDef *fd = m_memberDef->getBodyDef();
-      int startLine = m_memberDef->getStartBodyLine();
-      int endLine = m_memberDef->getEndBodyLine();
-      if (fd && readCodeFragment(fd->absFilePath(), startLine, endLine,
-                                 codeFragment)) {
-        QCString scopeName;
-        if (m_memberDef->getClassDef()) {
-          scopeName = m_memberDef->getClassDef()->name();
-        } else if (m_memberDef->getNamespaceDef()) {
-          scopeName = m_memberDef->getNamespaceDef()->name();
+    TemplateVariant friends() const
+    {
+      return getMemberList(getCache().friends,MemberListType_friends,theTranslator->trFriends());
+    }
+    TemplateVariant memberGroups() const
+    {
+      Cachable &cache = getCache();
+      if (!cache.memberGroups)
+      {
+        if (m_groupDef->getMemberGroupSDict())
+        {
+          cache.memberGroups.reset(MemberGroupListContext::alloc(m_groupDef,relPathAsString(),m_groupDef->getMemberGroupSDict(),m_groupDef->subGrouping()));
+        }
+        else
+        {
+          cache.memberGroups.reset(MemberGroupListContext::alloc());
         }
-        cache.sourceCode = parseCode(m_memberDef, scopeName, relPathAsString(),
-                                     codeFragment, startLine, endLine, TRUE);
-        cache.sourceCodeParsed = TRUE;
       }
+      return cache.memberGroups.get();
     }
-    return cache.sourceCode;
-  }
-  DotCallGraph *getCallGraph() const {
-    Cachable &cache = getCache();
-    if (!cache.callGraph) {
-      cache.callGraph.reset(new DotCallGraph(m_memberDef, FALSE));
+    TemplateVariant detailedMacros() const
+    {
+      return getMemberList(getCache().detailedMacros,MemberListType_docDefineMembers,theTranslator->trDefineDocumentation());
     }
-    return cache.callGraph.get();
-  }
-  TemplateVariant hasCallGraph() const {
-    static bool haveDot = Config_getBool(HAVE_DOT);
-    if (m_memberDef->hasCallGraph() && haveDot &&
-        (m_memberDef->isFunction() || m_memberDef->isSlot() ||
-         m_memberDef->isSignal())) {
-      DotCallGraph *cg = getCallGraph();
-      return !cg->isTooBig() && !cg->isTrivial();
-    }
-    return TemplateVariant(FALSE);
-  }
-  TemplateVariant callGraph() const {
-    if (hasCallGraph().toBool()) {
-      DotCallGraph *cg = getCallGraph();
-      QGString result;
-      FTextStream t(&result);
-      switch (g_globals.outputFormat) {
-      case ContextOutputFormat_Html: {
-        cg->writeGraph(t, GOF_BITMAP, EOF_Html, g_globals.outputDir,
-                       g_globals.outputDir + portable_pathSeparator() +
-                           m_memberDef->getOutputFileBase() +
-                           Doxygen::htmlFileExtension,
-                       relPathAsString(), TRUE, g_globals.dynSectionId);
-      } break;
-      case ContextOutputFormat_Latex: {
-        cg->writeGraph(t, GOF_EPS, EOF_LaTeX, g_globals.outputDir,
-                       g_globals.outputDir + portable_pathSeparator() +
-                           m_memberDef->getOutputFileBase() + ".tex",
-                       relPathAsString(), TRUE, g_globals.dynSectionId);
-      } break;
-      // TODO: support other generators
-      default:
-        err("context.cpp: output format not yet supported");
-        break;
-      }
-      g_globals.dynSectionId++;
-      return TemplateVariant(result.data(), TRUE);
-    } else {
-      return TemplateVariant("");
+    TemplateVariant detailedTypedefs() const
+    {
+      return getMemberList(getCache().detailedTypedefs,MemberListType_docTypedefMembers,theTranslator->trTypedefDocumentation());
     }
-  }
-  DotCallGraph *getCallerGraph() const {
-    Cachable &cache = getCache();
-    if (!cache.callerGraph) {
-      cache.callerGraph.reset(new DotCallGraph(m_memberDef, TRUE));
+    TemplateVariant detailedEnums() const
+    {
+      return getMemberList(getCache().detailedEnums,MemberListType_docEnumMembers,theTranslator->trEnumerationTypeDocumentation());
     }
-    return cache.callerGraph.get();
-  }
-  TemplateVariant hasCallerGraph() const {
-    static bool haveDot = Config_getBool(HAVE_DOT);
-    if (m_memberDef->hasCallerGraph() && haveDot &&
-        (m_memberDef->isFunction() || m_memberDef->isSlot() ||
-         m_memberDef->isSignal())) {
-      DotCallGraph *cg = getCallerGraph();
-      return !cg->isTooBig() && !cg->isTrivial();
-    }
-    return TemplateVariant(FALSE);
-  }
-  TemplateVariant callerGraph() const {
-    if (hasCallerGraph().toBool()) {
-      DotCallGraph *cg = getCallerGraph();
-      QGString result;
-      FTextStream t(&result);
-      switch (g_globals.outputFormat) {
-      case ContextOutputFormat_Html: {
-        cg->writeGraph(t, GOF_BITMAP, EOF_Html, g_globals.outputDir,
-                       g_globals.outputDir + portable_pathSeparator() +
-                           m_memberDef->getOutputFileBase() +
-                           Doxygen::htmlFileExtension,
-                       relPathAsString(), TRUE, g_globals.dynSectionId);
-      } break;
-      case ContextOutputFormat_Latex: {
-        cg->writeGraph(t, GOF_EPS, EOF_LaTeX, g_globals.outputDir,
-                       g_globals.outputDir + portable_pathSeparator() +
-                           m_memberDef->getOutputFileBase() + ".tex",
-                       relPathAsString(), TRUE, g_globals.dynSectionId);
-      } break;
-      // TODO: support other generators
-      default:
-        err("context.cpp: output format not yet supported");
-        break;
-      }
-      g_globals.dynSectionId++;
-      return TemplateVariant(result.data(), TRUE);
-    } else {
-      return TemplateVariant("");
+    TemplateVariant detailedEnumValues() const
+    {
+      return getMemberList(getCache().detailedEnumValues,MemberListType_docEnumValMembers,theTranslator->trEnumerationValueDocumentation());
     }
-  }
-  TemplateVariant type() const { return m_memberDef->typeString(); }
-  TemplateVariant
-  handleDetailsVisibleFor(const QValueList<TemplateVariant> &args) const {
-    if (args.count() == 1) {
-      return m_memberDef->isDetailedSectionVisible(
-          args[0].toString() == "module", args[0].toString() == "file");
-    } else {
-      err(".detailsVisibleFor should take one string argument, got %d\n",
-          args.count());
-    }
-    return TemplateVariant();
-  }
-  TemplateVariant detailsVisibleFor() const {
-    return TemplateVariant::Delegate::fromMethod<
-        Private, &Private::handleDetailsVisibleFor>(this);
-  }
-  TemplateVariant
-  handleNameWithContextFor(const QValueList<TemplateVariant> &args) const {
-    if (args.count() == 1) {
-      SrcLangExt lang = m_memberDef->getLanguage();
-      QCString n = m_memberDef->name();
-      QCString ctx = args[0].toString();
-      QCString sep = getLanguageSpecificSeparator(lang, TRUE);
-      if (m_memberDef->getEnumScope() && m_memberDef->livesInsideEnum()) {
-        n.prepend(m_memberDef->getEnumScope()->displayName() + sep);
-      }
-      if (ctx == "module" && m_memberDef->getClassDef() &&
-          !m_memberDef->isRelated()) {
-        n.prepend(m_memberDef->getClassDef()->displayName() + sep);
-      } else if ((ctx == "module" || ctx == "file") &&
-                 m_memberDef->getNamespaceDef()) {
-        n.prepend(m_memberDef->getNamespaceDef()->displayName() + sep);
-      }
-      return n;
-    } else {
-      err(".nameWithContextFor should take one string argument, got %d\n",
-          args.count());
-    }
-    return TemplateVariant();
-  }
-  TemplateVariant nameWithContextFor() const {
-    return TemplateVariant::Delegate::fromMethod<
-        Private, &Private::handleNameWithContextFor>(this);
-  }
-
-private:
-  MemberDef *m_memberDef;
-  struct Cachable : public DefinitionContext<MemberContext::Private>::Cachable {
-    Cachable(MemberDef *md)
-        : DefinitionContext<MemberContext::Private>::Cachable(md),
-          initializerParsed(FALSE), sourceCodeParsed(FALSE),
-          declArgsParsed(FALSE), declTypeParsed(FALSE) {}
-    SharedPtr<ArgumentListContext> templateArgs;
-    SharedPtr<ArgumentListContext> arguments;
-    SharedPtr<MemberListContext> enumValues;
-    SharedPtr<FileContext> fileDef;
-    SharedPtr<NamespaceContext> namespaceDef;
-    SharedPtr<ClassContext> category;
-    SharedPtr<MemberContext> categoryRelation;
-    SharedPtr<ClassContext> classDef;
-    SharedPtr<ClassContext> anonymousType;
-    SharedPtr<TemplateList> templateDecls;
-    ScopedPtr<TemplateVariant> paramDocs;
-    SharedPtr<TemplateList> implements;
-    SharedPtr<TemplateList> reimplements;
-    SharedPtr<TemplateList> implementedBy;
-    SharedPtr<MemberListContext> sourceRefs;
-    SharedPtr<MemberListContext> sourceRefBys;
-    ScopedPtr<DotCallGraph> callGraph;
-    ScopedPtr<DotCallGraph> callerGraph;
-    SharedPtr<MemberContext> anonymousMember;
-    SharedPtr<TemplateList> reimplementedBy;
-    SharedPtr<TemplateList> labels;
-    TemplateVariant initializer;
-    bool initializerParsed;
-    TemplateVariant sourceCode;
-    bool sourceCodeParsed;
-    TemplateVariant declArgs;
-    bool declArgsParsed;
-    TemplateVariant declType;
-    bool declTypeParsed;
-    SharedPtr<TemplateList> examples;
-    SharedPtr<TemplateList> exampleList;
-    SharedPtr<ArgumentListContext> typeConstraints;
-    SharedPtr<TemplateList> propertyAttrs;
-    SharedPtr<TemplateList> eventAttrs;
-  };
-  Cachable &getCache() const {
-    Cachable *c = static_cast<Cachable *>(m_memberDef->cookie());
-    assert(c != 0);
-    return *c;
-  }
-  static PropertyMapper<MemberContext::Private> s_inst;
-};
-//%% }
-
-PropertyMapper<MemberContext::Private> MemberContext::Private::s_inst;
-
-MemberContext::MemberContext(MemberDef *md)
-    : RefCountedContext("MemberContext") {
-  p = new Private(md);
-}
-
-MemberContext::~MemberContext() { delete p; }
-
-TemplateVariant MemberContext::get(const char *n) const { return p->get(n); }
-
-//------------------------------------------------------------------------
-
-//%% struct Module(Symbol): group information
-//%% {
-class ModuleContext::Private
-    : public DefinitionContext<ModuleContext::Private> {
-public:
-  Private(GroupDef *gd)
-      : DefinitionContext<ModuleContext::Private>(gd), m_groupDef(gd) {
-    static bool init = FALSE;
-    if (!init) {
-      addBaseProperties(s_inst);
-      s_inst.addProperty("title", &Private::title);
-      s_inst.addProperty("highlight", &Private::highlight);
-      s_inst.addProperty("subhighlight", &Private::subHighlight);
-      s_inst.addProperty("hasGroupGraph", &Private::hasGroupGraph);
-      s_inst.addProperty("groupGraph", &Private::groupGraph);
-      s_inst.addProperty("hasDetails", &Private::hasDetails);
-      s_inst.addProperty("modules", &Private::modules);
-      s_inst.addProperty("dirs", &Private::dirs);
-      s_inst.addProperty("files", &Private::files);
-      s_inst.addProperty("namespaces", &Private::namespaces);
-      s_inst.addProperty("classes", &Private::classes);
-      s_inst.addProperty("constantgroups", &Private::constantgroups);
-      s_inst.addProperty("examples", &Private::examples);
-      s_inst.addProperty("macros", &Private::macros);
-      s_inst.addProperty("typedefs", &Private::typedefs);
-      s_inst.addProperty("enums", &Private::enums);
-      s_inst.addProperty("enumvalues", &Private::enumValues);
-      s_inst.addProperty("functions", &Private::functions);
-      s_inst.addProperty("variables", &Private::variables);
-      s_inst.addProperty("signals", &Private::signals);
-      s_inst.addProperty("publicSlots", &Private::publicSlots);
-      s_inst.addProperty("protectedSlots", &Private::protectedSlots);
-      s_inst.addProperty("privateSlots", &Private::privateSlots);
-      s_inst.addProperty("events", &Private::events);
-      s_inst.addProperty("properties", &Private::properties);
-      s_inst.addProperty("friends", &Private::friends);
-      s_inst.addProperty("memberGroups", &Private::memberGroups);
-      s_inst.addProperty("detailedMacros", &Private::detailedMacros);
-      s_inst.addProperty("detailedTypedefs", &Private::detailedTypedefs);
-      s_inst.addProperty("detailedEnums", &Private::detailedEnums);
-      s_inst.addProperty("detailedEnumValues", &Private::detailedEnumValues);
-      s_inst.addProperty("detailedFunctions", &Private::detailedFunctions);
-      s_inst.addProperty("detailedVariables", &Private::detailedVariables);
-      s_inst.addProperty("detailedSignals", &Private::detailedSignals);
-      s_inst.addProperty("detailedPublicSlots", &Private::detailedPublicSlots);
-      s_inst.addProperty("detailedProtectedSlots",
-                         &Private::detailedProtectedSlots);
-      s_inst.addProperty("detailedPrivateSlots",
-                         &Private::detailedPrivateSlots);
-      s_inst.addProperty("detailedEvents", &Private::detailedEvents);
-      s_inst.addProperty("detailedProperties", &Private::detailedProperties);
-      s_inst.addProperty("detailedFriends", &Private::detailedFriends);
-      s_inst.addProperty("inlineClasses", &Private::inlineClasses);
-      s_inst.addProperty("compoundType", &Private::compoundType);
-      init = TRUE;
-    }
-    if (!gd->cookie()) {
-      gd->setCookie(new ModuleContext::Private::Cachable(gd));
+    TemplateVariant detailedFunctions() const
+    {
+      QCString title = theTranslator->trFunctionDocumentation();
+      SrcLangExt lang = m_groupDef->getLanguage();
+      if (lang==SrcLangExt_Fortran) title=theTranslator->trSubprogramDocumentation();
+      return getMemberList(getCache().detailedFunctions,MemberListType_docFuncMembers,title);
     }
-  }
-  virtual ~Private() {}
-  TemplateVariant get(const char *n) const { return s_inst.get(this, n); }
-  TemplateVariant title() const {
-    return TemplateVariant(m_groupDef->groupTitle());
-  }
-  TemplateVariant highlight() const { return TemplateVariant("modules"); }
-  TemplateVariant subHighlight() const { return TemplateVariant(""); }
-  DotGroupCollaboration *getGroupGraph() const {
-    Cachable &cache = getCache();
-    if (!cache.groupGraph) {
-      cache.groupGraph.reset(new DotGroupCollaboration(m_groupDef));
-    }
-    return cache.groupGraph.get();
-  }
-  TemplateVariant hasGroupGraph() const {
-    bool result = FALSE;
-    static bool haveDot = Config_getBool(HAVE_DOT);
-    static bool groupGraphs = Config_getBool(GROUP_GRAPHS);
-    if (haveDot && groupGraphs) {
-      DotGroupCollaboration *graph = getGroupGraph();
-      result = !graph->isTrivial();
-    }
-    return result;
-  }
-  TemplateVariant groupGraph() const {
-    QGString result;
-    static bool haveDot = Config_getBool(HAVE_DOT);
-    static bool groupGraphs = Config_getBool(GROUP_GRAPHS);
-    if (haveDot && groupGraphs) {
-      DotGroupCollaboration *graph = getGroupGraph();
-      FTextStream t(&result);
-      switch (g_globals.outputFormat) {
-      case ContextOutputFormat_Html: {
-        graph->writeGraph(t, GOF_BITMAP, EOF_Html, g_globals.outputDir,
-                          g_globals.outputDir + portable_pathSeparator() +
-                              m_groupDef->getOutputFileBase() +
-                              Doxygen::htmlFileExtension,
-                          relPathAsString(), TRUE, g_globals.dynSectionId);
-      } break;
-      case ContextOutputFormat_Latex: {
-        graph->writeGraph(t, GOF_EPS, EOF_LaTeX, g_globals.outputDir,
-                          g_globals.outputDir + portable_pathSeparator() +
-                              m_groupDef->getOutputFileBase() + ".tex",
-                          relPathAsString(), TRUE, g_globals.dynSectionId);
-      } break;
-      // TODO: support other generators
-      default:
-        err("context.cpp: output format not yet supported");
-        break;
-      }
-      g_globals.dynSectionId++;
+    TemplateVariant detailedVariables() const
+    {
+      return getMemberList(getCache().detailedVariables,MemberListType_docVarMembers,theTranslator->trVariableDocumentation());
     }
-    return TemplateVariant(result.data(), TRUE);
-  }
-  TemplateVariant hasDetails() const {
-    return m_groupDef->hasDetailedDescription();
-  }
-  TemplateVariant modules() const {
-    Cachable &cache = getCache();
-    if (!cache.modules) {
-      TemplateList *moduleList = TemplateList::alloc();
-      if (m_groupDef->getSubGroups()) {
-        GroupListIterator gli(*m_groupDef->getSubGroups());
-        GroupDef *gd;
-        for (gli.toFirst(); (gd = gli.current()); ++gli) {
-          if (gd->isVisible()) {
-            moduleList->append(ModuleContext::alloc(gd));
-          }
-        }
-      }
-      cache.modules.reset(moduleList);
+    TemplateVariant detailedSignals() const
+    {
+      return getMemberList(getCache().detailedSignals,MemberListType_docSignalMembers,theTranslator->trSignals());
     }
-    return cache.modules.get();
-  }
-  TemplateVariant examples() const {
-    Cachable &cache = getCache();
-    if (!cache.examples) {
-      TemplateList *exampleList = TemplateList::alloc();
-      if (m_groupDef->getExamples()) {
-        PageSDict::Iterator eli(*m_groupDef->getExamples());
-        PageDef *ex;
-        for (eli.toFirst(); (ex = eli.current()); ++eli) {
-          exampleList->append(PageContext::alloc(ex, FALSE, TRUE));
-        }
-      }
-      cache.examples.reset(exampleList);
+    TemplateVariant detailedPublicSlots() const
+    {
+      return getMemberList(getCache().detailedPublicSlots,MemberListType_docPubSlotMembers,theTranslator->trPublicSlots());
     }
-    return cache.examples.get();
-  }
-  TemplateVariant pages() const {
-    Cachable &cache = getCache();
-    if (!cache.pages) {
-      TemplateList *pageList = TemplateList::alloc();
-      if (m_groupDef->getExamples()) {
-        PageSDict::Iterator eli(*m_groupDef->getPages());
-        PageDef *ex;
-        for (eli.toFirst(); (ex = eli.current()); ++eli) {
-          pageList->append(PageContext::alloc(ex, FALSE, TRUE));
-        }
-      }
-      cache.pages.reset(pageList);
+    TemplateVariant detailedProtectedSlots() const
+    {
+      return getMemberList(getCache().detailedProtectedSlots,MemberListType_docProSlotMembers,theTranslator->trProtectedSlots());
     }
-    return cache.pages.get();
-  }
-  TemplateVariant dirs() const {
-    Cachable &cache = getCache();
-    if (!cache.dirs) {
-      TemplateList *dirList = TemplateList::alloc();
-      if (m_groupDef->getDirs()) {
-        QListIterator<DirDef> it(*m_groupDef->getDirs());
-        DirDef *dd;
-        for (it.toFirst(); (dd = it.current()); ++it) {
-          dirList->append(DirContext::alloc(dd));
-        }
-      }
-      cache.dirs.reset(dirList);
+    TemplateVariant detailedPrivateSlots() const
+    {
+      return getMemberList(getCache().detailedPrivateSlots,MemberListType_docPriSlotMembers,theTranslator->trPrivateSlots());
     }
-    return cache.dirs.get();
-  }
-  TemplateVariant files() const {
-    Cachable &cache = getCache();
-    if (!cache.files) {
-      TemplateList *fileList = TemplateList::alloc();
-      if (m_groupDef->getFiles()) {
-        QListIterator<FileDef> it(*m_groupDef->getFiles());
-        FileDef *fd;
-        for (it.toFirst(); (fd = it.current()); ++it) {
-          fileList->append(FileContext::alloc(fd));
-        }
-      }
-      cache.files.reset(fileList);
+    TemplateVariant detailedEvents() const
+    {
+      return getMemberList(getCache().detailedEvents,MemberListType_docEventMembers,theTranslator->trEventDocumentation(),TRUE);
     }
-    return cache.files.get();
-  }
-  TemplateVariant classes() const {
-    Cachable &cache = getCache();
-    if (!cache.classes) {
-      TemplateList *classList = TemplateList::alloc();
-      if (m_groupDef->getClasses()) {
-        ClassSDict::Iterator sdi(*m_groupDef->getClasses());
-        ClassDef *cd;
-        for (sdi.toFirst(); (cd = sdi.current()); ++sdi) {
-          if (cd->visibleInParentsDeclList()) {
-            classList->append(ClassContext::alloc(cd));
-          }
-        }
-      }
-      cache.classes.reset(classList);
+    TemplateVariant detailedProperties() const
+    {
+      return getMemberList(getCache().detailedProperties,MemberListType_docPropMembers,theTranslator->trPropertyDocumentation(),TRUE);
     }
-    return cache.classes.get();
-  }
-  TemplateVariant namespaces() const {
-    Cachable &cache = getCache();
-    if (!cache.namespaces) {
-      TemplateList *namespaceList = TemplateList::alloc();
-      if (m_groupDef->getNamespaces()) {
-        NamespaceSDict::Iterator sdi(*m_groupDef->getNamespaces());
-        NamespaceDef *nd;
-        for (sdi.toFirst(); (nd = sdi.current()); ++sdi) {
-          if (nd->isLinkable() && !nd->isConstantGroup()) {
-            namespaceList->append(NamespaceContext::alloc(nd));
-          }
-        }
-      }
-      cache.namespaces.reset(namespaceList);
+    TemplateVariant detailedFriends() const
+    {
+      return getMemberList(getCache().detailedFriends,MemberListType_docFriendMembers,theTranslator->trFriends(),TRUE);
     }
-    return cache.namespaces.get();
-  }
-  TemplateVariant constantgroups() const {
-    Cachable &cache = getCache();
-    if (!cache.constantgroups) {
-      TemplateList *namespaceList = TemplateList::alloc();
-      if (m_groupDef->getNamespaces()) {
-        NamespaceSDict::Iterator sdi(*m_groupDef->getNamespaces());
-        NamespaceDef *nd;
-        for (sdi.toFirst(); (nd = sdi.current()); ++sdi) {
-          if (nd->isLinkable() && nd->isConstantGroup()) {
-            namespaceList->append(NamespaceContext::alloc(nd));
+    TemplateVariant inlineClasses() const
+    {
+      Cachable &cache = getCache();
+      if (!cache.inlineClasses)
+      {
+        TemplateList *classList = TemplateList::alloc();
+        if (m_groupDef->getClasses())
+        {
+          ClassSDict::Iterator sdi(*m_groupDef->getClasses());
+          ClassDef *cd;
+          for (sdi.toFirst();(cd=sdi.current());++sdi)
+          {
+            if (cd->name().find('@')==-1 &&
+                cd->isLinkableInProject() &&
+                cd->isEmbeddedInOuterScope() &&
+                cd->partOfGroups()==0)
+            {
+              classList->append(ClassContext::alloc(cd));
+            }
           }
         }
+        cache.inlineClasses.reset(classList);
       }
-      cache.constantgroups.reset(namespaceList);
-    }
-    return cache.constantgroups.get();
-  }
-
-  TemplateVariant getMemberList(SharedPtr<MemberListInfoContext> &list,
-                                MemberListType type, const char *title,
-                                bool detailed = FALSE) const {
-    if (!list) {
-      MemberList *ml = m_groupDef->getMemberList(type);
-      if (ml) {
-        list.reset(MemberListInfoContext::alloc(m_groupDef, relPathAsString(),
-                                                ml, title, ""));
-      }
+      return cache.inlineClasses.get();
     }
-    if (list) {
-      return list.get();
-    } else {
-      return TemplateVariant(FALSE);
+    TemplateVariant compoundType() const
+    {
+      return "module"; //theTranslator->trGroup(FALSE,TRUE);
     }
-  }
-  TemplateVariant macros() const {
-    return getMemberList(getCache().macros, MemberListType_decDefineMembers,
-                         theTranslator->trDefines());
-  }
-  TemplateVariant typedefs() const {
-    return getMemberList(getCache().typedefs, MemberListType_decTypedefMembers,
-                         theTranslator->trTypedefs());
-  }
-  TemplateVariant enums() const {
-    return getMemberList(getCache().enums, MemberListType_decEnumMembers,
-                         theTranslator->trEnumerations());
-  }
-  TemplateVariant enumValues() const {
-    return getMemberList(getCache().enums, MemberListType_decEnumValMembers,
-                         theTranslator->trEnumerationValues());
-  }
-  TemplateVariant functions() const {
-    QCString title = theTranslator->trFunctions();
-    SrcLangExt lang = m_groupDef->getLanguage();
-    if (lang == SrcLangExt_Fortran)
-      title = theTranslator->trSubprograms();
-    else if (lang == SrcLangExt_VHDL)
-      title = VhdlDocGen::trFunctionAndProc();
-    return getMemberList(getCache().functions, MemberListType_decFuncMembers,
-                         title);
-  }
-  TemplateVariant variables() const {
-    return getMemberList(getCache().variables, MemberListType_decVarMembers,
-                         theTranslator->trVariables());
-  }
-  TemplateVariant signals() const {
-    return getMemberList(getCache().signals, MemberListType_signals,
-                         theTranslator->trSignals());
-  }
-  TemplateVariant publicSlots() const {
-    return getMemberList(getCache().publicSlots, MemberListType_pubSlots,
-                         theTranslator->trPublicSlots());
-  }
-  TemplateVariant protectedSlots() const {
-    return getMemberList(getCache().protectedSlots, MemberListType_proSlots,
-                         theTranslator->trProtectedSlots());
-  }
-  TemplateVariant privateSlots() const {
-    return getMemberList(getCache().privateSlots, MemberListType_priSlots,
-                         theTranslator->trPrivateSlots());
-  }
-  TemplateVariant events() const {
-    return getMemberList(getCache().events, MemberListType_events,
-                         theTranslator->trEvents());
-  }
-  TemplateVariant properties() const {
-    return getMemberList(getCache().properties, MemberListType_properties,
-                         theTranslator->trProperties());
-  }
-  TemplateVariant friends() const {
-    return getMemberList(getCache().friends, MemberListType_friends,
-                         theTranslator->trFriends());
-  }
-  TemplateVariant memberGroups() const {
-    Cachable &cache = getCache();
-    if (!cache.memberGroups) {
-      if (m_groupDef->getMemberGroupSDict()) {
-        cache.memberGroups.reset(MemberGroupListContext::alloc(
-            m_groupDef, relPathAsString(), m_groupDef->getMemberGroupSDict(),
-            m_groupDef->subGrouping()));
-      } else {
-        cache.memberGroups.reset(MemberGroupListContext::alloc());
-      }
-    }
-    return cache.memberGroups.get();
-  }
-  TemplateVariant detailedMacros() const {
-    return getMemberList(getCache().detailedMacros,
-                         MemberListType_docDefineMembers,
-                         theTranslator->trDefineDocumentation());
-  }
-  TemplateVariant detailedTypedefs() const {
-    return getMemberList(getCache().detailedTypedefs,
-                         MemberListType_docTypedefMembers,
-                         theTranslator->trTypedefDocumentation());
-  }
-  TemplateVariant detailedEnums() const {
-    return getMemberList(getCache().detailedEnums,
-                         MemberListType_docEnumMembers,
-                         theTranslator->trEnumerationTypeDocumentation());
-  }
-  TemplateVariant detailedEnumValues() const {
-    return getMemberList(getCache().detailedEnumValues,
-                         MemberListType_docEnumValMembers,
-                         theTranslator->trEnumerationValueDocumentation());
-  }
-  TemplateVariant detailedFunctions() const {
-    QCString title = theTranslator->trFunctionDocumentation();
-    SrcLangExt lang = m_groupDef->getLanguage();
-    if (lang == SrcLangExt_Fortran)
-      title = theTranslator->trSubprogramDocumentation();
-    return getMemberList(getCache().detailedFunctions,
-                         MemberListType_docFuncMembers, title);
-  }
-  TemplateVariant detailedVariables() const {
-    return getMemberList(getCache().detailedVariables,
-                         MemberListType_docVarMembers,
-                         theTranslator->trVariableDocumentation());
-  }
-  TemplateVariant detailedSignals() const {
-    return getMemberList(getCache().detailedSignals,
-                         MemberListType_docSignalMembers,
-                         theTranslator->trSignals());
-  }
-  TemplateVariant detailedPublicSlots() const {
-    return getMemberList(getCache().detailedPublicSlots,
-                         MemberListType_docPubSlotMembers,
-                         theTranslator->trPublicSlots());
-  }
-  TemplateVariant detailedProtectedSlots() const {
-    return getMemberList(getCache().detailedProtectedSlots,
-                         MemberListType_docProSlotMembers,
-                         theTranslator->trProtectedSlots());
-  }
-  TemplateVariant detailedPrivateSlots() const {
-    return getMemberList(getCache().detailedPrivateSlots,
-                         MemberListType_docPriSlotMembers,
-                         theTranslator->trPrivateSlots());
-  }
-  TemplateVariant detailedEvents() const {
-    return getMemberList(getCache().detailedEvents,
-                         MemberListType_docEventMembers,
-                         theTranslator->trEventDocumentation(), TRUE);
-  }
-  TemplateVariant detailedProperties() const {
-    return getMemberList(getCache().detailedProperties,
-                         MemberListType_docPropMembers,
-                         theTranslator->trPropertyDocumentation(), TRUE);
-  }
-  TemplateVariant detailedFriends() const {
-    return getMemberList(getCache().detailedFriends,
-                         MemberListType_docFriendMembers,
-                         theTranslator->trFriends(), TRUE);
-  }
-  TemplateVariant inlineClasses() const {
-    Cachable &cache = getCache();
-    if (!cache.inlineClasses) {
-      TemplateList *classList = TemplateList::alloc();
-      if (m_groupDef->getClasses()) {
-        ClassSDict::Iterator sdi(*m_groupDef->getClasses());
-        ClassDef *cd;
-        for (sdi.toFirst(); (cd = sdi.current()); ++sdi) {
-          if (cd->name().find('@') == -1 && cd->isLinkableInProject() &&
-              cd->isEmbeddedInOuterScope() && cd->partOfGroups() == 0) {
-            classList->append(ClassContext::alloc(cd));
-          }
-        }
-      }
-      cache.inlineClasses.reset(classList);
+  private:
+    GroupDef *m_groupDef;
+    struct Cachable : public DefinitionContext<ModuleContext::Private>::Cachable
+    {
+      Cachable(GroupDef *gd) : DefinitionContext<ModuleContext::Private>::Cachable(gd) {}
+      SharedPtr<TemplateList>               modules;
+      SharedPtr<TemplateList>               dirs;
+      SharedPtr<TemplateList>               files;
+      SharedPtr<TemplateList>               classes;
+      SharedPtr<TemplateList>               namespaces;
+      SharedPtr<TemplateList>               constantgroups;
+      SharedPtr<TemplateList>               examples;
+      SharedPtr<TemplateList>               pages;
+      SharedPtr<MemberListInfoContext>      macros;
+      SharedPtr<MemberListInfoContext>      typedefs;
+      SharedPtr<MemberListInfoContext>      enums;
+      SharedPtr<MemberListInfoContext>      enumValues;
+      SharedPtr<MemberListInfoContext>      functions;
+      SharedPtr<MemberListInfoContext>      variables;
+      SharedPtr<MemberListInfoContext>      signals;
+      SharedPtr<MemberListInfoContext>      publicSlots;
+      SharedPtr<MemberListInfoContext>      protectedSlots;
+      SharedPtr<MemberListInfoContext>      privateSlots;
+      SharedPtr<MemberListInfoContext>      events;
+      SharedPtr<MemberListInfoContext>      properties;
+      SharedPtr<MemberListInfoContext>      friends;
+      SharedPtr<MemberGroupListContext>     memberGroups;
+      SharedPtr<MemberListInfoContext>      detailedMacros;
+      SharedPtr<MemberListInfoContext>      detailedTypedefs;
+      SharedPtr<MemberListInfoContext>      detailedEnums;
+      SharedPtr<MemberListInfoContext>      detailedEnumValues;
+      SharedPtr<MemberListInfoContext>      detailedFunctions;
+      SharedPtr<MemberListInfoContext>      detailedVariables;
+      SharedPtr<MemberListInfoContext>      detailedSignals;
+      SharedPtr<MemberListInfoContext>      detailedPublicSlots;
+      SharedPtr<MemberListInfoContext>      detailedProtectedSlots;
+      SharedPtr<MemberListInfoContext>      detailedPrivateSlots;
+      SharedPtr<MemberListInfoContext>      detailedEvents;
+      SharedPtr<MemberListInfoContext>      detailedProperties;
+      SharedPtr<MemberListInfoContext>      detailedFriends;
+      SharedPtr<TemplateList>               inlineClasses;
+      ScopedPtr<DotGroupCollaboration>      groupGraph;
+    };
+    Cachable &getCache() const
+    {
+      Cachable *c = static_cast<Cachable*>(m_groupDef->cookie());
+      assert(c!=0);
+      return *c;
     }
-    return cache.inlineClasses.get();
-  }
-  TemplateVariant compoundType() const {
-    return "module"; // theTranslator->trGroup(FALSE,TRUE);
-  }
-
-private:
-  GroupDef *m_groupDef;
-  struct Cachable : public DefinitionContext<ModuleContext::Private>::Cachable {
-    Cachable(GroupDef *gd)
-        : DefinitionContext<ModuleContext::Private>::Cachable(gd) {}
-    SharedPtr<TemplateList> modules;
-    SharedPtr<TemplateList> dirs;
-    SharedPtr<TemplateList> files;
-    SharedPtr<TemplateList> classes;
-    SharedPtr<TemplateList> namespaces;
-    SharedPtr<TemplateList> constantgroups;
-    SharedPtr<TemplateList> examples;
-    SharedPtr<TemplateList> pages;
-    SharedPtr<MemberListInfoContext> macros;
-    SharedPtr<MemberListInfoContext> typedefs;
-    SharedPtr<MemberListInfoContext> enums;
-    SharedPtr<MemberListInfoContext> enumValues;
-    SharedPtr<MemberListInfoContext> functions;
-    SharedPtr<MemberListInfoContext> variables;
-    SharedPtr<MemberListInfoContext> signals;
-    SharedPtr<MemberListInfoContext> publicSlots;
-    SharedPtr<MemberListInfoContext> protectedSlots;
-    SharedPtr<MemberListInfoContext> privateSlots;
-    SharedPtr<MemberListInfoContext> events;
-    SharedPtr<MemberListInfoContext> properties;
-    SharedPtr<MemberListInfoContext> friends;
-    SharedPtr<MemberGroupListContext> memberGroups;
-    SharedPtr<MemberListInfoContext> detailedMacros;
-    SharedPtr<MemberListInfoContext> detailedTypedefs;
-    SharedPtr<MemberListInfoContext> detailedEnums;
-    SharedPtr<MemberListInfoContext> detailedEnumValues;
-    SharedPtr<MemberListInfoContext> detailedFunctions;
-    SharedPtr<MemberListInfoContext> detailedVariables;
-    SharedPtr<MemberListInfoContext> detailedSignals;
-    SharedPtr<MemberListInfoContext> detailedPublicSlots;
-    SharedPtr<MemberListInfoContext> detailedProtectedSlots;
-    SharedPtr<MemberListInfoContext> detailedPrivateSlots;
-    SharedPtr<MemberListInfoContext> detailedEvents;
-    SharedPtr<MemberListInfoContext> detailedProperties;
-    SharedPtr<MemberListInfoContext> detailedFriends;
-    SharedPtr<TemplateList> inlineClasses;
-    ScopedPtr<DotGroupCollaboration> groupGraph;
-  };
-  Cachable &getCache() const {
-    Cachable *c = static_cast<Cachable *>(m_groupDef->cookie());
-    assert(c != 0);
-    return *c;
-  }
-  static PropertyMapper<ModuleContext::Private> s_inst;
+    static PropertyMapper<ModuleContext::Private> s_inst;
 };
 //%% }
 
 PropertyMapper<ModuleContext::Private> ModuleContext::Private::s_inst;
 
-ModuleContext::ModuleContext(GroupDef *gd)
-    : RefCountedContext("ModuleContext") {
+ModuleContext::ModuleContext(GroupDef *gd) : RefCountedContext("ModuleContext")
+{
   p = new Private(gd);
 }
 
-ModuleContext::~ModuleContext() { delete p; }
+ModuleContext::~ModuleContext()
+{
+  delete p;
+}
 
-TemplateVariant ModuleContext::get(const char *n) const { return p->get(n); }
+TemplateVariant ModuleContext::get(const char *n) const
+{
+  return p->get(n);
+}
 
 //------------------------------------------------------------------------
 
 //%% list ClassList[Class] : list of classes
-class ClassListContext::Private : public GenericNodeListContext {
-public:
-  void addClasses(const ClassSDict &classSDict) {
-    ClassSDict::Iterator cli(classSDict);
-    ClassDef *cd;
-    for (cli.toFirst(); (cd = cli.current()); ++cli) {
-      if (cd->getLanguage() == SrcLangExt_VHDL &&
-          ((VhdlDocGen::VhdlClasses)cd->protection() ==
-               VhdlDocGen::PACKAGECLASS ||
-           (VhdlDocGen::VhdlClasses)cd->protection() ==
-               VhdlDocGen::PACKBODYCLASS)) // no architecture
+class ClassListContext::Private : public GenericNodeListContext
+{
+  public:
+    void addClasses(const ClassSDict &classSDict)
+    {
+      ClassSDict::Iterator cli(classSDict);
+      ClassDef *cd;
+      for (cli.toFirst() ; (cd=cli.current()) ; ++cli )
       {
-        continue;
-      }
-      if (cd->isLinkableInProject() && cd->templateMaster() == 0 &&
-          !cd->isHidden() && !cd->isEmbeddedInOuterScope()) {
-        append(ClassContext::alloc(cd));
+        if (cd->getLanguage()==SrcLangExt_VHDL &&
+            ((VhdlDocGen::VhdlClasses)cd->protection()==VhdlDocGen::PACKAGECLASS ||
+             (VhdlDocGen::VhdlClasses)cd->protection()==VhdlDocGen::PACKBODYCLASS)
+           ) // no architecture
+        {
+          continue;
+        }
+        if (cd->isLinkableInProject() && cd->templateMaster()==0 &&
+            !cd->isHidden() && !cd->isEmbeddedInOuterScope())
+        {
+          append(ClassContext::alloc(cd));
+        }
       }
     }
-  }
 };
 
-ClassListContext::ClassListContext() : RefCountedContext("ClassListContext") {
+ClassListContext::ClassListContext() : RefCountedContext("ClassListContext")
+{
   p = new Private;
   p->addClasses(*Doxygen::classSDict);
   p->addClasses(*Doxygen::hiddenClasses);
 }
 
-ClassListContext::~ClassListContext() { delete p; }
+ClassListContext::~ClassListContext()
+{
+  delete p;
+}
 
 // TemplateListIntf
-int ClassListContext::count() const { return p->count(); }
+int ClassListContext::count() const
+{
+  return p->count();
+}
 
-TemplateVariant ClassListContext::at(int index) const { return p->at(index); }
+TemplateVariant ClassListContext::at(int index) const
+{
+  return p->at(index);
+}
 
-TemplateListIntf::ConstIterator *ClassListContext::createIterator() const {
+TemplateListIntf::ConstIterator *ClassListContext::createIterator() const
+{
   return p->createIterator();
 }
 
 //------------------------------------------------------------------------
 
 //%% list ClassIndex[Class] : list of classes
-class ClassIndexContext::Private {
-public:
-  Private() {
-    static bool init = FALSE;
-    if (!init) {
-      s_inst.addProperty("list", &Private::list);
-      s_inst.addProperty("fileName", &Private::fileName);
-      s_inst.addProperty("relPath", &Private::relPath);
-      s_inst.addProperty("highlight", &Private::highlight);
-      s_inst.addProperty("subhighlight", &Private::subhighlight);
-      s_inst.addProperty("title", &Private::title);
-      init = TRUE;
+class ClassIndexContext::Private
+{
+  public:
+    Private()
+    {
+      static bool init=FALSE;
+      if (!init)
+      {
+        s_inst.addProperty("list",        &Private::list);
+        s_inst.addProperty("fileName",    &Private::fileName);
+        s_inst.addProperty("relPath",     &Private::relPath);
+        s_inst.addProperty("highlight",   &Private::highlight);
+        s_inst.addProperty("subhighlight",&Private::subhighlight);
+        s_inst.addProperty("title",       &Private::title);
+        init=TRUE;
+      }
     }
-  }
-  TemplateVariant get(const char *n) const { return s_inst.get(this, n); }
-  TemplateVariant list() const {
-    if (!m_cache.classes) {
-      TemplateList *classList = TemplateList::alloc();
-      if (Doxygen::classSDict) {
-        ClassSDict::Iterator cli(*Doxygen::classSDict);
-        ClassDef *cd;
-        for (cli.toFirst(); (cd = cli.current()); ++cli) {
-          if (cd->getLanguage() == SrcLangExt_VHDL &&
-              ((VhdlDocGen::VhdlClasses)cd->protection() ==
-                   VhdlDocGen::PACKAGECLASS ||
-               (VhdlDocGen::VhdlClasses)cd->protection() ==
-                   VhdlDocGen::PACKBODYCLASS)) // no architecture
+    TemplateVariant get(const char *n) const
+    {
+      return s_inst.get(this,n);
+    }
+    TemplateVariant list() const
+    {
+      if (!m_cache.classes)
+      {
+        TemplateList *classList = TemplateList::alloc();
+        if (Doxygen::classSDict)
+        {
+          ClassSDict::Iterator cli(*Doxygen::classSDict);
+          ClassDef *cd;
+          for (cli.toFirst() ; (cd=cli.current()) ; ++cli )
           {
-            continue;
-          }
-          if (cd->isLinkableInProject() && cd->templateMaster() == 0) {
-            classList->append(ClassContext::alloc(cd));
+            if (cd->getLanguage()==SrcLangExt_VHDL &&
+                ((VhdlDocGen::VhdlClasses)cd->protection()==VhdlDocGen::PACKAGECLASS ||
+                 (VhdlDocGen::VhdlClasses)cd->protection()==VhdlDocGen::PACKBODYCLASS)
+               ) // no architecture
+            {
+              continue;
+            }
+            if (cd->isLinkableInProject() && cd->templateMaster()==0)
+            {
+              classList->append(ClassContext::alloc(cd));
+            }
           }
         }
+        m_cache.classes.reset(classList);
       }
-      m_cache.classes.reset(classList);
+      return m_cache.classes.get();
     }
-    return m_cache.classes.get();
-  }
-  TemplateVariant fileName() const { return "classes"; }
-  TemplateVariant relPath() const { return ""; }
-  TemplateVariant highlight() const { return "classes"; }
-  TemplateVariant subhighlight() const { return "classindex"; }
-  TemplateVariant title() const {
-    static bool fortranOpt = Config_getBool(OPTIMIZE_FOR_FORTRAN);
-    static bool vhdlOpt = Config_getBool(OPTIMIZE_OUTPUT_VHDL);
-    if (fortranOpt) {
-      return theTranslator->trDataTypes();
-    } else if (vhdlOpt) {
-      return VhdlDocGen::trDesignUnits();
-    } else {
-      return theTranslator->trCompoundIndex();
+    TemplateVariant fileName() const
+    {
+      return "classes";
     }
-  }
-
-private:
-  struct Cachable {
-    SharedPtr<TemplateList> classes;
-  };
-  mutable Cachable m_cache;
-  static PropertyMapper<ClassIndexContext::Private> s_inst;
+    TemplateVariant relPath() const
+    {
+      return "";
+    }
+    TemplateVariant highlight() const
+    {
+      return "classes";
+    }
+    TemplateVariant subhighlight() const
+    {
+      return "classindex";
+    }
+    TemplateVariant title() const
+    {
+      static bool fortranOpt = Config_getBool(OPTIMIZE_FOR_FORTRAN);
+      static bool vhdlOpt    = Config_getBool(OPTIMIZE_OUTPUT_VHDL);
+      if (fortranOpt)
+      {
+        return theTranslator->trDataTypes();
+      }
+      else if (vhdlOpt)
+      {
+        return VhdlDocGen::trDesignUnits();
+      }
+      else
+      {
+        return theTranslator->trCompoundIndex();
+      }
+    }
+  private:
+    struct Cachable
+    {
+      SharedPtr<TemplateList> classes;
+    };
+    mutable Cachable m_cache;
+    static PropertyMapper<ClassIndexContext::Private> s_inst;
 };
 
 PropertyMapper<ClassIndexContext::Private> ClassIndexContext::Private::s_inst;
 
-ClassIndexContext::ClassIndexContext()
-    : RefCountedContext("ClassIndexContext") {
+ClassIndexContext::ClassIndexContext() : RefCountedContext("ClassIndexContext")
+{
   p = new Private;
-  // p->addClasses(*Doxygen::hiddenClasses);
+  //p->addClasses(*Doxygen::hiddenClasses);
 }
 
-ClassIndexContext::~ClassIndexContext() { delete p; }
+ClassIndexContext::~ClassIndexContext()
+{
+  delete p;
+}
 
 // TemplateStructIntf
-TemplateVariant ClassIndexContext::get(const char *n) const {
+TemplateVariant ClassIndexContext::get(const char *n) const
+{
   return p->get(n);
 }
 
 //------------------------------------------------------------------------
 
-static int computeMaxDepth(const TemplateListIntf *list) {
-  int maxDepth = 0;
-  if (list) {
+static int computeMaxDepth(const TemplateListIntf *list)
+{
+  int maxDepth=0;
+  if (list)
+  {
     TemplateListIntf::ConstIterator *it = list->createIterator();
     TemplateVariant v;
-    for (it->toFirst(); it->current(v); it->toNext()) {
+    for (it->toFirst();it->current(v);it->toNext())
+    {
       const TemplateStructIntf *s = v.toStruct();
       TemplateVariant child = s->get("children");
-      int d = computeMaxDepth(child.toList()) + 1;
-      if (d > maxDepth)
-        maxDepth = d;
+      int d = computeMaxDepth(child.toList())+1;
+      if (d>maxDepth) maxDepth=d;
     }
     delete it;
   }
   return maxDepth;
 }
 
-static int computeNumNodesAtLevel(const TemplateStructIntf *s, int level,
-                                  int maxLevel) {
-  int num = 0;
-  if (level < maxLevel) {
+static int computeNumNodesAtLevel(const TemplateStructIntf *s,int level,int maxLevel)
+{
+  int num=0;
+  if (level<maxLevel)
+  {
     num++;
     TemplateVariant child = s->get("children");
-    if (child.toList()) {
+    if (child.toList())
+    {
       TemplateListIntf::ConstIterator *it = child.toList()->createIterator();
       TemplateVariant v;
-      for (it->toFirst(); it->current(v); it->toNext()) {
-        num += computeNumNodesAtLevel(v.toStruct(), level + 1, maxLevel);
+      for (it->toFirst();it->current(v);it->toNext())
+      {
+        num+=computeNumNodesAtLevel(v.toStruct(),level+1,maxLevel);
+      }
+      delete it;
+    }
+  }
+  return num;
+}
+
+static int computePreferredDepth(const TemplateListIntf *list,int maxDepth)
+{
+  int preferredNumEntries = Config_getInt(HTML_INDEX_NUM_ENTRIES);
+  int preferredDepth=1;
+  if (preferredNumEntries>0)
+  {
+    int depth = maxDepth;
+    for (int i=1;i<=depth;i++)
+    {
+      int num=0;
+      TemplateListIntf::ConstIterator *it = list->createIterator();
+      TemplateVariant v;
+      for (it->toFirst();it->current(v);it->toNext())
+      {
+        num+=computeNumNodesAtLevel(v.toStruct(),0,i);
+      }
+      delete it;
+      if (num<=preferredNumEntries)
+      {
+        preferredDepth=i;
+      }
+      else
+      {
+        break;
+      }
+    }
+  }
+  return preferredDepth;
+}
+
+//------------------------------------------------------------------------
+
+//%% struct ClassHierarchy: inheritance tree
+//%% {
+class ClassHierarchyContext::Private
+{
+  public:
+    Private()
+    {
+      m_classTree.reset(NestingContext::alloc(0,0));
+      initClassHierarchy(Doxygen::classSDict);
+      initClassHierarchy(Doxygen::hiddenClasses);
+      m_classTree->addClassHierarchy(*Doxygen::classSDict,TRUE);
+      m_classTree->addClassHierarchy(*Doxygen::hiddenClasses,TRUE);
+      //%% ClassInheritance tree
+      static bool init=FALSE;
+      if (!init)
+      {
+        s_inst.addProperty("tree",            &Private::tree);
+        s_inst.addProperty("fileName",        &Private::fileName);
+        s_inst.addProperty("relPath",         &Private::relPath);
+        s_inst.addProperty("highlight",       &Private::highlight);
+        s_inst.addProperty("subhighlight",    &Private::subhighlight);
+        s_inst.addProperty("title",           &Private::title);
+        s_inst.addProperty("preferredDepth",  &Private::preferredDepth);
+        s_inst.addProperty("maxDepth",        &Private::maxDepth);
+        s_inst.addProperty("diagrams",        &Private::diagrams);
+        init=TRUE;
+      }
+    }
+    TemplateVariant get(const char *n) const
+    {
+      return s_inst.get(this,n);
+    }
+    TemplateVariant tree() const
+    {
+      return m_classTree.get();
+    }
+    TemplateVariant fileName() const
+    {
+      return "hierarchy";
+    }
+    TemplateVariant relPath() const
+    {
+      return "";
+    }
+    TemplateVariant highlight() const
+    {
+      return "classes";
+    }
+    TemplateVariant subhighlight() const
+    {
+      return "classhierarchy";
+    }
+    DotGfxHierarchyTable *getHierarchy() const
+    {
+      if (!m_cache.hierarchy)
+      {
+        m_cache.hierarchy.reset(new DotGfxHierarchyTable());
+      }
+      return m_cache.hierarchy.get();
+    }
+    TemplateVariant diagrams() const
+    {
+      if (!m_cache.diagrams)
+      {
+        TemplateList *diagrams = TemplateList::alloc();
+        DotGfxHierarchyTable *hierarchy = getHierarchy();
+        if (hierarchy->subGraphs())
+        {
+          int id=0;
+          QListIterator<DotNode> li(*hierarchy->subGraphs());
+          DotNode *n;
+          for (li.toFirst();(n=li.current());++li)
+          {
+            diagrams->append(InheritanceGraphContext::alloc(hierarchy,n,id++));
+          }
+        }
+        m_cache.diagrams.reset(diagrams);
+      }
+      return m_cache.diagrams.get();
+    }
+    TemplateVariant title() const
+    {
+      static bool vhdlOpt    = Config_getBool(OPTIMIZE_OUTPUT_VHDL);
+      if (vhdlOpt)
+      {
+        return VhdlDocGen::trDesignUnitHierarchy();
+      }
+      else
+      {
+        return theTranslator->trClassHierarchy();
+      }
+    }
+    TemplateVariant maxDepth() const
+    {
+      if (!m_cache.maxDepthComputed)
+      {
+        m_cache.maxDepth = computeMaxDepth(m_classTree.get());
+        m_cache.maxDepthComputed=TRUE;
+      }
+      return m_cache.maxDepth;
+    }
+    TemplateVariant preferredDepth() const
+    {
+      if (!m_cache.preferredDepthComputed)
+      {
+        m_cache.preferredDepth = computePreferredDepth(m_classTree.get(),maxDepth().toInt());
+        m_cache.preferredDepthComputed=TRUE;
+      }
+      return m_cache.preferredDepth;
+    }
+  private:
+    SharedPtr<NestingContext> m_classTree;
+    struct Cachable
+    {
+      Cachable() : maxDepth(0), maxDepthComputed(FALSE),
+                   preferredDepth(0), preferredDepthComputed(FALSE), hierarchy(0) {}
+      int   maxDepth;
+      bool  maxDepthComputed;
+      int   preferredDepth;
+      bool  preferredDepthComputed;
+      SharedPtr<TemplateList> diagrams;
+      ScopedPtr<DotGfxHierarchyTable> hierarchy;
+    };
+    mutable Cachable m_cache;
+    static PropertyMapper<ClassHierarchyContext::Private> s_inst;
+};
+//%% }
+
+PropertyMapper<ClassHierarchyContext::Private> ClassHierarchyContext::Private::s_inst;
+
+ClassHierarchyContext::ClassHierarchyContext() : RefCountedContext("ClassHierarchyContext")
+{
+  p = new Private;
+}
+
+ClassHierarchyContext::~ClassHierarchyContext()
+{
+  delete p;
+}
+
+TemplateVariant ClassHierarchyContext::get(const char *name) const
+{
+  return p->get(name);
+}
+
+//------------------------------------------------------------------------
+
+//%% struct NestingNode: node is a nesting relation tree
+//%% {
+class NestingNodeContext::Private
+{
+  public:
+    Private(const NestingNodeContext *parent,const NestingNodeContext *thisNode,
+        Definition *d,int index,int level,bool addCls,bool inherit, bool hideSuper)
+      : m_parent(parent), m_def(d), m_level(level), m_index(index)
+    {
+      m_children.reset(NestingContext::alloc(thisNode,level+1));
+      static bool init=FALSE;
+      if (!init)
+      {
+        //%% bool is_leaf_node: true if this node does not have any children
+        s_inst.addProperty("is_leaf_node",&Private::isLeafNode);
+        //%% Nesting children: list of nested classes/namespaces
+        s_inst.addProperty("children",&Private::children);
+        //%% [optional] Class class: class info (if this node represents a class)
+        s_inst.addProperty("class",&Private::getClass);
+        //%% [optional] Namespace namespace: namespace info (if this node represents a namespace)
+        s_inst.addProperty("namespace",&Private::getNamespace);
+        //%% [optional] File file: file info (if this node represents a file)
+        s_inst.addProperty("file",&Private::getFile);
+        //%% [optional] Dir dir: directory info (if this node represents a directory)
+        s_inst.addProperty("dir",&Private::getDir);
+        //%% [optional] Page page: page info (if this node represents a page)
+        s_inst.addProperty("page",&Private::getPage);
+        //%% [optional] Module module: module info (if this node represents a module)
+        s_inst.addProperty("module",&Private::getModule);
+        //%% int id
+        s_inst.addProperty("id",&Private::id);
+        //%% string level
+        s_inst.addProperty("level",&Private::level);
+        //%% string name
+        s_inst.addProperty("name",&Private::name);
+        //%% string brief
+        s_inst.addProperty("brief",&Private::brief);
+        //%% bool isLinkable
+        s_inst.addProperty("isLinkable",&Private::isLinkable);
+        s_inst.addProperty("anchor",&Private::anchor);
+        s_inst.addProperty("fileName",&Private::fileName);
+        s_inst.addProperty("isReference",&Private::isReference);
+        s_inst.addProperty("externalReference",&Private::externalReference);
+        init=TRUE;
+      }
+
+      addNamespaces(addCls);
+      addClasses(inherit,hideSuper);
+      addDirFiles();
+      addPages();
+      addModules();
+    }
+    TemplateVariant get(const char *n) const
+    {
+      return s_inst.get(this,n);
+    }
+    TemplateVariant isLeafNode() const
+    {
+      return m_children->count()==0;
+    }
+    TemplateVariant children() const
+    {
+      return m_children.get();
+    }
+    TemplateVariant getClass() const
+    {
+      if (!m_cache.classContext && m_def->definitionType()==Definition::TypeClass)
+      {
+        m_cache.classContext.reset(ClassContext::alloc((ClassDef*)m_def));
+      }
+      if (m_cache.classContext)
+      {
+        return m_cache.classContext.get();
+      }
+      else
+      {
+        return TemplateVariant(FALSE);
+      }
+    }
+    TemplateVariant getNamespace() const
+    {
+      if (!m_cache.namespaceContext && m_def->definitionType()==Definition::TypeNamespace)
+      {
+        m_cache.namespaceContext.reset(NamespaceContext::alloc((NamespaceDef*)m_def));
+      }
+      if (m_cache.namespaceContext)
+      {
+        return m_cache.namespaceContext.get();
+      }
+      else
+      {
+        return TemplateVariant(FALSE);
+      }
+    }
+    TemplateVariant getDir() const
+    {
+      if (!m_cache.dirContext && m_def->definitionType()==Definition::TypeDir)
+      {
+        m_cache.dirContext.reset(DirContext::alloc((DirDef*)m_def));
+      }
+      if (m_cache.dirContext)
+      {
+        return m_cache.dirContext.get();
+      }
+      else
+      {
+        return TemplateVariant(FALSE);
+      }
+    }
+    TemplateVariant getFile() const
+    {
+      if (!m_cache.fileContext && m_def->definitionType()==Definition::TypeFile)
+      {
+        m_cache.fileContext.reset(FileContext::alloc((FileDef*)m_def));
+      }
+      if (m_cache.fileContext)
+      {
+        return m_cache.fileContext.get();
+      }
+      else
+      {
+        return TemplateVariant(FALSE);
+      }
+    }
+    TemplateVariant getPage() const
+    {
+      if (!m_cache.pageContext && m_def->definitionType()==Definition::TypePage)
+      {
+        m_cache.pageContext.reset(PageContext::alloc((PageDef*)m_def,FALSE,FALSE));
+      }
+      if (m_cache.pageContext)
+      {
+        return m_cache.pageContext.get();
+      }
+      else
+      {
+        return TemplateVariant(FALSE);
       }
-      delete it;
     }
-  }
-  return num;
-}
-
-static int computePreferredDepth(const TemplateListIntf *list, int maxDepth) {
-  int preferredNumEntries = Config_getInt(HTML_INDEX_NUM_ENTRIES);
-  int preferredDepth = 1;
-  if (preferredNumEntries > 0) {
-    int depth = maxDepth;
-    for (int i = 1; i <= depth; i++) {
-      int num = 0;
-      TemplateListIntf::ConstIterator *it = list->createIterator();
-      TemplateVariant v;
-      for (it->toFirst(); it->current(v); it->toNext()) {
-        num += computeNumNodesAtLevel(v.toStruct(), 0, i);
+    TemplateVariant getModule() const
+    {
+      if (!m_cache.moduleContext && m_def->definitionType()==Definition::TypeGroup)
+      {
+        m_cache.moduleContext.reset(ModuleContext::alloc((GroupDef*)m_def));
       }
-      delete it;
-      if (num <= preferredNumEntries) {
-        preferredDepth = i;
-      } else {
-        break;
+      if (m_cache.moduleContext)
+      {
+        return m_cache.moduleContext.get();
       }
-    }
-  }
-  return preferredDepth;
-}
-
-//------------------------------------------------------------------------
-
-//%% struct ClassHierarchy: inheritance tree
-//%% {
-class ClassHierarchyContext::Private {
-public:
-  Private() {
-    m_classTree.reset(NestingContext::alloc(0, 0));
-    initClassHierarchy(Doxygen::classSDict);
-    initClassHierarchy(Doxygen::hiddenClasses);
-    m_classTree->addClassHierarchy(*Doxygen::classSDict, TRUE);
-    m_classTree->addClassHierarchy(*Doxygen::hiddenClasses, TRUE);
-    //%% ClassInheritance tree
-    static bool init = FALSE;
-    if (!init) {
-      s_inst.addProperty("tree", &Private::tree);
-      s_inst.addProperty("fileName", &Private::fileName);
-      s_inst.addProperty("relPath", &Private::relPath);
-      s_inst.addProperty("highlight", &Private::highlight);
-      s_inst.addProperty("subhighlight", &Private::subhighlight);
-      s_inst.addProperty("title", &Private::title);
-      s_inst.addProperty("preferredDepth", &Private::preferredDepth);
-      s_inst.addProperty("maxDepth", &Private::maxDepth);
-      s_inst.addProperty("diagrams", &Private::diagrams);
-      init = TRUE;
-    }
-  }
-  TemplateVariant get(const char *n) const { return s_inst.get(this, n); }
-  TemplateVariant tree() const { return m_classTree.get(); }
-  TemplateVariant fileName() const { return "hierarchy"; }
-  TemplateVariant relPath() const { return ""; }
-  TemplateVariant highlight() const { return "classes"; }
-  TemplateVariant subhighlight() const { return "classhierarchy"; }
-  DotGfxHierarchyTable *getHierarchy() const {
-    if (!m_cache.hierarchy) {
-      m_cache.hierarchy.reset(new DotGfxHierarchyTable());
-    }
-    return m_cache.hierarchy.get();
-  }
-  TemplateVariant diagrams() const {
-    if (!m_cache.diagrams) {
-      TemplateList *diagrams = TemplateList::alloc();
-      DotGfxHierarchyTable *hierarchy = getHierarchy();
-      if (hierarchy->subGraphs()) {
-        int id = 0;
-        QListIterator<DotNode> li(*hierarchy->subGraphs());
-        DotNode *n;
-        for (li.toFirst(); (n = li.current()); ++li) {
-          diagrams->append(InheritanceGraphContext::alloc(hierarchy, n, id++));
-        }
+      else
+      {
+        return TemplateVariant(FALSE);
       }
-      m_cache.diagrams.reset(diagrams);
-    }
-    return m_cache.diagrams.get();
-  }
-  TemplateVariant title() const {
-    static bool vhdlOpt = Config_getBool(OPTIMIZE_OUTPUT_VHDL);
-    if (vhdlOpt) {
-      return VhdlDocGen::trDesignUnitHierarchy();
-    } else {
-      return theTranslator->trClassHierarchy();
     }
-  }
-  TemplateVariant maxDepth() const {
-    if (!m_cache.maxDepthComputed) {
-      m_cache.maxDepth = computeMaxDepth(m_classTree.get());
-      m_cache.maxDepthComputed = TRUE;
+    TemplateVariant level() const
+    {
+      return m_level;
     }
-    return m_cache.maxDepth;
-  }
-  TemplateVariant preferredDepth() const {
-    if (!m_cache.preferredDepthComputed) {
-      m_cache.preferredDepth =
-          computePreferredDepth(m_classTree.get(), maxDepth().toInt());
-      m_cache.preferredDepthComputed = TRUE;
+    TemplateVariant id() const
+    {
+      QCString result;
+      if (m_parent) result=m_parent->id();
+      result+=QCString().setNum(m_index)+"_";
+      return result;
     }
-    return m_cache.preferredDepth;
-  }
-
-private:
-  SharedPtr<NestingContext> m_classTree;
-  struct Cachable {
-    Cachable()
-        : maxDepth(0), maxDepthComputed(FALSE), preferredDepth(0),
-          preferredDepthComputed(FALSE), hierarchy(0) {}
-    int maxDepth;
-    bool maxDepthComputed;
-    int preferredDepth;
-    bool preferredDepthComputed;
-    SharedPtr<TemplateList> diagrams;
-    ScopedPtr<DotGfxHierarchyTable> hierarchy;
-  };
-  mutable Cachable m_cache;
-  static PropertyMapper<ClassHierarchyContext::Private> s_inst;
-};
-//%% }
-
-PropertyMapper<ClassHierarchyContext::Private>
-    ClassHierarchyContext::Private::s_inst;
-
-ClassHierarchyContext::ClassHierarchyContext()
-    : RefCountedContext("ClassHierarchyContext") {
-  p = new Private;
-}
-
-ClassHierarchyContext::~ClassHierarchyContext() { delete p; }
-
-TemplateVariant ClassHierarchyContext::get(const char *name) const {
-  return p->get(name);
-}
-
-//------------------------------------------------------------------------
-
-//%% struct NestingNode: node is a nesting relation tree
-//%% {
-class NestingNodeContext::Private {
-public:
-  Private(const NestingNodeContext *parent, const NestingNodeContext *thisNode,
-          Definition *d, int index, int level, bool addCls, bool inherit,
-          bool hideSuper)
-      : m_parent(parent), m_def(d), m_level(level), m_index(index) {
-    m_children.reset(NestingContext::alloc(thisNode, level + 1));
-    static bool init = FALSE;
-    if (!init) {
-      //%% bool is_leaf_node: true if this node does not have any children
-      s_inst.addProperty("is_leaf_node", &Private::isLeafNode);
-      //%% Nesting children: list of nested classes/namespaces
-      s_inst.addProperty("children", &Private::children);
-      //%% [optional] Class class: class info (if this node represents a class)
-      s_inst.addProperty("class", &Private::getClass);
-      //%% [optional] Namespace namespace: namespace info (if this node
-      //represents a namespace)
-      s_inst.addProperty("namespace", &Private::getNamespace);
-      //%% [optional] File file: file info (if this node represents a file)
-      s_inst.addProperty("file", &Private::getFile);
-      //%% [optional] Dir dir: directory info (if this node represents a
-      //directory)
-      s_inst.addProperty("dir", &Private::getDir);
-      //%% [optional] Page page: page info (if this node represents a page)
-      s_inst.addProperty("page", &Private::getPage);
-      //%% [optional] Module module: module info (if this node represents a
-      //module)
-      s_inst.addProperty("module", &Private::getModule);
-      //%% int id
-      s_inst.addProperty("id", &Private::id);
-      //%% string level
-      s_inst.addProperty("level", &Private::level);
-      //%% string name
-      s_inst.addProperty("name", &Private::name);
-      //%% string brief
-      s_inst.addProperty("brief", &Private::brief);
-      //%% bool isLinkable
-      s_inst.addProperty("isLinkable", &Private::isLinkable);
-      s_inst.addProperty("anchor", &Private::anchor);
-      s_inst.addProperty("fileName", &Private::fileName);
-      s_inst.addProperty("isReference", &Private::isReference);
-      s_inst.addProperty("externalReference", &Private::externalReference);
-      init = TRUE;
-    }
-
-    addNamespaces(addCls);
-    addClasses(inherit, hideSuper);
-    addDirFiles();
-    addPages();
-    addModules();
-  }
-  TemplateVariant get(const char *n) const { return s_inst.get(this, n); }
-  TemplateVariant isLeafNode() const { return m_children->count() == 0; }
-  TemplateVariant children() const { return m_children.get(); }
-  TemplateVariant getClass() const {
-    if (!m_cache.classContext &&
-        m_def->definitionType() == Definition::TypeClass) {
-      m_cache.classContext.reset(ClassContext::alloc((ClassDef *)m_def));
-    }
-    if (m_cache.classContext) {
-      return m_cache.classContext.get();
-    } else {
-      return TemplateVariant(FALSE);
+    TemplateVariant name() const
+    {
+      return m_def->displayName(FALSE);
     }
-  }
-  TemplateVariant getNamespace() const {
-    if (!m_cache.namespaceContext &&
-        m_def->definitionType() == Definition::TypeNamespace) {
-      m_cache.namespaceContext.reset(
-          NamespaceContext::alloc((NamespaceDef *)m_def));
-    }
-    if (m_cache.namespaceContext) {
-      return m_cache.namespaceContext.get();
-    } else {
-      return TemplateVariant(FALSE);
+    QCString relPathAsString() const
+    {
+      static bool createSubdirs = Config_getBool(CREATE_SUBDIRS);
+      return createSubdirs ? QCString("../../") : QCString("");
     }
-  }
-  TemplateVariant getDir() const {
-    if (!m_cache.dirContext && m_def->definitionType() == Definition::TypeDir) {
-      m_cache.dirContext.reset(DirContext::alloc((DirDef *)m_def));
+    TemplateVariant brief() const
+    {
+      if (!m_cache.brief)
+      {
+        if (m_def->hasBriefDescription())
+        {
+          m_cache.brief.reset(new TemplateVariant(parseDoc(m_def,m_def->briefFile(),m_def->briefLine(),
+                              "",m_def->briefDescription(),TRUE)));
+        }
+        else
+        {
+          m_cache.brief.reset(new TemplateVariant(""));
+        }
+      }
+      return *m_cache.brief;
     }
-    if (m_cache.dirContext) {
-      return m_cache.dirContext.get();
-    } else {
-      return TemplateVariant(FALSE);
+    TemplateVariant isLinkable() const
+    {
+      return m_def->isLinkable();
     }
-  }
-  TemplateVariant getFile() const {
-    if (!m_cache.fileContext &&
-        m_def->definitionType() == Definition::TypeFile) {
-      m_cache.fileContext.reset(FileContext::alloc((FileDef *)m_def));
-    }
-    if (m_cache.fileContext) {
-      return m_cache.fileContext.get();
-    } else {
-      return TemplateVariant(FALSE);
+    TemplateVariant anchor() const
+    {
+      return m_def->anchor();
     }
-  }
-  TemplateVariant getPage() const {
-    if (!m_cache.pageContext &&
-        m_def->definitionType() == Definition::TypePage) {
-      m_cache.pageContext.reset(
-          PageContext::alloc((PageDef *)m_def, FALSE, FALSE));
-    }
-    if (m_cache.pageContext) {
-      return m_cache.pageContext.get();
-    } else {
-      return TemplateVariant(FALSE);
+    TemplateVariant fileName() const
+    {
+      return m_def->getOutputFileBase();
     }
-  }
-  TemplateVariant getModule() const {
-    if (!m_cache.moduleContext &&
-        m_def->definitionType() == Definition::TypeGroup) {
-      m_cache.moduleContext.reset(ModuleContext::alloc((GroupDef *)m_def));
-    }
-    if (m_cache.moduleContext) {
-      return m_cache.moduleContext.get();
-    } else {
-      return TemplateVariant(FALSE);
+    TemplateVariant isReference() const
+    {
+      return m_def->isReference();
     }
-  }
-  TemplateVariant level() const { return m_level; }
-  TemplateVariant id() const {
-    QCString result;
-    if (m_parent)
-      result = m_parent->id();
-    result += QCString().setNum(m_index) + "_";
-    return result;
-  }
-  TemplateVariant name() const { return m_def->displayName(FALSE); }
-  QCString relPathAsString() const {
-    static bool createSubdirs = Config_getBool(CREATE_SUBDIRS);
-    return createSubdirs ? QCString("../../") : QCString("");
-  }
-  TemplateVariant brief() const {
-    if (!m_cache.brief) {
-      if (m_def->hasBriefDescription()) {
-        m_cache.brief.reset(new TemplateVariant(
-            parseDoc(m_def, m_def->briefFile(), m_def->briefLine(), "",
-                     m_def->briefDescription(), TRUE)));
-      } else {
-        m_cache.brief.reset(new TemplateVariant(""));
-      }
+    TemplateVariant externalReference() const
+    {
+      return m_def->externalReference(relPathAsString());
     }
-    return *m_cache.brief;
-  }
-  TemplateVariant isLinkable() const { return m_def->isLinkable(); }
-  TemplateVariant anchor() const { return m_def->anchor(); }
-  TemplateVariant fileName() const { return m_def->getOutputFileBase(); }
-  TemplateVariant isReference() const { return m_def->isReference(); }
-  TemplateVariant externalReference() const {
-    return m_def->externalReference(relPathAsString());
-  }
 
-  //------------------------------------------------------------------
+    //------------------------------------------------------------------
 
-  void addClasses(bool inherit, bool hideSuper) {
-    ClassDef *cd = m_def->definitionType() == Definition::TypeClass
-                       ? (ClassDef *)m_def
-                       : 0;
-    if (cd && inherit) {
-      bool hasChildren =
-          !cd->visited && !hideSuper && classHasVisibleChildren(cd);
-      if (hasChildren) {
-        bool wasVisited = cd->visited;
-        cd->visited = TRUE;
-        if (cd->getLanguage() == SrcLangExt_VHDL) {
-          m_children->addDerivedClasses(cd->baseClasses(), wasVisited);
-        } else {
-          m_children->addDerivedClasses(cd->subClasses(), wasVisited);
+    void addClasses(bool inherit, bool hideSuper)
+    {
+      ClassDef *cd = m_def->definitionType()==Definition::TypeClass ? (ClassDef*)m_def : 0;
+      if (cd && inherit)
+      {
+        bool hasChildren = !cd->visited && !hideSuper && classHasVisibleChildren(cd);
+        if (hasChildren)
+        {
+          bool wasVisited=cd->visited;
+          cd->visited=TRUE;
+          if (cd->getLanguage()==SrcLangExt_VHDL)
+          {
+            m_children->addDerivedClasses(cd->baseClasses(),wasVisited);
+          }
+          else
+          {
+            m_children->addDerivedClasses(cd->subClasses(),wasVisited);
+          }
         }
       }
-    } else {
-      if (cd && cd->getClassSDict()) {
-        m_children->addClasses(*cd->getClassSDict(), FALSE);
+      else
+      {
+        if (cd && cd->getClassSDict())
+        {
+          m_children->addClasses(*cd->getClassSDict(),FALSE);
+        }
       }
     }
-  }
-  void addNamespaces(bool addClasses) {
-    NamespaceDef *nd = m_def->definitionType() == Definition::TypeNamespace
-                           ? (NamespaceDef *)m_def
-                           : 0;
-    if (nd && nd->getNamespaceSDict()) {
-      m_children->addNamespaces(*nd->getNamespaceSDict(), FALSE, addClasses);
-    }
-    if (addClasses && nd && nd->getClassSDict()) {
-      m_children->addClasses(*nd->getClassSDict(), FALSE);
+    void addNamespaces(bool addClasses)
+    {
+      NamespaceDef *nd = m_def->definitionType()==Definition::TypeNamespace ? (NamespaceDef*)m_def : 0;
+      if (nd && nd->getNamespaceSDict())
+      {
+        m_children->addNamespaces(*nd->getNamespaceSDict(),FALSE,addClasses);
+      }
+      if (addClasses && nd && nd->getClassSDict())
+      {
+        m_children->addClasses(*nd->getClassSDict(),FALSE);
+      }
     }
-  }
-  void addDirFiles() {
-    DirDef *dd =
-        m_def->definitionType() == Definition::TypeDir ? (DirDef *)m_def : 0;
-    if (dd) {
-      m_children->addDirs(dd->subDirs());
-      if (dd && dd->getFiles()) {
-        m_children->addFiles(*dd->getFiles());
+    void addDirFiles()
+    {
+      DirDef *dd = m_def->definitionType()==Definition::TypeDir ? (DirDef*)m_def : 0;
+      if (dd)
+      {
+        m_children->addDirs(dd->subDirs());
+        if (dd && dd->getFiles())
+        {
+          m_children->addFiles(*dd->getFiles());
+        }
       }
     }
-  }
-  void addPages() {
-    PageDef *pd =
-        m_def->definitionType() == Definition::TypePage ? (PageDef *)m_def : 0;
-    if (pd && pd->getSubPages()) {
-      m_children->addPages(*pd->getSubPages(), FALSE);
+    void addPages()
+    {
+      PageDef *pd = m_def->definitionType()==Definition::TypePage ? (PageDef*)m_def : 0;
+      if (pd && pd->getSubPages())
+      {
+        m_children->addPages(*pd->getSubPages(),FALSE);
+      }
     }
-  }
-  void addModules() {
-    GroupDef *gd = m_def->definitionType() == Definition::TypeGroup
-                       ? (GroupDef *)m_def
-                       : 0;
-    if (gd && gd->getSubGroups()) {
-      m_children->addModules(*gd->getSubGroups());
+    void addModules()
+    {
+      GroupDef *gd = m_def->definitionType()==Definition::TypeGroup ? (GroupDef*)m_def : 0;
+      if (gd && gd->getSubGroups())
+      {
+        m_children->addModules(*gd->getSubGroups());
+      }
     }
-  }
-
-private:
-  const NestingNodeContext *m_parent;
-  Definition *m_def;
-  SharedPtr<NestingContext> m_children;
-  int m_level;
-  int m_index;
-  struct Cachable {
-    SharedPtr<ClassContext> classContext;
-    SharedPtr<NamespaceContext> namespaceContext;
-    SharedPtr<DirContext> dirContext;
-    SharedPtr<FileContext> fileContext;
-    SharedPtr<PageContext> pageContext;
-    SharedPtr<ModuleContext> moduleContext;
-    ScopedPtr<TemplateVariant> brief;
-  };
-  mutable Cachable m_cache;
-  static PropertyMapper<NestingNodeContext::Private> s_inst;
+  private:
+    const NestingNodeContext *m_parent;
+    Definition *m_def;
+    SharedPtr<NestingContext> m_children;
+    int m_level;
+    int m_index;
+    struct Cachable
+    {
+      SharedPtr<ClassContext>     classContext;
+      SharedPtr<NamespaceContext> namespaceContext;
+      SharedPtr<DirContext>       dirContext;
+      SharedPtr<FileContext>      fileContext;
+      SharedPtr<PageContext>      pageContext;
+      SharedPtr<ModuleContext>    moduleContext;
+      ScopedPtr<TemplateVariant>  brief;
+    };
+    mutable Cachable m_cache;
+    static PropertyMapper<NestingNodeContext::Private> s_inst;
 };
 //%% }
 
 PropertyMapper<NestingNodeContext::Private> NestingNodeContext::Private::s_inst;
 
 NestingNodeContext::NestingNodeContext(const NestingNodeContext *parent,
-                                       Definition *d, int index, int level,
-                                       bool addClass, bool inherit,
-                                       bool hideSuper)
-    : RefCountedContext("NestingNodeContext") {
-  p = new Private(parent, this, d, index, level, addClass, inherit, hideSuper);
+                                       Definition *d,int index,int level,bool addClass,bool inherit,bool hideSuper)
+   : RefCountedContext("NestingNodeContext")
+{
+  p = new Private(parent,this,d,index,level,addClass,inherit,hideSuper);
 }
 
-NestingNodeContext::~NestingNodeContext() { delete p; }
+NestingNodeContext::~NestingNodeContext()
+{
+  delete p;
+}
 
-TemplateVariant NestingNodeContext::get(const char *n) const {
+TemplateVariant NestingNodeContext::get(const char *n) const
+{
   return p->get(n);
 }
 
-QCString NestingNodeContext::id() const { return p->id().toString(); }
+QCString NestingNodeContext::id() const
+{
+  return p->id().toString();
+}
 
 //------------------------------------------------------------------------
 
 //%% list Nesting[NestingNode]: namespace and class nesting relations
-class NestingContext::Private : public GenericNodeListContext {
-public:
-  Private(const NestingNodeContext *parent, int level)
+class NestingContext::Private : public GenericNodeListContext
+{
+  public:
+    Private(const NestingNodeContext *parent,int level)
       : m_parent(parent), m_level(level), m_index(0) {}
 
-  void addNamespaces(const NamespaceSDict &nsDict, bool rootOnly,
-                     bool addClasses) {
-    NamespaceSDict::Iterator nli(nsDict);
-    NamespaceDef *nd;
-    for (nli.toFirst(); (nd = nli.current()); ++nli) {
-      if (nd->localName().find('@') == -1 &&
-          (!rootOnly || nd->getOuterScope() == Doxygen::globalScope)) {
-        bool hasChildren = namespaceHasVisibleChild(nd, addClasses);
-        bool isLinkable = nd->isLinkableInProject();
-        if (isLinkable || hasChildren) {
-          NestingNodeContext *nnc = NestingNodeContext::alloc(
-              m_parent, nd, m_index, m_level, addClasses, FALSE, FALSE);
-          append(nnc);
-          m_index++;
+    void addNamespaces(const NamespaceSDict &nsDict,bool rootOnly,bool addClasses)
+    {
+      NamespaceSDict::Iterator nli(nsDict);
+      NamespaceDef *nd;
+      for (nli.toFirst();(nd=nli.current());++nli)
+      {
+        if (nd->localName().find('@')==-1 &&
+            (!rootOnly || nd->getOuterScope()==Doxygen::globalScope))
+        {
+          bool hasChildren = namespaceHasVisibleChild(nd,addClasses);
+          bool isLinkable  = nd->isLinkableInProject();
+          if (isLinkable || hasChildren)
+          {
+            NestingNodeContext *nnc = NestingNodeContext::alloc(m_parent,nd,m_index,m_level,addClasses,FALSE,FALSE);
+            append(nnc);
+            m_index++;
+          }
         }
       }
     }
-  }
-  void addClasses(const ClassSDict &clDict, bool rootOnly) {
-    ClassSDict::Iterator cli(clDict);
-    ClassDef *cd;
-    for (; (cd = cli.current()); ++cli) {
-      if (cd->getLanguage() == SrcLangExt_VHDL) {
-        if ((VhdlDocGen::VhdlClasses)cd->protection() ==
-                VhdlDocGen::PACKAGECLASS ||
-            (VhdlDocGen::VhdlClasses)cd->protection() ==
-                VhdlDocGen::PACKBODYCLASS) // no architecture
+    void addClasses(const ClassSDict &clDict,bool rootOnly)
+    {
+      ClassSDict::Iterator cli(clDict);
+      ClassDef *cd;
+      for (;(cd=cli.current());++cli)
+      {
+        if (cd->getLanguage()==SrcLangExt_VHDL)
         {
-          continue;
+          if ((VhdlDocGen::VhdlClasses)cd->protection()==VhdlDocGen::PACKAGECLASS ||
+              (VhdlDocGen::VhdlClasses)cd->protection()==VhdlDocGen::PACKBODYCLASS
+             )// no architecture
+          {
+            continue;
+          }
+        }
+        if (!rootOnly ||
+            cd->getOuterScope()==0 ||
+            cd->getOuterScope()==Doxygen::globalScope
+           )
+        {
+          if (classVisibleInIndex(cd) && cd->templateMaster()==0)
+          {
+            NestingNodeContext *nnc = NestingNodeContext::alloc(m_parent,cd,m_index,m_level,TRUE,FALSE,FALSE);
+            append(nnc);
+            m_index++;
+          }
         }
       }
-      if (!rootOnly || cd->getOuterScope() == 0 ||
-          cd->getOuterScope() == Doxygen::globalScope) {
-        if (classVisibleInIndex(cd) && cd->templateMaster() == 0) {
-          NestingNodeContext *nnc = NestingNodeContext::alloc(
-              m_parent, cd, m_index, m_level, TRUE, FALSE, FALSE);
-          append(nnc);
+    }
+    void addDirs(const DirSDict &dirDict)
+    {
+      SDict<DirDef>::Iterator dli(dirDict);
+      DirDef *dd;
+      for (dli.toFirst();(dd=dli.current());++dli)
+      {
+        if (dd->getOuterScope()==Doxygen::globalScope)
+        {
+          append(NestingNodeContext::alloc(m_parent,dd,m_index,m_level,FALSE,FALSE,FALSE));
           m_index++;
         }
       }
     }
-  }
-  void addDirs(const DirSDict &dirDict) {
-    SDict<DirDef>::Iterator dli(dirDict);
-    DirDef *dd;
-    for (dli.toFirst(); (dd = dli.current()); ++dli) {
-      if (dd->getOuterScope() == Doxygen::globalScope) {
-        append(NestingNodeContext::alloc(m_parent, dd, m_index, m_level, FALSE,
-                                         FALSE, FALSE));
+    void addDirs(const DirList &dirList)
+    {
+      QListIterator<DirDef> li(dirList);
+      DirDef *dd;
+      for (li.toFirst();(dd=li.current());++li)
+      {
+        append(NestingNodeContext::alloc(m_parent,dd,m_index,m_level,FALSE,FALSE,FALSE));
         m_index++;
       }
     }
-  }
-  void addDirs(const DirList &dirList) {
-    QListIterator<DirDef> li(dirList);
-    DirDef *dd;
-    for (li.toFirst(); (dd = li.current()); ++li) {
-      append(NestingNodeContext::alloc(m_parent, dd, m_index, m_level, FALSE,
-                                       FALSE, FALSE));
-      m_index++;
-    }
-  }
-  void addFiles(const FileNameList &fnList) {
-    FileNameListIterator fnli(fnList);
-    FileName *fn;
-    for (fnli.toFirst(); (fn = fnli.current()); ++fnli) {
-      FileNameIterator fni(*fn);
-      FileDef *fd;
-      for (; (fd = fni.current()); ++fni) {
-        if (fd->getDirDef() == 0) // top level file
+    void addFiles(const FileNameList &fnList)
+    {
+      FileNameListIterator fnli(fnList);
+      FileName *fn;
+      for (fnli.toFirst();(fn=fnli.current());++fnli)
+      {
+        FileNameIterator fni(*fn);
+        FileDef *fd;
+        for (;(fd=fni.current());++fni)
         {
-          append(NestingNodeContext::alloc(m_parent, fd, m_index, m_level,
-                                           FALSE, FALSE, FALSE));
-          m_index++;
+          if (fd->getDirDef()==0) // top level file
+          {
+            append(NestingNodeContext::alloc(m_parent,fd,m_index,m_level,FALSE,FALSE,FALSE));
+            m_index++;
+          }
         }
       }
     }
-  }
-  void addFiles(const FileList &fList) {
-    QListIterator<FileDef> li(fList);
-    FileDef *fd;
-    for (li.toFirst(); (fd = li.current()); ++li) {
-      append(NestingNodeContext::alloc(m_parent, fd, m_index, m_level, FALSE,
-                                       FALSE, FALSE));
-      m_index++;
-    }
-  }
-  void addPages(const PageSDict &pages, bool rootOnly) {
-    SDict<PageDef>::Iterator pli(pages);
-    PageDef *pd;
-    for (pli.toFirst(); (pd = pli.current()); ++pli) {
-      if (!rootOnly || pd->getOuterScope() == 0 ||
-          pd->getOuterScope()->definitionType() != Definition::TypePage) {
-        append(NestingNodeContext::alloc(m_parent, pd, m_index, m_level, FALSE,
-                                         FALSE, FALSE));
+    void addFiles(const FileList &fList)
+    {
+      QListIterator<FileDef> li(fList);
+      FileDef *fd;
+      for (li.toFirst();(fd=li.current());++li)
+      {
+        append(NestingNodeContext::alloc(m_parent,fd,m_index,m_level,FALSE,FALSE,FALSE));
         m_index++;
       }
     }
-  }
-  void addModules(const GroupSDict &groups) {
-    GroupSDict::Iterator gli(groups);
-    GroupDef *gd;
-    for (gli.toFirst(); (gd = gli.current()); ++gli) {
-      static bool externalGroups = Config_getBool(EXTERNAL_GROUPS);
-      if (!gd->isASubGroup() && gd->isVisible() &&
-          (!gd->isReference() || externalGroups)) {
-        append(NestingNodeContext::alloc(m_parent, gd, m_index, m_level, FALSE,
-                                         FALSE, FALSE));
-        m_index++;
+    void addPages(const PageSDict &pages,bool rootOnly)
+    {
+      SDict<PageDef>::Iterator pli(pages);
+      PageDef *pd;
+      for (pli.toFirst();(pd=pli.current());++pli)
+      {
+        if (!rootOnly ||
+            pd->getOuterScope()==0 ||
+            pd->getOuterScope()->definitionType()!=Definition::TypePage)
+        {
+          append(NestingNodeContext::alloc(m_parent,pd,m_index,m_level,FALSE,FALSE,FALSE));
+          m_index++;
+        }
       }
     }
-  }
-  void addModules(const GroupList &list) {
-    GroupListIterator gli(list);
-    GroupDef *gd;
-    for (gli.toFirst(); (gd = gli.current()); ++gli) {
-      if (gd->isVisible()) {
-        append(NestingNodeContext::alloc(m_parent, gd, m_index, m_level, FALSE,
-                                         FALSE, FALSE));
-        m_index++;
+    void addModules(const GroupSDict &groups)
+    {
+      GroupSDict::Iterator gli(groups);
+      GroupDef *gd;
+      for (gli.toFirst();(gd=gli.current());++gli)
+      {
+        static bool externalGroups = Config_getBool(EXTERNAL_GROUPS);
+        if (!gd->isASubGroup() && gd->isVisible() &&
+             (!gd->isReference() || externalGroups)
+           )
+        {
+          append(NestingNodeContext::alloc(m_parent,gd,m_index,m_level,FALSE,FALSE,FALSE));
+          m_index++;
+        }
       }
     }
-  }
-  void addDerivedClasses(const BaseClassList *bcl, bool hideSuper) {
-    if (bcl == 0)
-      return;
-    BaseClassListIterator bcli(*bcl);
-    BaseClassDef *bcd;
-    for (bcli.toFirst(); (bcd = bcli.current()); ++bcli) {
-      ClassDef *cd = bcd->classDef;
-      if (cd->getLanguage() == SrcLangExt_VHDL &&
-          (VhdlDocGen::VhdlClasses)cd->protection() !=
-              VhdlDocGen::ENTITYCLASS) {
-        continue;
+    void addModules(const GroupList &list)
+    {
+      GroupListIterator gli(list);
+      GroupDef *gd;
+      for (gli.toFirst();(gd=gli.current());++gli)
+      {
+        if (gd->isVisible())
+        {
+          append(NestingNodeContext::alloc(m_parent,gd,m_index,m_level,FALSE,FALSE,FALSE));
+          m_index++;
+        }
       }
+    }
+    void addDerivedClasses(const BaseClassList *bcl,bool hideSuper)
+    {
+      if (bcl==0) return;
+      BaseClassListIterator bcli(*bcl);
+      BaseClassDef *bcd;
+      for (bcli.toFirst() ; (bcd=bcli.current()) ; ++bcli)
+      {
+        ClassDef *cd=bcd->classDef;
+        if (cd->getLanguage()==SrcLangExt_VHDL && (VhdlDocGen::VhdlClasses)cd->protection()!=VhdlDocGen::ENTITYCLASS)
+        {
+          continue;
+        }
 
-      bool b;
-      if (cd->getLanguage() == SrcLangExt_VHDL) {
-        b = hasVisibleRoot(cd->subClasses());
-      } else {
-        b = hasVisibleRoot(cd->baseClasses());
-      }
+        bool b;
+        if (cd->getLanguage()==SrcLangExt_VHDL)
+        {
+          b=hasVisibleRoot(cd->subClasses());
+        }
+        else
+        {
+          b=hasVisibleRoot(cd->baseClasses());
+        }
 
-      if (cd->isVisibleInHierarchy() && b) {
-        NestingNodeContext *tnc = NestingNodeContext::alloc(
-            m_parent, cd, m_index, m_level, TRUE, TRUE, hideSuper);
-        append(tnc);
-        m_index++;
+        if (cd->isVisibleInHierarchy() && b)
+        {
+          NestingNodeContext *tnc = NestingNodeContext::alloc(m_parent,cd,m_index,m_level,TRUE,TRUE,hideSuper);
+          append(tnc);
+          m_index++;
+        }
       }
     }
-  }
-  void addClassHierarchy(const ClassSDict &classSDict, bool) {
-    ClassSDict::Iterator cli(classSDict);
-    ClassDef *cd;
-    for (cli.toFirst(); (cd = cli.current()); ++cli) {
-      bool b;
-      if (cd->getLanguage() == SrcLangExt_VHDL) {
-        if ((VhdlDocGen::VhdlClasses)cd->protection() !=
-            VhdlDocGen::ENTITYCLASS) {
-          continue;
+    void addClassHierarchy(const ClassSDict &classSDict,bool)
+    {
+      ClassSDict::Iterator cli(classSDict);
+      ClassDef *cd;
+      for (cli.toFirst();(cd=cli.current());++cli)
+      {
+        bool b;
+        if (cd->getLanguage()==SrcLangExt_VHDL)
+        {
+          if ((VhdlDocGen::VhdlClasses)cd->protection()!=VhdlDocGen::ENTITYCLASS)
+          {
+            continue;
+          }
+          b=!hasVisibleRoot(cd->subClasses());
         }
-        b = !hasVisibleRoot(cd->subClasses());
-      } else {
-        b = !hasVisibleRoot(cd->baseClasses());
-      }
-      if (b) {
-        if (cd->isVisibleInHierarchy()) // should it be visible
+        else
         {
-          // new root level class
-          NestingNodeContext *nnc = NestingNodeContext::alloc(
-              m_parent, cd, m_index, m_level, TRUE, TRUE, cd->visited);
-          append(nnc);
-          m_index++;
+          b=!hasVisibleRoot(cd->baseClasses());
+        }
+        if (b)
+        {
+          if (cd->isVisibleInHierarchy()) // should it be visible
+          {
+            // new root level class
+            NestingNodeContext *nnc = NestingNodeContext::alloc(m_parent,cd,m_index,m_level,TRUE,TRUE,cd->visited);
+            append(nnc);
+            m_index++;
+          }
         }
       }
     }
-  }
 
-private:
-  const NestingNodeContext *m_parent;
-  int m_level;
-  int m_index;
+  private:
+    const NestingNodeContext *m_parent;
+    int m_level;
+    int m_index;
 };
 
-NestingContext::NestingContext(const NestingNodeContext *parent, int level)
-    : RefCountedContext("NestingContext") {
-  p = new Private(parent, level);
+NestingContext::NestingContext(const NestingNodeContext *parent,int level) : RefCountedContext("NestingContext")
+{
+  p = new Private(parent,level);
 }
 
-NestingContext::~NestingContext() { delete p; }
+NestingContext::~NestingContext()
+{
+  delete p;
+}
 
 // TemplateListIntf
-int NestingContext::count() const { return p->count(); }
+int NestingContext::count() const
+{
+  return p->count();
+}
 
-TemplateVariant NestingContext::at(int index) const { return p->at(index); }
+TemplateVariant NestingContext::at(int index) const
+{
+  return p->at(index);
+}
 
-TemplateListIntf::ConstIterator *NestingContext::createIterator() const {
+TemplateListIntf::ConstIterator *NestingContext::createIterator() const
+{
   return p->createIterator();
 }
 
-void NestingContext::addClasses(const ClassSDict &clDict, bool rootOnly) {
-  p->addClasses(clDict, rootOnly);
+void NestingContext::addClasses(const ClassSDict &clDict,bool rootOnly)
+{
+  p->addClasses(clDict,rootOnly);
 }
 
-void NestingContext::addNamespaces(const NamespaceSDict &nsDict, bool rootOnly,
-                                   bool addClasses) {
-  p->addNamespaces(nsDict, rootOnly, addClasses);
+void NestingContext::addNamespaces(const NamespaceSDict &nsDict,bool rootOnly,bool addClasses)
+{
+  p->addNamespaces(nsDict,rootOnly,addClasses);
 }
 
-void NestingContext::addDirs(const DirSDict &dirs) { p->addDirs(dirs); }
+void NestingContext::addDirs(const DirSDict &dirs)
+{
+  p->addDirs(dirs);
+}
 
-void NestingContext::addDirs(const DirList &dirs) { p->addDirs(dirs); }
+void NestingContext::addDirs(const DirList &dirs)
+{
+  p->addDirs(dirs);
+}
 
-void NestingContext::addFiles(const FileNameList &files) { p->addFiles(files); }
+void NestingContext::addFiles(const FileNameList &files)
+{
+  p->addFiles(files);
+}
 
-void NestingContext::addFiles(const FileList &files) { p->addFiles(files); }
+void NestingContext::addFiles(const FileList &files)
+{
+  p->addFiles(files);
+}
 
-void NestingContext::addPages(const PageSDict &pages, bool rootOnly) {
-  p->addPages(pages, rootOnly);
+void NestingContext::addPages(const PageSDict &pages,bool rootOnly)
+{
+  p->addPages(pages,rootOnly);
 }
 
-void NestingContext::addModules(const GroupSDict &modules) {
+void NestingContext::addModules(const GroupSDict &modules)
+{
   p->addModules(modules);
 }
 
-void NestingContext::addModules(const GroupList &modules) {
+void NestingContext::addModules(const GroupList &modules)
+{
   p->addModules(modules);
 }
 
-void NestingContext::addClassHierarchy(const ClassSDict &classSDict,
-                                       bool rootOnly) {
-  p->addClassHierarchy(classSDict, rootOnly);
+void NestingContext::addClassHierarchy(const ClassSDict &classSDict,bool rootOnly)
+{
+  p->addClassHierarchy(classSDict,rootOnly);
 }
 
-void NestingContext::addDerivedClasses(const BaseClassList *bcl,
-                                       bool hideSuper) {
-  p->addDerivedClasses(bcl, hideSuper);
+void NestingContext::addDerivedClasses(const BaseClassList *bcl,bool hideSuper)
+{
+  p->addDerivedClasses(bcl,hideSuper);
 }
 
 //------------------------------------------------------------------------
 
 //%% struct ClassTree: Class nesting relations
 //%% {
-class ClassTreeContext::Private {
-public:
-  Private() {
-    m_classTree.reset(NestingContext::alloc(0, 0));
-    if (Doxygen::namespaceSDict) {
-      m_classTree->addNamespaces(*Doxygen::namespaceSDict, TRUE, TRUE);
-    }
-    if (Doxygen::classSDict) {
-      m_classTree->addClasses(*Doxygen::classSDict, TRUE);
-    }
-    //%% Nesting tree
-    static bool init = FALSE;
-    if (!init) {
-      s_inst.addProperty("tree", &Private::tree);
-      s_inst.addProperty("fileName", &Private::fileName);
-      s_inst.addProperty("relPath", &Private::relPath);
-      s_inst.addProperty("highlight", &Private::highlight);
-      s_inst.addProperty("subhighlight", &Private::subhighlight);
-      s_inst.addProperty("title", &Private::title);
-      s_inst.addProperty("preferredDepth", &Private::preferredDepth);
-      s_inst.addProperty("maxDepth", &Private::maxDepth);
-      init = TRUE;
+class ClassTreeContext::Private
+{
+  public:
+    Private()
+    {
+      m_classTree.reset(NestingContext::alloc(0,0));
+      if (Doxygen::namespaceSDict)
+      {
+        m_classTree->addNamespaces(*Doxygen::namespaceSDict,TRUE,TRUE);
+      }
+      if (Doxygen::classSDict)
+      {
+        m_classTree->addClasses(*Doxygen::classSDict,TRUE);
+      }
+      //%% Nesting tree
+      static bool init=FALSE;
+      if (!init)
+      {
+        s_inst.addProperty("tree",          &Private::tree);
+        s_inst.addProperty("fileName",      &Private::fileName);
+        s_inst.addProperty("relPath",       &Private::relPath);
+        s_inst.addProperty("highlight",     &Private::highlight);
+        s_inst.addProperty("subhighlight",  &Private::subhighlight);
+        s_inst.addProperty("title",         &Private::title);
+        s_inst.addProperty("preferredDepth",&Private::preferredDepth);
+        s_inst.addProperty("maxDepth",      &Private::maxDepth);
+        init=TRUE;
+      }
     }
-  }
-  TemplateVariant get(const char *n) const { return s_inst.get(this, n); }
-  TemplateVariant tree() const { return m_classTree.get(); }
-  TemplateVariant fileName() const { return "annotated"; }
-  TemplateVariant relPath() const { return ""; }
-  TemplateVariant highlight() const { return "classes"; }
-  TemplateVariant subhighlight() const { return "classlist"; }
-  TemplateVariant title() const {
-    static bool fortranOpt = Config_getBool(OPTIMIZE_FOR_FORTRAN);
-    static bool vhdlOpt = Config_getBool(OPTIMIZE_OUTPUT_VHDL);
-    if (fortranOpt) {
-      return theTranslator->trCompoundListFortran();
-    } else if (vhdlOpt) {
-      return VhdlDocGen::trDesignUnitList();
-    } else {
-      return theTranslator->trClasses();
+    TemplateVariant get(const char *n) const
+    {
+      return s_inst.get(this,n);
     }
-  }
-  TemplateVariant maxDepth() const {
-    if (!m_cache.maxDepthComputed) {
-      m_cache.maxDepth = computeMaxDepth(m_classTree.get());
-      m_cache.maxDepthComputed = TRUE;
+    TemplateVariant tree() const
+    {
+      return m_classTree.get();
     }
-    return m_cache.maxDepth;
-  }
-  TemplateVariant preferredDepth() const {
-    if (!m_cache.preferredDepthComputed) {
-      m_cache.preferredDepth =
-          computePreferredDepth(m_classTree.get(), maxDepth().toInt());
-      m_cache.preferredDepthComputed = TRUE;
+    TemplateVariant fileName() const
+    {
+      return "annotated";
     }
-    return m_cache.preferredDepth;
-  }
-
-private:
-  SharedPtr<NestingContext> m_classTree;
-  struct Cachable {
-    Cachable()
-        : maxDepth(0), maxDepthComputed(FALSE), preferredDepth(0),
-          preferredDepthComputed(FALSE) {}
-    int maxDepth;
-    bool maxDepthComputed;
-    int preferredDepth;
-    bool preferredDepthComputed;
-  };
-  mutable Cachable m_cache;
-  static PropertyMapper<ClassTreeContext::Private> s_inst;
+    TemplateVariant relPath() const
+    {
+      return "";
+    }
+    TemplateVariant highlight() const
+    {
+      return "classes";
+    }
+    TemplateVariant subhighlight() const
+    {
+      return "classlist";
+    }
+    TemplateVariant title() const
+    {
+      static bool fortranOpt = Config_getBool(OPTIMIZE_FOR_FORTRAN);
+      static bool vhdlOpt    = Config_getBool(OPTIMIZE_OUTPUT_VHDL);
+      if (fortranOpt)
+      {
+        return theTranslator->trCompoundListFortran();
+      }
+      else if (vhdlOpt)
+      {
+        return VhdlDocGen::trDesignUnitList();
+      }
+      else
+      {
+        return theTranslator->trClasses();
+      }
+    }
+    TemplateVariant maxDepth() const
+    {
+      if (!m_cache.maxDepthComputed)
+      {
+        m_cache.maxDepth = computeMaxDepth(m_classTree.get());
+        m_cache.maxDepthComputed=TRUE;
+      }
+      return m_cache.maxDepth;
+    }
+    TemplateVariant preferredDepth() const
+    {
+      if (!m_cache.preferredDepthComputed)
+      {
+        m_cache.preferredDepth = computePreferredDepth(m_classTree.get(),maxDepth().toInt());
+        m_cache.preferredDepthComputed=TRUE;
+      }
+      return m_cache.preferredDepth;
+    }
+  private:
+    SharedPtr<NestingContext> m_classTree;
+    struct Cachable
+    {
+      Cachable() : maxDepth(0), maxDepthComputed(FALSE),
+                   preferredDepth(0), preferredDepthComputed(FALSE) {}
+      int   maxDepth;
+      bool  maxDepthComputed;
+      int   preferredDepth;
+      bool  preferredDepthComputed;
+    };
+    mutable Cachable m_cache;
+    static PropertyMapper<ClassTreeContext::Private> s_inst;
 };
 //%% }
 
 PropertyMapper<ClassTreeContext::Private> ClassTreeContext::Private::s_inst;
 
-ClassTreeContext::ClassTreeContext() : RefCountedContext("ClassTreeContext") {
+ClassTreeContext::ClassTreeContext() : RefCountedContext("ClassTreeContext")
+{
   p = new Private;
 }
 
-ClassTreeContext::~ClassTreeContext() { delete p; }
+ClassTreeContext::~ClassTreeContext()
+{
+  delete p;
+}
 
-TemplateVariant ClassTreeContext::get(const char *name) const {
+TemplateVariant ClassTreeContext::get(const char *name) const
+{
   return p->get(name);
 }
 
 //------------------------------------------------------------------------
 
 //%% list NamespaceList[Namespace] : list of namespaces
-class NamespaceListContext::Private : public GenericNodeListContext {
-public:
-  void addNamespaces(const NamespaceSDict &nsDict) {
-    NamespaceSDict::Iterator nli(nsDict);
-    NamespaceDef *nd;
-    for (nli.toFirst(); (nd = nli.current()); ++nli) {
-      if (nd->isLinkableInProject()) {
-        append(NamespaceContext::alloc(nd));
+class NamespaceListContext::Private : public GenericNodeListContext
+{
+  public:
+    void addNamespaces(const NamespaceSDict &nsDict)
+    {
+      NamespaceSDict::Iterator nli(nsDict);
+      NamespaceDef *nd;
+      for (nli.toFirst();(nd=nli.current());++nli)
+      {
+        if (nd->isLinkableInProject())
+        {
+          append(NamespaceContext::alloc(nd));
+        }
       }
     }
-  }
 };
 
-NamespaceListContext::NamespaceListContext()
-    : RefCountedContext("NamespaceListContext") {
+NamespaceListContext::NamespaceListContext() : RefCountedContext("NamespaceListContext")
+{
   p = new Private;
   p->addNamespaces(*Doxygen::namespaceSDict);
 }
 
-NamespaceListContext::~NamespaceListContext() { delete p; }
+NamespaceListContext::~NamespaceListContext()
+{
+  delete p;
+}
 
 // TemplateListIntf
-int NamespaceListContext::count() const { return p->count(); }
+int NamespaceListContext::count() const
+{
+  return p->count();
+}
 
-TemplateVariant NamespaceListContext::at(int index) const {
+TemplateVariant NamespaceListContext::at(int index) const
+{
   return p->at(index);
 }
 
-TemplateListIntf::ConstIterator *NamespaceListContext::createIterator() const {
+TemplateListIntf::ConstIterator *NamespaceListContext::createIterator() const
+{
   return p->createIterator();
 }
 
@@ -7734,269 +6889,385 @@ TemplateListIntf::ConstIterator *NamespaceListContext::createIterator() const {
 
 //%% struct NamespaceTree: tree of nested namespace
 //%% {
-class NamespaceTreeContext::Private {
-public:
-  Private() {
-    m_namespaceTree.reset(NestingContext::alloc(0, 0));
-    if (Doxygen::namespaceSDict) {
-      m_namespaceTree->addNamespaces(*Doxygen::namespaceSDict, TRUE, FALSE);
-    }
-    //%% Nesting tree
-    static bool init = FALSE;
-    if (!init) {
-      s_inst.addProperty("tree", &Private::tree);
-      s_inst.addProperty("fileName", &Private::fileName);
-      s_inst.addProperty("relPath", &Private::relPath);
-      s_inst.addProperty("highlight", &Private::highlight);
-      s_inst.addProperty("subhighlight", &Private::subhighlight);
-      s_inst.addProperty("title", &Private::title);
-      s_inst.addProperty("preferredDepth", &Private::preferredDepth);
-      s_inst.addProperty("maxDepth", &Private::maxDepth);
-      init = TRUE;
+class NamespaceTreeContext::Private
+{
+  public:
+    Private()
+    {
+      m_namespaceTree.reset(NestingContext::alloc(0,0));
+      if (Doxygen::namespaceSDict)
+      {
+        m_namespaceTree->addNamespaces(*Doxygen::namespaceSDict,TRUE,FALSE);
+      }
+      //%% Nesting tree
+      static bool init=FALSE;
+      if (!init)
+      {
+        s_inst.addProperty("tree",          &Private::tree);
+        s_inst.addProperty("fileName",      &Private::fileName);
+        s_inst.addProperty("relPath",       &Private::relPath);
+        s_inst.addProperty("highlight",     &Private::highlight);
+        s_inst.addProperty("subhighlight",  &Private::subhighlight);
+        s_inst.addProperty("title",         &Private::title);
+        s_inst.addProperty("preferredDepth",&Private::preferredDepth);
+        s_inst.addProperty("maxDepth",      &Private::maxDepth);
+        init=TRUE;
+      }
     }
-  }
-  TemplateVariant get(const char *n) const { return s_inst.get(this, n); }
-  TemplateVariant tree() const { return m_namespaceTree.get(); }
-  TemplateVariant fileName() const { return "namespaces"; }
-  TemplateVariant relPath() const { return ""; }
-  TemplateVariant highlight() const { return "namespaces"; }
-  TemplateVariant subhighlight() const { return "namespacelist"; }
-  TemplateVariant title() const {
-    static bool javaOpt = Config_getBool(OPTIMIZE_OUTPUT_JAVA);
-    static bool fortranOpt = Config_getBool(OPTIMIZE_FOR_FORTRAN);
-    static bool vhdlOpt = Config_getBool(OPTIMIZE_OUTPUT_VHDL);
-    if (javaOpt || vhdlOpt) {
-      return theTranslator->trPackages();
-    } else if (fortranOpt) {
-      return theTranslator->trModulesList();
-    } else {
-      return theTranslator->trNamespaceList();
+    TemplateVariant get(const char *n) const
+    {
+      return s_inst.get(this,n);
     }
-  }
-  TemplateVariant maxDepth() const {
-    if (!m_cache.maxDepthComputed) {
-      m_cache.maxDepth = computeMaxDepth(m_namespaceTree.get());
-      m_cache.maxDepthComputed = TRUE;
+    TemplateVariant tree() const
+    {
+      return m_namespaceTree.get();
     }
-    return m_cache.maxDepth;
-  }
-  TemplateVariant preferredDepth() const {
-    if (!m_cache.preferredDepthComputed) {
-      m_cache.preferredDepth =
-          computePreferredDepth(m_namespaceTree.get(), maxDepth().toInt());
-      m_cache.preferredDepthComputed = TRUE;
+    TemplateVariant fileName() const
+    {
+      return "namespaces";
     }
-    return m_cache.preferredDepth;
-  }
-
-private:
-  SharedPtr<NestingContext> m_namespaceTree;
-  struct Cachable {
-    Cachable() : maxDepthComputed(FALSE), preferredDepthComputed(FALSE) {}
-    int maxDepth;
-    bool maxDepthComputed;
-    int preferredDepth;
-    bool preferredDepthComputed;
-  };
-  mutable Cachable m_cache;
-  static PropertyMapper<NamespaceTreeContext::Private> s_inst;
+    TemplateVariant relPath() const
+    {
+      return "";
+    }
+    TemplateVariant highlight() const
+    {
+      return "namespaces";
+    }
+    TemplateVariant subhighlight() const
+    {
+      return "namespacelist";
+    }
+    TemplateVariant title() const
+    {
+      static bool javaOpt    = Config_getBool(OPTIMIZE_OUTPUT_JAVA);
+      static bool fortranOpt = Config_getBool(OPTIMIZE_FOR_FORTRAN);
+      static bool vhdlOpt    = Config_getBool(OPTIMIZE_OUTPUT_VHDL);
+      if (javaOpt || vhdlOpt)
+      {
+        return theTranslator->trPackages();
+      }
+      else if (fortranOpt)
+      {
+        return theTranslator->trModulesList();
+      }
+      else
+      {
+        return theTranslator->trNamespaceList();
+      }
+    }
+    TemplateVariant maxDepth() const
+    {
+      if (!m_cache.maxDepthComputed)
+      {
+        m_cache.maxDepth = computeMaxDepth(m_namespaceTree.get());
+        m_cache.maxDepthComputed=TRUE;
+      }
+      return m_cache.maxDepth;
+    }
+    TemplateVariant preferredDepth() const
+    {
+      if (!m_cache.preferredDepthComputed)
+      {
+        m_cache.preferredDepth = computePreferredDepth(m_namespaceTree.get(),maxDepth().toInt());
+        m_cache.preferredDepthComputed=TRUE;
+      }
+      return m_cache.preferredDepth;
+    }
+  private:
+    SharedPtr<NestingContext> m_namespaceTree;
+    struct Cachable
+    {
+      Cachable() : maxDepthComputed(FALSE), preferredDepthComputed(FALSE) {}
+      int   maxDepth;
+      bool  maxDepthComputed;
+      int   preferredDepth;
+      bool  preferredDepthComputed;
+    };
+    mutable Cachable m_cache;
+    static PropertyMapper<NamespaceTreeContext::Private> s_inst;
 };
 //%% }
 
-PropertyMapper<NamespaceTreeContext::Private>
-    NamespaceTreeContext::Private::s_inst;
+PropertyMapper<NamespaceTreeContext::Private> NamespaceTreeContext::Private::s_inst;
 
-NamespaceTreeContext::NamespaceTreeContext()
-    : RefCountedContext("NamespaceTreeContext") {
+NamespaceTreeContext::NamespaceTreeContext() : RefCountedContext("NamespaceTreeContext")
+{
   p = new Private;
 }
 
-NamespaceTreeContext::~NamespaceTreeContext() { delete p; }
+NamespaceTreeContext::~NamespaceTreeContext()
+{
+  delete p;
+}
 
-TemplateVariant NamespaceTreeContext::get(const char *name) const {
+TemplateVariant NamespaceTreeContext::get(const char *name) const
+{
   return p->get(name);
 }
 
 //------------------------------------------------------------------------
 
 //%% list FileList[File] : list of files
-class FileListContext::Private : public GenericNodeListContext {
-public:
-  void addFiles(const FileNameList &fnList) {
-    // TODO: if FULL_PATH_NAMES is enabled, the ordering should be dir+file
-    FileNameListIterator fnli(fnList);
-    FileName *fn;
-    for (fnli.toFirst(); (fn = fnli.current()); ++fnli) {
-      FileNameIterator fni(*fn);
-      FileDef *fd;
-      for (fni.toFirst(); (fd = fni.current()); ++fni) {
-        bool doc = fd->isLinkableInProject();
-        bool src = fd->generateSourceFile();
-        bool nameOk = !fd->isDocumentationFile();
-        if (nameOk && (doc || src) && !fd->isReference()) {
-          append(FileContext::alloc(fd));
+class FileListContext::Private : public GenericNodeListContext
+{
+  public:
+    void addFiles(const FileNameList &fnList)
+    {
+      // TODO: if FULL_PATH_NAMES is enabled, the ordering should be dir+file
+      FileNameListIterator fnli(fnList);
+      FileName *fn;
+      for (fnli.toFirst();(fn=fnli.current());++fnli)
+      {
+        FileNameIterator fni(*fn);
+        FileDef *fd;
+        for (fni.toFirst();(fd=fni.current());++fni)
+        {
+          bool doc = fd->isLinkableInProject();
+          bool src = fd->generateSourceFile();
+          bool nameOk = !fd->isDocumentationFile();
+          if (nameOk && (doc || src) && !fd->isReference())
+          {
+            append(FileContext::alloc(fd));
+          }
         }
       }
     }
-  }
 };
 
-FileListContext::FileListContext() : RefCountedContext("FileListContext") {
+FileListContext::FileListContext() : RefCountedContext("FileListContext")
+{
   p = new Private;
-  if (Doxygen::inputNameList)
-    p->addFiles(*Doxygen::inputNameList);
+  if (Doxygen::inputNameList) p->addFiles(*Doxygen::inputNameList);
 }
 
-FileListContext::~FileListContext() { delete p; }
+FileListContext::~FileListContext()
+{
+  delete p;
+}
 
 // TemplateListIntf
-int FileListContext::count() const { return p->count(); }
+int FileListContext::count() const
+{
+  return p->count();
+}
 
-TemplateVariant FileListContext::at(int index) const { return p->at(index); }
+TemplateVariant FileListContext::at(int index) const
+{
+  return p->at(index);
+}
 
-TemplateListIntf::ConstIterator *FileListContext::createIterator() const {
+TemplateListIntf::ConstIterator *FileListContext::createIterator() const
+{
   return p->createIterator();
 }
 
 //------------------------------------------------------------------------
 
 //%% list DirList[Dir] : list of files
-class DirListContext::Private : public GenericNodeListContext {
-public:
-  Private() {
-    DirDef *dir;
-    DirSDict::Iterator sdi(*Doxygen::directories);
-    for (sdi.toFirst(); (dir = sdi.current()); ++sdi) {
-      append(DirContext::alloc(dir));
+class DirListContext::Private : public GenericNodeListContext
+{
+  public:
+    Private()
+    {
+      DirDef *dir;
+      DirSDict::Iterator sdi(*Doxygen::directories);
+      for (sdi.toFirst();(dir=sdi.current());++sdi)
+      {
+        append(DirContext::alloc(dir));
+      }
     }
-  }
 };
 
-DirListContext::DirListContext() : RefCountedContext("DirListContext") {
+DirListContext::DirListContext() : RefCountedContext("DirListContext")
+{
   p = new Private;
 }
 
-DirListContext::~DirListContext() { delete p; }
+DirListContext::~DirListContext()
+{
+  delete p;
+}
 
 // TemplateListIntf
-int DirListContext::count() const { return p->count(); }
+int DirListContext::count() const
+{
+  return p->count();
+}
 
-TemplateVariant DirListContext::at(int index) const { return p->at(index); }
+TemplateVariant DirListContext::at(int index) const
+{
+  return p->at(index);
+}
 
-TemplateListIntf::ConstIterator *DirListContext::createIterator() const {
+TemplateListIntf::ConstIterator *DirListContext::createIterator() const
+{
   return p->createIterator();
 }
 
+
 //------------------------------------------------------------------------
 
 //%% list UsedFiles[File] : list of files
-class UsedFilesContext::Private : public GenericNodeListContext {
-public:
-  void addFile(FileDef *fd) { append(FileContext::alloc(fd)); }
+class UsedFilesContext::Private : public GenericNodeListContext
+{
+  public:
+    void addFile(FileDef *fd)
+    {
+      append(FileContext::alloc(fd));
+    }
 };
 
-UsedFilesContext::UsedFilesContext(ClassDef *cd)
-    : RefCountedContext("UsedFilesContext") {
+UsedFilesContext::UsedFilesContext(ClassDef *cd) : RefCountedContext("UsedFilesContext")
+{
   p = new Private;
-  if (cd) {
+  if (cd)
+  {
     QListIterator<FileDef> li(cd->usedFiles());
     FileDef *fd;
-    for (li.toFirst(); (fd = li.current()); ++li) {
+    for (li.toFirst();(fd=li.current());++li)
+    {
       p->addFile(fd);
     }
   }
 }
 
-UsedFilesContext::~UsedFilesContext() { delete p; }
+UsedFilesContext::~UsedFilesContext()
+{
+  delete p;
+}
 
 // TemplateListIntf
-int UsedFilesContext::count() const { return p->count(); }
+int UsedFilesContext::count() const
+{
+  return p->count();
+}
 
-TemplateVariant UsedFilesContext::at(int index) const { return p->at(index); }
+TemplateVariant UsedFilesContext::at(int index) const
+{
+  return p->at(index);
+}
 
-TemplateListIntf::ConstIterator *UsedFilesContext::createIterator() const {
+TemplateListIntf::ConstIterator *UsedFilesContext::createIterator() const
+{
   return p->createIterator();
 }
 
-void UsedFilesContext::addFile(FileDef *fd) { p->addFile(fd); }
+void UsedFilesContext::addFile(FileDef *fd)
+{
+  p->addFile(fd);
+}
 
 //------------------------------------------------------------------------
 
 //%% struct FileTree: tree of directories and files
 //%% {
-class FileTreeContext::Private {
-public:
-  Private() {
-    // Add dirs tree
-    m_dirFileTree.reset(NestingContext::alloc(0, 0));
-    if (Doxygen::directories) {
-      m_dirFileTree->addDirs(*Doxygen::directories);
-    }
-    if (Doxygen::inputNameList) {
-      m_dirFileTree->addFiles(*Doxygen::inputNameList);
-    }
-    //%% DirFile tree:
-    static bool init = FALSE;
-    if (!init) {
-      s_inst.addProperty("tree", &Private::tree);
-      s_inst.addProperty("fileName", &Private::fileName);
-      s_inst.addProperty("relPath", &Private::relPath);
-      s_inst.addProperty("highlight", &Private::highlight);
-      s_inst.addProperty("subhighlight", &Private::subhighlight);
-      s_inst.addProperty("title", &Private::title);
-      s_inst.addProperty("preferredDepth", &Private::preferredDepth);
-      s_inst.addProperty("maxDepth", &Private::maxDepth);
-      init = TRUE;
+class FileTreeContext::Private
+{
+  public:
+    Private()
+    {
+      // Add dirs tree
+      m_dirFileTree.reset(NestingContext::alloc(0,0));
+      if (Doxygen::directories)
+      {
+        m_dirFileTree->addDirs(*Doxygen::directories);
+      }
+      if (Doxygen::inputNameList)
+      {
+        m_dirFileTree->addFiles(*Doxygen::inputNameList);
+      }
+      //%% DirFile tree:
+      static bool init=FALSE;
+      if (!init)
+      {
+        s_inst.addProperty("tree",          &Private::tree);
+        s_inst.addProperty("fileName",      &Private::fileName);
+        s_inst.addProperty("relPath",       &Private::relPath);
+        s_inst.addProperty("highlight",     &Private::highlight);
+        s_inst.addProperty("subhighlight",  &Private::subhighlight);
+        s_inst.addProperty("title",         &Private::title);
+        s_inst.addProperty("preferredDepth",&Private::preferredDepth);
+        s_inst.addProperty("maxDepth",      &Private::maxDepth);
+        init=TRUE;
+      }
     }
-  }
-  TemplateVariant get(const char *n) const { return s_inst.get(this, n); }
-  TemplateVariant tree() const { return m_dirFileTree.get(); }
-  TemplateVariant fileName() const { return "files"; }
-  TemplateVariant relPath() const { return ""; }
-  TemplateVariant highlight() const { return "files"; }
-  TemplateVariant subhighlight() const { return "filelist"; }
-  TemplateVariant title() const { return theTranslator->trFileList(); }
-  TemplateVariant maxDepth() const {
-    if (!m_cache.maxDepthComputed) {
-      m_cache.maxDepth = computeMaxDepth(m_dirFileTree.get());
-      m_cache.maxDepthComputed = TRUE;
-    }
-    return m_cache.maxDepth;
-  }
-  TemplateVariant preferredDepth() const {
-    if (!m_cache.preferredDepthComputed) {
-      m_cache.preferredDepth =
-          computePreferredDepth(m_dirFileTree.get(), maxDepth().toInt());
-      m_cache.preferredDepthComputed = TRUE;
+    TemplateVariant get(const char *n) const
+    {
+      return s_inst.get(this,n);
+    }
+    TemplateVariant tree() const
+    {
+      return m_dirFileTree.get();
+    }
+    TemplateVariant fileName() const
+    {
+      return "files";
+    }
+    TemplateVariant relPath() const
+    {
+      return "";
+    }
+    TemplateVariant highlight() const
+    {
+      return "files";
+    }
+    TemplateVariant subhighlight() const
+    {
+      return "filelist";
+    }
+    TemplateVariant title() const
+    {
+      return theTranslator->trFileList();
+    }
+    TemplateVariant maxDepth() const
+    {
+      if (!m_cache.maxDepthComputed)
+      {
+        m_cache.maxDepth = computeMaxDepth(m_dirFileTree.get());
+        m_cache.maxDepthComputed=TRUE;
+      }
+      return m_cache.maxDepth;
+    }
+    TemplateVariant preferredDepth() const
+    {
+      if (!m_cache.preferredDepthComputed)
+      {
+        m_cache.preferredDepth = computePreferredDepth(m_dirFileTree.get(),maxDepth().toInt());
+        m_cache.preferredDepthComputed=TRUE;
+      }
+      return m_cache.preferredDepth;
     }
-    return m_cache.preferredDepth;
-  }
-
-private:
-  SharedPtr<NestingContext> m_dirFileTree;
-  struct Cachable {
-    Cachable()
-        : maxDepth(0), maxDepthComputed(FALSE), preferredDepth(0),
-          preferredDepthComputed(FALSE) {}
-    int maxDepth;
-    bool maxDepthComputed;
-    int preferredDepth;
-    bool preferredDepthComputed;
-  };
-  mutable Cachable m_cache;
-  static PropertyMapper<FileTreeContext::Private> s_inst;
+  private:
+    SharedPtr<NestingContext> m_dirFileTree;
+    struct Cachable
+    {
+      Cachable() : maxDepth(0), maxDepthComputed(FALSE),
+                   preferredDepth(0), preferredDepthComputed(FALSE) {}
+      int   maxDepth;
+      bool  maxDepthComputed;
+      int   preferredDepth;
+      bool  preferredDepthComputed;
+    };
+    mutable Cachable m_cache;
+    static PropertyMapper<FileTreeContext::Private> s_inst;
 };
 //%% }
 
 PropertyMapper<FileTreeContext::Private> FileTreeContext::Private::s_inst;
 
-FileTreeContext::FileTreeContext() : RefCountedContext("FileTreeContext") {
+FileTreeContext::FileTreeContext() : RefCountedContext("FileTreeContext")
+{
   p = new Private;
 }
 
-FileTreeContext::~FileTreeContext() { delete p; }
+FileTreeContext::~FileTreeContext()
+{
+  delete p;
+}
 
-TemplateVariant FileTreeContext::get(const char *name) const {
+TemplateVariant FileTreeContext::get(const char *name) const
+{
   return p->get(name);
 }
 
@@ -8004,177 +7275,251 @@ TemplateVariant FileTreeContext::get(const char *name) const {
 
 //%% struct PageTree: tree of related pages
 //%% {
-class PageTreeContext::Private {
-public:
-  Private(const PageSDict *pages) {
-    m_pageTree.reset(NestingContext::alloc(0, 0));
-    // Add pages
-    if (pages) {
-      m_pageTree->addPages(*pages, TRUE);
-    }
-
-    //%% PageNodeList tree:
-    static bool init = FALSE;
-    if (!init) {
-      s_inst.addProperty("tree", &Private::tree);
-      s_inst.addProperty("fileName", &Private::fileName);
-      s_inst.addProperty("relPath", &Private::relPath);
-      s_inst.addProperty("highlight", &Private::highlight);
-      s_inst.addProperty("subhighlight", &Private::subhighlight);
-      s_inst.addProperty("title", &Private::title);
-      s_inst.addProperty("preferredDepth", &Private::preferredDepth);
-      s_inst.addProperty("maxDepth", &Private::maxDepth);
-      init = TRUE;
+class PageTreeContext::Private
+{
+  public:
+    Private(const PageSDict *pages)
+    {
+      m_pageTree.reset(NestingContext::alloc(0,0));
+      // Add pages
+      if (pages)
+      {
+        m_pageTree->addPages(*pages,TRUE);
+      }
+
+      //%% PageNodeList tree:
+      static bool init=FALSE;
+      if (!init)
+      {
+        s_inst.addProperty("tree",          &Private::tree);
+        s_inst.addProperty("fileName",      &Private::fileName);
+        s_inst.addProperty("relPath",       &Private::relPath);
+        s_inst.addProperty("highlight",     &Private::highlight);
+        s_inst.addProperty("subhighlight",  &Private::subhighlight);
+        s_inst.addProperty("title",         &Private::title);
+        s_inst.addProperty("preferredDepth",&Private::preferredDepth);
+        s_inst.addProperty("maxDepth",      &Private::maxDepth);
+        init=TRUE;
+      }
     }
-  }
-  TemplateVariant get(const char *n) const { return s_inst.get(this, n); }
-  TemplateVariant tree() const { return m_pageTree.get(); }
-  TemplateVariant fileName() const { return "pages"; }
-  TemplateVariant relPath() const { return ""; }
-  TemplateVariant highlight() const { return "pages"; }
-  TemplateVariant subhighlight() const { return ""; }
-  TemplateVariant title() const { return theTranslator->trRelatedPages(); }
-  TemplateVariant maxDepth() const {
-    if (!m_cache.maxDepthComputed) {
-      m_cache.maxDepth = computeMaxDepth(m_pageTree.get());
-      m_cache.maxDepthComputed = TRUE;
-    }
-    return m_cache.maxDepth;
-  }
-  TemplateVariant preferredDepth() const {
-    if (!m_cache.preferredDepthComputed) {
-      m_cache.preferredDepth =
-          computePreferredDepth(m_pageTree.get(), maxDepth().toInt());
-      m_cache.preferredDepthComputed = TRUE;
+    TemplateVariant get(const char *n) const
+    {
+      return s_inst.get(this,n);
     }
-    return m_cache.preferredDepth;
-  }
-
-private:
-  SharedPtr<NestingContext> m_pageTree;
-  struct Cachable {
-    Cachable() : maxDepthComputed(FALSE), preferredDepthComputed(FALSE) {}
-    int maxDepth;
-    bool maxDepthComputed;
-    int preferredDepth;
-    bool preferredDepthComputed;
-  };
-  mutable Cachable m_cache;
-  static PropertyMapper<PageTreeContext::Private> s_inst;
+    TemplateVariant tree() const
+    {
+      return m_pageTree.get();
+    }
+    TemplateVariant fileName() const
+    {
+      return "pages";
+    }
+    TemplateVariant relPath() const
+    {
+      return "";
+    }
+    TemplateVariant highlight() const
+    {
+      return "pages";
+    }
+    TemplateVariant subhighlight() const
+    {
+      return "";
+    }
+    TemplateVariant title() const
+    {
+      return theTranslator->trRelatedPages();
+    }
+    TemplateVariant maxDepth() const
+    {
+      if (!m_cache.maxDepthComputed)
+      {
+        m_cache.maxDepth = computeMaxDepth(m_pageTree.get());
+        m_cache.maxDepthComputed=TRUE;
+      }
+      return m_cache.maxDepth;
+    }
+    TemplateVariant preferredDepth() const
+    {
+      if (!m_cache.preferredDepthComputed)
+      {
+        m_cache.preferredDepth = computePreferredDepth(m_pageTree.get(),maxDepth().toInt());
+        m_cache.preferredDepthComputed=TRUE;
+      }
+      return m_cache.preferredDepth;
+    }
+  private:
+    SharedPtr<NestingContext> m_pageTree;
+    struct Cachable
+    {
+      Cachable() : maxDepthComputed(FALSE), preferredDepthComputed(FALSE) {}
+      int   maxDepth;
+      bool  maxDepthComputed;
+      int   preferredDepth;
+      bool  preferredDepthComputed;
+    };
+    mutable Cachable m_cache;
+    static PropertyMapper<PageTreeContext::Private> s_inst;
 };
 //%% }
 
 PropertyMapper<PageTreeContext::Private> PageTreeContext::Private::s_inst;
 
-PageTreeContext::PageTreeContext(const PageSDict *pages)
-    : RefCountedContext("PageTreeContext") {
+PageTreeContext::PageTreeContext(const PageSDict *pages) : RefCountedContext("PageTreeContext")
+{
   p = new Private(pages);
 }
 
-PageTreeContext::~PageTreeContext() { delete p; }
+PageTreeContext::~PageTreeContext()
+{
+  delete p;
+}
 
-TemplateVariant PageTreeContext::get(const char *name) const {
+TemplateVariant PageTreeContext::get(const char *name) const
+{
   return p->get(name);
 }
 
 //------------------------------------------------------------------------
 
 //%% list PageList[Page]: list of pages
-class PageListContext::Private : public GenericNodeListContext {
-public:
-  void addPages(const PageSDict &pages) {
-    PageSDict::Iterator pdi(pages);
-    PageDef *pd = 0;
-    for (pdi.toFirst(); (pd = pdi.current()); ++pdi) {
-      if (!pd->getGroupDef() && !pd->isReference()) {
-        append(PageContext::alloc(pd, FALSE, FALSE));
+class PageListContext::Private : public GenericNodeListContext
+{
+  public:
+    void addPages(const PageSDict &pages)
+    {
+      PageSDict::Iterator pdi(pages);
+      PageDef *pd=0;
+      for (pdi.toFirst();(pd=pdi.current());++pdi)
+      {
+        if (!pd->getGroupDef() && !pd->isReference())
+        {
+          append(PageContext::alloc(pd,FALSE,FALSE));
+        }
       }
     }
-  }
 };
 
-PageListContext::PageListContext(const PageSDict *pages)
-    : RefCountedContext("PageListContext") {
+PageListContext::PageListContext(const PageSDict *pages) : RefCountedContext("PageListContext")
+{
   p = new Private;
-  if (pages)
-    p->addPages(*pages);
+  if (pages) p->addPages(*pages);
 }
 
-PageListContext::~PageListContext() { delete p; }
+PageListContext::~PageListContext()
+{
+  delete p;
+}
 
 // TemplateListIntf
-int PageListContext::count() const { return p->count(); }
+int PageListContext::count() const
+{
+  return p->count();
+}
 
-TemplateVariant PageListContext::at(int index) const { return p->at(index); }
+TemplateVariant PageListContext::at(int index) const
+{
+  return p->at(index);
+}
 
-TemplateListIntf::ConstIterator *PageListContext::createIterator() const {
+TemplateListIntf::ConstIterator *PageListContext::createIterator() const
+{
   return p->createIterator();
 }
 
 //------------------------------------------------------------------------
 
 //%% list ExampleList[Page]: list of pages
-class ExampleListContext::Private : public GenericNodeListContext {
-public:
-  Private() {
-    if (Doxygen::exampleSDict) {
-      PageSDict::Iterator pdi(*Doxygen::exampleSDict);
-      PageDef *pd = 0;
-      for (pdi.toFirst(); (pd = pdi.current()); ++pdi) {
-        if (!pd->getGroupDef() && !pd->isReference()) {
-          append(PageContext::alloc(pd, FALSE, TRUE));
+class ExampleListContext::Private : public GenericNodeListContext
+{
+  public:
+    Private()
+    {
+      if (Doxygen::exampleSDict)
+      {
+        PageSDict::Iterator pdi(*Doxygen::exampleSDict);
+        PageDef *pd=0;
+        for (pdi.toFirst();(pd=pdi.current());++pdi)
+        {
+          if (!pd->getGroupDef() && !pd->isReference())
+          {
+            append(PageContext::alloc(pd,FALSE,TRUE));
+          }
         }
       }
     }
-  }
 };
 
-ExampleListContext::ExampleListContext()
-    : RefCountedContext("ExampleListContext") {
+ExampleListContext::ExampleListContext() : RefCountedContext("ExampleListContext")
+{
   p = new Private;
 }
 
-ExampleListContext::~ExampleListContext() { delete p; }
+ExampleListContext::~ExampleListContext()
+{
+  delete p;
+}
 
 // TemplateListIntf
-int ExampleListContext::count() const { return p->count(); }
+int ExampleListContext::count() const
+{
+  return p->count();
+}
 
-TemplateVariant ExampleListContext::at(int index) const { return p->at(index); }
+TemplateVariant ExampleListContext::at(int index) const
+{
+  return p->at(index);
+}
 
-TemplateListIntf::ConstIterator *ExampleListContext::createIterator() const {
+TemplateListIntf::ConstIterator *ExampleListContext::createIterator() const
+{
   return p->createIterator();
 }
 
 //------------------------------------------------------------------------
 
 //%% list ModuleList[ModuleNode]: list of directories and/or files
-class ModuleListContext::Private : public GenericNodeListContext {
-public:
-  void addModules() {
-    GroupSDict::Iterator gli(*Doxygen::groupSDict);
-    GroupDef *gd;
-    for (gli.toFirst(); (gd = gli.current()); ++gli) {
-      if (!gd->isReference()) {
-        append(ModuleContext::alloc(gd));
+class ModuleListContext::Private : public GenericNodeListContext
+{
+  public:
+    void addModules()
+    {
+      GroupSDict::Iterator gli(*Doxygen::groupSDict);
+      GroupDef *gd;
+      for (gli.toFirst();(gd=gli.current());++gli)
+      {
+        if (!gd->isReference())
+        {
+          append(ModuleContext::alloc(gd));
+        }
       }
     }
-  }
 };
 
-ModuleListContext::ModuleListContext()
-    : RefCountedContext("ModuleListContext") {
+ModuleListContext::ModuleListContext() : RefCountedContext("ModuleListContext")
+{
   p = new Private;
   p->addModules();
 }
 
-ModuleListContext::~ModuleListContext() { delete p; }
+ModuleListContext::~ModuleListContext()
+{
+  delete p;
+}
 
 // TemplateListIntf
-int ModuleListContext::count() const { return p->count(); }
+int ModuleListContext::count() const
+{
+  return p->count();
+}
 
-TemplateVariant ModuleListContext::at(int index) const { return p->at(index); }
+TemplateVariant ModuleListContext::at(int index) const
+{
+  return p->at(index);
+}
 
-TemplateListIntf::ConstIterator *ModuleListContext::createIterator() const {
+TemplateListIntf::ConstIterator *ModuleListContext::createIterator() const
+{
   return p->createIterator();
 }
 
@@ -8182,76 +7527,108 @@ TemplateListIntf::ConstIterator *ModuleListContext::createIterator() const {
 
 //%% struct ModuleTree: tree of modules
 //%% {
-class ModuleTreeContext::Private {
-public:
-  Private() {
-    m_moduleTree.reset(NestingContext::alloc(0, 0));
-    // Add modules
-    if (Doxygen::groupSDict) {
-      m_moduleTree->addModules(*Doxygen::groupSDict);
-    }
-
-    //%% ModuleList tree:
-    static bool init = FALSE;
-    if (!init) {
-      s_inst.addProperty("tree", &Private::tree);
-      s_inst.addProperty("fileName", &Private::fileName);
-      s_inst.addProperty("relPath", &Private::relPath);
-      s_inst.addProperty("highlight", &Private::highlight);
-      s_inst.addProperty("subhighlight", &Private::subhighlight);
-      s_inst.addProperty("title", &Private::title);
-      s_inst.addProperty("preferredDepth", &Private::preferredDepth);
-      s_inst.addProperty("maxDepth", &Private::maxDepth);
-      init = TRUE;
+class ModuleTreeContext::Private
+{
+  public:
+    Private()
+    {
+      m_moduleTree.reset(NestingContext::alloc(0,0));
+      // Add modules
+      if (Doxygen::groupSDict)
+      {
+        m_moduleTree->addModules(*Doxygen::groupSDict);
+      }
+
+      //%% ModuleList tree:
+      static bool init=FALSE;
+      if (!init)
+      {
+        s_inst.addProperty("tree",          &Private::tree);
+        s_inst.addProperty("fileName",      &Private::fileName);
+        s_inst.addProperty("relPath",       &Private::relPath);
+        s_inst.addProperty("highlight",     &Private::highlight);
+        s_inst.addProperty("subhighlight",  &Private::subhighlight);
+        s_inst.addProperty("title",         &Private::title);
+        s_inst.addProperty("preferredDepth",&Private::preferredDepth);
+        s_inst.addProperty("maxDepth",      &Private::maxDepth);
+        init=TRUE;
+      }
     }
-  }
-  TemplateVariant get(const char *n) const { return s_inst.get(this, n); }
-  TemplateVariant tree() const { return m_moduleTree.get(); }
-  TemplateVariant fileName() const { return "modules"; }
-  TemplateVariant relPath() const { return ""; }
-  TemplateVariant highlight() const { return "modules"; }
-  TemplateVariant subhighlight() const { return ""; }
-  TemplateVariant title() const { return theTranslator->trModules(); }
-  TemplateVariant maxDepth() const {
-    if (!m_cache.maxDepthComputed) {
-      m_cache.maxDepth = computeMaxDepth(m_moduleTree.get());
-      m_cache.maxDepthComputed = TRUE;
-    }
-    return m_cache.maxDepth;
-  }
-  TemplateVariant preferredDepth() const {
-    if (!m_cache.preferredDepthComputed) {
-      m_cache.preferredDepth =
-          computePreferredDepth(m_moduleTree.get(), maxDepth().toInt());
-      m_cache.preferredDepthComputed = TRUE;
+    TemplateVariant get(const char *n) const
+    {
+      return s_inst.get(this,n);
     }
-    return m_cache.preferredDepth;
-  }
-
-private:
-  SharedPtr<NestingContext> m_moduleTree;
-  struct Cachable {
-    Cachable() : maxDepthComputed(FALSE), preferredDepthComputed(FALSE) {}
-    int maxDepth;
-    bool maxDepthComputed;
-    int preferredDepth;
-    bool preferredDepthComputed;
-  };
-  mutable Cachable m_cache;
-  static PropertyMapper<ModuleTreeContext::Private> s_inst;
+    TemplateVariant tree() const
+    {
+      return m_moduleTree.get();
+    }
+    TemplateVariant fileName() const
+    {
+      return "modules";
+    }
+    TemplateVariant relPath() const
+    {
+      return "";
+    }
+    TemplateVariant highlight() const
+    {
+      return "modules";
+    }
+    TemplateVariant subhighlight() const
+    {
+      return "";
+    }
+    TemplateVariant title() const
+    {
+      return theTranslator->trModules();
+    }
+    TemplateVariant maxDepth() const
+    {
+      if (!m_cache.maxDepthComputed)
+      {
+        m_cache.maxDepth = computeMaxDepth(m_moduleTree.get());
+        m_cache.maxDepthComputed=TRUE;
+      }
+      return m_cache.maxDepth;
+    }
+    TemplateVariant preferredDepth() const
+    {
+      if (!m_cache.preferredDepthComputed)
+      {
+        m_cache.preferredDepth = computePreferredDepth(m_moduleTree.get(),maxDepth().toInt());
+        m_cache.preferredDepthComputed=TRUE;
+      }
+      return m_cache.preferredDepth;
+    }
+  private:
+    SharedPtr<NestingContext> m_moduleTree;
+    struct Cachable
+    {
+      Cachable() : maxDepthComputed(FALSE), preferredDepthComputed(FALSE) {}
+      int   maxDepth;
+      bool  maxDepthComputed;
+      int   preferredDepth;
+      bool  preferredDepthComputed;
+    };
+    mutable Cachable m_cache;
+    static PropertyMapper<ModuleTreeContext::Private> s_inst;
 };
 //%% }
 
 PropertyMapper<ModuleTreeContext::Private> ModuleTreeContext::Private::s_inst;
 
-ModuleTreeContext::ModuleTreeContext()
-    : RefCountedContext("ModuleTreeContext") {
+ModuleTreeContext::ModuleTreeContext() : RefCountedContext("ModuleTreeContext")
+{
   p = new Private;
 }
 
-ModuleTreeContext::~ModuleTreeContext() { delete p; }
+ModuleTreeContext::~ModuleTreeContext()
+{
+  delete p;
+}
 
-TemplateVariant ModuleTreeContext::get(const char *name) const {
+TemplateVariant ModuleTreeContext::get(const char *name) const
+{
   return p->get(name);
 }
 
@@ -8259,140 +7636,202 @@ TemplateVariant ModuleTreeContext::get(const char *name) const {
 
 //%% struct NavPathElem: list of examples page
 //%% {
-class NavPathElemContext::Private {
-public:
-  Private(Definition *def) : m_def(def) {
-    static bool init = FALSE;
-    if (!init) {
-      s_inst.addProperty("isLinkable", &Private::isLinkable);
-      s_inst.addProperty("fileName", &Private::fileName);
-      s_inst.addProperty("anchor", &Private::anchor);
-      s_inst.addProperty("text", &Private::text);
-      s_inst.addProperty("isReference", &Private::isReference);
-      s_inst.addProperty("externalReference", &Private::externalReference);
-      init = TRUE;
+class NavPathElemContext::Private
+{
+  public:
+    Private(Definition *def) : m_def(def)
+    {
+      static bool init=FALSE;
+      if (!init)
+      {
+        s_inst.addProperty("isLinkable",       &Private::isLinkable);
+        s_inst.addProperty("fileName",         &Private::fileName);
+        s_inst.addProperty("anchor",           &Private::anchor);
+        s_inst.addProperty("text",             &Private::text);
+        s_inst.addProperty("isReference",      &Private::isReference);
+        s_inst.addProperty("externalReference",&Private::externalReference);
+        init=TRUE;
+      }
     }
-  }
-  TemplateVariant get(const char *n) const { return s_inst.get(this, n); }
-  TemplateVariant isLinkable() const { return m_def->isLinkable(); }
-  TemplateVariant anchor() const { return m_def->anchor(); }
-  TemplateVariant fileName() const { return m_def->getOutputFileBase(); }
-  TemplateVariant text() const {
-    Definition::DefType type = m_def->definitionType();
-    QCString text = m_def->localName();
-    if (type == Definition::TypeGroup) {
-      text = ((const GroupDef *)m_def)->groupTitle();
-    } else if (type == Definition::TypePage &&
-               !(((const PageDef *)m_def)->title().isEmpty())) {
-      text = ((const PageDef *)m_def)->title();
-    } else if (type == Definition::TypeClass) {
-      if (text.right(2) == "-p") {
-        text = text.left(text.length() - 2);
+    TemplateVariant get(const char *n) const
+    {
+      return s_inst.get(this,n);
+    }
+    TemplateVariant isLinkable() const
+    {
+      return m_def->isLinkable();
+    }
+    TemplateVariant anchor() const
+    {
+      return m_def->anchor();
+    }
+    TemplateVariant fileName() const
+    {
+      return m_def->getOutputFileBase();
+    }
+    TemplateVariant text() const
+    {
+      Definition::DefType type = m_def->definitionType();
+      QCString text = m_def->localName();
+      if (type==Definition::TypeGroup)
+      {
+        text = ((const GroupDef*)m_def)->groupTitle();
+      }
+      else if (type==Definition::TypePage && !(((const PageDef*)m_def)->title().isEmpty()))
+      {
+        text = ((const PageDef*)m_def)->title();
       }
+      else if (type==Definition::TypeClass)
+      {
+        if (text.right(2)=="-p")
+        {
+          text = text.left(text.length()-2);
+        }
+      }
+      return text;
     }
-    return text;
-  }
-  TemplateVariant isReference() const { return m_def->isReference(); }
-  QCString relPathAsString() const {
-    static bool createSubdirs = Config_getBool(CREATE_SUBDIRS);
-    return createSubdirs ? QCString("../../") : QCString("");
-  }
-  TemplateVariant externalReference() const {
-    return m_def->externalReference(relPathAsString());
-  }
-
-private:
-  Definition *m_def;
-  static PropertyMapper<NavPathElemContext::Private> s_inst;
+    TemplateVariant isReference() const
+    {
+      return m_def->isReference();
+    }
+    QCString relPathAsString() const
+    {
+      static bool createSubdirs = Config_getBool(CREATE_SUBDIRS);
+      return createSubdirs ? QCString("../../") : QCString("");
+    }
+    TemplateVariant externalReference() const
+    {
+      return m_def->externalReference(relPathAsString());
+    }
+  private:
+    Definition *m_def;
+    static PropertyMapper<NavPathElemContext::Private> s_inst;
 };
 //%% }
 
 PropertyMapper<NavPathElemContext::Private> NavPathElemContext::Private::s_inst;
 
-NavPathElemContext::NavPathElemContext(Definition *def)
-    : RefCountedContext("NavPathElemContext") {
+NavPathElemContext::NavPathElemContext(Definition *def) : RefCountedContext("NavPathElemContext")
+{
   p = new Private(def);
 }
 
-NavPathElemContext::~NavPathElemContext() { delete p; }
+NavPathElemContext::~NavPathElemContext()
+{
+  delete p;
+}
 
-TemplateVariant NavPathElemContext::get(const char *name) const {
+TemplateVariant NavPathElemContext::get(const char *name) const
+{
   return p->get(name);
 }
 
+
 //------------------------------------------------------------------------
 
 //%% struct ExampleList: list of examples page
 //%% {
-class ExampleTreeContext::Private {
-public:
-  Private() {
-    m_exampleTree.reset(NestingContext::alloc(0, 0));
-    // Add pages
-    if (Doxygen::exampleSDict) {
-      m_exampleTree->addPages(*Doxygen::exampleSDict, TRUE);
-    }
-
-    static bool init = FALSE;
-    if (!init) {
-      s_inst.addProperty("tree", &Private::tree);
-      s_inst.addProperty("fileName", &Private::fileName);
-      s_inst.addProperty("relPath", &Private::relPath);
-      s_inst.addProperty("highlight", &Private::highlight);
-      s_inst.addProperty("subhighlight", &Private::subhighlight);
-      s_inst.addProperty("title", &Private::title);
-      s_inst.addProperty("preferredDepth", &Private::preferredDepth);
-      s_inst.addProperty("maxDepth", &Private::maxDepth);
-      init = TRUE;
+class ExampleTreeContext::Private
+{
+  public:
+    Private()
+    {
+      m_exampleTree.reset(NestingContext::alloc(0,0));
+      // Add pages
+      if (Doxygen::exampleSDict)
+      {
+        m_exampleTree->addPages(*Doxygen::exampleSDict,TRUE);
+      }
+
+      static bool init=FALSE;
+      if (!init)
+      {
+        s_inst.addProperty("tree",          &Private::tree);
+        s_inst.addProperty("fileName",      &Private::fileName);
+        s_inst.addProperty("relPath",       &Private::relPath);
+        s_inst.addProperty("highlight",     &Private::highlight);
+        s_inst.addProperty("subhighlight",  &Private::subhighlight);
+        s_inst.addProperty("title",         &Private::title);
+        s_inst.addProperty("preferredDepth",&Private::preferredDepth);
+        s_inst.addProperty("maxDepth",      &Private::maxDepth);
+        init=TRUE;
+      }
+    }
+    TemplateVariant get(const char *n) const
+    {
+      return s_inst.get(this,n);
+    }
+    TemplateVariant tree() const
+    {
+      return m_exampleTree.get();
+    }
+    TemplateVariant fileName() const
+    {
+      return "examples";
+    }
+    TemplateVariant relPath() const
+    {
+      return "";
+    }
+    TemplateVariant highlight() const
+    {
+      return "examples";
     }
-  }
-  TemplateVariant get(const char *n) const { return s_inst.get(this, n); }
-  TemplateVariant tree() const { return m_exampleTree.get(); }
-  TemplateVariant fileName() const { return "examples"; }
-  TemplateVariant relPath() const { return ""; }
-  TemplateVariant highlight() const { return "examples"; }
-  TemplateVariant subhighlight() const { return ""; }
-  TemplateVariant title() const { return theTranslator->trExamples(); }
-  TemplateVariant maxDepth() const {
-    if (!m_cache.maxDepthComputed) {
-      m_cache.maxDepth = computeMaxDepth(m_exampleTree.get());
-      m_cache.maxDepthComputed = TRUE;
-    }
-    return m_cache.maxDepth;
-  }
-  TemplateVariant preferredDepth() const {
-    if (!m_cache.preferredDepthComputed) {
-      m_cache.preferredDepth =
-          computePreferredDepth(m_exampleTree.get(), maxDepth().toInt());
-      m_cache.preferredDepthComputed = TRUE;
+    TemplateVariant subhighlight() const
+    {
+      return "";
     }
-    return m_cache.preferredDepth;
-  }
-
-private:
-  SharedPtr<NestingContext> m_exampleTree;
-  struct Cachable {
-    Cachable() : maxDepthComputed(FALSE), preferredDepthComputed(FALSE) {}
-    int maxDepth;
-    bool maxDepthComputed;
-    int preferredDepth;
-    bool preferredDepthComputed;
-  };
-  mutable Cachable m_cache;
-  static PropertyMapper<ExampleTreeContext::Private> s_inst;
+    TemplateVariant title() const
+    {
+      return theTranslator->trExamples();
+    }
+    TemplateVariant maxDepth() const
+    {
+      if (!m_cache.maxDepthComputed)
+      {
+        m_cache.maxDepth = computeMaxDepth(m_exampleTree.get());
+        m_cache.maxDepthComputed=TRUE;
+      }
+      return m_cache.maxDepth;
+    }
+    TemplateVariant preferredDepth() const
+    {
+      if (!m_cache.preferredDepthComputed)
+      {
+        m_cache.preferredDepth = computePreferredDepth(m_exampleTree.get(),maxDepth().toInt());
+        m_cache.preferredDepthComputed=TRUE;
+      }
+      return m_cache.preferredDepth;
+    }
+  private:
+    SharedPtr<NestingContext> m_exampleTree;
+    struct Cachable
+    {
+      Cachable() : maxDepthComputed(FALSE), preferredDepthComputed(FALSE) {}
+      int   maxDepth;
+      bool  maxDepthComputed;
+      int   preferredDepth;
+      bool  preferredDepthComputed;
+    };
+    mutable Cachable m_cache;
+    static PropertyMapper<ExampleTreeContext::Private> s_inst;
 };
 //%% }
 
 PropertyMapper<ExampleTreeContext::Private> ExampleTreeContext::Private::s_inst;
 
-ExampleTreeContext::ExampleTreeContext()
-    : RefCountedContext("ExampleTreeContext") {
+ExampleTreeContext::ExampleTreeContext() : RefCountedContext("ExampleTreeContext")
+{
   p = new Private;
 }
 
-ExampleTreeContext::~ExampleTreeContext() { delete p; }
+ExampleTreeContext::~ExampleTreeContext()
+{
+  delete p;
+}
 
-TemplateVariant ExampleTreeContext::get(const char *name) const {
+TemplateVariant ExampleTreeContext::get(const char *name) const
+{
   return p->get(name);
 }
 
@@ -8400,109 +7839,156 @@ TemplateVariant ExampleTreeContext::get(const char *name) const {
 
 //%% struct GlobalsIndex: list of examples page
 //%% {
-class GlobalsIndexContext::Private {
-public:
-  Private() {
-    static bool init = FALSE;
-    if (!init) {
-      s_inst.addProperty("all", &Private::all);
-      s_inst.addProperty("functions", &Private::functions);
-      s_inst.addProperty("variables", &Private::variables);
-      s_inst.addProperty("typedefs", &Private::typedefs);
-      s_inst.addProperty("enums", &Private::enums);
-      s_inst.addProperty("enumValues", &Private::enumValues);
-      s_inst.addProperty("macros", &Private::macros);
-      s_inst.addProperty("properties", &Private::properties);
-      s_inst.addProperty("events", &Private::events);
-      s_inst.addProperty("related", &Private::related);
-      s_inst.addProperty("fileName", &Private::fileName);
-      s_inst.addProperty("relPath", &Private::relPath);
-      s_inst.addProperty("highlight", &Private::highlight);
-      s_inst.addProperty("subhighlight", &Private::subhighlight);
-      s_inst.addProperty("title", &Private::title);
-      init = TRUE;
+class GlobalsIndexContext::Private
+{
+  public:
+    Private()
+    {
+      static bool init=FALSE;
+      if (!init)
+      {
+        s_inst.addProperty("all",         &Private::all);
+        s_inst.addProperty("functions",   &Private::functions);
+        s_inst.addProperty("variables",   &Private::variables);
+        s_inst.addProperty("typedefs",    &Private::typedefs);
+        s_inst.addProperty("enums",       &Private::enums);
+        s_inst.addProperty("enumValues",  &Private::enumValues);
+        s_inst.addProperty("macros",      &Private::macros);
+        s_inst.addProperty("properties",  &Private::properties);
+        s_inst.addProperty("events",      &Private::events);
+        s_inst.addProperty("related",     &Private::related);
+        s_inst.addProperty("fileName",    &Private::fileName);
+        s_inst.addProperty("relPath",     &Private::relPath);
+        s_inst.addProperty("highlight",   &Private::highlight);
+        s_inst.addProperty("subhighlight",&Private::subhighlight);
+        s_inst.addProperty("title",       &Private::title);
+        init=TRUE;
+      }
     }
-  }
-  TemplateVariant get(const char *n) const { return s_inst.get(this, n); }
-  typedef bool (MemberDef::*MemberFunc)() const;
-  TemplateVariant getMembersFiltered(SharedPtr<TemplateList> &listRef,
-                                     MemberFunc filter) const {
-    if (!listRef) {
-      TemplateList *list = TemplateList::alloc();
-      MemberName *mn;
-      MemberNameSDict::Iterator fnli(*Doxygen::functionNameSDict);
-      for (fnli.toFirst(); (mn = fnli.current()); ++fnli) {
-        MemberDef *md;
-        MemberNameIterator mni(*mn);
-        for (mni.toFirst(); (md = mni.current()); ++mni) {
-          FileDef *fd = md->getFileDef();
-          if (fd && fd->isLinkableInProject() && !md->name().isEmpty() &&
-              !md->getNamespaceDef() && md->isLinkableInProject()) {
-            if (filter == 0 || (md->*filter)()) {
-              list->append(MemberContext::alloc(md));
+    TemplateVariant get(const char *n) const
+    {
+      return s_inst.get(this,n);
+    }
+    typedef bool (MemberDef::*MemberFunc)() const;
+    TemplateVariant getMembersFiltered(SharedPtr<TemplateList> &listRef,MemberFunc filter) const
+    {
+      if (!listRef)
+      {
+        TemplateList *list = TemplateList::alloc();
+        MemberName *mn;
+        MemberNameSDict::Iterator fnli(*Doxygen::functionNameSDict);
+        for (fnli.toFirst();(mn=fnli.current());++fnli)
+        {
+          MemberDef *md;
+          MemberNameIterator mni(*mn);
+          for (mni.toFirst();(md=mni.current());++mni)
+          {
+            FileDef *fd=md->getFileDef();
+            if (fd && fd->isLinkableInProject() &&
+                !md->name().isEmpty() && !md->getNamespaceDef() && md->isLinkableInProject())
+            {
+              if (filter==0 || (md->*filter)())
+              {
+                list->append(MemberContext::alloc(md));
+              }
             }
           }
         }
+        listRef.reset(list);
       }
-      listRef.reset(list);
+      return listRef.get();
     }
-    return listRef.get();
-  }
-  TemplateVariant all() const { return getMembersFiltered(m_cache.all, 0); }
-  TemplateVariant functions() const {
-    return getMembersFiltered(m_cache.functions, &MemberDef::isFunction);
-  }
-  TemplateVariant variables() const {
-    return getMembersFiltered(m_cache.variables, &MemberDef::isVariable);
-  }
-  TemplateVariant typedefs() const {
-    return getMembersFiltered(m_cache.typedefs, &MemberDef::isTypedef);
-  }
-  TemplateVariant enums() const {
-    return getMembersFiltered(m_cache.enums, &MemberDef::isEnumerate);
-  }
-  TemplateVariant enumValues() const {
-    return getMembersFiltered(m_cache.enumValues, &MemberDef::isEnumValue);
-  }
-  TemplateVariant macros() const {
-    return getMembersFiltered(m_cache.macros, &MemberDef::isDefine);
-  }
-  TemplateVariant properties() const { return FALSE; }
-  TemplateVariant events() const { return FALSE; }
-  TemplateVariant related() const { return FALSE; }
-  TemplateVariant fileName() const { return "globals"; }
-  TemplateVariant relPath() const { return ""; }
-  TemplateVariant highlight() const { return "files"; }
-  TemplateVariant subhighlight() const { return "filemembers"; }
-  TemplateVariant title() const { return theTranslator->trFileMembers(); }
-
-private:
-  struct Cachable {
-    Cachable() {}
-    SharedPtr<TemplateList> all;
-    SharedPtr<TemplateList> functions;
-    SharedPtr<TemplateList> variables;
-    SharedPtr<TemplateList> typedefs;
-    SharedPtr<TemplateList> enums;
-    SharedPtr<TemplateList> enumValues;
-    SharedPtr<TemplateList> macros;
-  };
-  mutable Cachable m_cache;
-  static PropertyMapper<GlobalsIndexContext::Private> s_inst;
+    TemplateVariant all() const
+    {
+      return getMembersFiltered(m_cache.all,0);
+    }
+    TemplateVariant functions() const
+    {
+      return getMembersFiltered(m_cache.functions,&MemberDef::isFunction);
+    }
+    TemplateVariant variables() const
+    {
+      return getMembersFiltered(m_cache.variables,&MemberDef::isVariable);
+    }
+    TemplateVariant typedefs() const
+    {
+      return getMembersFiltered(m_cache.typedefs,&MemberDef::isTypedef);
+    }
+    TemplateVariant enums() const
+    {
+      return getMembersFiltered(m_cache.enums,&MemberDef::isEnumerate);
+    }
+    TemplateVariant enumValues() const
+    {
+      return getMembersFiltered(m_cache.enumValues,&MemberDef::isEnumValue);
+    }
+    TemplateVariant macros() const
+    {
+      return getMembersFiltered(m_cache.macros,&MemberDef::isDefine);
+    }
+    TemplateVariant properties() const
+    {
+      return FALSE;
+    }
+    TemplateVariant events() const
+    {
+      return FALSE;
+    }
+    TemplateVariant related() const
+    {
+      return FALSE;
+    }
+    TemplateVariant fileName() const
+    {
+      return "globals";
+    }
+    TemplateVariant relPath() const
+    {
+      return "";
+    }
+    TemplateVariant highlight() const
+    {
+      return "files";
+    }
+    TemplateVariant subhighlight() const
+    {
+      return "filemembers";
+    }
+    TemplateVariant title() const
+    {
+      return theTranslator->trFileMembers();
+    }
+  private:
+    struct Cachable
+    {
+      Cachable() {}
+      SharedPtr<TemplateList> all;
+      SharedPtr<TemplateList> functions;
+      SharedPtr<TemplateList> variables;
+      SharedPtr<TemplateList> typedefs;
+      SharedPtr<TemplateList> enums;
+      SharedPtr<TemplateList> enumValues;
+      SharedPtr<TemplateList> macros;
+    };
+    mutable Cachable m_cache;
+    static PropertyMapper<GlobalsIndexContext::Private> s_inst;
 };
 //%% }
 
-PropertyMapper<GlobalsIndexContext::Private>
-    GlobalsIndexContext::Private::s_inst;
+PropertyMapper<GlobalsIndexContext::Private> GlobalsIndexContext::Private::s_inst;
 
-GlobalsIndexContext::GlobalsIndexContext()
-    : RefCountedContext("GlobalsIndexContext") {
+GlobalsIndexContext::GlobalsIndexContext() : RefCountedContext("GlobalsIndexContext")
+{
   p = new Private;
 }
 
-GlobalsIndexContext::~GlobalsIndexContext() { delete p; }
+GlobalsIndexContext::~GlobalsIndexContext()
+{
+  delete p;
+}
 
-TemplateVariant GlobalsIndexContext::get(const char *name) const {
+TemplateVariant GlobalsIndexContext::get(const char *name) const
+{
   return p->get(name);
 }
 
@@ -8510,118 +7996,158 @@ TemplateVariant GlobalsIndexContext::get(const char *name) const {
 
 //%% struct ClassMembersIndex: list of examples page
 //%% {
-class ClassMembersIndexContext::Private {
-public:
-  Private() {
-    static bool init = FALSE;
-    if (!init) {
-      s_inst.addProperty("all", &Private::all);
-      s_inst.addProperty("functions", &Private::functions);
-      s_inst.addProperty("variables", &Private::variables);
-      s_inst.addProperty("typedefs", &Private::typedefs);
-      s_inst.addProperty("enums", &Private::enums);
-      s_inst.addProperty("enumValues", &Private::enumValues);
-      s_inst.addProperty("macros", &Private::macros);
-      s_inst.addProperty("properties", &Private::properties);
-      s_inst.addProperty("events", &Private::events);
-      s_inst.addProperty("related", &Private::related);
-      s_inst.addProperty("fileName", &Private::fileName);
-      s_inst.addProperty("relPath", &Private::relPath);
-      s_inst.addProperty("highlight", &Private::highlight);
-      s_inst.addProperty("subhighlight", &Private::subhighlight);
-      s_inst.addProperty("title", &Private::title);
-      init = TRUE;
+class ClassMembersIndexContext::Private
+{
+  public:
+    Private()
+    {
+      static bool init=FALSE;
+      if (!init)
+      {
+        s_inst.addProperty("all",         &Private::all);
+        s_inst.addProperty("functions",   &Private::functions);
+        s_inst.addProperty("variables",   &Private::variables);
+        s_inst.addProperty("typedefs",    &Private::typedefs);
+        s_inst.addProperty("enums",       &Private::enums);
+        s_inst.addProperty("enumValues",  &Private::enumValues);
+        s_inst.addProperty("macros",      &Private::macros);
+        s_inst.addProperty("properties",  &Private::properties);
+        s_inst.addProperty("events",      &Private::events);
+        s_inst.addProperty("related",     &Private::related);
+        s_inst.addProperty("fileName",    &Private::fileName);
+        s_inst.addProperty("relPath",     &Private::relPath);
+        s_inst.addProperty("highlight",   &Private::highlight);
+        s_inst.addProperty("subhighlight",&Private::subhighlight);
+        s_inst.addProperty("title",       &Private::title);
+        init=TRUE;
+      }
     }
-  }
-  TemplateVariant get(const char *n) const { return s_inst.get(this, n); }
-  typedef bool (MemberDef::*MemberFunc)() const;
-  TemplateVariant getMembersFiltered(SharedPtr<TemplateList> &listRef,
-                                     MemberFunc filter) const {
-    if (!listRef) {
-      TemplateList *list = TemplateList::alloc();
-      MemberName *mn;
-      MemberNameSDict::Iterator mnli(*Doxygen::memberNameSDict);
-      for (mnli.toFirst(); (mn = mnli.current()); ++mnli) {
-        MemberDef *md;
-        MemberNameIterator mni(*mn);
-        for (mni.toFirst(); (md = mni.current()); ++mni) {
-          ClassDef *cd = md->getClassDef();
-          if (cd && cd->isLinkableInProject() && cd->templateMaster() == 0 &&
-              md->isLinkableInProject() && !md->name().isEmpty()) {
-            if (filter == 0 || (md->*filter)()) {
-              list->append(MemberContext::alloc(md));
+    TemplateVariant get(const char *n) const
+    {
+      return s_inst.get(this,n);
+    }
+    typedef bool (MemberDef::*MemberFunc)() const;
+    TemplateVariant getMembersFiltered(SharedPtr<TemplateList> &listRef,MemberFunc filter) const
+    {
+      if (!listRef)
+      {
+        TemplateList *list = TemplateList::alloc();
+        MemberName *mn;
+        MemberNameSDict::Iterator mnli(*Doxygen::memberNameSDict);
+        for (mnli.toFirst();(mn=mnli.current());++mnli)
+        {
+          MemberDef *md;
+          MemberNameIterator mni(*mn);
+          for (mni.toFirst();(md=mni.current());++mni)
+          {
+            ClassDef *cd = md->getClassDef();
+            if (cd && cd->isLinkableInProject() && cd->templateMaster()==0 &&
+                md->isLinkableInProject() && !md->name().isEmpty())
+            {
+              if (filter==0 || (md->*filter)())
+              {
+                list->append(MemberContext::alloc(md));
+              }
             }
           }
         }
+        listRef.reset(list);
       }
-      listRef.reset(list);
+      return listRef.get();
     }
-    return listRef.get();
-  }
-  TemplateVariant all() const {
-    return getMembersFiltered(m_cache.all, &MemberDef::isNotFriend);
-  }
-  TemplateVariant functions() const {
-    return getMembersFiltered(m_cache.functions,
-                              &MemberDef::isFunctionOrSignalSlot);
-  }
-  TemplateVariant variables() const {
-    return getMembersFiltered(m_cache.variables, &MemberDef::isVariable);
-  }
-  TemplateVariant typedefs() const {
-    return getMembersFiltered(m_cache.typedefs, &MemberDef::isTypedef);
-  }
-  TemplateVariant enums() const {
-    return getMembersFiltered(m_cache.enums, &MemberDef::isEnumerate);
-  }
-  TemplateVariant enumValues() const {
-    return getMembersFiltered(m_cache.enumValues, &MemberDef::isEnumValue);
-  }
-  TemplateVariant macros() const { return FALSE; }
-  TemplateVariant properties() const {
-    return getMembersFiltered(m_cache.properties, &MemberDef::isProperty);
-  }
-  TemplateVariant events() const {
-    return getMembersFiltered(m_cache.events, &MemberDef::isEvent);
-  }
-  TemplateVariant related() const {
-    return getMembersFiltered(m_cache.related, &MemberDef::isRelated);
-  }
-  TemplateVariant fileName() const { return "functions"; }
-  TemplateVariant relPath() const { return ""; }
-  TemplateVariant highlight() const { return "classes"; }
-  TemplateVariant subhighlight() const { return "classmembers"; }
-  TemplateVariant title() const { return theTranslator->trCompoundMembers(); }
-
-private:
-  struct Cachable {
-    Cachable() {}
-    SharedPtr<TemplateList> all;
-    SharedPtr<TemplateList> functions;
-    SharedPtr<TemplateList> variables;
-    SharedPtr<TemplateList> typedefs;
-    SharedPtr<TemplateList> enums;
-    SharedPtr<TemplateList> enumValues;
-    SharedPtr<TemplateList> properties;
-    SharedPtr<TemplateList> events;
-    SharedPtr<TemplateList> related;
-  };
-  mutable Cachable m_cache;
-  static PropertyMapper<ClassMembersIndexContext::Private> s_inst;
+    TemplateVariant all() const
+    {
+      return getMembersFiltered(m_cache.all,&MemberDef::isNotFriend);
+    }
+    TemplateVariant functions() const
+    {
+      return getMembersFiltered(m_cache.functions,&MemberDef::isFunctionOrSignalSlot);
+    }
+    TemplateVariant variables() const
+    {
+      return getMembersFiltered(m_cache.variables,&MemberDef::isVariable);
+    }
+    TemplateVariant typedefs() const
+    {
+      return getMembersFiltered(m_cache.typedefs,&MemberDef::isTypedef);
+    }
+    TemplateVariant enums() const
+    {
+      return getMembersFiltered(m_cache.enums,&MemberDef::isEnumerate);
+    }
+    TemplateVariant enumValues() const
+    {
+      return getMembersFiltered(m_cache.enumValues,&MemberDef::isEnumValue);
+    }
+    TemplateVariant macros() const
+    {
+      return FALSE;
+    }
+    TemplateVariant properties() const
+    {
+      return getMembersFiltered(m_cache.properties,&MemberDef::isProperty);
+    }
+    TemplateVariant events() const
+    {
+      return getMembersFiltered(m_cache.events,&MemberDef::isEvent);
+    }
+    TemplateVariant related() const
+    {
+      return getMembersFiltered(m_cache.related,&MemberDef::isRelated);
+    }
+    TemplateVariant fileName() const
+    {
+      return "functions";
+    }
+    TemplateVariant relPath() const
+    {
+      return "";
+    }
+    TemplateVariant highlight() const
+    {
+      return "classes";
+    }
+    TemplateVariant subhighlight() const
+    {
+      return "classmembers";
+    }
+    TemplateVariant title() const
+    {
+      return theTranslator->trCompoundMembers();
+    }
+  private:
+    struct Cachable
+    {
+      Cachable() {}
+      SharedPtr<TemplateList> all;
+      SharedPtr<TemplateList> functions;
+      SharedPtr<TemplateList> variables;
+      SharedPtr<TemplateList> typedefs;
+      SharedPtr<TemplateList> enums;
+      SharedPtr<TemplateList> enumValues;
+      SharedPtr<TemplateList> properties;
+      SharedPtr<TemplateList> events;
+      SharedPtr<TemplateList> related;
+    };
+    mutable Cachable m_cache;
+    static PropertyMapper<ClassMembersIndexContext::Private> s_inst;
 };
 //%% }
 
-PropertyMapper<ClassMembersIndexContext::Private>
-    ClassMembersIndexContext::Private::s_inst;
+PropertyMapper<ClassMembersIndexContext::Private> ClassMembersIndexContext::Private::s_inst;
 
-ClassMembersIndexContext::ClassMembersIndexContext()
-    : RefCountedContext("ClassMembersIndexContext") {
+ClassMembersIndexContext::ClassMembersIndexContext() : RefCountedContext("ClassMembersIndexContext")
+{
   p = new Private;
 }
 
-ClassMembersIndexContext::~ClassMembersIndexContext() { delete p; }
+ClassMembersIndexContext::~ClassMembersIndexContext()
+{
+  delete p;
+}
 
-TemplateVariant ClassMembersIndexContext::get(const char *name) const {
+TemplateVariant ClassMembersIndexContext::get(const char *name) const
+{
   return p->get(name);
 }
 
@@ -8629,309 +8155,411 @@ TemplateVariant ClassMembersIndexContext::get(const char *name) const {
 
 //%% struct NamespaceMembersIndex: list of examples page
 //%% {
-class NamespaceMembersIndexContext::Private {
-public:
-  Private() {
-    static bool init = FALSE;
-    if (!init) {
-      s_inst.addProperty("all", &Private::all);
-      s_inst.addProperty("functions", &Private::functions);
-      s_inst.addProperty("variables", &Private::variables);
-      s_inst.addProperty("typedefs", &Private::typedefs);
-      s_inst.addProperty("enums", &Private::enums);
-      s_inst.addProperty("enumValues", &Private::enumValues);
-      s_inst.addProperty("macros", &Private::macros);
-      s_inst.addProperty("properties", &Private::properties);
-      s_inst.addProperty("events", &Private::events);
-      s_inst.addProperty("related", &Private::related);
-      s_inst.addProperty("fileName", &Private::fileName);
-      s_inst.addProperty("relPath", &Private::relPath);
-      s_inst.addProperty("highlight", &Private::highlight);
-      s_inst.addProperty("subhighlight", &Private::subhighlight);
-      s_inst.addProperty("title", &Private::title);
-      init = TRUE;
+class NamespaceMembersIndexContext::Private
+{
+  public:
+    Private()
+    {
+      static bool init=FALSE;
+      if (!init)
+      {
+        s_inst.addProperty("all",         &Private::all);
+        s_inst.addProperty("functions",   &Private::functions);
+        s_inst.addProperty("variables",   &Private::variables);
+        s_inst.addProperty("typedefs",    &Private::typedefs);
+        s_inst.addProperty("enums",       &Private::enums);
+        s_inst.addProperty("enumValues",  &Private::enumValues);
+        s_inst.addProperty("macros",      &Private::macros);
+        s_inst.addProperty("properties",  &Private::properties);
+        s_inst.addProperty("events",      &Private::events);
+        s_inst.addProperty("related",     &Private::related);
+        s_inst.addProperty("fileName",    &Private::fileName);
+        s_inst.addProperty("relPath",     &Private::relPath);
+        s_inst.addProperty("highlight",   &Private::highlight);
+        s_inst.addProperty("subhighlight",&Private::subhighlight);
+        s_inst.addProperty("title",       &Private::title);
+        init=TRUE;
+      }
     }
-  }
-  TemplateVariant get(const char *n) const { return s_inst.get(this, n); }
-  typedef bool (MemberDef::*MemberFunc)() const;
-  TemplateVariant getMembersFiltered(SharedPtr<TemplateList> &listRef,
-                                     MemberFunc filter) const {
-    if (!listRef) {
-      TemplateList *list = TemplateList::alloc();
-      MemberName *mn;
-      MemberNameSDict::Iterator fnli(*Doxygen::functionNameSDict);
-      for (fnli.toFirst(); (mn = fnli.current()); ++fnli) {
-        MemberDef *md;
-        MemberNameIterator mni(*mn);
-        for (mni.toFirst(); (md = mni.current()); ++mni) {
-          NamespaceDef *nd = md->getNamespaceDef();
-          if (nd && nd->isLinkableInProject() && !md->name().isEmpty() &&
-              md->isLinkableInProject()) {
-            if (filter == 0 || (md->*filter)()) {
-              list->append(MemberContext::alloc(md));
+    TemplateVariant get(const char *n) const
+    {
+      return s_inst.get(this,n);
+    }
+    typedef bool (MemberDef::*MemberFunc)() const;
+    TemplateVariant getMembersFiltered(SharedPtr<TemplateList> &listRef,MemberFunc filter) const
+    {
+      if (!listRef)
+      {
+        TemplateList *list = TemplateList::alloc();
+        MemberName *mn;
+        MemberNameSDict::Iterator fnli(*Doxygen::functionNameSDict);
+        for (fnli.toFirst();(mn=fnli.current());++fnli)
+        {
+          MemberDef *md;
+          MemberNameIterator mni(*mn);
+          for (mni.toFirst();(md=mni.current());++mni)
+          {
+            NamespaceDef *nd=md->getNamespaceDef();
+            if (nd && nd->isLinkableInProject() &&
+                !md->name().isEmpty() && md->isLinkableInProject())
+            {
+              if (filter==0 || (md->*filter)())
+              {
+                list->append(MemberContext::alloc(md));
+              }
             }
           }
         }
+        listRef.reset(list);
       }
-      listRef.reset(list);
+      return listRef.get();
+    }
+    TemplateVariant all() const
+    {
+      return getMembersFiltered(m_cache.all,0);
+    }
+    TemplateVariant functions() const
+    {
+      return getMembersFiltered(m_cache.functions,&MemberDef::isFunction);
+    }
+    TemplateVariant variables() const
+    {
+      return getMembersFiltered(m_cache.variables,&MemberDef::isVariable);
+    }
+    TemplateVariant typedefs() const
+    {
+      return getMembersFiltered(m_cache.typedefs,&MemberDef::isTypedef);
+    }
+    TemplateVariant enums() const
+    {
+      return getMembersFiltered(m_cache.enums,&MemberDef::isEnumerate);
+    }
+    TemplateVariant enumValues() const
+    {
+      return getMembersFiltered(m_cache.enumValues,&MemberDef::isEnumValue);
+    }
+    TemplateVariant macros() const
+    {
+      return FALSE;
+    }
+    TemplateVariant properties() const
+    {
+      return FALSE;
+    }
+    TemplateVariant events() const
+    {
+      return FALSE;
+    }
+    TemplateVariant related() const
+    {
+      return FALSE;
+    }
+    TemplateVariant fileName() const
+    {
+      return "namespacemembers";
+    }
+    TemplateVariant relPath() const
+    {
+      return "";
+    }
+    TemplateVariant highlight() const
+    {
+      return "namespaces";
     }
-    return listRef.get();
-  }
-  TemplateVariant all() const { return getMembersFiltered(m_cache.all, 0); }
-  TemplateVariant functions() const {
-    return getMembersFiltered(m_cache.functions, &MemberDef::isFunction);
-  }
-  TemplateVariant variables() const {
-    return getMembersFiltered(m_cache.variables, &MemberDef::isVariable);
-  }
-  TemplateVariant typedefs() const {
-    return getMembersFiltered(m_cache.typedefs, &MemberDef::isTypedef);
-  }
-  TemplateVariant enums() const {
-    return getMembersFiltered(m_cache.enums, &MemberDef::isEnumerate);
-  }
-  TemplateVariant enumValues() const {
-    return getMembersFiltered(m_cache.enumValues, &MemberDef::isEnumValue);
-  }
-  TemplateVariant macros() const { return FALSE; }
-  TemplateVariant properties() const { return FALSE; }
-  TemplateVariant events() const { return FALSE; }
-  TemplateVariant related() const { return FALSE; }
-  TemplateVariant fileName() const { return "namespacemembers"; }
-  TemplateVariant relPath() const { return ""; }
-  TemplateVariant highlight() const { return "namespaces"; }
-  TemplateVariant subhighlight() const { return "namespacemembers"; }
-  TemplateVariant title() const { return theTranslator->trNamespaceMembers(); }
-
-private:
-  struct Cachable {
-    Cachable() {}
-    SharedPtr<TemplateList> all;
-    SharedPtr<TemplateList> functions;
-    SharedPtr<TemplateList> variables;
-    SharedPtr<TemplateList> typedefs;
-    SharedPtr<TemplateList> enums;
-    SharedPtr<TemplateList> enumValues;
-  };
-  mutable Cachable m_cache;
-  static PropertyMapper<NamespaceMembersIndexContext::Private> s_inst;
+    TemplateVariant subhighlight() const
+    {
+      return "namespacemembers";
+    }
+    TemplateVariant title() const
+    {
+      return theTranslator->trNamespaceMembers();
+    }
+  private:
+    struct Cachable
+    {
+      Cachable() {}
+      SharedPtr<TemplateList> all;
+      SharedPtr<TemplateList> functions;
+      SharedPtr<TemplateList> variables;
+      SharedPtr<TemplateList> typedefs;
+      SharedPtr<TemplateList> enums;
+      SharedPtr<TemplateList> enumValues;
+    };
+    mutable Cachable m_cache;
+    static PropertyMapper<NamespaceMembersIndexContext::Private> s_inst;
 };
 //%% }
 
-PropertyMapper<NamespaceMembersIndexContext::Private>
-    NamespaceMembersIndexContext::Private::s_inst;
+PropertyMapper<NamespaceMembersIndexContext::Private> NamespaceMembersIndexContext::Private::s_inst;
 
-NamespaceMembersIndexContext::NamespaceMembersIndexContext()
-    : RefCountedContext("NamespaceMembersIndexContext") {
+NamespaceMembersIndexContext::NamespaceMembersIndexContext() : RefCountedContext("NamespaceMembersIndexContext")
+{
   p = new Private;
 }
 
-NamespaceMembersIndexContext::~NamespaceMembersIndexContext() { delete p; }
+NamespaceMembersIndexContext::~NamespaceMembersIndexContext()
+{
+  delete p;
+}
 
-TemplateVariant NamespaceMembersIndexContext::get(const char *name) const {
+TemplateVariant NamespaceMembersIndexContext::get(const char *name) const
+{
   return p->get(name);
 }
 
 //------------------------------------------------------------------------
 
-//%% struct InheritanceGraph: a connected graph reprenting part of the overall
-//interitance tree
+//%% struct InheritanceGraph: a connected graph reprenting part of the overall interitance tree
 //%% {
-class InheritanceGraphContext::Private {
-public:
-  Private(DotGfxHierarchyTable *hierarchy, DotNode *n, int id)
-      : m_hierarchy(hierarchy), m_node(n), m_id(id) {
-    static bool init = FALSE;
-    if (!init) {
-      s_inst.addProperty("graph", &Private::graph);
-      init = TRUE;
+class InheritanceGraphContext::Private
+{
+  public:
+    Private(DotGfxHierarchyTable *hierarchy,DotNode *n,int id) : m_hierarchy(hierarchy), m_node(n), m_id(id)
+    {
+      static bool init=FALSE;
+      if (!init)
+      {
+        s_inst.addProperty("graph",&Private::graph);
+        init=TRUE;
+      }
     }
-  }
-  TemplateVariant get(const char *n) const { return s_inst.get(this, n); }
-  TemplateVariant graph() const {
-    QGString result;
-    static bool haveDot = Config_getBool(HAVE_DOT);
-    static bool graphicalHierarchy = Config_getBool(GRAPHICAL_HIERARCHY);
-    if (haveDot && graphicalHierarchy) {
-      FTextStream t(&result);
-      m_hierarchy->createGraph(m_node, t,
-                               /*GOF_BITMAP,
-                               EOF_Html,*/
-                               g_globals.outputDir,
-                               g_globals.outputDir + portable_pathSeparator() +
-                                   "inherits" + Doxygen::htmlFileExtension,
-                               m_id);
-    }
-    return TemplateVariant(result.data(), TRUE);
-  }
-
-private:
-  DotGfxHierarchyTable *m_hierarchy;
-  DotNode *m_node;
-  int m_id;
-  static PropertyMapper<InheritanceGraphContext::Private> s_inst;
+    TemplateVariant get(const char *n) const
+    {
+      return s_inst.get(this,n);
+    }
+    TemplateVariant graph() const
+    {
+      QGString result;
+      static bool haveDot            = Config_getBool(HAVE_DOT);
+      static bool graphicalHierarchy = Config_getBool(GRAPHICAL_HIERARCHY);
+      if (haveDot && graphicalHierarchy)
+      {
+        FTextStream t(&result);
+        m_hierarchy->createGraph(m_node,t,
+                          /*GOF_BITMAP,
+                          EOF_Html,*/
+                          g_globals.outputDir,
+                          g_globals.outputDir+portable_pathSeparator()+"inherits"+Doxygen::htmlFileExtension,
+                          m_id);
+      }
+      return TemplateVariant(result.data(),TRUE);
+    }
+  private:
+    DotGfxHierarchyTable *m_hierarchy;
+    DotNode *m_node;
+    int m_id;
+    static PropertyMapper<InheritanceGraphContext::Private> s_inst;
 };
 
-PropertyMapper<InheritanceGraphContext::Private>
-    InheritanceGraphContext::Private::s_inst;
+PropertyMapper<InheritanceGraphContext::Private> InheritanceGraphContext::Private::s_inst;
 
-InheritanceGraphContext::InheritanceGraphContext(
-    DotGfxHierarchyTable *hierarchy, DotNode *n, int id)
-    : RefCountedContext("InheritanceGraphContext") {
-  p = new Private(hierarchy, n, id);
+InheritanceGraphContext::InheritanceGraphContext(DotGfxHierarchyTable *hierarchy,DotNode *n,int id)
+   : RefCountedContext("InheritanceGraphContext")
+{
+  p = new Private(hierarchy,n,id);
 }
 
-InheritanceGraphContext::~InheritanceGraphContext() { delete p; }
+InheritanceGraphContext::~InheritanceGraphContext()
+{
+  delete p;
+}
 
-TemplateVariant InheritanceGraphContext::get(const char *name) const {
+TemplateVariant InheritanceGraphContext::get(const char *name) const
+{
   return p->get(name);
 }
 
+
 //------------------------------------------------------------------------
 
 //%% struct InheritanceNode: a class in the inheritance list
 //%% {
-class InheritanceNodeContext::Private {
-public:
-  Private(ClassDef *cd, const QCString &name) : m_classDef(cd), m_name(name) {
-    static bool init = FALSE;
-    if (!init) {
-      s_inst.addProperty("class", &Private::getClass);
-      s_inst.addProperty("name", &Private::name);
-      init = TRUE;
+class InheritanceNodeContext::Private
+{
+  public:
+    Private(ClassDef *cd,const QCString &name) : m_classDef(cd), m_name(name)
+    {
+      static bool init=FALSE;
+      if (!init)
+      {
+        s_inst.addProperty("class",&Private::getClass);
+        s_inst.addProperty("name", &Private::name);
+        init=TRUE;
+      }
     }
-  }
-  TemplateVariant get(const char *n) const { return s_inst.get(this, n); }
-  TemplateVariant getClass() const {
-    if (!m_classContext) {
-      m_classContext.reset(ClassContext::alloc(m_classDef));
+    TemplateVariant get(const char *n) const
+    {
+      return s_inst.get(this,n);
     }
-    return m_classContext.get();
-  }
-  TemplateVariant name() const { return m_name; }
-
-private:
-  ClassDef *m_classDef;
-  mutable SharedPtr<ClassContext> m_classContext;
-  QCString m_name;
-  static PropertyMapper<InheritanceNodeContext::Private> s_inst;
+    TemplateVariant getClass() const
+    {
+      if (!m_classContext)
+      {
+        m_classContext.reset(ClassContext::alloc(m_classDef));
+      }
+      return m_classContext.get();
+    }
+    TemplateVariant name() const
+    {
+      return m_name;
+    }
+  private:
+    ClassDef *m_classDef;
+    mutable SharedPtr<ClassContext> m_classContext;
+    QCString m_name;
+    static PropertyMapper<InheritanceNodeContext::Private> s_inst;
 };
 //%% }
 
-PropertyMapper<InheritanceNodeContext::Private>
-    InheritanceNodeContext::Private::s_inst;
+PropertyMapper<InheritanceNodeContext::Private> InheritanceNodeContext::Private::s_inst;
 
-InheritanceNodeContext::InheritanceNodeContext(ClassDef *cd,
-                                               const QCString &name)
-    : RefCountedContext("InheritanceNodeContext") {
-  p = new Private(cd, name);
+InheritanceNodeContext::InheritanceNodeContext(ClassDef *cd,const QCString &name) : RefCountedContext("InheritanceNodeContext")
+{
+  p = new Private(cd,name);
 }
 
-InheritanceNodeContext::~InheritanceNodeContext() { delete p; }
+InheritanceNodeContext::~InheritanceNodeContext()
+{
+  delete p;
+}
 
-TemplateVariant InheritanceNodeContext::get(const char *name) const {
+TemplateVariant InheritanceNodeContext::get(const char *name) const
+{
   return p->get(name);
 }
 
 //------------------------------------------------------------------------
 
 //%% list InheritanceList[InheritanceNode] : list of inherited classes
-class InheritanceListContext::Private : public GenericNodeListContext {
-public:
-  void addClass(ClassDef *cd, const QCString &name) {
-    append(InheritanceNodeContext::alloc(cd, name));
-  }
+class InheritanceListContext::Private : public GenericNodeListContext
+{
+  public:
+    void addClass(ClassDef *cd,const QCString &name)
+    {
+      append(InheritanceNodeContext::alloc(cd,name));
+    }
 };
 
-InheritanceListContext::InheritanceListContext(const BaseClassList *list,
-                                               bool baseClasses)
-    : RefCountedContext("InheritanceListContext") {
+InheritanceListContext::InheritanceListContext(const BaseClassList *list, bool baseClasses) : RefCountedContext("InheritanceListContext")
+{
   p = new Private;
-  if (list) {
+  if (list)
+  {
     BaseClassListIterator li(*list);
     BaseClassDef *bcd;
-    for (li.toFirst(); (bcd = li.current()); ++li) {
-      ClassDef *cd = bcd->classDef;
+    for (li.toFirst();(bcd=li.current());++li)
+    {
+      ClassDef *cd=bcd->classDef;
       QCString name;
-      if (baseClasses) {
-        name = insertTemplateSpecifierInScope(cd->displayName(),
-                                              bcd->templSpecifiers);
-      } else {
+      if (baseClasses)
+      {
+        name = insertTemplateSpecifierInScope(
+                     cd->displayName(),bcd->templSpecifiers);
+      }
+      else
+      {
         name = cd->displayName();
       }
-      // printf("InheritanceListContext: adding %s
-      // baseClass=%d\n",name.data(),baseClasses);
-      p->addClass(cd, name);
+      //printf("InheritanceListContext: adding %s baseClass=%d\n",name.data(),baseClasses);
+      p->addClass(cd,name);
     }
   }
 }
 
-InheritanceListContext::~InheritanceListContext() { delete p; }
+InheritanceListContext::~InheritanceListContext()
+{
+  delete p;
+}
 
 // TemplateListIntf
-int InheritanceListContext::count() const { return p->count(); }
+int InheritanceListContext::count() const
+{
+  return p->count();
+}
 
-TemplateVariant InheritanceListContext::at(int index) const {
+TemplateVariant InheritanceListContext::at(int index) const
+{
   return p->at(index);
 }
 
-TemplateListIntf::ConstIterator *
-InheritanceListContext::createIterator() const {
+TemplateListIntf::ConstIterator *InheritanceListContext::createIterator() const
+{
   return p->createIterator();
 }
 
 //------------------------------------------------------------------------
 
 //%% list MemberList[Member] : list of inherited classes
-class MemberListContext::Private : public GenericNodeListContext {
-public:
-  void addMember(MemberDef *md) { append(MemberContext::alloc(md)); }
+class MemberListContext::Private : public GenericNodeListContext
+{
+  public:
+    void addMember(MemberDef *md)
+    {
+      append(MemberContext::alloc(md));
+    }
 };
 
-MemberListContext::MemberListContext()
-    : RefCountedContext("MemberListContext") {
+MemberListContext::MemberListContext() : RefCountedContext("MemberListContext")
+{
   p = new Private;
 }
 
-MemberListContext::MemberListContext(const MemberList *list)
-    : RefCountedContext("MemberListContext") {
+MemberListContext::MemberListContext(const MemberList *list) : RefCountedContext("MemberListContext")
+{
   p = new Private;
-  if (list) {
-    bool details = list->listType() & MemberListType_detailedLists;
+  if (list)
+  {
+    bool details = list->listType()&MemberListType_detailedLists;
     MemberListIterator mli(*list);
     MemberDef *md;
-    for (mli.toFirst(); (md = mli.current()); ++mli) {
+    for (mli.toFirst();(md=mli.current());++mli)
+    {
       if ((md->isBriefSectionVisible() && !details) ||
-          (md->isDetailedSectionLinkable() && details)) {
+          (md->isDetailedSectionLinkable() && details)
+         )
+      {
         p->addMember(md);
       }
     }
   }
 }
 
-MemberListContext::MemberListContext(MemberSDict *list, bool doSort)
-    : RefCountedContext("MemberListContext") {
+MemberListContext::MemberListContext(MemberSDict *list,bool doSort) : RefCountedContext("MemberListContext")
+{
   p = new Private;
-  if (list) {
-    if (doSort) {
+  if (list)
+  {
+    if (doSort)
+    {
       list->sort();
     }
     MemberSDict::Iterator it(*list);
     MemberDef *md;
-    for (it.toFirst(); (md = it.current()); ++it) {
+    for (it.toFirst();(md=it.current());++it)
+    {
       p->addMember(md);
     }
   }
 }
 
-MemberListContext::~MemberListContext() { delete p; }
+MemberListContext::~MemberListContext()
+{
+  delete p;
+}
 
 // TemplateListIntf
-int MemberListContext::count() const { return p->count(); }
+int MemberListContext::count() const
+{
+  return p->count();
+}
 
-TemplateVariant MemberListContext::at(int index) const { return p->at(index); }
+TemplateVariant MemberListContext::at(int index) const
+{
+  return p->at(index);
+}
 
-TemplateListIntf::ConstIterator *MemberListContext::createIterator() const {
+TemplateListIntf::ConstIterator *MemberListContext::createIterator() const
+{
   return p->createIterator();
 }
 
@@ -8939,131 +8567,160 @@ TemplateListIntf::ConstIterator *MemberListContext::createIterator() const {
 
 //%% struct MemberInfo: member information
 //%% {
-class MemberInfoContext::Private {
-public:
-  Private(const MemberInfo *mi) : m_memberInfo(mi) {
-    static bool init = FALSE;
-    if (!init) {
-      //%% string protection
-      s_inst.addProperty("protection", &Private::protection);
-      //%% string virtualness
-      s_inst.addProperty("virtualness", &Private::virtualness);
-      //%% string ambiguityScope
-      s_inst.addProperty("ambiguityScope", &Private::ambiguityScope);
-      //%% Member member
-      s_inst.addProperty("member", &Private::member);
-      init = TRUE;
+class MemberInfoContext::Private
+{
+  public:
+    Private(const MemberInfo *mi) : m_memberInfo(mi)
+    {
+      static bool init=FALSE;
+      if (!init)
+      {
+        //%% string protection
+        s_inst.addProperty("protection",    &Private::protection);
+        //%% string virtualness
+        s_inst.addProperty("virtualness",   &Private::virtualness);
+        //%% string ambiguityScope
+        s_inst.addProperty("ambiguityScope",&Private::ambiguityScope);
+        //%% Member member
+        s_inst.addProperty("member",        &Private::member);
+        init=TRUE;
+      }
     }
-  }
-  TemplateVariant get(const char *n) const { return s_inst.get(this, n); }
-  TemplateVariant protection() const {
-    switch (m_memberInfo->prot) {
-    case ::Public:
-      return "public";
-    case ::Protected:
-      return "protected";
-    case ::Private:
-      return "private";
-    case ::Package:
-      return "package";
-    }
-    return "";
-  }
-  TemplateVariant virtualness() const {
-    switch (m_memberInfo->virt) {
-    case ::Normal:
-      return "normal";
-    case ::Virtual:
-      return "virtual";
-    case ::Pure:
-      return "pure";
-    }
-    return "";
-  }
-  TemplateVariant ambiguityScope() const {
-    return m_memberInfo->ambiguityResolutionScope;
-  }
-  TemplateVariant member() const {
-    if (!m_member && m_memberInfo->memberDef) {
-      m_member.reset(MemberContext::alloc(m_memberInfo->memberDef));
+    TemplateVariant get(const char *n) const
+    {
+      return s_inst.get(this,n);
     }
-    if (m_member) {
-      return m_member.get();
-    } else {
-      return TemplateVariant(FALSE);
+    TemplateVariant protection() const
+    {
+      switch (m_memberInfo->prot)
+      {
+        case ::Public:    return "public";
+        case ::Protected: return "protected";
+        case ::Private:   return "private";
+        case ::Package:   return "package";
+      }
+      return "";
     }
-  }
-
-private:
-  const MemberInfo *m_memberInfo;
-  mutable SharedPtr<MemberContext> m_member;
-  static PropertyMapper<MemberInfoContext::Private> s_inst;
+    TemplateVariant virtualness() const
+    {
+      switch (m_memberInfo->virt)
+      {
+        case ::Normal:   return "normal";
+        case ::Virtual:  return "virtual";
+        case ::Pure:     return "pure";
+      }
+      return "";
+    }
+    TemplateVariant ambiguityScope() const
+    {
+      return m_memberInfo->ambiguityResolutionScope;
+    }
+    TemplateVariant member() const
+    {
+      if (!m_member && m_memberInfo->memberDef)
+      {
+        m_member.reset(MemberContext::alloc(m_memberInfo->memberDef));
+      }
+      if (m_member)
+      {
+        return m_member.get();
+      }
+      else
+      {
+        return TemplateVariant(FALSE);
+      }
+    }
+  private:
+    const MemberInfo *m_memberInfo;
+    mutable SharedPtr<MemberContext> m_member;
+    static PropertyMapper<MemberInfoContext::Private> s_inst;
 };
 //%% }
 
 PropertyMapper<MemberInfoContext::Private> MemberInfoContext::Private::s_inst;
 
-MemberInfoContext::MemberInfoContext(const MemberInfo *mi)
-    : RefCountedContext("MemberInfoContext") {
+MemberInfoContext::MemberInfoContext(const MemberInfo *mi) : RefCountedContext("MemberInfoContext")
+{
   p = new Private(mi);
 }
 
-MemberInfoContext::~MemberInfoContext() { delete p; }
+MemberInfoContext::~MemberInfoContext()
+{
+  delete p;
+}
 
-TemplateVariant MemberInfoContext::get(const char *name) const {
+TemplateVariant MemberInfoContext::get(const char *name) const
+{
   return p->get(name);
 }
 
+
 //------------------------------------------------------------------------
 
 //%% list AllMembersList[MemberList] : list of inherited classes
-class AllMembersListContext::Private : public GenericNodeListContext {
-public:
-  Private(const MemberNameInfoSDict *ml) {
-    if (ml) {
-      static bool hideUndocMembers = Config_getBool(HIDE_UNDOC_MEMBERS);
-      MemberNameInfoSDict::Iterator mnii(*ml);
-      MemberNameInfo *mni;
-      for (mnii.toFirst(); (mni = mnii.current()); ++mnii) {
-        MemberNameInfoIterator mnii2(*mni);
-        MemberInfo *mi;
-        for (mnii2.toFirst(); (mi = mnii2.current()); ++mnii2) {
-          MemberDef *md = mi->memberDef;
-          ClassDef *cd = md->getClassDef();
-          if (cd && !md->name().isEmpty() && md->name()[0] != '@') {
-            if ((cd->isLinkable() && md->isLinkable()) ||
-                (!cd->isArtificial() && !hideUndocMembers &&
-                 (protectionLevelVisible(md->protection()) ||
-                  md->isFriend()))) {
-              append(MemberInfoContext::alloc(mi));
+class AllMembersListContext::Private : public GenericNodeListContext
+{
+  public:
+    Private(const MemberNameInfoSDict *ml)
+    {
+      if (ml)
+      {
+        static bool hideUndocMembers = Config_getBool(HIDE_UNDOC_MEMBERS);
+        MemberNameInfoSDict::Iterator mnii(*ml);
+        MemberNameInfo *mni;
+        for (mnii.toFirst();(mni=mnii.current());++mnii)
+        {
+          MemberNameInfoIterator mnii2(*mni);
+          MemberInfo *mi;
+          for (mnii2.toFirst();(mi=mnii2.current());++mnii2)
+          {
+            MemberDef *md=mi->memberDef;
+            ClassDef  *cd=md->getClassDef();
+            if (cd && !md->name().isEmpty() && md->name()[0]!='@')
+            {
+              if ((cd->isLinkable() && md->isLinkable()) ||
+                  (!cd->isArtificial() && !hideUndocMembers &&
+                   (protectionLevelVisible(md->protection()) || md->isFriend())
+                  )
+                 )
+              {
+                append(MemberInfoContext::alloc(mi));
+              }
             }
           }
         }
       }
     }
-  }
 };
 
-AllMembersListContext::AllMembersListContext()
-    : RefCountedContext("AllMembersListContext") {
+AllMembersListContext::AllMembersListContext() : RefCountedContext("AllMembersListContext")
+{
   p = new Private(0);
 }
 
-AllMembersListContext::AllMembersListContext(const MemberNameInfoSDict *ml)
-    : RefCountedContext("AllMembersListContext") {
+AllMembersListContext::AllMembersListContext(const MemberNameInfoSDict *ml) : RefCountedContext("AllMembersListContext")
+{
   p = new Private(ml);
 }
 
-AllMembersListContext::~AllMembersListContext() { delete p; }
+AllMembersListContext::~AllMembersListContext()
+{
+  delete p;
+}
 
 // TemplateListIntf
-int AllMembersListContext::count() const { return p->count(); }
+int AllMembersListContext::count() const
+{
+  return p->count();
+}
 
-TemplateVariant AllMembersListContext::at(int index) const {
+TemplateVariant AllMembersListContext::at(int index) const
+{
   return p->at(index);
 }
 
-TemplateListIntf::ConstIterator *AllMembersListContext::createIterator() const {
+TemplateListIntf::ConstIterator *AllMembersListContext::createIterator() const
+{
   return p->createIterator();
 }
 
@@ -9071,234 +8728,294 @@ TemplateListIntf::ConstIterator *AllMembersListContext::createIterator() const {
 
 //%% struct MemberGroupInfo: member group information
 //%% {
-class MemberGroupInfoContext::Private {
-public:
-  Private(Definition *def, const QCString &relPath, const MemberGroup *mg)
-      : m_def(def), m_relPath(relPath), m_memberGroup(mg) {
-    static bool init = FALSE;
-    if (!init) {
-      s_inst.addProperty("members", &Private::members);
-      s_inst.addProperty("title", &Private::groupTitle);
-      s_inst.addProperty("subtitle", &Private::groupSubtitle);
-      s_inst.addProperty("anchor", &Private::groupAnchor);
-      s_inst.addProperty("memberGroups", &Private::memberGroups);
-      s_inst.addProperty("docs", &Private::docs);
-      s_inst.addProperty("inherited", &Private::inherited);
-      init = TRUE;
+class MemberGroupInfoContext::Private
+{
+  public:
+    Private(Definition *def,const QCString &relPath,const MemberGroup *mg) :
+      m_def(def),
+      m_relPath(relPath),
+      m_memberGroup(mg)
+    {
+      static bool init=FALSE;
+      if (!init)
+      {
+        s_inst.addProperty("members",      &Private::members);
+        s_inst.addProperty("title",        &Private::groupTitle);
+        s_inst.addProperty("subtitle",     &Private::groupSubtitle);
+        s_inst.addProperty("anchor",       &Private::groupAnchor);
+        s_inst.addProperty("memberGroups", &Private::memberGroups);
+        s_inst.addProperty("docs",         &Private::docs);
+        s_inst.addProperty("inherited",    &Private::inherited);
+        init=TRUE;
+      }
     }
-  }
-  TemplateVariant get(const char *n) const { return s_inst.get(this, n); }
-  TemplateVariant members() const {
-    if (!m_cache.memberListContext) {
-      m_cache.memberListContext.reset(
-          MemberListContext::alloc(m_memberGroup->members()));
+    TemplateVariant get(const char *n) const
+    {
+      return s_inst.get(this,n);
     }
-    return m_cache.memberListContext.get();
-  }
-  TemplateVariant groupTitle() const { return m_memberGroup->header(); }
-  TemplateVariant groupSubtitle() const { return ""; }
-  TemplateVariant groupAnchor() const { return m_memberGroup->anchor(); }
-  TemplateVariant memberGroups() const {
-    if (!m_cache.memberGroups) {
-      m_cache.memberGroups.reset(
-          MemberGroupListContext::alloc(m_def, m_relPath, 0));
-    }
-    return m_cache.memberGroups.get();
-  }
-  TemplateVariant docs() const {
-    if (!m_cache.docs) {
-      QCString docs = m_memberGroup->documentation();
-      if (!docs.isEmpty()) {
-        m_cache.docs.reset(new TemplateVariant(
-            parseDoc(m_def, "[@name docs]", -1, // TODO store file & line
-                     m_relPath, m_memberGroup->documentation() + "\n", FALSE)));
-      } else {
-        m_cache.docs.reset(new TemplateVariant(""));
-      }
-    }
-    return *m_cache.docs;
-  }
-  TemplateVariant inherited() const { return FALSE; }
-
-private:
-  Definition *m_def;
-  QCString m_relPath;
-  const MemberGroup *m_memberGroup;
-  struct Cachable {
-    SharedPtr<MemberListContext> memberListContext;
-    SharedPtr<MemberGroupListContext> memberGroups;
-    ScopedPtr<TemplateVariant> docs;
-  };
-  mutable Cachable m_cache;
-  static PropertyMapper<MemberGroupInfoContext::Private> s_inst;
+    TemplateVariant members() const
+    {
+      if (!m_cache.memberListContext)
+      {
+        m_cache.memberListContext.reset(MemberListContext::alloc(m_memberGroup->members()));
+      }
+      return m_cache.memberListContext.get();
+    }
+    TemplateVariant groupTitle() const
+    {
+      return m_memberGroup->header();
+    }
+    TemplateVariant groupSubtitle() const
+    {
+      return "";
+    }
+    TemplateVariant groupAnchor() const
+    {
+      return m_memberGroup->anchor();
+    }
+    TemplateVariant memberGroups() const
+    {
+      if (!m_cache.memberGroups)
+      {
+        m_cache.memberGroups.reset(MemberGroupListContext::alloc(m_def,m_relPath,0));
+      }
+      return m_cache.memberGroups.get();
+    }
+    TemplateVariant docs() const
+    {
+      if (!m_cache.docs)
+      {
+        QCString docs = m_memberGroup->documentation();
+        if (!docs.isEmpty())
+        {
+          m_cache.docs.reset(new TemplateVariant(
+                           parseDoc(m_def,"[@name docs]",-1, // TODO store file & line
+                                    m_relPath,
+                                    m_memberGroup->documentation()+"\n",FALSE)));
+        }
+        else
+        {
+          m_cache.docs.reset(new TemplateVariant(""));
+        }
+      }
+      return *m_cache.docs;
+    }
+    TemplateVariant inherited() const
+    {
+      return FALSE;
+    }
+  private:
+    Definition *m_def;
+    QCString m_relPath;
+    const MemberGroup *m_memberGroup;
+    struct Cachable
+    {
+      SharedPtr<MemberListContext>      memberListContext;
+      SharedPtr<MemberGroupListContext> memberGroups;
+      ScopedPtr<TemplateVariant>        docs;
+    };
+    mutable Cachable m_cache;
+    static PropertyMapper<MemberGroupInfoContext::Private> s_inst;
 };
 //%% }
 
-PropertyMapper<MemberGroupInfoContext::Private>
-    MemberGroupInfoContext::Private::s_inst;
+PropertyMapper<MemberGroupInfoContext::Private> MemberGroupInfoContext::Private::s_inst;
 
 MemberGroupInfoContext::MemberGroupInfoContext(Definition *def,
-                                               const QCString &relPath,
-                                               const MemberGroup *mg)
-    : RefCountedContext("MemberGroupInfoContext") {
-  p = new Private(def, relPath, mg);
+       const QCString &relPath,const MemberGroup *mg) : RefCountedContext("MemberGroupInfoContext")
+{
+  p = new Private(def,relPath,mg);
 }
 
-MemberGroupInfoContext::~MemberGroupInfoContext() { delete p; }
+MemberGroupInfoContext::~MemberGroupInfoContext()
+{
+  delete p;
+}
 
-TemplateVariant MemberGroupInfoContext::get(const char *name) const {
+TemplateVariant MemberGroupInfoContext::get(const char *name) const
+{
   return p->get(name);
 }
 
 //------------------------------------------------------------------------
 
 //%% list MemberGroupList[MemberGroupInfo] : list of member groups
-class MemberGroupListContext::Private : public GenericNodeListContext {
-public:
-  void addMemberGroup(Definition *def, const QCString &relPath,
-                      const MemberGroup *mg) {
-    append(MemberGroupInfoContext::alloc(def, relPath, mg));
-  }
+class MemberGroupListContext::Private : public GenericNodeListContext
+{
+  public:
+    void addMemberGroup(Definition *def,const QCString &relPath,const MemberGroup *mg)
+    {
+      append(MemberGroupInfoContext::alloc(def,relPath,mg));
+    }
 };
 
-MemberGroupListContext::MemberGroupListContext()
-    : RefCountedContext("MemberGroupListContext") {
+MemberGroupListContext::MemberGroupListContext() : RefCountedContext("MemberGroupListContext")
+{
   p = new Private;
 }
 
-MemberGroupListContext::MemberGroupListContext(Definition *def,
-                                               const QCString &relPath,
-                                               const MemberGroupList *list)
-    : RefCountedContext("MemberGroupListContext") {
+MemberGroupListContext::MemberGroupListContext(Definition *def,const QCString &relPath,const MemberGroupList *list) : RefCountedContext("MemberGroupListContext")
+{
   p = new Private;
-  if (list) {
+  if (list)
+  {
     MemberGroupListIterator mgli(*list);
     MemberGroup *mg;
-    for (; (mg = mgli.current()); ++mgli) {
-      p->addMemberGroup(def, relPath, mg);
+    for (;(mg=mgli.current());++mgli)
+    {
+      p->addMemberGroup(def,relPath,mg);
     }
   }
 }
 
-MemberGroupListContext::MemberGroupListContext(Definition *def,
-                                               const QCString &relPath,
-                                               const MemberGroupSDict *dict,
-                                               bool subGrouping)
-    : RefCountedContext("MemberGroupListContext") {
+MemberGroupListContext::MemberGroupListContext(Definition *def,const QCString &relPath,const MemberGroupSDict *dict,bool subGrouping) : RefCountedContext("MemberGroupListContext")
+{
   p = new Private;
-  if (dict) {
+  if (dict)
+  {
     MemberGroupSDict::Iterator di(*dict);
     const MemberGroup *mg;
-    for (di.toFirst(); (mg = di.current()); ++di) {
-      if (!mg->allMembersInSameSection() || !subGrouping) {
-        p->addMemberGroup(def, relPath, mg);
+    for (di.toFirst();(mg=di.current());++di)
+    {
+      if (!mg->allMembersInSameSection() || !subGrouping)
+      {
+        p->addMemberGroup(def,relPath,mg);
       }
     }
   }
 }
 
-MemberGroupListContext::~MemberGroupListContext() { delete p; }
-
+MemberGroupListContext::~MemberGroupListContext()
+{
+  delete p;
+}
+
 // TemplateListIntf
-int MemberGroupListContext::count() const { return p->count(); }
+int MemberGroupListContext::count() const
+{
+  return p->count();
+}
 
-TemplateVariant MemberGroupListContext::at(int index) const {
+TemplateVariant MemberGroupListContext::at(int index) const
+{
   return p->at(index);
 }
 
-TemplateListIntf::ConstIterator *
-MemberGroupListContext::createIterator() const {
+TemplateListIntf::ConstIterator *MemberGroupListContext::createIterator() const
+{
   return p->createIterator();
 }
 
+
 //------------------------------------------------------------------------
 
 //%% struct MemberListInfo: member list information
 //%% {
-class MemberListInfoContext::Private {
-public:
-  Private(Definition *def, const QCString &relPath, const MemberList *ml,
-          const QCString &title, const QCString &subtitle)
-      : m_def(def), m_memberList(ml), m_relPath(relPath), m_title(title),
-        m_subtitle(subtitle) {
-    static bool init = FALSE;
-    if (!init) {
-      s_inst.addProperty("members", &Private::members);
-      s_inst.addProperty("title", &Private::title);
-      s_inst.addProperty("subtitle", &Private::subtitle);
-      s_inst.addProperty("anchor", &Private::anchor);
-      s_inst.addProperty("memberGroups", &Private::memberGroups);
-      s_inst.addProperty("inherited", &Private::inherited);
-      init = TRUE;
+class MemberListInfoContext::Private
+{
+  public:
+    Private(Definition *def,const QCString &relPath,const MemberList *ml,const QCString &title,const QCString &subtitle) :
+      m_def(def),
+      m_memberList(ml),
+      m_relPath(relPath),
+      m_title(title),
+      m_subtitle(subtitle)
+    {
+      static bool init=FALSE;
+      if (!init)
+      {
+        s_inst.addProperty("members",      &Private::members);
+        s_inst.addProperty("title",        &Private::title);
+        s_inst.addProperty("subtitle",     &Private::subtitle);
+        s_inst.addProperty("anchor",       &Private::anchor);
+        s_inst.addProperty("memberGroups", &Private::memberGroups);
+        s_inst.addProperty("inherited",    &Private::inherited);
+        init=TRUE;
+      }
     }
-  }
-  TemplateVariant get(const char *n) const { return s_inst.get(this, n); }
-  TemplateVariant members() const {
-    if (!m_cache.memberListContext) {
-      m_cache.memberListContext.reset(MemberListContext::alloc(m_memberList));
+    TemplateVariant get(const char *n) const
+    {
+      return s_inst.get(this,n);
     }
-    return m_cache.memberListContext.get();
-  }
-  TemplateVariant title() const { return m_title; }
-  TemplateVariant subtitle() const { return m_subtitle; }
-  TemplateVariant anchor() const {
-    return MemberList::listTypeAsString(m_memberList->listType());
-  }
-  TemplateVariant memberGroups() const {
-    if (!m_cache.memberGroups) {
-      m_cache.memberGroups.reset(MemberGroupListContext::alloc(
-          m_def, m_relPath, m_memberList->getMemberGroupList()));
+    TemplateVariant members() const
+    {
+      if (!m_cache.memberListContext)
+      {
+        m_cache.memberListContext.reset(MemberListContext::alloc(m_memberList));
+      }
+      return m_cache.memberListContext.get();
     }
-    return m_cache.memberGroups.get();
-  }
-  TemplateVariant inherited() const {
-    if (!m_cache.inherited &&
-        (m_memberList->listType() & MemberListType_detailedLists) == 0 &&
-        m_def->definitionType() == Definition::TypeClass) {
-      InheritedMemberInfoListContext *ctx =
-          InheritedMemberInfoListContext::alloc();
-      ctx->addMemberList((ClassDef *)m_def, m_memberList->listType(), m_title,
-                         FALSE);
-      m_cache.inherited.reset(ctx);
-    }
-    if (m_cache.inherited) {
-      return m_cache.inherited.get();
-    } else {
-      return TemplateVariant(FALSE);
+    TemplateVariant title() const
+    {
+      return m_title;
     }
-  }
-
-private:
-  Definition *m_def;
-  const MemberList *m_memberList;
-  QCString m_relPath;
-  QCString m_title;
-  QCString m_subtitle;
-  struct Cachable {
-    SharedPtr<MemberListContext> memberListContext;
-    SharedPtr<MemberGroupListContext> memberGroups;
-    SharedPtr<InheritedMemberInfoListContext> inherited;
-  };
-  mutable Cachable m_cache;
-  static PropertyMapper<MemberListInfoContext::Private> s_inst;
+    TemplateVariant subtitle() const
+    {
+      return m_subtitle;
+    }
+    TemplateVariant anchor() const
+    {
+      return MemberList::listTypeAsString(m_memberList->listType());
+    }
+    TemplateVariant memberGroups() const
+    {
+      if (!m_cache.memberGroups)
+      {
+        m_cache.memberGroups.reset(MemberGroupListContext::alloc(m_def,m_relPath,m_memberList->getMemberGroupList()));
+      }
+      return m_cache.memberGroups.get();
+    }
+    TemplateVariant inherited() const
+    {
+      if (!m_cache.inherited && (m_memberList->listType()&MemberListType_detailedLists)==0 &&
+          m_def->definitionType()==Definition::TypeClass)
+      {
+        InheritedMemberInfoListContext *ctx = InheritedMemberInfoListContext::alloc();
+        ctx->addMemberList((ClassDef*)m_def,m_memberList->listType(),m_title,FALSE);
+        m_cache.inherited.reset(ctx);
+      }
+      if (m_cache.inherited)
+      {
+        return m_cache.inherited.get();
+      }
+      else
+      {
+        return TemplateVariant(FALSE);
+      }
+    }
+  private:
+    Definition *m_def;
+    const MemberList *m_memberList;
+    QCString m_relPath;
+    QCString m_title;
+    QCString m_subtitle;
+    struct Cachable
+    {
+      SharedPtr<MemberListContext> memberListContext;
+      SharedPtr<MemberGroupListContext> memberGroups;
+      SharedPtr<InheritedMemberInfoListContext> inherited;
+    };
+    mutable Cachable m_cache;
+    static PropertyMapper<MemberListInfoContext::Private> s_inst;
 };
 //%% }
 
-PropertyMapper<MemberListInfoContext::Private>
-    MemberListInfoContext::Private::s_inst;
+PropertyMapper<MemberListInfoContext::Private> MemberListInfoContext::Private::s_inst;
 
-MemberListInfoContext::MemberListInfoContext(Definition *def,
-                                             const QCString &relPath,
-                                             const MemberList *ml,
-                                             const QCString &title,
-                                             const QCString &subtitle)
-    : RefCountedContext("MemberListInfoContext") {
-  p = new Private(def, relPath, ml, title, subtitle);
+MemberListInfoContext::MemberListInfoContext(
+           Definition *def,const QCString &relPath,const MemberList *ml,
+           const QCString &title,const QCString &subtitle) : RefCountedContext("MemberListInfoContext")
+{
+  p = new Private(def,relPath,ml,title,subtitle);
 }
 
-MemberListInfoContext::~MemberListInfoContext() { delete p; }
+MemberListInfoContext::~MemberListInfoContext()
+{
+  delete p;
+}
 
-TemplateVariant MemberListInfoContext::get(const char *name) const {
+TemplateVariant MemberListInfoContext::get(const char *name) const
+{
   return p->get(name);
 }
 
@@ -9306,219 +9023,249 @@ TemplateVariant MemberListInfoContext::get(const char *name) const {
 
 //%% struct InheritedMemberInfo: inherited member information
 //%% {
-class InheritedMemberInfoContext::Private {
-public:
-  Private(ClassDef *cd, MemberList *ml, const QCString &title)
-      : m_class(cd), m_memberList(ml), m_title(title) {
-    static bool init = FALSE;
-    if (!init) {
-      s_inst.addProperty("class", &Private::getClass);
-      s_inst.addProperty("title", &Private::title);
-      s_inst.addProperty("members", &Private::members);
-      s_inst.addProperty("id", &Private::id);
-      s_inst.addProperty("inheritedFrom", &Private::inheritedFrom);
-      init = TRUE;
+class InheritedMemberInfoContext::Private
+{
+  public:
+    Private(ClassDef *cd,MemberList *ml,const QCString &title)
+      : m_class(cd), m_memberList(ml), m_title(title)
+    {
+      static bool init=FALSE;
+      if (!init)
+      {
+        s_inst.addProperty("class",         &Private::getClass);
+        s_inst.addProperty("title",         &Private::title);
+        s_inst.addProperty("members",       &Private::members);
+        s_inst.addProperty("id",            &Private::id);
+        s_inst.addProperty("inheritedFrom", &Private::inheritedFrom);
+        init=TRUE;
+      }
     }
-  }
-  TemplateVariant get(const char *n) const { return s_inst.get(this, n); }
-  virtual ~Private() { delete m_memberList; }
-  TemplateVariant getClass() const {
-    if (!m_classCtx) {
-      m_classCtx.reset(ClassContext::alloc(m_class));
+    TemplateVariant get(const char *n) const
+    {
+      return s_inst.get(this,n);
     }
-    return m_classCtx.get();
-  }
-  TemplateVariant title() const { return m_title; }
-  TemplateVariant members() const {
-    if (!m_memberListCtx) {
-      m_memberListCtx.reset(MemberListContext::alloc(m_memberList));
+    virtual ~Private()
+    {
+      delete m_memberList;
     }
-    return m_memberListCtx.get();
-  }
-  TemplateVariant id() const {
-    return substitute(MemberList::listTypeAsString(m_memberList->listType()),
-                      "-", "_") +
-           "_" + stripPath(m_class->getOutputFileBase());
-  }
-  TemplateVariant inheritedFrom() const {
-    if (!m_inheritedFrom) {
-      m_inheritedFrom.reset(TemplateList::alloc());
-      m_inheritedFrom->append(title());
-      m_inheritedFrom->append(getClass());
+    TemplateVariant getClass() const
+    {
+      if (!m_classCtx)
+      {
+        m_classCtx.reset(ClassContext::alloc(m_class));
+      }
+      return m_classCtx.get();
+    }
+    TemplateVariant title() const
+    {
+      return m_title;
+    }
+    TemplateVariant members() const
+    {
+      if (!m_memberListCtx)
+      {
+        m_memberListCtx.reset(MemberListContext::alloc(m_memberList));
+      }
+      return m_memberListCtx.get();
+    }
+    TemplateVariant id() const
+    {
+      return substitute(MemberList::listTypeAsString(m_memberList->listType()),"-","_")+"_"+
+                        stripPath(m_class->getOutputFileBase());
+    }
+    TemplateVariant inheritedFrom() const
+    {
+      if (!m_inheritedFrom)
+      {
+        m_inheritedFrom.reset(TemplateList::alloc());
+        m_inheritedFrom->append(title());
+        m_inheritedFrom->append(getClass());
+      }
+      return m_inheritedFrom.get();
     }
-    return m_inheritedFrom.get();
-  }
 
-private:
-  ClassDef *m_class;
-  MemberList *m_memberList;
-  QCString m_title;
-  mutable SharedPtr<ClassContext> m_classCtx;
-  mutable SharedPtr<MemberListContext> m_memberListCtx;
-  mutable SharedPtr<TemplateList> m_inheritedFrom;
-  static PropertyMapper<InheritedMemberInfoContext::Private> s_inst;
+  private:
+    ClassDef *  m_class;
+    MemberList *m_memberList;
+    QCString    m_title;
+    mutable SharedPtr<ClassContext> m_classCtx;
+    mutable SharedPtr<MemberListContext> m_memberListCtx;
+    mutable SharedPtr<TemplateList> m_inheritedFrom;
+    static PropertyMapper<InheritedMemberInfoContext::Private> s_inst;
 };
 //%% }
 
-PropertyMapper<InheritedMemberInfoContext::Private>
-    InheritedMemberInfoContext::Private::s_inst;
+PropertyMapper<InheritedMemberInfoContext::Private> InheritedMemberInfoContext::Private::s_inst;
 
-InheritedMemberInfoContext::InheritedMemberInfoContext(ClassDef *cd,
-                                                       MemberList *ml,
-                                                       const QCString &title)
-    : RefCountedContext("InheritedMemberInfoContext") {
-  p = new Private(cd, ml, title);
+InheritedMemberInfoContext::InheritedMemberInfoContext(ClassDef *cd,MemberList *ml,
+                                                       const QCString &title) : RefCountedContext("InheritedMemberInfoContext")
+{
+  p = new Private(cd,ml,title);
 }
 
-InheritedMemberInfoContext::~InheritedMemberInfoContext() { delete p; }
+InheritedMemberInfoContext::~InheritedMemberInfoContext()
+{
+  delete p;
+}
 
-TemplateVariant InheritedMemberInfoContext::get(const char *name) const {
+TemplateVariant InheritedMemberInfoContext::get(const char *name) const
+{
   return p->get(name);
 }
 
 //------------------------------------------------------------------------
 
 //%% list InheritedMemberList[InheritedMemberInfo] : list of inherited classes
-class InheritedMemberInfoListContext::Private : public GenericNodeListContext {
-public:
-  void addMemberList(ClassDef *inheritedFrom, MemberList *ml,
-                     MemberList *combinedList) {
-    if (ml) {
-      MemberListIterator li(*ml);
-      MemberDef *md;
-      for (li.toFirst(); (md = li.current()); ++li) {
-        if (md->isBriefSectionVisible() &&
-            !md->isReimplementedBy(inheritedFrom)) {
-          combinedList->append(md);
+class InheritedMemberInfoListContext::Private : public GenericNodeListContext
+{
+  public:
+    void addMemberList(ClassDef *inheritedFrom,MemberList *ml,MemberList *combinedList)
+    {
+      if (ml)
+      {
+        MemberListIterator li(*ml);
+        MemberDef *md;
+        for (li.toFirst();(md=li.current());++li)
+        {
+          if (md->isBriefSectionVisible() && !md->isReimplementedBy(inheritedFrom))
+          {
+            combinedList->append(md);
+          }
         }
       }
     }
-  }
-  void addMemberListIncludingGrouped(ClassDef *inheritedFrom, MemberList *ml,
-                                     MemberList *combinedList) {
-    if (ml) {
-      addMemberList(inheritedFrom, ml, combinedList);
-      if (ml->getMemberGroupList()) {
-        MemberGroupListIterator mgli(*ml->getMemberGroupList());
-        MemberGroup *mg;
-        for (mgli.toFirst(); (mg = mgli.current()); ++mgli) {
-          addMemberList(inheritedFrom, mg->members(), combinedList);
+    void addMemberListIncludingGrouped(ClassDef *inheritedFrom,MemberList *ml,MemberList *combinedList)
+    {
+      if (ml)
+      {
+        addMemberList(inheritedFrom,ml,combinedList);
+        if (ml->getMemberGroupList())
+        {
+          MemberGroupListIterator mgli(*ml->getMemberGroupList());
+          MemberGroup *mg;
+          for (mgli.toFirst();(mg=mgli.current());++mgli)
+          {
+            addMemberList(inheritedFrom,mg->members(),combinedList);
+          }
         }
       }
     }
-  }
-  void addMemberGroupsOfClass(ClassDef *inheritedFrom, ClassDef *cd,
-                              MemberListType lt, MemberList *combinedList) {
-    if (cd->getMemberGroupSDict()) {
-      MemberGroupSDict::Iterator mgli(*cd->getMemberGroupSDict());
-      MemberGroup *mg;
-      for (; (mg = mgli.current()); ++mgli) {
-        if (mg->members() &&
-            (!mg->allMembersInSameSection() ||
-             !cd->subGrouping())) // group is in its own section
-        {
-          MemberListIterator li(*mg->members());
-          MemberDef *md;
-          for (li.toFirst(); (md = li.current()); ++li) {
-            if (lt == md->getSectionList(mg->parent())->listType() &&
-                !md->isReimplementedBy(inheritedFrom) &&
-                md->isBriefSectionVisible()) {
-              combinedList->append(md);
+    void addMemberGroupsOfClass(ClassDef *inheritedFrom,
+                                ClassDef *cd,MemberListType lt,MemberList *combinedList)
+    {
+      if (cd->getMemberGroupSDict())
+      {
+        MemberGroupSDict::Iterator mgli(*cd->getMemberGroupSDict());
+        MemberGroup *mg;
+        for (;(mg=mgli.current());++mgli)
+        {
+          if (mg->members() && (!mg->allMembersInSameSection() || !cd->subGrouping())) // group is in its own section
+          {
+            MemberListIterator li(*mg->members());
+            MemberDef *md;
+            for (li.toFirst();(md=li.current());++li)
+            {
+              if (lt==md->getSectionList(mg->parent())->listType() &&
+                  !md->isReimplementedBy(inheritedFrom) &&
+                  md->isBriefSectionVisible())
+              {
+                combinedList->append(md);
+              }
             }
           }
         }
       }
     }
-  }
-  void addInheritedMembers(ClassDef *inheritedFrom, ClassDef *cd,
-                           MemberListType lt, MemberListType lt1, int lt2,
-                           const QCString &title, bool additionalList) {
-    int count =
-        cd->countMembersIncludingGrouped(lt1, inheritedFrom, additionalList);
-    if (lt2 != -1)
-      count += cd->countMembersIncludingGrouped((MemberListType)lt2,
-                                                inheritedFrom, additionalList);
-    if (count > 0) {
-      MemberList *ml = cd->getMemberList(lt1);
-      MemberList *ml2 = lt2 != -1 ? cd->getMemberList((MemberListType)lt2) : 0;
-      MemberList *combinedList = new MemberList(lt);
-      addMemberListIncludingGrouped(inheritedFrom, ml, combinedList);
-      addMemberListIncludingGrouped(inheritedFrom, ml2, combinedList);
-      addMemberGroupsOfClass(inheritedFrom, cd, lt, combinedList);
-      if (lt2 != -1)
-        addMemberGroupsOfClass(inheritedFrom, cd, (MemberListType)lt2,
-                               combinedList);
-      append(InheritedMemberInfoContext::alloc(cd, combinedList, title));
+    void addInheritedMembers(ClassDef *inheritedFrom,ClassDef *cd,MemberListType lt,
+                             MemberListType lt1,int lt2,const QCString &title,bool additionalList)
+    {
+      int count = cd->countMembersIncludingGrouped(lt1,inheritedFrom,additionalList);
+      if (lt2!=-1) count += cd->countMembersIncludingGrouped((MemberListType)lt2,inheritedFrom,additionalList);
+      if (count>0)
+      {
+        MemberList *ml  = cd->getMemberList(lt1);
+        MemberList *ml2 = lt2!=-1 ? cd->getMemberList((MemberListType)lt2) : 0;
+        MemberList *combinedList = new MemberList(lt);
+        addMemberListIncludingGrouped(inheritedFrom,ml,combinedList);
+        addMemberListIncludingGrouped(inheritedFrom,ml2,combinedList);
+        addMemberGroupsOfClass(inheritedFrom,cd,lt,combinedList);
+        if (lt2!=-1) addMemberGroupsOfClass(inheritedFrom,cd,(MemberListType)lt2,combinedList);
+        append(InheritedMemberInfoContext::alloc(cd,combinedList,title));
+      }
     }
-  }
-  void findInheritedMembers(ClassDef *inheritedFrom, ClassDef *cd,
-                            MemberListType lt, int lt2, const QCString &title,
-                            bool additionalList,
-                            QPtrDict<void> *visitedClasses) {
-    if (cd->baseClasses()) {
-      BaseClassListIterator it(*cd->baseClasses());
-      BaseClassDef *ibcd;
-      for (it.toFirst(); (ibcd = it.current()); ++it) {
-        ClassDef *icd = ibcd->classDef;
-        if (icd->isLinkable()) {
-          int lt1, lt3;
-          convertProtectionLevel(lt, ibcd->prot, &lt1, &lt3);
-          if (lt2 == -1 && lt3 != -1) {
-            lt2 = lt3;
-          }
-          if (visitedClasses->find(icd) == 0) {
-            visitedClasses->insert(
-                icd, icd); // guard for multiple virtual inheritance
-            if (lt1 != -1) {
-              // add member info for members of cd with list type lt
-              addInheritedMembers(inheritedFrom, icd, lt, (MemberListType)lt1,
-                                  lt2, title, additionalList);
-              // recurse down the inheritance tree
-              findInheritedMembers(inheritedFrom, icd, (MemberListType)lt1, lt2,
-                                   title, additionalList, visitedClasses);
+    void findInheritedMembers(ClassDef *inheritedFrom,ClassDef *cd,MemberListType lt,
+                              int lt2, const QCString &title,bool additionalList,
+                              QPtrDict<void> *visitedClasses)
+    {
+      if (cd->baseClasses())
+      {
+        BaseClassListIterator it(*cd->baseClasses());
+        BaseClassDef *ibcd;
+        for (it.toFirst();(ibcd=it.current());++it)
+        {
+          ClassDef *icd=ibcd->classDef;
+          if (icd->isLinkable())
+          {
+            int lt1,lt3;
+            convertProtectionLevel(lt,ibcd->prot,&lt1,&lt3);
+            if (lt2==-1 && lt3!=-1)
+            {
+              lt2=lt3;
+            }
+            if (visitedClasses->find(icd)==0)
+            {
+              visitedClasses->insert(icd,icd); // guard for multiple virtual inheritance
+              if (lt1!=-1)
+              {
+                // add member info for members of cd with list type lt
+                addInheritedMembers(inheritedFrom,icd,lt,(MemberListType)lt1,lt2,title,additionalList);
+                // recurse down the inheritance tree
+                findInheritedMembers(inheritedFrom,icd,(MemberListType)lt1,lt2,title,additionalList,visitedClasses);
+              }
             }
           }
         }
       }
     }
-  }
 };
 
-InheritedMemberInfoListContext::InheritedMemberInfoListContext()
-    : RefCountedContext("InheritedMemberInfoListContext") {
+InheritedMemberInfoListContext::InheritedMemberInfoListContext() : RefCountedContext("InheritedMemberInfoListContext")
+{
   p = new Private;
 }
 
-void InheritedMemberInfoListContext::addMemberList(ClassDef *cd,
-                                                   MemberListType lt,
-                                                   const QCString &title,
-                                                   bool additionalList) {
+void InheritedMemberInfoListContext::addMemberList(
+    ClassDef *cd,MemberListType lt,const QCString &title,bool additionalList)
+{
   QPtrDict<void> visited(17);
-  bool memberInSection = cd->countMembersIncludingGrouped(lt, cd, FALSE) > 0;
-  bool show = (additionalList && !memberInSection) || // inherited member to
-                                                      // show in the additional
-                                                      // inherited members list
-              (!additionalList && memberInSection); // inherited member to show
-                                                    // in a member list of the
-                                                    // class
-  // printf("%s:%s
-  // show=%d\n",cd->name().data(),MemberList::listTypeAsString(lt).data(),show);
-  if (show) {
-    p->findInheritedMembers(cd, cd, lt, -1, title, additionalList, &visited);
+  bool memberInSection = cd->countMembersIncludingGrouped(lt,cd,FALSE)>0;
+  bool show = (additionalList && !memberInSection) || // inherited member to show in the additional inherited members list
+              (!additionalList && memberInSection);   // inherited member to show in a member list of the class
+  //printf("%s:%s show=%d\n",cd->name().data(),MemberList::listTypeAsString(lt).data(),show);
+  if (show)
+  {
+    p->findInheritedMembers(cd,cd,lt,-1,title,additionalList,&visited);
   }
 }
 
-InheritedMemberInfoListContext::~InheritedMemberInfoListContext() { delete p; }
+InheritedMemberInfoListContext::~InheritedMemberInfoListContext()
+{
+  delete p;
+}
 
 // TemplateListIntf
-int InheritedMemberInfoListContext::count() const { return p->count(); }
+int InheritedMemberInfoListContext::count() const
+{
+  return p->count();
+}
 
-TemplateVariant InheritedMemberInfoListContext::at(int index) const {
+TemplateVariant InheritedMemberInfoListContext::at(int index) const
+{
   return p->at(index);
 }
 
-TemplateListIntf::ConstIterator *
-InheritedMemberInfoListContext::createIterator() const {
+TemplateListIntf::ConstIterator *InheritedMemberInfoListContext::createIterator() const
+{
   return p->createIterator();
 }
 
@@ -9526,121 +9273,157 @@ InheritedMemberInfoListContext::createIterator() const {
 
 //%% struct Argument: parameter information
 //%% {
-class ArgumentContext::Private {
-public:
-  Private(const Argument *arg, Definition *def, const QCString &relPath)
-      : m_argument(arg), m_def(def), m_relPath(relPath) {
-    static bool init = FALSE;
-    if (!init) {
-      s_inst.addProperty("type", &Private::type);
-      s_inst.addProperty("name", &Private::name);
-      s_inst.addProperty("defVal", &Private::defVal);
-      s_inst.addProperty("docs", &Private::docs);
-      s_inst.addProperty("attrib", &Private::attrib);
-      s_inst.addProperty("array", &Private::array);
-      s_inst.addProperty("namePart", &Private::namePart);
-      init = TRUE;
+class ArgumentContext::Private
+{
+  public:
+    Private(const Argument *arg,Definition *def,const QCString &relPath) :
+      m_argument(arg), m_def(def), m_relPath(relPath)
+    {
+      static bool init=FALSE;
+      if (!init)
+      {
+        s_inst.addProperty("type",     &Private::type);
+        s_inst.addProperty("name",     &Private::name);
+        s_inst.addProperty("defVal",   &Private::defVal);
+        s_inst.addProperty("docs",     &Private::docs);
+        s_inst.addProperty("attrib",   &Private::attrib);
+        s_inst.addProperty("array",    &Private::array);
+        s_inst.addProperty("namePart", &Private::namePart);
+        init=TRUE;
+      }
     }
-  }
-  TemplateVariant get(const char *n) const { return s_inst.get(this, n); }
-  TemplateVariant type() const {
-    return createLinkedText(m_def, m_relPath, m_argument->type);
-  }
-  TemplateVariant attrib() const { return m_argument->attrib; }
-  TemplateVariant name() const { return m_argument->name; }
-  TemplateVariant defVal() const {
-    return createLinkedText(m_def, m_relPath, m_argument->defval);
-  }
-  TemplateVariant array() const { return m_argument->array; }
-  TemplateVariant docs() const {
-    if (!m_cache.docs && m_def) {
-      if (!m_argument->docs.isEmpty()) {
-        m_cache.docs.reset(new TemplateVariant(
-            parseDoc(m_def, m_def->docFile(), m_def->docLine(), m_relPath,
-                     m_argument->docs, TRUE)));
-      } else {
-        m_cache.docs.reset(new TemplateVariant(""));
-      }
-    }
-    return *m_cache.docs;
-  }
-  TemplateVariant namePart() const {
-    QCString result = m_argument->attrib;
-    int l = result.length();
-    if (l > 2 && result.at(0) == '[' && result.at(l - 1) == ']') {
-      result = result.mid(1, l - 2);
-      if (result != ",")
-        result += ":"; // for normal keywords add colon
-    }
-    return result;
-  }
-
-private:
-  const Argument *m_argument;
-  Definition *m_def;
-  QCString m_relPath;
-  struct Cachable {
-    ScopedPtr<TemplateVariant> docs;
-  };
-  mutable Cachable m_cache;
-  static PropertyMapper<ArgumentContext::Private> s_inst;
+    TemplateVariant get(const char *n) const
+    {
+      return s_inst.get(this,n);
+    }
+    TemplateVariant type() const
+    {
+      return createLinkedText(m_def,m_relPath,m_argument->type);
+    }
+    TemplateVariant attrib() const
+    {
+      return m_argument->attrib;
+    }
+    TemplateVariant name() const
+    {
+      return m_argument->name;
+    }
+    TemplateVariant defVal() const
+    {
+      return createLinkedText(m_def,m_relPath,m_argument->defval);
+    }
+    TemplateVariant array() const
+    {
+      return m_argument->array;
+    }
+    TemplateVariant docs() const
+    {
+      if (!m_cache.docs && m_def)
+      {
+        if (!m_argument->docs.isEmpty())
+        {
+          m_cache.docs.reset(new TemplateVariant(
+                             parseDoc(m_def,m_def->docFile(),m_def->docLine(),
+                             m_relPath,m_argument->docs,TRUE)));
+        }
+        else
+        {
+          m_cache.docs.reset(new TemplateVariant(""));
+        }
+      }
+      return *m_cache.docs;
+    }
+    TemplateVariant namePart() const
+    {
+      QCString result = m_argument->attrib;
+      int l = result.length();
+      if (l>2 && result.at(0)=='[' && result.at(l-1)==']')
+      {
+        result = result.mid(1,l-2);
+        if (result!=",") result+=":"; // for normal keywords add colon
+      }
+      return result;
+    }
+  private:
+    const Argument *m_argument;
+    Definition *m_def;
+    QCString m_relPath;
+    struct Cachable
+    {
+      ScopedPtr<TemplateVariant> docs;
+    };
+    mutable Cachable m_cache;
+    static PropertyMapper<ArgumentContext::Private> s_inst;
 };
 //%% }
 
 PropertyMapper<ArgumentContext::Private> ArgumentContext::Private::s_inst;
 
-ArgumentContext::ArgumentContext(const Argument *al, Definition *def,
-                                 const QCString &relPath)
-    : RefCountedContext("ArgumentContext") {
-  p = new Private(al, def, relPath);
+ArgumentContext::ArgumentContext(const Argument *al,Definition *def,const QCString &relPath) : RefCountedContext("ArgumentContext")
+{
+  p = new Private(al,def,relPath);
 }
 
-ArgumentContext::~ArgumentContext() { delete p; }
+ArgumentContext::~ArgumentContext()
+{
+  delete p;
+}
 
-TemplateVariant ArgumentContext::get(const char *name) const {
+TemplateVariant ArgumentContext::get(const char *name) const
+{
   return p->get(name);
 }
 
 //------------------------------------------------------------------------
 
 //%% list ArgumentList[Argument] : list of inherited classes
-class ArgumentListContext::Private : public GenericNodeListContext {
-public:
-  void addArgument(const Argument *arg, Definition *def,
-                   const QCString &relPath) {
-    append(ArgumentContext::alloc(arg, def, relPath));
-  }
+class ArgumentListContext::Private : public GenericNodeListContext
+{
+  public:
+    void addArgument(const Argument *arg,Definition *def,const QCString &relPath)
+    {
+      append(ArgumentContext::alloc(arg,def,relPath));
+    }
 };
 
-ArgumentListContext::ArgumentListContext()
-    : RefCountedContext("ArgumentListContext") {
+ArgumentListContext::ArgumentListContext() : RefCountedContext("ArgumentListContext")
+{
   p = new Private;
 }
 
 ArgumentListContext::ArgumentListContext(const ArgumentList *list,
-                                         Definition *def,
-                                         const QCString &relPath)
-    : RefCountedContext("ArgumentListContext") {
+                        Definition *def,const QCString &relPath) : RefCountedContext("ArgumentListContext")
+{
   p = new Private;
-  if (list) {
+  if (list)
+  {
     ArgumentListIterator ali(*list);
     const Argument *arg;
-    for (ali.toFirst(); (arg = ali.current()); ++ali) {
-      p->addArgument(arg, def, relPath);
+    for (ali.toFirst();(arg=ali.current());++ali)
+    {
+      p->addArgument(arg,def,relPath);
     }
   }
 }
 
-ArgumentListContext::~ArgumentListContext() { delete p; }
+ArgumentListContext::~ArgumentListContext()
+{
+  delete p;
+}
 
 // TemplateListIntf
-int ArgumentListContext::count() const { return p->count(); }
+int ArgumentListContext::count() const
+{
+  return p->count();
+}
 
-TemplateVariant ArgumentListContext::at(int index) const {
+TemplateVariant ArgumentListContext::at(int index) const
+{
   return p->at(index);
 }
 
-TemplateListIntf::ConstIterator *ArgumentListContext::createIterator() const {
+TemplateListIntf::ConstIterator *ArgumentListContext::createIterator() const
+{
   return p->createIterator();
 }
 
@@ -9665,142 +9448,177 @@ TemplateListIntf::ConstIterator *ArgumentListContext::createIterator() const {
 
 //%% struct SymbolGroup: search group of similar symbols
 //%% {
-class SymbolContext::Private {
-public:
-  Private(const Definition *d, const Definition *prev, const Definition *next)
-      : m_def(d), m_prevDef(prev), m_nextDef(next) {
-    static bool init = FALSE;
-    if (!init) {
-      s_inst.addProperty("fileName", &Private::fileName);
-      s_inst.addProperty("anchor", &Private::anchor);
-      s_inst.addProperty("scope", &Private::scope);
-      s_inst.addProperty("relPath", &Private::relPath);
-      init = TRUE;
+class SymbolContext::Private
+{
+  public:
+    Private(const Definition *d,const Definition *prev,
+            const Definition *next) : m_def(d), m_prevDef(prev), m_nextDef(next)
+    {
+      static bool init=FALSE;
+      if (!init)
+      {
+        s_inst.addProperty("fileName",&Private::fileName);
+        s_inst.addProperty("anchor",  &Private::anchor);
+        s_inst.addProperty("scope",   &Private::scope);
+        s_inst.addProperty("relPath", &Private::relPath);
+        init=TRUE;
+      }
+    }
+    TemplateVariant get(const char *n) const
+    {
+      return s_inst.get(this,n);
+    }
+    TemplateVariant fileName() const
+    {
+      return m_def->getOutputFileBase();
+    }
+    TemplateVariant anchor() const
+    {
+      return m_def->anchor();
+    }
+    TemplateVariant scope() const
+    {
+      const Definition *scope     = m_def->getOuterScope();
+      const Definition *next      = m_nextDef;
+      const Definition *prev      = m_prevDef;
+      const Definition *nextScope = next ? next->getOuterScope() : 0;
+      const Definition *prevScope = prev ? prev->getOuterScope() : 0;
+      bool isMemberDef            = m_def->definitionType()==Definition::TypeMember;
+      const MemberDef  *md        = isMemberDef ? (const MemberDef*)m_def : 0;
+      bool isFunctionLike   = md && (md->isFunction() || md->isSlot() || md->isSignal());
+      bool overloadedFunction = isFunctionLike &&
+                                ((prevScope!=0 && scope==prevScope) || (scope && scope==nextScope));
+      QCString prefix;
+      if (md) prefix=md->localName();
+      if (overloadedFunction) // overloaded member function
+      {
+        prefix+=md->argsString();
+        // show argument list to disambiguate overloaded functions
+      }
+      else if (md && isFunctionLike) // unique member function
+      {
+        prefix+="()"; // only to show it is a function
+      }
+      bool found=FALSE;
+      QCString name;
+      if (m_def->definitionType()==Definition::TypeClass)
+      {
+        name = m_def->displayName();
+        found = TRUE;
+      }
+      else if (m_def->definitionType()==Definition::TypeNamespace)
+      {
+        name = m_def->displayName();
+        found = TRUE;
+      }
+      else if (scope==0 || scope==Doxygen::globalScope) // in global scope
+      {
+        if (md)
+        {
+          FileDef *fd = md->getBodyDef();
+          if (fd==0) fd = md->getFileDef();
+          if (fd)
+          {
+            if (!prefix.isEmpty()) prefix+=": ";
+            name = prefix + convertToXML(fd->localName());
+            found = TRUE;
+          }
+        }
+      }
+      else if (md && (md->getClassDef() || md->getNamespaceDef()))
+        // member in class or namespace scope
+      {
+        SrcLangExt lang = md->getLanguage();
+        name = m_def->getOuterScope()->qualifiedName()
+          + getLanguageSpecificSeparator(lang) + prefix;
+        found = TRUE;
+      }
+      else if (scope) // some thing else? -> show scope
+      {
+        name = prefix + convertToXML(scope->name());
+        found = TRUE;
+      }
+      if (!found) // fallback
+      {
+        name = prefix + "("+theTranslator->trGlobalNamespace()+")";
+      }
+      return name;
     }
-  }
-  TemplateVariant get(const char *n) const { return s_inst.get(this, n); }
-  TemplateVariant fileName() const { return m_def->getOutputFileBase(); }
-  TemplateVariant anchor() const { return m_def->anchor(); }
-  TemplateVariant scope() const {
-    const Definition *scope = m_def->getOuterScope();
-    const Definition *next = m_nextDef;
-    const Definition *prev = m_prevDef;
-    const Definition *nextScope = next ? next->getOuterScope() : 0;
-    const Definition *prevScope = prev ? prev->getOuterScope() : 0;
-    bool isMemberDef = m_def->definitionType() == Definition::TypeMember;
-    const MemberDef *md = isMemberDef ? (const MemberDef *)m_def : 0;
-    bool isFunctionLike =
-        md && (md->isFunction() || md->isSlot() || md->isSignal());
-    bool overloadedFunction =
-        isFunctionLike && ((prevScope != 0 && scope == prevScope) ||
-                           (scope && scope == nextScope));
-    QCString prefix;
-    if (md)
-      prefix = md->localName();
-    if (overloadedFunction) // overloaded member function
-    {
-      prefix += md->argsString();
-      // show argument list to disambiguate overloaded functions
-    } else if (md && isFunctionLike) // unique member function
-    {
-      prefix += "()"; // only to show it is a function
-    }
-    bool found = FALSE;
-    QCString name;
-    if (m_def->definitionType() == Definition::TypeClass) {
-      name = m_def->displayName();
-      found = TRUE;
-    } else if (m_def->definitionType() == Definition::TypeNamespace) {
-      name = m_def->displayName();
-      found = TRUE;
-    } else if (scope == 0 || scope == Doxygen::globalScope) // in global scope
-    {
-      if (md) {
-        FileDef *fd = md->getBodyDef();
-        if (fd == 0)
-          fd = md->getFileDef();
-        if (fd) {
-          if (!prefix.isEmpty())
-            prefix += ": ";
-          name = prefix + convertToXML(fd->localName());
-          found = TRUE;
-        }
-      }
-    } else if (md && (md->getClassDef() || md->getNamespaceDef()))
-    // member in class or namespace scope
-    {
-      SrcLangExt lang = md->getLanguage();
-      name = m_def->getOuterScope()->qualifiedName() +
-             getLanguageSpecificSeparator(lang) + prefix;
-      found = TRUE;
-    } else if (scope) // some thing else? -> show scope
-    {
-      name = prefix + convertToXML(scope->name());
-      found = TRUE;
-    }
-    if (!found) // fallback
-    {
-      name = prefix + "(" + theTranslator->trGlobalNamespace() + ")";
-    }
-    return name;
-  }
-  TemplateVariant relPath() const {
-    return externalRef("../", m_def->getReference(), TRUE);
-  }
-
-private:
-  const Definition *m_def;
-  const Definition *m_prevDef;
-  const Definition *m_nextDef;
-  static PropertyMapper<SymbolContext::Private> s_inst;
+    TemplateVariant relPath() const
+    {
+      return externalRef("../",m_def->getReference(),TRUE);
+    }
+  private:
+    const Definition *m_def;
+    const Definition *m_prevDef;
+    const Definition *m_nextDef;
+    static PropertyMapper<SymbolContext::Private> s_inst;
 };
 //%% }
 
 PropertyMapper<SymbolContext::Private> SymbolContext::Private::s_inst;
 
-SymbolContext::SymbolContext(const Definition *def, const Definition *prevDef,
-                             const Definition *nextDef)
-    : RefCountedContext("SymbolContext") {
-  p = new Private(def, prevDef, nextDef);
+SymbolContext::SymbolContext(const Definition *def,const Definition *prevDef,const Definition *nextDef)
+    : RefCountedContext("SymbolContext")
+{
+  p = new Private(def,prevDef,nextDef);
 }
 
-SymbolContext::~SymbolContext() { delete p; }
+SymbolContext::~SymbolContext()
+{
+  delete p;
+}
 
-TemplateVariant SymbolContext::get(const char *name) const {
+TemplateVariant SymbolContext::get(const char *name) const
+{
   return p->get(name);
 }
 
 //------------------------------------------------------------------------
 
 //%% list SymbolList[Symbol] : list of search symbols with the same name
-class SymbolListContext::Private : public GenericNodeListContext {
-public:
-  Private(const SearchDefinitionList *sdl) {
-    QListIterator<Definition> li(*sdl);
-    Definition *def;
-    Definition *prev = 0;
-    for (li.toFirst(); (def = li.current());) {
-      ++li;
-      const Definition *next = li.current();
-      append(SymbolContext::alloc(def, prev, next));
-      prev = def;
+class SymbolListContext::Private : public GenericNodeListContext
+{
+  public:
+    Private(const SearchDefinitionList *sdl)
+    {
+      QListIterator<Definition> li(*sdl);
+      Definition *def;
+      Definition *prev = 0;
+      for (li.toFirst();(def=li.current());)
+      {
+        ++li;
+        const Definition *next = li.current();
+        append(SymbolContext::alloc(def,prev,next));
+        prev = def;
+      }
     }
-  }
 };
 
 SymbolListContext::SymbolListContext(const SearchDefinitionList *sdl)
-    : RefCountedContext("SymbolListContext") {
+    : RefCountedContext("SymbolListContext")
+{
   p = new Private(sdl);
 }
 
-SymbolListContext::~SymbolListContext() { delete p; }
+SymbolListContext::~SymbolListContext()
+{
+  delete p;
+}
 
 // TemplateListIntf
-int SymbolListContext::count() const { return p->count(); }
+int SymbolListContext::count() const
+{
+  return p->count();
+}
 
-TemplateVariant SymbolListContext::at(int index) const { return p->at(index); }
+TemplateVariant SymbolListContext::at(int index) const
+{
+  return p->at(index);
+}
 
-TemplateListIntf::ConstIterator *SymbolListContext::createIterator() const {
+TemplateListIntf::ConstIterator *SymbolListContext::createIterator() const
+{
   return p->createIterator();
 }
 
@@ -9808,80 +9626,110 @@ TemplateListIntf::ConstIterator *SymbolListContext::createIterator() const {
 
 //%% struct SymbolGroup: search group of similar symbols
 //%% {
-class SymbolGroupContext::Private {
-public:
-  Private(const SearchDefinitionList *sdl) : m_sdl(sdl) {
-    static bool init = FALSE;
-    if (!init) {
-      s_inst.addProperty("id", &Private::id);
-      s_inst.addProperty("name", &Private::name);
-      s_inst.addProperty("symbols", &Private::symbolList);
-      init = TRUE;
+class SymbolGroupContext::Private
+{
+  public:
+    Private(const SearchDefinitionList *sdl) : m_sdl(sdl)
+    {
+      static bool init=FALSE;
+      if (!init)
+      {
+        s_inst.addProperty("id",     &Private::id);
+        s_inst.addProperty("name",   &Private::name);
+        s_inst.addProperty("symbols",&Private::symbolList);
+        init=TRUE;
+      }
     }
-  }
-  TemplateVariant get(const char *n) const { return s_inst.get(this, n); }
-  TemplateVariant id() const { return m_sdl->id(); }
-  TemplateVariant name() const { return m_sdl->name(); }
-  TemplateVariant symbolList() const {
-    if (!m_cache.symbolList) {
-      m_cache.symbolList.reset(SymbolListContext::alloc(m_sdl));
-    }
-    return m_cache.symbolList.get();
-  }
-
-private:
-  const SearchDefinitionList *m_sdl;
-  struct Cachable {
-    SharedPtr<SymbolListContext> symbolList;
-  };
-  mutable Cachable m_cache;
-  static PropertyMapper<SymbolGroupContext::Private> s_inst;
+    TemplateVariant get(const char *n) const
+    {
+      return s_inst.get(this,n);
+    }
+    TemplateVariant id() const
+    {
+      return m_sdl->id();
+    }
+    TemplateVariant name() const
+    {
+      return m_sdl->name();
+    }
+    TemplateVariant symbolList() const
+    {
+      if (!m_cache.symbolList)
+      {
+        m_cache.symbolList.reset(SymbolListContext::alloc(m_sdl));
+      }
+      return m_cache.symbolList.get();
+    }
+  private:
+    const SearchDefinitionList *m_sdl;
+    struct Cachable
+    {
+      SharedPtr<SymbolListContext> symbolList;
+    };
+    mutable Cachable m_cache;
+    static PropertyMapper<SymbolGroupContext::Private> s_inst;
 };
 //%% }
 
 PropertyMapper<SymbolGroupContext::Private> SymbolGroupContext::Private::s_inst;
 
 SymbolGroupContext::SymbolGroupContext(const SearchDefinitionList *sdl)
-    : RefCountedContext("SymbolGroupContext") {
+    : RefCountedContext("SymbolGroupContext")
+{
   p = new Private(sdl);
 }
 
-SymbolGroupContext::~SymbolGroupContext() { delete p; }
+SymbolGroupContext::~SymbolGroupContext()
+{
+  delete p;
+}
 
-TemplateVariant SymbolGroupContext::get(const char *name) const {
+TemplateVariant SymbolGroupContext::get(const char *name) const
+{
   return p->get(name);
 }
 
 //------------------------------------------------------------------------
 
 //%% list SymbolGroupList[SymbolGroup] : list of search groups one per by name
-class SymbolGroupListContext::Private : public GenericNodeListContext {
-public:
-  Private(const SearchIndexList *sil) {
-    SDict<SearchDefinitionList>::Iterator li(*sil);
-    SearchDefinitionList *dl;
-    for (li.toFirst(); (dl = li.current()); ++li) {
-      append(SymbolGroupContext::alloc(dl));
+class SymbolGroupListContext::Private : public GenericNodeListContext
+{
+  public:
+    Private(const SearchIndexList *sil)
+    {
+      SDict<SearchDefinitionList>::Iterator li(*sil);
+      SearchDefinitionList *dl;
+      for (li.toFirst();(dl=li.current());++li)
+      {
+        append(SymbolGroupContext::alloc(dl));
+      }
     }
-  }
 };
 
-SymbolGroupListContext::SymbolGroupListContext(const SearchIndexList *sil)
-    : RefCountedContext("SymbolGroupListContext") {
+SymbolGroupListContext::SymbolGroupListContext(const SearchIndexList *sil) 
+    : RefCountedContext("SymbolGroupListContext")
+{
   p = new Private(sil);
 }
 
-SymbolGroupListContext::~SymbolGroupListContext() { delete p; }
+SymbolGroupListContext::~SymbolGroupListContext()
+{
+  delete p;
+}
 
 // TemplateListIntf
-int SymbolGroupListContext::count() const { return p->count(); }
+int SymbolGroupListContext::count() const
+{
+  return p->count();
+}
 
-TemplateVariant SymbolGroupListContext::at(int index) const {
+TemplateVariant SymbolGroupListContext::at(int index) const
+{
   return p->at(index);
 }
 
-TemplateListIntf::ConstIterator *
-SymbolGroupListContext::createIterator() const {
+TemplateListIntf::ConstIterator *SymbolGroupListContext::createIterator() const
+{
   return p->createIterator();
 }
 
@@ -9889,86 +9737,111 @@ SymbolGroupListContext::createIterator() const {
 
 //%% struct SymbolIndex: search index
 //%% {
-class SymbolIndexContext::Private {
-public:
-  Private(const SearchIndexList *sl, const QCString &name)
-      : m_searchList(sl), m_name(name) {
-    static bool init = FALSE;
-    if (!init) {
-      s_inst.addProperty("name", &Private::name);
-      s_inst.addProperty("letter", &Private::letter);
-      s_inst.addProperty("symbolGroups", &Private::symbolGroups);
-      init = TRUE;
+class SymbolIndexContext::Private
+{
+  public:
+    Private(const SearchIndexList *sl,const QCString &name) : m_searchList(sl), m_name(name)
+    {
+      static bool init=FALSE;
+      if (!init)
+      {
+        s_inst.addProperty("name",        &Private::name);
+        s_inst.addProperty("letter",      &Private::letter);
+        s_inst.addProperty("symbolGroups",&Private::symbolGroups);
+        init=TRUE;
+      }
     }
-  }
-  TemplateVariant get(const char *n) const { return s_inst.get(this, n); }
-  TemplateVariant name() const { return m_name; }
-  TemplateVariant letter() const {
-    return QString(QChar(m_searchList->letter())).utf8();
-  }
-  TemplateVariant symbolGroups() const {
-    if (!m_cache.symbolGroups) {
-      m_cache.symbolGroups.reset(SymbolGroupListContext::alloc(m_searchList));
+    TemplateVariant get(const char *n) const
+    {
+      return s_inst.get(this,n);
     }
-    return m_cache.symbolGroups.get();
-  }
-
-private:
-  const SearchIndexList *m_searchList;
-  QCString m_name;
-  struct Cachable {
-    SharedPtr<SymbolGroupListContext> symbolGroups;
-  };
-  mutable Cachable m_cache;
-  static PropertyMapper<SymbolIndexContext::Private> s_inst;
+    TemplateVariant name() const
+    {
+      return m_name;
+    }
+    TemplateVariant letter() const
+    {
+      return QString(QChar(m_searchList->letter())).utf8();
+    }
+    TemplateVariant symbolGroups() const
+    {
+      if (!m_cache.symbolGroups)
+      {
+        m_cache.symbolGroups.reset(SymbolGroupListContext::alloc(m_searchList));
+      }
+      return m_cache.symbolGroups.get();
+    }
+  private:
+    const SearchIndexList *m_searchList;
+    QCString m_name;
+    struct Cachable
+    {
+      SharedPtr<SymbolGroupListContext> symbolGroups;
+    };
+    mutable Cachable m_cache;
+    static PropertyMapper<SymbolIndexContext::Private> s_inst;
 };
 //%% }
 
 PropertyMapper<SymbolIndexContext::Private> SymbolIndexContext::Private::s_inst;
 
-SymbolIndexContext::SymbolIndexContext(const SearchIndexList *sl,
-                                       const QCString &name)
-    : RefCountedContext("SymbolIndexContext") {
-  p = new Private(sl, name);
+SymbolIndexContext::SymbolIndexContext(const SearchIndexList *sl,const QCString &name)
+    : RefCountedContext("SymbolIndexContext")
+{
+  p = new Private(sl,name);
 }
 
-SymbolIndexContext::~SymbolIndexContext() { delete p; }
+SymbolIndexContext::~SymbolIndexContext()
+{
+  delete p;
+}
 
-TemplateVariant SymbolIndexContext::get(const char *name) const {
+TemplateVariant SymbolIndexContext::get(const char *name) const
+{
   return p->get(name);
 }
 
 //------------------------------------------------------------------------
 
 //%% list SymbolIndices[SymbolIndex] : list of search indices one per by type
-class SymbolIndicesContext::Private : public GenericNodeListContext {
-public:
-  Private(const SearchIndexInfo *info) {
-    // use info->symbolList to populate the list
-    SIntDict<SearchIndexList>::Iterator it(info->symbolList);
-    const SearchIndexList *sl;
-    for (it.toFirst(); (sl = it.current()); ++it) // for each letter
+class SymbolIndicesContext::Private : public GenericNodeListContext
+{
+  public:
+    Private(const SearchIndexInfo *info)
     {
-      append(SymbolIndexContext::alloc(sl, info->name));
+      // use info->symbolList to populate the list
+      SIntDict<SearchIndexList>::Iterator it(info->symbolList);
+      const SearchIndexList *sl;
+      for (it.toFirst();(sl=it.current());++it) // for each letter
+      {
+        append(SymbolIndexContext::alloc(sl,info->name));
+      }
     }
-  }
 };
 
-SymbolIndicesContext::SymbolIndicesContext(const SearchIndexInfo *info)
-    : RefCountedContext("SymbolIndicesContext") {
+SymbolIndicesContext::SymbolIndicesContext(const SearchIndexInfo *info) : RefCountedContext("SymbolIndicesContext")
+{
   p = new Private(info);
 }
 
-SymbolIndicesContext::~SymbolIndicesContext() { delete p; }
+SymbolIndicesContext::~SymbolIndicesContext()
+{
+  delete p;
+}
 
 // TemplateListIntf
-int SymbolIndicesContext::count() const { return p->count(); }
+int SymbolIndicesContext::count() const
+{
+  return p->count();
+}
 
-TemplateVariant SymbolIndicesContext::at(int index) const {
+TemplateVariant SymbolIndicesContext::at(int index) const
+{
   return p->at(index);
 }
 
-TemplateListIntf::ConstIterator *SymbolIndicesContext::createIterator() const {
+TemplateListIntf::ConstIterator *SymbolIndicesContext::createIterator() const
+{
   return p->createIterator();
 }
 
@@ -9976,349 +9849,385 @@ TemplateListIntf::ConstIterator *SymbolIndicesContext::createIterator() const {
 
 //%% struct SearchIndex: search index
 //%% {
-class SearchIndexContext::Private {
-public:
-  Private(const SearchIndexInfo *info) : m_info(info) {
-    static bool init = FALSE;
-    if (!init) {
-      s_inst.addProperty("name", &Private::name);
-      s_inst.addProperty("text", &Private::text);
-      s_inst.addProperty("symbolIndices", &Private::symbolIndices);
-      init = TRUE;
+class SearchIndexContext::Private
+{
+  public:
+    Private(const SearchIndexInfo *info) : m_info(info)
+    {
+      static bool init=FALSE;
+      if (!init)
+      {
+        s_inst.addProperty("name",         &Private::name);
+        s_inst.addProperty("text",         &Private::text);
+        s_inst.addProperty("symbolIndices",&Private::symbolIndices);
+        init=TRUE;
+      }
     }
-  }
-  TemplateVariant get(const char *n) const { return s_inst.get(this, n); }
-  TemplateVariant name() const { return m_info->name; }
-  TemplateVariant text() const { return m_info->text; }
-  TemplateVariant symbolIndices() const {
-    if (!m_cache.symbolIndices) {
-      m_cache.symbolIndices.reset(SymbolIndicesContext::alloc(m_info));
-    }
-    return m_cache.symbolIndices.get();
-  }
-
-private:
-  const SearchIndexInfo *m_info;
-  struct Cachable {
-    SharedPtr<SymbolIndicesContext> symbolIndices;
-  };
-  mutable Cachable m_cache;
-  static PropertyMapper<SearchIndexContext::Private> s_inst;
+    TemplateVariant get(const char *n) const
+    {
+      return s_inst.get(this,n);
+    }
+    TemplateVariant name() const
+    {
+      return m_info->name;
+    }
+    TemplateVariant text() const
+    {
+      return m_info->text;
+    }
+    TemplateVariant symbolIndices() const
+    {
+      if (!m_cache.symbolIndices)
+      {
+        m_cache.symbolIndices.reset(SymbolIndicesContext::alloc(m_info));
+      }
+      return m_cache.symbolIndices.get();
+    }
+  private:
+    const SearchIndexInfo *m_info;
+    struct Cachable
+    {
+      SharedPtr<SymbolIndicesContext> symbolIndices;
+    };
+    mutable Cachable m_cache;
+    static PropertyMapper<SearchIndexContext::Private> s_inst;
 };
 //%% }
 
 PropertyMapper<SearchIndexContext::Private> SearchIndexContext::Private::s_inst;
 
 SearchIndexContext::SearchIndexContext(const SearchIndexInfo *info)
-    : RefCountedContext("SearchIndexContext") {
+    : RefCountedContext("SearchIndexContext")
+{
   p = new Private(info);
 }
 
-SearchIndexContext::~SearchIndexContext() { delete p; }
+SearchIndexContext::~SearchIndexContext()
+{
+  delete p;
+}
 
-TemplateVariant SearchIndexContext::get(const char *name) const {
+TemplateVariant SearchIndexContext::get(const char *name) const
+{
   return p->get(name);
 }
 
 //------------------------------------------------------------------------
 
 //%% list SearchIndices[SearchIndex] : list of search indices one per by type
-class SearchIndicesContext::Private : public GenericNodeListContext {
-public:
-  Private() {
-    const SearchIndexInfo *indices = getSearchIndices();
-    for (int i = 0; i < NUM_SEARCH_INDICES; i++) {
-      append(SearchIndexContext::alloc(&indices[i]));
+class SearchIndicesContext::Private : public GenericNodeListContext
+{
+  public:
+    Private()
+    {
+      const SearchIndexInfo *indices = getSearchIndices();
+      for (int i=0;i<NUM_SEARCH_INDICES;i++)
+      {
+        append(SearchIndexContext::alloc(&indices[i]));
+      }
     }
-  }
 };
 
-SearchIndicesContext::SearchIndicesContext()
-    : RefCountedContext("SearchIndicesContext") {
+SearchIndicesContext::SearchIndicesContext() : RefCountedContext("SearchIndicesContext")
+{
   p = new Private;
 }
 
-SearchIndicesContext::~SearchIndicesContext() { delete p; }
+SearchIndicesContext::~SearchIndicesContext()
+{
+  delete p;
+}
 
 // TemplateListIntf
-int SearchIndicesContext::count() const { return p->count(); }
+int SearchIndicesContext::count() const
+{
+  return p->count();
+}
 
-TemplateVariant SearchIndicesContext::at(int index) const {
+TemplateVariant SearchIndicesContext::at(int index) const
+{
   return p->at(index);
 }
 
-TemplateListIntf::ConstIterator *SearchIndicesContext::createIterator() const {
+TemplateListIntf::ConstIterator *SearchIndicesContext::createIterator() const
+{
   return p->createIterator();
 }
 
+
 //------------------------------------------------------------------------
 
-class HtmlEscaper : public TemplateEscapeIntf {
-public:
-  QCString escape(const QCString &s) { return convertToHtml(s, TRUE); }
-  void enableTabbing(bool) {}
+class HtmlEscaper : public TemplateEscapeIntf
+{
+  public:
+    QCString escape(const QCString &s)
+    {
+      return convertToHtml(s,TRUE);
+    }
+    void enableTabbing(bool) {}
 };
 
 //------------------------------------------------------------------------
 
-class LatexSpaceless : public TemplateSpacelessIntf {
-public:
-  LatexSpaceless() { reset(); }
-  void reset() {}
-  QCString remove(const QCString &s) {
-    QGString result;
-    const char *p = s.data();
-    char c;
-    while ((c = *p++)) {
-      switch (c) {
-      case '\t':
-      case ' ':
-      case '\n':
-        break;
-      default:
-        result += c;
-        break;
+class LatexSpaceless : public TemplateSpacelessIntf
+{
+  public:
+    LatexSpaceless() { reset(); }
+    void reset() { }
+    QCString remove(const QCString &s)
+    {
+      QGString result;
+      const char *p = s.data();
+      char c;
+      while ((c=*p++))
+      {
+        switch(c)
+        {
+          case '\t': case ' ': case '\n':
+            break;
+          default:
+            result+=c;
+            break;
+        }
       }
+      result+='\0';
+      return result.data();
     }
-    result += '\0';
-    return result.data();
-  }
-
-private:
+  private:
 };
 
 //------------------------------------------------------------------------
 
-class HtmlSpaceless : public TemplateSpacelessIntf {
-public:
-  HtmlSpaceless() { reset(); }
-  void reset() {
-    m_insideTag = FALSE;
-    m_insideString = '\0';
-    m_removeSpaces = TRUE;
-  }
-  QCString remove(const QCString &s) {
-    QGString result;
-    const char *p = s.data();
-    char c;
-    while ((c = *p++)) {
-      switch (c) {
-      case '<': // start of a tag
-        if (!m_insideString)
-          m_insideTag = TRUE, m_removeSpaces = FALSE;
-        result += c;
-        break;
-      case '>': // end of a tag
-        if (!m_insideString)
-          m_insideTag = FALSE, m_removeSpaces = TRUE;
-        result += c;
-        break;
-      case '\\': // escaped character in a string
-        result += c;
-        if (m_insideString && *p)
-          result += *p++;
-        break;
-      case '"':
-      case '\'':
-        if (m_insideTag) {
-          if (m_insideString == c) // end of string
-          {
-            m_insideString = '\0';
-          } else if (m_insideString == '\0') // start of string
-          {
-            m_insideString = c;
-          }
-        }
-        result += c;
-        break;
-      case ' ':
-      case '\t':
-      case '\n':          // whitespace
-        if (!m_insideTag) // outside tags strip consecutive whitespace
+class HtmlSpaceless : public TemplateSpacelessIntf
+{
+  public:
+    HtmlSpaceless() { reset(); }
+    void reset()
+    {
+      m_insideTag = FALSE;
+      m_insideString = '\0';
+      m_removeSpaces = TRUE;
+    }
+    QCString remove(const QCString &s)
+    {
+      QGString result;
+      const char *p = s.data();
+      char c;
+      while ((c=*p++))
+      {
+        switch(c)
         {
-          m_removeSpaces = TRUE;
-        } else {
-          result += ' ';
+          case '<': // start of a tag
+            if (!m_insideString) m_insideTag=TRUE,m_removeSpaces=FALSE;
+            result+=c;
+            break;
+          case '>': // end of a tag
+            if (!m_insideString) m_insideTag=FALSE,m_removeSpaces=TRUE;
+            result+=c;
+            break;
+          case '\\': // escaped character in a string
+            result+=c;
+            if (m_insideString && *p) result+=*p++;
+            break;
+          case '"': case '\'':
+            if (m_insideTag)
+            {
+              if (m_insideString==c) // end of string
+              {
+                m_insideString='\0';
+              }
+              else if (m_insideString=='\0') // start of string
+              {
+                m_insideString=c;
+              }
+            }
+            result+=c;
+            break;
+          case ' ': case '\t': case '\n': // whitespace
+            if (!m_insideTag) // outside tags strip consecutive whitespace
+            {
+              m_removeSpaces=TRUE;
+            }
+            else
+            {
+              result+=' ';
+            }
+            break;
+          default:
+            //if (m_removeSpaces) result+=' ';
+            result+=c;
+            m_removeSpaces=FALSE;
+            break;
         }
-        break;
-      default:
-        // if (m_removeSpaces) result+=' ';
-        result += c;
-        m_removeSpaces = FALSE;
-        break;
       }
+      result+='\0';
+      //printf("HtmlSpaceless::remove({%s})={%s} m_insideTag=%d m_insideString=%c (%d) removeSpaces=%d\n",s.data(),result.data(),
+      //    m_insideTag,m_insideString,m_insideString,m_removeSpaces);
+      return result.data();
     }
-    result += '\0';
-    // printf("HtmlSpaceless::remove({%s})={%s} m_insideTag=%d m_insideString=%c
-    // (%d) removeSpaces=%d\n",s.data(),result.data(),
-    //    m_insideTag,m_insideString,m_insideString,m_removeSpaces);
-    return result.data();
-  }
-
-private:
-  bool m_insideTag;
-  char m_insideString;
-  bool m_removeSpaces;
+  private:
+    bool m_insideTag;
+    char m_insideString;
+    bool m_removeSpaces;
 };
 
 //------------------------------------------------------------------------
 
-class LatexEscaper : public TemplateEscapeIntf {
-public:
-  LatexEscaper() : m_tabbing(FALSE) {}
-  QCString escape(const QCString &s) { return convertToLaTeX(s, m_tabbing); }
-  void enableTabbing(bool b) { m_tabbing = b; }
-
-private:
-  bool m_tabbing;
+class LatexEscaper : public TemplateEscapeIntf
+{
+  public:
+    LatexEscaper() : m_tabbing(FALSE) {}
+    QCString escape(const QCString &s)
+    {
+      return convertToLaTeX(s,m_tabbing);
+    }
+    void enableTabbing(bool b) { m_tabbing=b; }
+  private:
+    bool m_tabbing;
 };
 
+
 //------------------------------------------------------------------------
 
 #if DEBUG_REF
 int RefCountedContext::s_totalCount;
 #endif
 
-void generateOutputViaTemplate() {
+void generateOutputViaTemplate()
+{
   msg("Generating output via template engine...\n");
   {
     TemplateEngine e;
     TemplateContext *ctx = e.createContext();
-    if (ctx) {
-      SharedPtr<DoxygenContext> doxygen(DoxygenContext::alloc());
-      SharedPtr<ConfigContext> config(ConfigContext::alloc());
-      SharedPtr<TranslateContext> tr(TranslateContext::alloc());
-      SharedPtr<ClassListContext> classList(ClassListContext::alloc());
-      SharedPtr<ClassIndexContext> classIndex(ClassIndexContext::alloc());
-      SharedPtr<ClassTreeContext> classTree(ClassTreeContext::alloc());
-      SharedPtr<ClassHierarchyContext> classHierarchy(
-          ClassHierarchyContext::alloc());
-      SharedPtr<NamespaceListContext> namespaceList(
-          NamespaceListContext::alloc());
-      SharedPtr<NamespaceTreeContext> namespaceTree(
-          NamespaceTreeContext::alloc());
-      SharedPtr<DirListContext> dirList(DirListContext::alloc());
-      SharedPtr<FileListContext> fileList(FileListContext::alloc());
-      SharedPtr<FileTreeContext> fileTree(FileTreeContext::alloc());
-      SharedPtr<PageTreeContext> pageTree(
-          PageTreeContext::alloc(Doxygen::pageSDict));
-      SharedPtr<PageListContext> pageList(
-          PageListContext::alloc(Doxygen::pageSDict));
-      SharedPtr<ExampleTreeContext> exampleTree(ExampleTreeContext::alloc());
-      SharedPtr<ExampleListContext> exampleList(ExampleListContext::alloc());
-      SharedPtr<ModuleTreeContext> moduleTree(ModuleTreeContext::alloc());
-      SharedPtr<ModuleListContext> moduleList(ModuleListContext::alloc());
-      SharedPtr<GlobalsIndexContext> globalsIndex(GlobalsIndexContext::alloc());
-      SharedPtr<ClassMembersIndexContext> classMembersIndex(
-          ClassMembersIndexContext::alloc());
-      SharedPtr<NamespaceMembersIndexContext> namespaceMembersIndex(
-          NamespaceMembersIndexContext::alloc());
-      SharedPtr<SearchIndicesContext> searchIndices(
-          SearchIndicesContext::alloc());
+    if (ctx)
+    {
+      SharedPtr<DoxygenContext>               doxygen              (DoxygenContext::alloc());
+      SharedPtr<ConfigContext>                config               (ConfigContext::alloc());
+      SharedPtr<TranslateContext>             tr                   (TranslateContext::alloc());
+      SharedPtr<ClassListContext>             classList            (ClassListContext::alloc());
+      SharedPtr<ClassIndexContext>            classIndex           (ClassIndexContext::alloc());
+      SharedPtr<ClassTreeContext>             classTree            (ClassTreeContext::alloc());
+      SharedPtr<ClassHierarchyContext>        classHierarchy       (ClassHierarchyContext::alloc());
+      SharedPtr<NamespaceListContext>         namespaceList        (NamespaceListContext::alloc());
+      SharedPtr<NamespaceTreeContext>         namespaceTree        (NamespaceTreeContext::alloc());
+      SharedPtr<DirListContext>               dirList              (DirListContext::alloc());
+      SharedPtr<FileListContext>              fileList             (FileListContext::alloc());
+      SharedPtr<FileTreeContext>              fileTree             (FileTreeContext::alloc());
+      SharedPtr<PageTreeContext>              pageTree             (PageTreeContext::alloc(Doxygen::pageSDict));
+      SharedPtr<PageListContext>              pageList             (PageListContext::alloc(Doxygen::pageSDict));
+      SharedPtr<ExampleTreeContext>           exampleTree          (ExampleTreeContext::alloc());
+      SharedPtr<ExampleListContext>           exampleList          (ExampleListContext::alloc());
+      SharedPtr<ModuleTreeContext>            moduleTree           (ModuleTreeContext::alloc());
+      SharedPtr<ModuleListContext>            moduleList           (ModuleListContext::alloc());
+      SharedPtr<GlobalsIndexContext>          globalsIndex         (GlobalsIndexContext::alloc());
+      SharedPtr<ClassMembersIndexContext>     classMembersIndex    (ClassMembersIndexContext::alloc());
+      SharedPtr<NamespaceMembersIndexContext> namespaceMembersIndex(NamespaceMembersIndexContext::alloc());
+      SharedPtr<SearchIndicesContext>         searchIndices        (SearchIndicesContext::alloc());
 
       //%% Doxygen doxygen:
-      ctx->set("doxygen", doxygen.get());
+      ctx->set("doxygen",doxygen.get());
       //%% Translator tr:
-      ctx->set("tr", tr.get());
+      ctx->set("tr",tr.get());
       //%% Config config:
-      ctx->set("config", config.get());
+      ctx->set("config",config.get());
       //%% ClassList classList:
-      ctx->set("classList", classList.get()); // not used for standard HTML
+      ctx->set("classList",classList.get()); // not used for standard HTML
       //%% ClassTree classTree:
-      ctx->set("classTree", classTree.get());
+      ctx->set("classTree",classTree.get());
       //%% ClassIndex classIndex:
-      ctx->set("classIndex", classIndex.get());
+      ctx->set("classIndex",classIndex.get());
       //%% ClassHierarchy classHierarchy:
-      ctx->set("classHierarchy", classHierarchy.get());
+      ctx->set("classHierarchy",classHierarchy.get());
       //%% NamespaceList namespaceList:
-      ctx->set("namespaceList", namespaceList.get());
+      ctx->set("namespaceList",namespaceList.get());
       //%% NamespaceTree namespaceTree:
-      ctx->set("namespaceTree", namespaceTree.get());
+      ctx->set("namespaceTree",namespaceTree.get());
       //%% FileList fileList:
-      ctx->set("fileList", fileList.get());
+      ctx->set("fileList",fileList.get());
       //%% FileTree fileTree:
-      ctx->set("fileTree", fileTree.get());
+      ctx->set("fileTree",fileTree.get());
       //%% PageList pageList
-      ctx->set("pageList", pageList.get());
+      ctx->set("pageList",pageList.get());
       //%% PageTree pageTree
-      ctx->set("pageTree", pageTree.get());
+      ctx->set("pageTree",pageTree.get());
       //%% ExampleTree exampleTree
-      ctx->set("exampleTree", exampleTree.get());
+      ctx->set("exampleTree",exampleTree.get());
       //%% ExampleList exampleList
-      ctx->set("exampleList", exampleList.get());
+      ctx->set("exampleList",exampleList.get());
       //%% ModuleTree moduleTree
-      ctx->set("moduleTree", moduleTree.get());
+      ctx->set("moduleTree",moduleTree.get());
       //%% ModuleList moduleList
-      ctx->set("moduleList", moduleList.get());
+      ctx->set("moduleList",moduleList.get());
       //%% DirList dirList
-      ctx->set("dirList", dirList.get());
+      ctx->set("dirList",dirList.get());
       //%% Page mainPage
-      if (Doxygen::mainPage) {
-        SharedPtr<PageContext> mainPage(
-            PageContext::alloc(Doxygen::mainPage, TRUE, FALSE));
-        ctx->set("mainPage", mainPage.get());
-      } else {
+      if (Doxygen::mainPage)
+      {
+        SharedPtr<PageContext> mainPage(PageContext::alloc(Doxygen::mainPage,TRUE,FALSE));
+        ctx->set("mainPage",mainPage.get());
+      }
+      else
+      {
         // TODO: for LaTeX output index should be main... => solve in template
-        Doxygen::mainPage = new PageDef("[generated]", 1, "index", "",
-                                        theTranslator->trMainPage());
+        Doxygen::mainPage = new PageDef("[generated]",1,"index","",theTranslator->trMainPage());
         Doxygen::mainPage->setFileName("index");
-        SharedPtr<PageContext> mainPage(
-            PageContext::alloc(Doxygen::mainPage, TRUE, FALSE));
-        ctx->set("mainPage", mainPage.get());
+        SharedPtr<PageContext> mainPage(PageContext::alloc(Doxygen::mainPage,TRUE,FALSE));
+        ctx->set("mainPage",mainPage.get());
       }
       //%% GlobalsIndex globalsIndex:
-      ctx->set("globalsIndex", globalsIndex.get());
+      ctx->set("globalsIndex",globalsIndex.get());
       //%% ClassMembersIndex classMembersIndex:
-      ctx->set("classMembersIndex", classMembersIndex.get());
+      ctx->set("classMembersIndex",classMembersIndex.get());
       //%% NamespaceMembersIndex namespaceMembersIndex:
-      ctx->set("namespaceMembersIndex", namespaceMembersIndex.get());
+      ctx->set("namespaceMembersIndex",namespaceMembersIndex.get());
       //%% SearchIndicaes searchindicaes
-      ctx->set("searchIndices", searchIndices.get());
+      ctx->set("searchIndices",searchIndices.get());
       //%% string space
-      ctx->set("space", " ");
+      ctx->set("space"," ");
 
-      // if (Config_getBool(GENERATE_HTML))
+      //if (Config_getBool(GENERATE_HTML))
       { // render HTML output
-        e.setTemplateDir(
-            "templates/html"); // TODO: make template part user configurable
-        Template *tpl = e.loadByName("htmllayout.tpl", 1);
-        if (tpl) {
+        e.setTemplateDir("templates/html"); // TODO: make template part user configurable
+        Template *tpl = e.loadByName("htmllayout.tpl",1);
+        if (tpl)
+        {
           g_globals.outputFormat = ContextOutputFormat_Html;
           g_globals.dynSectionId = 0;
-          g_globals.outputDir = Config_getString(HTML_OUTPUT);
+          g_globals.outputDir    = Config_getString(HTML_OUTPUT);
           QDir dir(g_globals.outputDir);
           createSubDirs(dir);
           HtmlEscaper htmlEsc;
-          ctx->setEscapeIntf(Config_getString(HTML_FILE_EXTENSION), &htmlEsc);
+          ctx->setEscapeIntf(Config_getString(HTML_FILE_EXTENSION),&htmlEsc);
           HtmlSpaceless spl;
           ctx->setSpacelessIntf(&spl);
           ctx->setOutputDirectory(g_globals.outputDir);
           FTextStream ts;
-          tpl->render(ts, ctx);
+          tpl->render(ts,ctx);
           e.unload(tpl);
         }
       }
 
       // TODO: clean index before each run...
 
-      // if (Config_getBool(GENERATE_LATEX))
-      if (0) { // render LaTeX output
-        e.setTemplateDir(
-            "templates/latex"); // TODO: make template part user configurable
-        Template *tpl = e.loadByName("latexlayout.tpl", 1);
-        if (tpl) {
+      //if (Config_getBool(GENERATE_LATEX))
+      if (0)
+      { // render LaTeX output
+        e.setTemplateDir("templates/latex"); // TODO: make template part user configurable
+        Template *tpl = e.loadByName("latexlayout.tpl",1);
+        if (tpl)
+        {
           g_globals.outputFormat = ContextOutputFormat_Latex;
           g_globals.dynSectionId = 0;
-          g_globals.outputDir = Config_getString(LATEX_OUTPUT);
+          g_globals.outputDir    = Config_getString(LATEX_OUTPUT);
           QDir dir(g_globals.outputDir);
           createSubDirs(dir);
           LatexEscaper latexEsc;
-          ctx->setEscapeIntf(".tex", &latexEsc);
+          ctx->setEscapeIntf(".tex",&latexEsc);
           LatexSpaceless spl;
           ctx->setSpacelessIntf(&spl);
           ctx->setOutputDirectory(g_globals.outputDir);
           FTextStream ts;
-          tpl->render(ts, ctx);
+          tpl->render(ts,ctx);
           e.unload(tpl);
         }
       }
@@ -10326,17 +10235,19 @@ void generateOutputViaTemplate() {
       // clear all cached data in Definition objects.
       QDictIterator<DefinitionIntf> di(*Doxygen::symbolMap);
       DefinitionIntf *intf;
-      for (; (intf = di.current()); ++di) {
-        if (intf->definitionType() ==
-            DefinitionIntf::TypeSymbolList) // list of symbols
+      for (;(intf=di.current());++di)
+      {
+        if (intf->definitionType()==DefinitionIntf::TypeSymbolList) // list of symbols
         {
-          DefinitionListIterator dli(*(DefinitionList *)intf);
+          DefinitionListIterator dli(*(DefinitionList*)intf);
           Definition *d;
           // for each symbol
-          for (dli.toFirst(); (d = dli.current()); ++dli) {
+          for (dli.toFirst();(d=dli.current());++dli)
+          {
             d->setCookie(0);
           }
-        } else // single symbol
+        }
+        else // single symbol
         {
           Definition *d = (Definition *)intf;
           d->setCookie(0);
@@ -10347,22 +10258,24 @@ void generateOutputViaTemplate() {
     }
   }
 #if DEBUG_REF // should be 0, i.e. all objects are deleted
-  printf("==== total ref count %d\n", RefCountedContext::s_totalCount);
+  printf("==== total ref count %d\n",RefCountedContext::s_totalCount);
 #endif
 }
 
-void generateTemplateFiles(const char *templateDir) {
-  if (!templateDir)
-    return;
+void generateTemplateFiles(const char *templateDir)
+{
+  if (!templateDir) return;
   QDir thisDir;
-  if (!thisDir.exists(templateDir) && !thisDir.mkdir(templateDir)) {
-    err("Failed to create output directory '%s'\n", templateDir);
+  if (!thisDir.exists(templateDir) && !thisDir.mkdir(templateDir))
+  {
+    err("Failed to create output directory '%s'\n",templateDir);
     return;
   }
-  QCString outDir = QCString(templateDir) + "/html";
-  if (!thisDir.exists(outDir) && !thisDir.mkdir(outDir)) {
-    err("Failed to create output directory '%s'\n", templateDir);
+  QCString outDir = QCString(templateDir)+"/html";
+  if (!thisDir.exists(outDir) && !thisDir.mkdir(outDir))
+  {
+    err("Failed to create output directory '%s'\n",templateDir);
     return;
   }
-  ResourceMgr::instance().writeCategory("html", outDir);
+  ResourceMgr::instance().writeCategory("html",outDir);
 }
diff --git a/src/doxygen.cpp b/src/doxygen.cpp
index 76a70282..e58d4a6b 100644
--- a/src/doxygen.cpp
+++ b/src/doxygen.cpp
@@ -15,102 +15,100 @@
 
 #include <locale.h>
 
-#include <errno.h>
-#include <qdict.h>
-#include <qdir.h>
-#include <qfile.h>
 #include <qfileinfo.h>
-#include <qptrdict.h>
+#include <qfile.h>
+#include <qdir.h>
+#include <qdict.h>
 #include <qregexp.h>
 #include <qstrlist.h>
-#include <qtextcodec.h>
-#include <qtextstream.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <sys/stat.h>
+#include <qtextcodec.h>
+#include <errno.h>
+#include <qptrdict.h>
+#include <qtextstream.h>
 
-#include "arguments.h"
-#include "bufstr.h"
-#include "cite.h"
-#include "classlist.h"
-#include "cmdmapper.h"
-#include "code.h"
-#include "commentcnv.h"
-#include "config.h"
-#include "context.h"
-#include "debug.h"
-#include "declinfo.h"
-#include "defargs.h"
-#include "defgen.h"
-#include "dirdef.h"
-#include "docbookgen.h"
-#include "docparser.h"
-#include "docsets.h"
-#include "dot.h"
+#include "version.h"
 #include "doxygen.h"
-#include "eclipsehelp.h"
+#include "scanner.h"
 #include "entry.h"
-#include "filename.h"
-#include "fileparser.h"
-#include "filestorage.h"
-#include "formula.h"
-#include "fortranscanner.h"
-#include "ftvhelp.h"
-#include "groupdef.h"
-#include "htags.h"
-#include "htmlgen.h"
-#include "htmlhelp.h"
 #include "index.h"
-#include "language.h"
-#include "latexgen.h"
-#include "layout.h"
 #include "logos.h"
-#include "mangen.h"
-#include "markdown.h"
-#include "marshal.h"
-#include "membergroup.h"
-#include "memberlist.h"
-#include "membername.h"
 #include "message.h"
+#include "config.h"
+#include "util.h"
+#include "pre.h"
+#include "tagreader.h"
+#include "dot.h"
 #include "msc.h"
-#include "namespacedef.h"
-#include "objcache.h"
+#include "docparser.h"
+#include "dirdef.h"
 #include "outputlist.h"
-#include "pagedef.h"
-#include "parserintf.h"
-#include "perlmodgen.h"
-#include "portable.h"
-#include "pre.h"
-#include "prologscanner.h"
-#include "pyscanner.h"
+#include "declinfo.h"
+#include "htmlgen.h"
+#include "latexgen.h"
+#include "mangen.h"
+#include "language.h"
+#include "debug.h"
+#include "htmlhelp.h"
 #include "qhp.h"
-#include "reflist.h"
+#include "ftvhelp.h"
+#include "defargs.h"
 #include "rtfgen.h"
-#include "scanner.h"
-#include "searchindex.h"
-#include "settings.h"
 #include "sqlite3gen.h"
-#include "store.h"
-#include "tagreader.h"
-#include "tclscanner.h"
-#include "util.h"
-#include "version.h"
-#include "vhdldocgen.h"
-#include "vhdljjparser.h"
 #include "xmlgen.h"
+#include "docbookgen.h"
+#include "defgen.h"
+#include "perlmodgen.h"
+#include "reflist.h"
+#include "pagedef.h"
+#include "bufstr.h"
+#include "commentcnv.h"
+#include "cmdmapper.h"
+#include "searchindex.h"
+#include "parserintf.h"
+#include "htags.h"
+#include "pyscanner.h"
+#include "prologscanner.h"
+#include "fortranscanner.h"
 #include "xmlscanner.h"
+#include "tclscanner.h"
+#include "code.h"
+#include "objcache.h"
+#include "store.h"
+#include "marshal.h"
+#include "portable.h"
+#include "vhdljjparser.h"
+#include "vhdldocgen.h"
+#include "eclipsehelp.h"
+#include "cite.h"
+#include "filestorage.h"
+#include "markdown.h"
+#include "arguments.h"
+#include "memberlist.h"
+#include "layout.h"
+#include "groupdef.h"
+#include "classlist.h"
+#include "namespacedef.h"
+#include "filename.h"
+#include "membername.h"
+#include "membergroup.h"
+#include "docsets.h"
+#include "formula.h"
+#include "settings.h"
+#include "context.h"
+#include "fileparser.h"
 
 // provided by the generated file resources.cpp
 extern void initResources();
 
-#define RECURSE_ENTRYTREE(func, var)                                           \
-  do {                                                                         \
-    if (var->children()) {                                                     \
-      EntryNavListIterator eli(*var->children());                              \
-      for (; eli.current(); ++eli)                                             \
-        func(eli.current());                                                   \
-    }                                                                          \
-  } while (0)
+#define RECURSE_ENTRYTREE(func,var) \
+  do { if (var->children()) { \
+    EntryNavListIterator eli(*var->children()); \
+    for (;eli.current();++eli) func(eli.current()); \
+  } } while(0)
+
 
 #if !defined(_WIN32) || defined(__CYGWIN__)
 #include <signal.h>
@@ -118,81 +116,78 @@ extern void initResources();
 #endif
 
 // globally accessible variables
-ClassSDict *Doxygen::classSDict = 0;
-ClassSDict *Doxygen::hiddenClasses = 0;
-NamespaceSDict *Doxygen::namespaceSDict = 0;
+ClassSDict      *Doxygen::classSDict = 0;
+ClassSDict      *Doxygen::hiddenClasses = 0;
+NamespaceSDict  *Doxygen::namespaceSDict = 0;
 MemberNameSDict *Doxygen::memberNameSDict = 0;
 MemberNameSDict *Doxygen::functionNameSDict = 0;
-FileNameList *Doxygen::inputNameList = 0; // all input files
-FileNameDict *Doxygen::inputNameDict = 0;
-GroupSDict *Doxygen::groupSDict = 0;
-FormulaList *Doxygen::formulaList = 0;     // all formulas
-FormulaDict *Doxygen::formulaDict = 0;     // all formulas
-FormulaDict *Doxygen::formulaNameDict = 0; // the label name of all formulas
-PageSDict *Doxygen::pageSDict = 0;
-PageSDict *Doxygen::exampleSDict = 0;
-SectionDict *Doxygen::sectionDict = 0; // all page sections
-CiteDict *Doxygen::citeDict = 0;       // database of bibliographic references
-StringDict Doxygen::aliasDict(257);    // aliases
-QDict<void> Doxygen::inputPaths(1009);
-FileNameDict *Doxygen::includeNameDict = 0;  // include names
-FileNameDict *Doxygen::exampleNameDict = 0;  // examples
-FileNameDict *Doxygen::imageNameDict = 0;    // images
-FileNameDict *Doxygen::dotFileNameDict = 0;  // dot files
-FileNameDict *Doxygen::mscFileNameDict = 0;  // msc files
-FileNameDict *Doxygen::diaFileNameDict = 0;  // dia files
-StringDict Doxygen::namespaceAliasDict(257); // all namespace aliases
-StringDict Doxygen::tagDestinationDict(257); // all tag locations
-QDict<void>
-    Doxygen::expandAsDefinedDict(257); // all macros that should be expanded
-QIntDict<MemberGroupInfo>
-    Doxygen::memGrpInfoDict(1009); // dictionary of the member groups heading
-PageDef *Doxygen::mainPage = 0;
-bool Doxygen::insideMainPage =
-    FALSE; // are we generating docs for the main page?
-NamespaceDef *Doxygen::globalScope = 0;
-QDict<RefList> *Doxygen::xrefLists =
-    new QDict<RefList>; // dictionary of cross-referenced item lists
-bool Doxygen::parseSourcesNeeded = FALSE;
-QTime Doxygen::runningTime;
-SearchIndexIntf *Doxygen::searchIndex = 0;
+FileNameList    *Doxygen::inputNameList = 0;       // all input files
+FileNameDict    *Doxygen::inputNameDict = 0;
+GroupSDict      *Doxygen::groupSDict = 0;
+FormulaList     *Doxygen::formulaList = 0;       // all formulas
+FormulaDict     *Doxygen::formulaDict = 0;       // all formulas
+FormulaDict     *Doxygen::formulaNameDict = 0;   // the label name of all formulas
+PageSDict       *Doxygen::pageSDict = 0;
+PageSDict       *Doxygen::exampleSDict = 0;
+SectionDict     *Doxygen::sectionDict = 0;        // all page sections
+CiteDict        *Doxygen::citeDict=0;              // database of bibliographic references
+StringDict       Doxygen::aliasDict(257);          // aliases
+QDict<void>      Doxygen::inputPaths(1009);
+FileNameDict    *Doxygen::includeNameDict = 0;     // include names
+FileNameDict    *Doxygen::exampleNameDict = 0;     // examples
+FileNameDict    *Doxygen::imageNameDict = 0;       // images
+FileNameDict    *Doxygen::dotFileNameDict = 0;     // dot files
+FileNameDict    *Doxygen::mscFileNameDict = 0;     // msc files
+FileNameDict    *Doxygen::diaFileNameDict = 0;     // dia files
+StringDict       Doxygen::namespaceAliasDict(257); // all namespace aliases
+StringDict       Doxygen::tagDestinationDict(257); // all tag locations
+QDict<void>      Doxygen::expandAsDefinedDict(257); // all macros that should be expanded
+QIntDict<MemberGroupInfo> Doxygen::memGrpInfoDict(1009); // dictionary of the member groups heading
+PageDef         *Doxygen::mainPage = 0;
+bool             Doxygen::insideMainPage = FALSE; // are we generating docs for the main page?
+NamespaceDef    *Doxygen::globalScope = 0;
+QDict<RefList>  *Doxygen::xrefLists = new QDict<RefList>; // dictionary of cross-referenced item lists
+bool             Doxygen::parseSourcesNeeded = FALSE;
+QTime            Doxygen::runningTime;
+SearchIndexIntf *Doxygen::searchIndex=0;
 QDict<DefinitionIntf> *Doxygen::symbolMap = 0;
 QDict<Definition> *Doxygen::clangUsrMap = 0;
-bool Doxygen::outputToWizard = FALSE;
-QDict<int> *Doxygen::htmlDirMap = 0;
+bool             Doxygen::outputToWizard=FALSE;
+QDict<int> *     Doxygen::htmlDirMap = 0;
 QCache<LookupInfo> *Doxygen::lookupCache;
-DirSDict *Doxygen::directories;
+DirSDict        *Doxygen::directories;
 SDict<DirRelation> Doxygen::dirRelations(257);
-ParserManager *Doxygen::parserManager = 0;
+ParserManager   *Doxygen::parserManager = 0;
 QCString Doxygen::htmlFileExtension;
-bool Doxygen::suppressDocWarnings = FALSE;
-Store *Doxygen::symbolStorage;
-QCString Doxygen::objDBFileName;
-QCString Doxygen::entryDBFileName;
-bool Doxygen::gatherDefines = TRUE;
-IndexList *Doxygen::indexList;
-int Doxygen::subpageNestingLevel = 0;
-bool Doxygen::userComments = FALSE;
-QCString Doxygen::spaces;
-bool Doxygen::generatingXmlOutput = FALSE;
-bool Doxygen::markdownSupport = TRUE;
-GenericsSDict *Doxygen::genericsDict;
+bool             Doxygen::suppressDocWarnings = FALSE;
+Store           *Doxygen::symbolStorage;
+QCString         Doxygen::objDBFileName;
+QCString         Doxygen::entryDBFileName;
+bool             Doxygen::gatherDefines = TRUE;
+IndexList       *Doxygen::indexList;
+int              Doxygen::subpageNestingLevel = 0;
+bool             Doxygen::userComments = FALSE;
+QCString         Doxygen::spaces;
+bool             Doxygen::generatingXmlOutput = FALSE;
+bool             Doxygen::markdownSupport = TRUE;
+GenericsSDict   *Doxygen::genericsDict;
 
 // locally accessible globals
-static QDict<EntryNav> g_classEntries(1009);
-static StringList g_inputFiles;
-static QDict<void> g_compoundKeywordDict(7); // keywords recognised as compounds
-static OutputList *g_outputList = 0; // list of output generating objects
-static QDict<FileDef> g_usingDeclarations(1009); // used classes
-static FileStorage *g_storage = 0;
-static bool g_successfulRun = FALSE;
-static bool g_dumpSymbolMap = FALSE;
-static bool g_useOutputTemplate = FALSE;
-
-void clearAll() {
+static QDict<EntryNav>  g_classEntries(1009);
+static StringList       g_inputFiles;
+static QDict<void>      g_compoundKeywordDict(7);  // keywords recognised as compounds
+static OutputList      *g_outputList = 0;          // list of output generating objects
+static QDict<FileDef>   g_usingDeclarations(1009); // used classes
+static FileStorage     *g_storage = 0;
+static bool             g_successfulRun = FALSE;
+static bool             g_dumpSymbolMap = FALSE;
+static bool             g_useOutputTemplate = FALSE;
+
+void clearAll()
+{
   g_inputFiles.clear();
-  // g_excludeNameDict.clear();
-  // delete g_outputList; g_outputList=0;
+  //g_excludeNameDict.clear();
+  //delete g_outputList; g_outputList=0;
 
   Doxygen::classSDict->clear();
   Doxygen::namespaceSDict->clear();
@@ -212,104 +207,122 @@ void clearAll() {
   Doxygen::formulaNameDict->clear();
   Doxygen::tagDestinationDict.clear();
   delete Doxygen::citeDict;
-  delete Doxygen::mainPage;
-  Doxygen::mainPage = 0;
-}
-
-class Statistics {
-public:
-  Statistics() { stats.setAutoDelete(TRUE); }
-  void begin(const char *name) {
-    msg(name);
-    stat *entry = new stat(name, 0);
-    stats.append(entry);
-    time.restart();
-  }
-  void end() { stats.getLast()->elapsed = ((double)time.elapsed()) / 1000.0; }
-  void print() {
-    bool restore = FALSE;
-    if (Debug::isFlagSet(Debug::Time)) {
-      Debug::clearFlag("time");
-      restore = TRUE;
-    }
-    msg("----------------------\n");
-    QListIterator<stat> sli(stats);
-    stat *s;
-    for (sli.toFirst(); (s = sli.current()); ++sli) {
-      msg("Spent %.3f seconds in %s", s->elapsed, s->name);
-    }
-    if (restore)
-      Debug::setFlag("time");
-  }
-
-private:
-  struct stat {
-    const char *name;
-    double elapsed;
-    stat() : name(NULL), elapsed(0) {}
-    stat(const char *n, double el) : name(n), elapsed(el) {}
-  };
-  QList<stat> stats;
-  QTime time;
+  delete Doxygen::mainPage; Doxygen::mainPage=0;
+}
+
+class Statistics
+{
+  public:
+    Statistics() { stats.setAutoDelete(TRUE); }
+    void begin(const char *name)
+    {
+      msg(name);
+      stat *entry= new stat(name,0);
+      stats.append(entry);
+      time.restart();
+    }
+    void end()
+    {
+      stats.getLast()->elapsed=((double)time.elapsed())/1000.0;
+    }
+    void print()
+    {
+      bool restore=FALSE;
+      if (Debug::isFlagSet(Debug::Time))
+      {
+        Debug::clearFlag("time");
+        restore=TRUE;
+      }
+      msg("----------------------\n");
+      QListIterator<stat> sli(stats);
+      stat *s;
+      for ( sli.toFirst(); (s=sli.current()); ++sli )
+      {
+        msg("Spent %.3f seconds in %s",s->elapsed,s->name);
+      }
+      if (restore) Debug::setFlag("time");
+    }
+  private:
+    struct stat
+    {
+      const char *name;
+      double elapsed;
+      stat() : name(NULL),elapsed(0) {}
+      stat(const char *n, double el) : name(n),elapsed(el) {}
+    };
+    QList<stat> stats;
+    QTime       time;
 } g_s;
 
-void statistics() {
-  fprintf(stderr, "--- inputNameDict stats ----\n");
+
+void statistics()
+{
+  fprintf(stderr,"--- inputNameDict stats ----\n");
   Doxygen::inputNameDict->statistics();
-  fprintf(stderr, "--- includeNameDict stats ----\n");
+  fprintf(stderr,"--- includeNameDict stats ----\n");
   Doxygen::includeNameDict->statistics();
-  fprintf(stderr, "--- exampleNameDict stats ----\n");
+  fprintf(stderr,"--- exampleNameDict stats ----\n");
   Doxygen::exampleNameDict->statistics();
-  fprintf(stderr, "--- imageNameDict stats ----\n");
+  fprintf(stderr,"--- imageNameDict stats ----\n");
   Doxygen::imageNameDict->statistics();
-  fprintf(stderr, "--- dotFileNameDict stats ----\n");
+  fprintf(stderr,"--- dotFileNameDict stats ----\n");
   Doxygen::dotFileNameDict->statistics();
-  fprintf(stderr, "--- mscFileNameDict stats ----\n");
+  fprintf(stderr,"--- mscFileNameDict stats ----\n");
   Doxygen::mscFileNameDict->statistics();
-  fprintf(stderr, "--- diaFileNameDict stats ----\n");
+  fprintf(stderr,"--- diaFileNameDict stats ----\n");
   Doxygen::diaFileNameDict->statistics();
-  // fprintf(stderr,"--- g_excludeNameDict stats ----\n");
-  // g_excludeNameDict.statistics();
-  fprintf(stderr, "--- aliasDict stats ----\n");
+  //fprintf(stderr,"--- g_excludeNameDict stats ----\n");
+  //g_excludeNameDict.statistics();
+  fprintf(stderr,"--- aliasDict stats ----\n");
   Doxygen::aliasDict.statistics();
-  fprintf(stderr, "--- typedefDict stats ----\n");
-  fprintf(stderr, "--- namespaceAliasDict stats ----\n");
+  fprintf(stderr,"--- typedefDict stats ----\n");
+  fprintf(stderr,"--- namespaceAliasDict stats ----\n");
   Doxygen::namespaceAliasDict.statistics();
-  fprintf(stderr, "--- formulaDict stats ----\n");
+  fprintf(stderr,"--- formulaDict stats ----\n");
   Doxygen::formulaDict->statistics();
-  fprintf(stderr, "--- formulaNameDict stats ----\n");
+  fprintf(stderr,"--- formulaNameDict stats ----\n");
   Doxygen::formulaNameDict->statistics();
-  fprintf(stderr, "--- tagDestinationDict stats ----\n");
+  fprintf(stderr,"--- tagDestinationDict stats ----\n");
   Doxygen::tagDestinationDict.statistics();
-  fprintf(stderr, "--- g_compoundKeywordDict stats ----\n");
+  fprintf(stderr,"--- g_compoundKeywordDict stats ----\n");
   g_compoundKeywordDict.statistics();
-  fprintf(stderr, "--- expandAsDefinedDict stats ----\n");
+  fprintf(stderr,"--- expandAsDefinedDict stats ----\n");
   Doxygen::expandAsDefinedDict.statistics();
-  fprintf(stderr, "--- memGrpInfoDict stats ----\n");
+  fprintf(stderr,"--- memGrpInfoDict stats ----\n");
   Doxygen::memGrpInfoDict.statistics();
 }
 
-static void addMemberDocs(EntryNav *rootNav, MemberDef *md,
-                          const char *funcDecl, ArgumentList *al,
-                          bool over_load, NamespaceSDict *nl = 0);
-static void findMember(EntryNav *rootNav, QCString funcDecl, bool overloaded,
-                       bool isFunc);
 
-enum FindBaseClassRelation_Mode {
+
+static void addMemberDocs(EntryNav *rootNav,MemberDef *md, const char *funcDecl,
+                   ArgumentList *al,bool over_load,NamespaceSDict *nl=0);
+static void findMember(EntryNav *rootNav,
+                       QCString funcDecl,
+                       bool overloaded,
+                       bool isFunc
+                      );
+
+enum FindBaseClassRelation_Mode
+{
   TemplateInstances,
   DocumentedOnly,
   Undocumented
 };
 
-static bool findClassRelation(EntryNav *rootNav, Definition *context,
-                              ClassDef *cd, BaseInfo *bi,
-                              QDict<int> *templateNames,
-                              /*bool insertUndocumented*/
-                              FindBaseClassRelation_Mode mode,
-                              bool isArtificial);
+static bool findClassRelation(
+                           EntryNav *rootNav,
+                           Definition *context,
+                           ClassDef *cd,
+                           BaseInfo *bi,
+                           QDict<int> *templateNames,
+                           /*bool insertUndocumented*/
+                           FindBaseClassRelation_Mode mode,
+                           bool isArtificial
+                          );
 
 /** A struct contained the data for an STL class */
-struct STLInfo {
+struct STLInfo
+{
   const char *className;
   const char *baseClass1;
   const char *baseClass2;
@@ -321,176 +334,172 @@ struct STLInfo {
   bool iterators;
 };
 
-static STLInfo g_stlinfo[] = {
-    // className              baseClass1                      baseClass2
-    // templType1     templName1     templType2    templName2
-    // virtInheritance  // iterators
-    {"allocator", 0, 0, "T", "elements", 0, 0, FALSE, FALSE},
-    {"array", 0, 0, "T", "elements", 0, 0, FALSE, FALSE}, // C++11
-    {"auto_ptr", 0, 0, "T", "ptr", 0, 0, FALSE, FALSE},   // deprecated
-    {"smart_ptr", 0, 0, "T", "ptr", 0, 0, FALSE, FALSE},  // C++11
-    {"unique_ptr", 0, 0, "T", "ptr", 0, 0, FALSE, FALSE}, // C++11
-    {"weak_ptr", 0, 0, "T", "ptr", 0, 0, FALSE, FALSE},   // C++11
-    {"ios_base", 0, 0, 0, 0, 0, 0, FALSE, FALSE},         // C++11
-    {"error_code", 0, 0, 0, 0, 0, 0, FALSE, FALSE},       // C++11
-    {"error_category", 0, 0, 0, 0, 0, 0, FALSE, FALSE},   // C++11
-    {"system_error", 0, 0, 0, 0, 0, 0, FALSE, FALSE},     // C++11
-    {"error_condition", 0, 0, 0, 0, 0, 0, FALSE, FALSE},  // C++11
-    {"thread", 0, 0, 0, 0, 0, 0, FALSE, FALSE},           // C++11
-    {"basic_ios", "ios_base", 0, "Char", 0, 0, 0, FALSE, FALSE},
-    {"basic_istream", "basic_ios<Char>", 0, "Char", 0, 0, 0, TRUE, FALSE},
-    {"basic_ostream", "basic_ios<Char>", 0, "Char", 0, 0, 0, TRUE, FALSE},
-    {"basic_iostream", "basic_istream<Char>", "basic_ostream<Char>", "Char", 0,
-     0, 0, FALSE, FALSE},
-    {"basic_ifstream", "basic_istream<Char>", 0, "Char", 0, 0, 0, FALSE, FALSE},
-    {"basic_ofstream", "basic_ostream<Char>", 0, "Char", 0, 0, 0, FALSE, FALSE},
-    {"basic_fstream", "basic_iostream<Char>", 0, "Char", 0, 0, 0, FALSE, FALSE},
-    {"basic_istringstream", "basic_istream<Char>", 0, "Char", 0, 0, 0, FALSE,
-     FALSE},
-    {"basic_ostringstream", "basic_ostream<Char>", 0, "Char", 0, 0, 0, FALSE,
-     FALSE},
-    {"basic_stringstream", "basic_iostream<Char>", 0, "Char", 0, 0, 0, FALSE,
-     FALSE},
-    {"ios", "basic_ios<char>", 0, 0, 0, 0, 0, FALSE, FALSE},
-    {"wios", "basic_ios<wchar_t>", 0, 0, 0, 0, 0, FALSE, FALSE},
-    {"istream", "basic_istream<char>", 0, 0, 0, 0, 0, FALSE, FALSE},
-    {"wistream", "basic_istream<wchar_t>", 0, 0, 0, 0, 0, FALSE, FALSE},
-    {"ostream", "basic_ostream<char>", 0, 0, 0, 0, 0, FALSE, FALSE},
-    {"wostream", "basic_ostream<wchar_t>", 0, 0, 0, 0, 0, FALSE, FALSE},
-    {"ifstream", "basic_ifstream<char>", 0, 0, 0, 0, 0, FALSE, FALSE},
-    {"wifstream", "basic_ifstream<wchar_t>", 0, 0, 0, 0, 0, FALSE, FALSE},
-    {"ofstream", "basic_ofstream<char>", 0, 0, 0, 0, 0, FALSE, FALSE},
-    {"wofstream", "basic_ofstream<wchar_t>", 0, 0, 0, 0, 0, FALSE, FALSE},
-    {"fstream", "basic_fstream<char>", 0, 0, 0, 0, 0, FALSE, FALSE},
-    {"wfstream", "basic_fstream<wchar_t>", 0, 0, 0, 0, 0, FALSE, FALSE},
-    {"istringstream", "basic_istringstream<char>", 0, 0, 0, 0, 0, FALSE, FALSE},
-    {"wistringstream", "basic_istringstream<wchar_t>", 0, 0, 0, 0, 0, FALSE,
-     FALSE},
-    {"ostringstream", "basic_ostringstream<char>", 0, 0, 0, 0, 0, FALSE, FALSE},
-    {"wostringstream", "basic_ostringstream<wchar_t>", 0, 0, 0, 0, 0, FALSE,
-     FALSE},
-    {"stringstream", "basic_stringstream<char>", 0, 0, 0, 0, 0, FALSE, FALSE},
-    {"wstringstream", "basic_stringstream<wchar_t>", 0, 0, 0, 0, 0, FALSE,
-     FALSE},
-    {"basic_string", 0, 0, "Char", 0, 0, 0, FALSE, TRUE},
-    {"string", "basic_string<char>", 0, 0, 0, 0, 0, FALSE, TRUE},
-    {"wstring", "basic_string<wchar_t>", 0, 0, 0, 0, 0, FALSE, TRUE},
-    {"complex", 0, 0, 0, 0, 0, 0, FALSE, FALSE},
-    {"bitset", 0, 0, "Bits", 0, 0, 0, FALSE, FALSE},
-    {"deque", 0, 0, "T", "elements", 0, 0, FALSE, TRUE},
-    {"list", 0, 0, "T", "elements", 0, 0, FALSE, TRUE},
-    {"forward_list", 0, 0, "T", "elements", 0, 0, FALSE, TRUE}, // C++11
-    {"map", 0, 0, "K", "keys", "T", "elements", FALSE, TRUE},
-    {"unordered_map", 0, 0, "K", "keys", "T", "elements", FALSE, TRUE}, // C++11
-    {"multimap", 0, 0, "K", "keys", "T", "elements", FALSE, TRUE},
-    {"unordered_multimap", 0, 0, "K", "keys", "T", "elements", FALSE,
-     TRUE}, // C++11
-    {"set", 0, 0, "K", "keys", 0, 0, FALSE, TRUE},
-    {"unordered_set", 0, 0, "K", "keys", 0, 0, FALSE, TRUE}, // C++11
-    {"multiset", 0, 0, "K", "keys", 0, 0, FALSE, TRUE},
-    {"unordered_multiset", 0, 0, "K", "keys", 0, 0, FALSE, TRUE}, // C++11
-    {"vector", 0, 0, "T", "elements", 0, 0, FALSE, TRUE},
-    {"queue", 0, 0, "T", "elements", 0, 0, FALSE, FALSE},
-    {"priority_queue", 0, 0, "T", "elements", 0, 0, FALSE, FALSE},
-    {"stack", 0, 0, "T", "elements", 0, 0, FALSE, FALSE},
-    {"valarray", 0, 0, "T", "elements", 0, 0, FALSE, FALSE},
-    {"exception", 0, 0, 0, 0, 0, 0, FALSE, FALSE},
-    {"bad_alloc", "exception", 0, 0, 0, 0, 0, FALSE, FALSE},
-    {"bad_cast", "exception", 0, 0, 0, 0, 0, FALSE, FALSE},
-    {"bad_typeid", "exception", 0, 0, 0, 0, 0, FALSE, FALSE},
-    {"logic_error", "exception", 0, 0, 0, 0, 0, FALSE, FALSE},
-    {"ios_base::failure", "exception", 0, 0, 0, 0, 0, FALSE, FALSE},
-    {"runtime_error", "exception", 0, 0, 0, 0, 0, FALSE, FALSE},
-    {"bad_exception", "exception", 0, 0, 0, 0, 0, FALSE, FALSE},
-    {"domain_error", "logic_error", 0, 0, 0, 0, 0, FALSE, FALSE},
-    {"invalid_argument", "logic_error", 0, 0, 0, 0, 0, FALSE, FALSE},
-    {"length_error", "logic_error", 0, 0, 0, 0, 0, FALSE, FALSE},
-    {"out_of_range", "logic_error", 0, 0, 0, 0, 0, FALSE, FALSE},
-    {"range_error", "runtime_error", 0, 0, 0, 0, 0, FALSE, FALSE},
-    {"overflow_error", "runtime_error", 0, 0, 0, 0, 0, FALSE, FALSE},
-    {"underflow_error", "runtime_error", 0, 0, 0, 0, 0, FALSE, FALSE},
-    {0, 0, 0, 0, 0, 0, 0, FALSE, FALSE}};
-
-static void addSTLMember(EntryNav *rootNav, const char *type,
-                         const char *name) {
+static STLInfo g_stlinfo[] =
+{
+  // className              baseClass1                      baseClass2             templType1     templName1     templType2    templName2     virtInheritance  // iterators
+  { "allocator",            0,                              0,                     "T",           "elements",    0,            0,             FALSE,              FALSE },
+  { "array",                0,                              0,                     "T",           "elements",    0,            0,             FALSE,              FALSE }, // C++11
+  { "auto_ptr",             0,                              0,                     "T",           "ptr",         0,            0,             FALSE,              FALSE }, // deprecated
+  { "smart_ptr",            0,                              0,                     "T",           "ptr",         0,            0,             FALSE,              FALSE }, // C++11
+  { "unique_ptr",           0,                              0,                     "T",           "ptr",         0,            0,             FALSE,              FALSE }, // C++11
+  { "weak_ptr",             0,                              0,                     "T",           "ptr",         0,            0,             FALSE,              FALSE }, // C++11
+  { "ios_base",             0,                              0,                     0,             0,             0,            0,             FALSE,              FALSE }, // C++11
+  { "error_code",           0,                              0,                     0,             0,             0,            0,             FALSE,              FALSE }, // C++11
+  { "error_category",       0,                              0,                     0,             0,             0,            0,             FALSE,              FALSE }, // C++11
+  { "system_error",         0,                              0,                     0,             0,             0,            0,             FALSE,              FALSE }, // C++11
+  { "error_condition",      0,                              0,                     0,             0,             0,            0,             FALSE,              FALSE }, // C++11
+  { "thread",               0,                              0,                     0,             0,             0,            0,             FALSE,              FALSE }, // C++11
+  { "basic_ios",            "ios_base",                     0,                     "Char",        0,             0,            0,             FALSE,              FALSE },
+  { "basic_istream",        "basic_ios<Char>",              0,                     "Char",        0,             0,            0,             TRUE,               FALSE },
+  { "basic_ostream",        "basic_ios<Char>",              0,                     "Char",        0,             0,            0,             TRUE,               FALSE },
+  { "basic_iostream",       "basic_istream<Char>",          "basic_ostream<Char>", "Char",        0,             0,            0,             FALSE,              FALSE },
+  { "basic_ifstream",       "basic_istream<Char>",          0,                     "Char",        0,             0,            0,             FALSE,              FALSE },
+  { "basic_ofstream",       "basic_ostream<Char>",          0,                     "Char",        0,             0,            0,             FALSE,              FALSE },
+  { "basic_fstream",        "basic_iostream<Char>",         0,                     "Char",        0,             0,            0,             FALSE,              FALSE },
+  { "basic_istringstream",  "basic_istream<Char>",          0,                     "Char",        0,             0,            0,             FALSE,              FALSE },
+  { "basic_ostringstream",  "basic_ostream<Char>",          0,                     "Char",        0,             0,            0,             FALSE,              FALSE },
+  { "basic_stringstream",   "basic_iostream<Char>",         0,                     "Char",        0,             0,            0,             FALSE,              FALSE },
+  { "ios",                  "basic_ios<char>",              0,                     0,             0,             0,            0,             FALSE,              FALSE },
+  { "wios",                 "basic_ios<wchar_t>",           0,                     0,             0,             0,            0,             FALSE,              FALSE },
+  { "istream",              "basic_istream<char>",          0,                     0,             0,             0,            0,             FALSE,              FALSE },
+  { "wistream",             "basic_istream<wchar_t>",       0,                     0,             0,             0,            0,             FALSE,              FALSE },
+  { "ostream",              "basic_ostream<char>",          0,                     0,             0,             0,            0,             FALSE,              FALSE },
+  { "wostream",             "basic_ostream<wchar_t>",       0,                     0,             0,             0,            0,             FALSE,              FALSE },
+  { "ifstream",             "basic_ifstream<char>",         0,                     0,             0,             0,            0,             FALSE,              FALSE },
+  { "wifstream",            "basic_ifstream<wchar_t>",      0,                     0,             0,             0,            0,             FALSE,              FALSE },
+  { "ofstream",             "basic_ofstream<char>",         0,                     0,             0,             0,            0,             FALSE,              FALSE },
+  { "wofstream",            "basic_ofstream<wchar_t>",      0,                     0,             0,             0,            0,             FALSE,              FALSE },
+  { "fstream",              "basic_fstream<char>",          0,                     0,             0,             0,            0,             FALSE,              FALSE },
+  { "wfstream",             "basic_fstream<wchar_t>",       0,                     0,             0,             0,            0,             FALSE,              FALSE },
+  { "istringstream",        "basic_istringstream<char>",    0,                     0,             0,             0,            0,             FALSE,              FALSE },
+  { "wistringstream",       "basic_istringstream<wchar_t>", 0,                     0,             0,             0,            0,             FALSE,              FALSE },
+  { "ostringstream",        "basic_ostringstream<char>",    0,                     0,             0,             0,            0,             FALSE,              FALSE },
+  { "wostringstream",       "basic_ostringstream<wchar_t>", 0,                     0,             0,             0,            0,             FALSE,              FALSE },
+  { "stringstream",         "basic_stringstream<char>",     0,                     0,             0,             0,            0,             FALSE,              FALSE },
+  { "wstringstream",        "basic_stringstream<wchar_t>",  0,                     0,             0,             0,            0,             FALSE,              FALSE },
+  { "basic_string",         0,                              0,                     "Char",        0,             0,            0,             FALSE,              TRUE  },
+  { "string",               "basic_string<char>",           0,                     0,             0,             0,            0,             FALSE,              TRUE  },
+  { "wstring",              "basic_string<wchar_t>",        0,                     0,             0,             0,            0,             FALSE,              TRUE  },
+  { "complex",              0,                              0,                     0,             0,             0,            0,             FALSE,              FALSE },
+  { "bitset",               0,                              0,                     "Bits",        0,             0,            0,             FALSE,              FALSE },
+  { "deque",                0,                              0,                     "T",           "elements",    0,            0,             FALSE,              TRUE  },
+  { "list",                 0,                              0,                     "T",           "elements",    0,            0,             FALSE,              TRUE  },
+  { "forward_list",         0,                              0,                     "T",           "elements",    0,            0,             FALSE,              TRUE  }, // C++11
+  { "map",                  0,                              0,                     "K",           "keys",        "T",          "elements",    FALSE,              TRUE  },
+  { "unordered_map",        0,                              0,                     "K",           "keys",        "T",          "elements",    FALSE,              TRUE  }, // C++11
+  { "multimap",             0,                              0,                     "K",           "keys",        "T",          "elements",    FALSE,              TRUE  },
+  { "unordered_multimap",   0,                              0,                     "K",           "keys",        "T",          "elements",    FALSE,              TRUE  }, // C++11
+  { "set",                  0,                              0,                     "K",           "keys",        0,            0,             FALSE,              TRUE  },
+  { "unordered_set",        0,                              0,                     "K",           "keys",        0,            0,             FALSE,              TRUE  }, // C++11
+  { "multiset",             0,                              0,                     "K",           "keys",        0,            0,             FALSE,              TRUE  },
+  { "unordered_multiset",   0,                              0,                     "K",           "keys",        0,            0,             FALSE,              TRUE  }, // C++11
+  { "vector",               0,                              0,                     "T",           "elements",    0,            0,             FALSE,              TRUE  },
+  { "queue",                0,                              0,                     "T",           "elements",    0,            0,             FALSE,              FALSE },
+  { "priority_queue",       0,                              0,                     "T",           "elements",    0,            0,             FALSE,              FALSE },
+  { "stack",                0,                              0,                     "T",           "elements",    0,            0,             FALSE,              FALSE },
+  { "valarray",             0,                              0,                     "T",           "elements",    0,            0,             FALSE,              FALSE },
+  { "exception",            0,                              0,                     0,             0,             0,            0,             FALSE,              FALSE },
+  { "bad_alloc",            "exception",                    0,                     0,             0,             0,            0,             FALSE,              FALSE },
+  { "bad_cast",             "exception",                    0,                     0,             0,             0,            0,             FALSE,              FALSE },
+  { "bad_typeid",           "exception",                    0,                     0,             0,             0,            0,             FALSE,              FALSE },
+  { "logic_error",          "exception",                    0,                     0,             0,             0,            0,             FALSE,              FALSE },
+  { "ios_base::failure",    "exception",                    0,                     0,             0,             0,            0,             FALSE,              FALSE },
+  { "runtime_error",        "exception",                    0,                     0,             0,             0,            0,             FALSE,              FALSE },
+  { "bad_exception",        "exception",                    0,                     0,             0,             0,            0,             FALSE,              FALSE },
+  { "domain_error",         "logic_error",                  0,                     0,             0,             0,            0,             FALSE,              FALSE },
+  { "invalid_argument",     "logic_error",                  0,                     0,             0,             0,            0,             FALSE,              FALSE },
+  { "length_error",         "logic_error",                  0,                     0,             0,             0,            0,             FALSE,              FALSE },
+  { "out_of_range",         "logic_error",                  0,                     0,             0,             0,            0,             FALSE,              FALSE },
+  { "range_error",          "runtime_error",                0,                     0,             0,             0,            0,             FALSE,              FALSE },
+  { "overflow_error",       "runtime_error",                0,                     0,             0,             0,            0,             FALSE,              FALSE },
+  { "underflow_error",      "runtime_error",                0,                     0,             0,             0,            0,             FALSE,              FALSE },
+  { 0,                      0,                              0,                     0,             0,             0,            0,             FALSE,              FALSE }
+};
+
+static void addSTLMember(EntryNav *rootNav,const char *type,const char *name)
+{
   Entry *memEntry = new Entry;
-  memEntry->name = name;
-  memEntry->type = type;
+  memEntry->name       = name;
+  memEntry->type       = type;
   memEntry->protection = Public;
-  memEntry->section = Entry::VARIABLE_SEC;
-  memEntry->brief = "STL member";
-  memEntry->hidden = FALSE;
+  memEntry->section    = Entry::VARIABLE_SEC;
+  memEntry->brief      = "STL member";
+  memEntry->hidden     = FALSE;
   memEntry->artificial = TRUE;
-  // memEntry->parent     = root;
-  // root->addSubEntry(memEntry);
-  EntryNav *memEntryNav = new EntryNav(rootNav, memEntry);
+  //memEntry->parent     = root;
+  //root->addSubEntry(memEntry);
+  EntryNav *memEntryNav = new EntryNav(rootNav,memEntry);
   memEntryNav->setEntry(memEntry);
   rootNav->addChild(memEntryNav);
 }
 
-static void addSTLIterator(EntryNav *classEntryNav, const char *name) {
+static void addSTLIterator(EntryNav *classEntryNav,const char *name)
+{
   Entry *iteratorClassEntry = new Entry;
-  iteratorClassEntry->fileName = "[STL]";
+  iteratorClassEntry->fileName  = "[STL]";
   iteratorClassEntry->startLine = 1;
-  iteratorClassEntry->name = name;
-  iteratorClassEntry->section = Entry::CLASS_SEC;
-  iteratorClassEntry->brief = "STL iterator class";
-  iteratorClassEntry->hidden = FALSE;
-  iteratorClassEntry->artificial = TRUE;
-  EntryNav *iteratorClassEntryNav =
-      new EntryNav(classEntryNav, iteratorClassEntry);
+  iteratorClassEntry->name      = name;
+  iteratorClassEntry->section   = Entry::CLASS_SEC;
+  iteratorClassEntry->brief     = "STL iterator class";
+  iteratorClassEntry->hidden    = FALSE;
+  iteratorClassEntry->artificial= TRUE;
+  EntryNav *iteratorClassEntryNav = new EntryNav(classEntryNav,iteratorClassEntry);
   iteratorClassEntryNav->setEntry(iteratorClassEntry);
   classEntryNav->addChild(iteratorClassEntryNav);
 }
 
-static void addSTLClasses(EntryNav *rootNav) {
+
+static void addSTLClasses(EntryNav *rootNav)
+{
   Entry *namespaceEntry = new Entry;
-  namespaceEntry->fileName = "[STL]";
+  namespaceEntry->fileName  = "[STL]";
   namespaceEntry->startLine = 1;
-  // namespaceEntry->parent    = rootNav->entry();
-  namespaceEntry->name = "std";
-  namespaceEntry->section = Entry::NAMESPACE_SEC;
-  namespaceEntry->brief = "STL namespace";
-  namespaceEntry->hidden = FALSE;
-  namespaceEntry->artificial = TRUE;
-  // root->addSubEntry(namespaceEntry);
-  EntryNav *namespaceEntryNav = new EntryNav(rootNav, namespaceEntry);
+  //namespaceEntry->parent    = rootNav->entry();
+  namespaceEntry->name      = "std";
+  namespaceEntry->section   = Entry::NAMESPACE_SEC;
+  namespaceEntry->brief     = "STL namespace";
+  namespaceEntry->hidden    = FALSE;
+  namespaceEntry->artificial= TRUE;
+  //root->addSubEntry(namespaceEntry);
+  EntryNav *namespaceEntryNav = new EntryNav(rootNav,namespaceEntry);
   namespaceEntryNav->setEntry(namespaceEntry);
   rootNav->addChild(namespaceEntryNav);
 
   STLInfo *info = g_stlinfo;
-  while (info->className) {
-    // printf("Adding STL class %s\n",info->className);
+  while (info->className)
+  {
+    //printf("Adding STL class %s\n",info->className);
     QCString fullName = info->className;
     fullName.prepend("std::");
 
     // add fake Entry for the class
     Entry *classEntry = new Entry;
-    classEntry->fileName = "[STL]";
+    classEntry->fileName  = "[STL]";
     classEntry->startLine = 1;
-    classEntry->name = fullName;
-    // classEntry->parent    = namespaceEntry;
-    classEntry->section = Entry::CLASS_SEC;
-    classEntry->brief = "STL class";
-    classEntry->hidden = FALSE;
-    classEntry->artificial = TRUE;
-    // namespaceEntry->addSubEntry(classEntry);
-    EntryNav *classEntryNav = new EntryNav(namespaceEntryNav, classEntry);
+    classEntry->name      = fullName;
+    //classEntry->parent    = namespaceEntry;
+    classEntry->section   = Entry::CLASS_SEC;
+    classEntry->brief     = "STL class";
+    classEntry->hidden    = FALSE;
+    classEntry->artificial= TRUE;
+    //namespaceEntry->addSubEntry(classEntry);
+    EntryNav *classEntryNav = new EntryNav(namespaceEntryNav,classEntry);
     classEntryNav->setEntry(classEntry);
     namespaceEntryNav->addChild(classEntryNav);
 
     // add template arguments to class
-    if (info->templType1) {
+    if (info->templType1)
+    {
       ArgumentList *al = new ArgumentList;
-      Argument *a = new Argument;
-      a->type = "typename";
-      a->name = info->templType1;
+      Argument *a=new Argument;
+      a->type="typename";
+      a->name=info->templType1;
       al->append(a);
       if (info->templType2) // another template argument
       {
-        a = new Argument;
-        a->type = "typename";
-        a->name = info->templType2;
+        a=new Argument;
+        a->type="typename";
+        a->name=info->templType2;
         al->append(a);
       }
       classEntry->tArgLists = new QList<ArgumentList>;
@@ -498,43 +507,45 @@ static void addSTLClasses(EntryNav *rootNav) {
       classEntry->tArgLists->append(al);
     }
     // add member variables
-    if (info->templName1) {
-      addSTLMember(classEntryNav, info->templType1, info->templName1);
+    if (info->templName1)
+    {
+      addSTLMember(classEntryNav,info->templType1,info->templName1);
     }
-    if (info->templName2) {
-      addSTLMember(classEntryNav, info->templType2, info->templName2);
+    if (info->templName2)
+    {
+      addSTLMember(classEntryNav,info->templType2,info->templName2);
     }
-    if (fullName == "std::auto_ptr" || fullName == "std::smart_ptr" ||
-        fullName == "std::unique_ptr" || fullName == "std::weak_ptr") {
+    if (fullName=="std::auto_ptr" || fullName=="std::smart_ptr" ||
+        fullName=="std::unique_ptr" || fullName=="std::weak_ptr")
+    {
       Entry *memEntry = new Entry;
-      memEntry->name = "operator->";
-      memEntry->args = "()";
-      memEntry->type = "T*";
+      memEntry->name       = "operator->";
+      memEntry->args       = "()";
+      memEntry->type       = "T*";
       memEntry->protection = Public;
-      memEntry->section = Entry::FUNCTION_SEC;
-      memEntry->brief = "STL member";
-      memEntry->hidden = FALSE;
+      memEntry->section    = Entry::FUNCTION_SEC;
+      memEntry->brief      = "STL member";
+      memEntry->hidden     = FALSE;
       memEntry->artificial = FALSE;
-      EntryNav *memEntryNav = new EntryNav(classEntryNav, memEntry);
+      EntryNav *memEntryNav = new EntryNav(classEntryNav,memEntry);
       memEntryNav->setEntry(memEntry);
       classEntryNav->addChild(memEntryNav);
     }
-    if (info->baseClass1) {
-      classEntry->extends->append(
-          new BaseInfo(info->baseClass1, Public,
-                       info->virtualInheritance ? Virtual : Normal));
+    if (info->baseClass1)
+    {
+      classEntry->extends->append(new BaseInfo(info->baseClass1,Public,info->virtualInheritance?Virtual:Normal));
     }
-    if (info->baseClass2) {
-      classEntry->extends->append(
-          new BaseInfo(info->baseClass2, Public,
-                       info->virtualInheritance ? Virtual : Normal));
+    if (info->baseClass2)
+    {
+      classEntry->extends->append(new BaseInfo(info->baseClass2,Public,info->virtualInheritance?Virtual:Normal));
     }
-    if (info->iterators) {
+    if (info->iterators)
+    {
       // add iterator class
-      addSTLIterator(classEntryNav, fullName + "::iterator");
-      addSTLIterator(classEntryNav, fullName + "::const_iterator");
-      addSTLIterator(classEntryNav, fullName + "::reverse_iterator");
-      addSTLIterator(classEntryNav, fullName + "::const_reverse_iterator");
+      addSTLIterator(classEntryNav,fullName+"::iterator");
+      addSTLIterator(classEntryNav,fullName+"::const_iterator");
+      addSTLIterator(classEntryNav,fullName+"::reverse_iterator");
+      addSTLIterator(classEntryNav,fullName+"::const_reverse_iterator");
     }
     info++;
   }
@@ -542,105 +553,116 @@ static void addSTLClasses(EntryNav *rootNav) {
 
 //----------------------------------------------------------------------------
 
-static Definition *findScopeFromQualifiedName(Definition *startScope,
-                                              const QCString &n,
-                                              FileDef *fileScope,
-                                              TagInfo *tagInfo);
+static Definition *findScopeFromQualifiedName(Definition *startScope,const QCString &n,
+                                              FileDef *fileScope,TagInfo *tagInfo);
 
-static void addPageToContext(PageDef *pd, EntryNav *rootNav) {
+static void addPageToContext(PageDef *pd,EntryNav *rootNav)
+{
   if (rootNav->parent()) // add the page to it's scope
   {
     QCString scope = rootNav->parent()->name();
-    if (rootNav->parent()->section() == Entry::PACKAGEDOC_SEC) {
-      scope = substitute(scope, ".", "::");
+    if (rootNav->parent()->section()==Entry::PACKAGEDOC_SEC)
+    {
+      scope=substitute(scope,".","::");
     }
     scope = stripAnonymousNamespaceScope(scope);
-    scope += "::" + pd->name();
-    Definition *d = findScopeFromQualifiedName(Doxygen::globalScope, scope, 0,
-                                               rootNav->tagInfo());
-    if (d) {
+    scope+="::"+pd->name();
+    Definition *d = findScopeFromQualifiedName(Doxygen::globalScope,scope,0,rootNav->tagInfo());
+    if (d)
+    {
       pd->setPageScope(d);
     }
   }
 }
 
-static void addRelatedPage(EntryNav *rootNav) {
+static void addRelatedPage(EntryNav *rootNav)
+{
   Entry *root = rootNav->entry();
-  GroupDef *gd = 0;
+  GroupDef *gd=0;
   QListIterator<Grouping> gli(*root->groups);
   Grouping *g;
-  for (; (g = gli.current()); ++gli) {
-    if (!g->groupname.isEmpty() &&
-        (gd = Doxygen::groupSDict->find(g->groupname)))
-      break;
+  for (;(g=gli.current());++gli)
+  {
+    if (!g->groupname.isEmpty() && (gd=Doxygen::groupSDict->find(g->groupname))) break;
   }
-  // printf("---> addRelatedPage() %s gd=%p\n",root->name.data(),gd);
+  //printf("---> addRelatedPage() %s gd=%p\n",root->name.data(),gd);
   QCString doc;
-  if (root->brief.isEmpty()) {
-    doc = root->doc + root->inbodyDocs;
-  } else {
-    doc = root->brief + "\n\n" + root->doc + root->inbodyDocs;
-  }
-  PageDef *pd = addRelatedPage(root->name, root->args, doc, root->anchors,
-                               root->docFile, root->docLine, root->sli, gd,
-                               rootNav->tagInfo(), root->lang);
-  if (pd) {
-    pd->setBriefDescription(root->brief, root->briefFile, root->briefLine);
+  if (root->brief.isEmpty())
+  {
+    doc=root->doc+root->inbodyDocs;
+  }
+  else
+  {
+    doc=root->brief+"\n\n"+root->doc+root->inbodyDocs;
+  }
+  PageDef *pd = addRelatedPage(root->name,root->args,doc,root->anchors,
+      root->docFile,root->docLine,
+      root->sli,
+      gd,rootNav->tagInfo(),
+      root->lang
+     );
+  if (pd)
+  {
+    pd->setBriefDescription(root->brief,root->briefFile,root->briefLine);
     pd->addSectionsToDefinition(root->anchors);
     pd->setShowToc(root->stat);
-    addPageToContext(pd, rootNav);
+    addPageToContext(pd,rootNav);
   }
 }
 
-static void buildGroupListFiltered(EntryNav *rootNav, bool additional,
-                                   bool includeExternal) {
-  if (rootNav->section() == Entry::GROUPDOC_SEC && !rootNav->name().isEmpty() &&
-      ((!includeExternal && rootNav->tagInfo() == 0) ||
-       (includeExternal && rootNav->tagInfo() != 0))) {
+static void buildGroupListFiltered(EntryNav *rootNav,bool additional, bool includeExternal)
+{
+  if (rootNav->section()==Entry::GROUPDOC_SEC && !rootNav->name().isEmpty() &&
+        ((!includeExternal && rootNav->tagInfo()==0) ||
+         ( includeExternal && rootNav->tagInfo()!=0))
+     )
+  {
     rootNav->loadEntry(g_storage);
     Entry *root = rootNav->entry();
 
-    if ((root->groupDocType == Entry::GROUPDOC_NORMAL && !additional) ||
-        (root->groupDocType != Entry::GROUPDOC_NORMAL && additional)) {
+    if ((root->groupDocType==Entry::GROUPDOC_NORMAL && !additional) ||
+        (root->groupDocType!=Entry::GROUPDOC_NORMAL &&  additional))
+    {
       GroupDef *gd = Doxygen::groupSDict->find(root->name);
-      // printf("Processing group '%s':'%s' add=%d ext=%d gd=%p\n",
+      //printf("Processing group '%s':'%s' add=%d ext=%d gd=%p\n",
       //    root->type.data(),root->name.data(),additional,includeExternal,gd);
 
-      if (gd) {
-        if (!gd->hasGroupTitle()) {
-          gd->setGroupTitle(root->type);
-        } else if (root->type.length() > 0 && root->name != root->type &&
-                   gd->groupTitle() != root->type) {
-          warn(root->fileName, root->startLine, "group %s: ignoring title "
-                                                "\"%s\" that does not match "
-                                                "old title \"%s\"\n",
-               qPrint(root->name), qPrint(root->type),
-               qPrint(gd->groupTitle()));
-        }
-        gd->setBriefDescription(root->brief, root->briefFile, root->briefLine);
-        gd->setDocumentation(root->doc, root->docFile, root->docLine);
-        gd->setInbodyDocumentation(root->inbodyDocs, root->inbodyFile,
-                                   root->inbodyLine);
+      if (gd)
+      {
+        if ( !gd->hasGroupTitle() )
+        {
+          gd->setGroupTitle( root->type );
+        }
+        else if ( root->type.length() > 0 && root->name != root->type && gd->groupTitle() != root->type )
+        {
+          warn( root->fileName,root->startLine,
+              "group %s: ignoring title \"%s\" that does not match old title \"%s\"\n",
+              qPrint(root->name), qPrint(root->type), qPrint(gd->groupTitle()) );
+        }
+        gd->setBriefDescription(root->brief,root->briefFile,root->briefLine);
+        gd->setDocumentation( root->doc, root->docFile, root->docLine );
+        gd->setInbodyDocumentation( root->inbodyDocs, root->inbodyFile, root->inbodyLine );
         gd->addSectionsToDefinition(root->anchors);
         gd->setRefItems(root->sli);
         gd->setLanguage(root->lang);
-      } else {
-        if (rootNav->tagInfo()) {
-          gd = new GroupDef(root->fileName, root->startLine, root->name,
-                            root->type, rootNav->tagInfo()->fileName);
+      }
+      else
+      {
+        if (rootNav->tagInfo())
+        {
+          gd = new GroupDef(root->fileName,root->startLine,root->name,root->type,rootNav->tagInfo()->fileName);
           gd->setReference(rootNav->tagInfo()->tagName);
-        } else {
-          gd = new GroupDef(root->fileName, root->startLine, root->name,
-                            root->type);
         }
-        gd->setBriefDescription(root->brief, root->briefFile, root->briefLine);
+        else
+        {
+          gd = new GroupDef(root->fileName,root->startLine,root->name,root->type);
+        }
+        gd->setBriefDescription(root->brief,root->briefFile,root->briefLine);
         // allow empty docs for group
-        gd->setDocumentation(!root->doc.isEmpty() ? root->doc : QCString(" "),
-                             root->docFile, root->docLine, FALSE);
-        gd->setInbodyDocumentation(root->inbodyDocs, root->inbodyFile,
-                                   root->inbodyLine);
+        gd->setDocumentation(!root->doc.isEmpty() ? root->doc : QCString(" "),root->docFile,root->docLine,FALSE);
+        gd->setInbodyDocumentation( root->inbodyDocs, root->inbodyFile, root->inbodyLine );
         gd->addSectionsToDefinition(root->anchors);
-        Doxygen::groupSDict->append(root->name, gd);
+        Doxygen::groupSDict->append(root->name,gd);
         gd->setRefItems(root->sli);
         gd->setLanguage(root->lang);
       }
@@ -648,101 +670,115 @@ static void buildGroupListFiltered(EntryNav *rootNav, bool additional,
 
     rootNav->releaseEntry();
   }
-  if (rootNav->children()) {
+  if (rootNav->children())
+  {
     EntryNavListIterator eli(*rootNav->children());
     EntryNav *e;
-    for (; (e = eli.current()); ++eli) {
-      buildGroupListFiltered(e, additional, includeExternal);
+    for (;(e=eli.current());++eli)
+    {
+      buildGroupListFiltered(e,additional,includeExternal);
     }
   }
 }
 
-static void buildGroupList(EntryNav *rootNav) {
+static void buildGroupList(EntryNav *rootNav)
+{
   // --- first process only local groups
   // first process the @defgroups blocks
-  buildGroupListFiltered(rootNav, FALSE, FALSE);
+  buildGroupListFiltered(rootNav,FALSE,FALSE);
   // then process the @addtogroup, @weakgroup blocks
-  buildGroupListFiltered(rootNav, TRUE, FALSE);
+  buildGroupListFiltered(rootNav,TRUE,FALSE);
 
   // --- then also process external groups
   // first process the @defgroups blocks
-  buildGroupListFiltered(rootNav, FALSE, TRUE);
+  buildGroupListFiltered(rootNav,FALSE,TRUE);
   // then process the @addtogroup, @weakgroup blocks
-  buildGroupListFiltered(rootNav, TRUE, TRUE);
+  buildGroupListFiltered(rootNav,TRUE,TRUE);
 }
 
-static void findGroupScope(EntryNav *rootNav) {
-  if (rootNav->section() == Entry::GROUPDOC_SEC && !rootNav->name().isEmpty() &&
-      rootNav->parent() && !rootNav->parent()->name().isEmpty()) {
+static void findGroupScope(EntryNav *rootNav)
+{
+  if (rootNav->section()==Entry::GROUPDOC_SEC && !rootNav->name().isEmpty() &&
+      rootNav->parent() && !rootNav->parent()->name().isEmpty())
+  {
     GroupDef *gd;
-    if ((gd = Doxygen::groupSDict->find(rootNav->name()))) {
+    if ((gd=Doxygen::groupSDict->find(rootNav->name())))
+    {
       QCString scope = rootNav->parent()->name();
-      if (rootNav->parent()->section() == Entry::PACKAGEDOC_SEC) {
-        scope = substitute(scope, ".", "::");
+      if (rootNav->parent()->section()==Entry::PACKAGEDOC_SEC)
+      {
+        scope=substitute(scope,".","::");
       }
       scope = stripAnonymousNamespaceScope(scope);
-      scope += "::" + gd->name();
-      Definition *d = findScopeFromQualifiedName(Doxygen::globalScope, scope, 0,
-                                                 rootNav->tagInfo());
-      if (d) {
+      scope+="::"+gd->name();
+      Definition *d = findScopeFromQualifiedName(Doxygen::globalScope,scope,0,rootNav->tagInfo());
+      if (d)
+      {
         gd->setGroupScope(d);
       }
     }
   }
-  RECURSE_ENTRYTREE(findGroupScope, rootNav);
+  RECURSE_ENTRYTREE(findGroupScope,rootNav);
 }
 
-static void organizeSubGroupsFiltered(EntryNav *rootNav, bool additional) {
-  if (rootNav->section() == Entry::GROUPDOC_SEC && !rootNav->name().isEmpty()) {
+static void organizeSubGroupsFiltered(EntryNav *rootNav,bool additional)
+{
+  if (rootNav->section()==Entry::GROUPDOC_SEC && !rootNav->name().isEmpty())
+  {
     rootNav->loadEntry(g_storage);
     Entry *root = rootNav->entry();
 
-    if ((root->groupDocType == Entry::GROUPDOC_NORMAL && !additional) ||
-        (root->groupDocType != Entry::GROUPDOC_NORMAL && additional)) {
+    if ((root->groupDocType==Entry::GROUPDOC_NORMAL && !additional) ||
+        (root->groupDocType!=Entry::GROUPDOC_NORMAL && additional))
+    {
       GroupDef *gd;
-      if ((gd = Doxygen::groupSDict->find(root->name))) {
-        // printf("adding %s to group
-        // %s\n",root->name.data(),gd->name().data());
-        addGroupToGroups(root, gd);
+      if ((gd=Doxygen::groupSDict->find(root->name)))
+      {
+        //printf("adding %s to group %s\n",root->name.data(),gd->name().data());
+        addGroupToGroups(root,gd);
       }
     }
 
     rootNav->releaseEntry();
   }
-  if (rootNav->children()) {
+  if (rootNav->children())
+  {
     EntryNavListIterator eli(*rootNav->children());
     EntryNav *e;
-    for (; (e = eli.current()); ++eli) {
-      organizeSubGroupsFiltered(e, additional);
+    for (;(e=eli.current());++eli)
+    {
+      organizeSubGroupsFiltered(e,additional);
     }
   }
 }
 
-static void organizeSubGroups(EntryNav *rootNav) {
-  // printf("Defining groups\n");
+static void organizeSubGroups(EntryNav *rootNav)
+{
+  //printf("Defining groups\n");
   // first process the @defgroups blocks
-  organizeSubGroupsFiltered(rootNav, FALSE);
-  // printf("Additional groups\n");
+  organizeSubGroupsFiltered(rootNav,FALSE);
+  //printf("Additional groups\n");
   // then process the @addtogroup, @weakgroup blocks
-  organizeSubGroupsFiltered(rootNav, TRUE);
+  organizeSubGroupsFiltered(rootNav,TRUE);
 }
 
 //----------------------------------------------------------------------
 
-static void buildFileList(EntryNav *rootNav) {
-  if (((rootNav->section() == Entry::FILEDOC_SEC) ||
-       ((rootNav->section() & Entry::FILE_MASK) &&
-        Config_getBool(EXTRACT_ALL))) &&
-      !rootNav->name().isEmpty() &&
-      !rootNav->tagInfo() // skip any file coming from tag files
-      ) {
+static void buildFileList(EntryNav *rootNav)
+{
+  if (((rootNav->section()==Entry::FILEDOC_SEC) ||
+        ((rootNav->section() & Entry::FILE_MASK) && Config_getBool(EXTRACT_ALL))) &&
+      !rootNav->name().isEmpty() && !rootNav->tagInfo() // skip any file coming from tag files
+     )
+  {
     rootNav->loadEntry(g_storage);
     Entry *root = rootNav->entry();
 
     bool ambig;
-    FileDef *fd = findFileDef(Doxygen::inputNameDict, root->name, ambig);
-    // printf("**************** root->name=%s fd=%p\n",root->name.data(),fd);
-    if (fd && !ambig) {
+    FileDef *fd=findFileDef(Doxygen::inputNameDict,root->name,ambig);
+    //printf("**************** root->name=%s fd=%p\n",root->name.data(),fd);
+    if (fd && !ambig)
+    {
 #if 0
       if ((!root->doc.isEmpty() && !fd->documentation().isEmpty()) ||
           (!root->brief.isEmpty() && !fd->briefDescription().isEmpty()))
@@ -757,125 +793,144 @@ static void buildFileList(EntryNav *rootNav) {
       else
 #endif
       {
-        // printf("Adding documentation!\n");
+        //printf("Adding documentation!\n");
         // using FALSE in setDocumentation is small hack to make sure a file
         // is documented even if a \file command is used without further
         // documentation
-        fd->setDocumentation(root->doc, root->docFile, root->docLine, FALSE);
-        fd->setBriefDescription(root->brief, root->briefFile, root->briefLine);
+        fd->setDocumentation(root->doc,root->docFile,root->docLine,FALSE);
+        fd->setBriefDescription(root->brief,root->briefFile,root->briefLine);
         fd->addSectionsToDefinition(root->anchors);
         fd->setRefItems(root->sli);
         QListIterator<Grouping> gli(*root->groups);
         Grouping *g;
-        for (; (g = gli.current()); ++gli) {
-          GroupDef *gd = 0;
-          if (!g->groupname.isEmpty() &&
-              (gd = Doxygen::groupSDict->find(g->groupname))) {
+        for (;(g=gli.current());++gli)
+        {
+          GroupDef *gd=0;
+          if (!g->groupname.isEmpty() && (gd=Doxygen::groupSDict->find(g->groupname)))
+          {
             gd->addFile(fd);
             fd->makePartOfGroup(gd);
-            // printf("File %s: in group %s\n",fd->name().data(),s->data());
+            //printf("File %s: in group %s\n",fd->name().data(),s->data());
           }
         }
       }
-    } else {
+    }
+    else
+    {
       const char *fn = root->fileName.data();
       QCString text(4096);
       text.sprintf("the name `%s' supplied as "
-                   "the second argument in the \\file statement ",
-                   qPrint(root->name));
+          "the second argument in the \\file statement ",
+          qPrint(root->name));
       if (ambig) // name is ambiguous
       {
-        text += "matches the following input files:\n";
-        text += showFileDefMatches(Doxygen::inputNameDict, root->name);
-        text += "Please use a more specific name by "
-                "including a (larger) part of the path!";
-      } else // name is not an input file
+        text+="matches the following input files:\n";
+        text+=showFileDefMatches(Doxygen::inputNameDict,root->name);
+        text+="Please use a more specific name by "
+          "including a (larger) part of the path!";
+      }
+      else // name is not an input file
       {
-        text += "is not an input file";
+        text+="is not an input file";
       }
-      warn(fn, root->startLine, text);
+      warn(fn,root->startLine,text);
     }
 
     rootNav->releaseEntry();
   }
-  RECURSE_ENTRYTREE(buildFileList, rootNav);
+  RECURSE_ENTRYTREE(buildFileList,rootNav);
 }
 
-static void addIncludeFile(ClassDef *cd, FileDef *ifd, Entry *root) {
-  if ((!root->doc.stripWhiteSpace().isEmpty() ||
+static void addIncludeFile(ClassDef *cd,FileDef *ifd,Entry *root)
+{
+  if (
+      (!root->doc.stripWhiteSpace().isEmpty() ||
        !root->brief.stripWhiteSpace().isEmpty() ||
-       Config_getBool(EXTRACT_ALL)) &&
-      root->protection != Private) {
-    // printf(">>>>>> includeFile=%s\n",root->includeFile.data());
+       Config_getBool(EXTRACT_ALL)
+      ) && root->protection!=Private
+     )
+  {
+    //printf(">>>>>> includeFile=%s\n",root->includeFile.data());
 
-    bool local = Config_getBool(FORCE_LOCAL_INCLUDES);
+    bool local=Config_getBool(FORCE_LOCAL_INCLUDES);
     QCString includeFile = root->includeFile;
-    if (!includeFile.isEmpty() && includeFile.at(0) == '"') {
+    if (!includeFile.isEmpty() && includeFile.at(0)=='"')
+    {
       local = TRUE;
-      includeFile = includeFile.mid(1, includeFile.length() - 2);
-    } else if (!includeFile.isEmpty() && includeFile.at(0) == '<') {
+      includeFile=includeFile.mid(1,includeFile.length()-2);
+    }
+    else if (!includeFile.isEmpty() && includeFile.at(0)=='<')
+    {
       local = FALSE;
-      includeFile = includeFile.mid(1, includeFile.length() - 2);
+      includeFile=includeFile.mid(1,includeFile.length()-2);
     }
 
     bool ambig;
-    FileDef *fd = 0;
+    FileDef *fd=0;
     // see if we need to include a verbatim copy of the header file
-    // printf("root->includeFile=%s\n",root->includeFile.data());
+    //printf("root->includeFile=%s\n",root->includeFile.data());
     if (!includeFile.isEmpty() &&
-        (fd = findFileDef(Doxygen::inputNameDict, includeFile, ambig)) ==
-            0) { // explicit request
+        (fd=findFileDef(Doxygen::inputNameDict,includeFile,ambig))==0
+       )
+    { // explicit request
       QCString text;
       text.sprintf("the name `%s' supplied as "
-                   "the argument of the \\class, \\struct, \\union, or "
-                   "\\include command ",
-                   qPrint(includeFile));
+                  "the argument of the \\class, \\struct, \\union, or \\include command ",
+                  qPrint(includeFile)
+                 );
       if (ambig) // name is ambiguous
       {
-        text += "matches the following input files:\n";
-        text += showFileDefMatches(Doxygen::inputNameDict, root->includeFile);
-        text += "Please use a more specific name by "
-                "including a (larger) part of the path!";
-      } else // name is not an input file
+        text+="matches the following input files:\n";
+        text+=showFileDefMatches(Doxygen::inputNameDict,root->includeFile);
+        text+="Please use a more specific name by "
+            "including a (larger) part of the path!";
+      }
+      else // name is not an input file
       {
-        text += "is not an input file";
+        text+="is not an input file";
       }
-      warn(root->fileName, root->startLine, text);
-    } else if (includeFile.isEmpty() && ifd &&
-               // see if the file extension makes sense
-               guessSection(ifd->name()) ==
-                   Entry::HEADER_SEC) { // implicit assumption
-      fd = ifd;
+      warn(root->fileName,root->startLine,text);
+    }
+    else if (includeFile.isEmpty() && ifd &&
+        // see if the file extension makes sense
+        guessSection(ifd->name())==Entry::HEADER_SEC)
+    { // implicit assumption
+      fd=ifd;
     }
 
     // if a file is found, we mark it as a source file.
-    if (fd) {
-      QCString iName =
-          !root->includeName.isEmpty() ? root->includeName : includeFile;
+    if (fd)
+    {
+      QCString iName = !root->includeName.isEmpty() ?
+                       root->includeName : includeFile;
       if (!iName.isEmpty()) // user specified include file
       {
-        if (iName.at(0) == '<')
-          local = FALSE; // explicit override
-        else if (iName.at(0) == '"')
-          local = TRUE;
-        if (iName.at(0) == '"' || iName.at(0) == '<') {
-          iName = iName.mid(1, iName.length() - 2); // strip quotes or brackets
+        if (iName.at(0)=='<') local=FALSE; // explicit override
+        else if (iName.at(0)=='"') local=TRUE;
+        if (iName.at(0)=='"' || iName.at(0)=='<')
+        {
+          iName=iName.mid(1,iName.length()-2); // strip quotes or brackets
         }
-        if (iName.isEmpty()) {
-          iName = fd->name();
+        if (iName.isEmpty())
+        {
+          iName=fd->name();
         }
-      } else if (!Config_getList(STRIP_FROM_INC_PATH).isEmpty()) {
-        iName = stripFromIncludePath(fd->absFilePath());
-      } else // use name of the file containing the class definition
+      }
+      else if (!Config_getList(STRIP_FROM_INC_PATH).isEmpty())
       {
-        iName = fd->name();
+        iName=stripFromIncludePath(fd->absFilePath());
+      }
+      else // use name of the file containing the class definition
+      {
+        iName=fd->name();
       }
       if (fd->generateSourceFile()) // generate code for header
       {
-        cd->setIncludeFile(fd, iName, local, !root->includeName.isEmpty());
-      } else // put #include in the class documentation without link
+        cd->setIncludeFile(fd,iName,local,!root->includeName.isEmpty());
+      }
+      else // put #include in the class documentation without link
       {
-        cd->setIncludeFile(0, iName, local, TRUE);
+        cd->setIncludeFile(0,iName,local,TRUE);
       }
     }
   }
@@ -944,108 +999,109 @@ static Definition *findScope(Entry *root,int level=0)
  *  full qualified name \a name. Creates an artificial scope if the scope is
  *  not found and set the parent/child scope relation if the scope is found.
  */
-static Definition *buildScopeFromQualifiedName(const QCString name, int level,
-                                               SrcLangExt lang,
-                                               TagInfo *tagInfo) {
-  // printf("buildScopeFromQualifiedName(%s) level=%d\n",name.data(),level);
-  int i = 0;
-  int p = 0, l;
-  Definition *prevScope = Doxygen::globalScope;
+static Definition *buildScopeFromQualifiedName(const QCString name,
+                                               int level,SrcLangExt lang,TagInfo *tagInfo)
+{
+  //printf("buildScopeFromQualifiedName(%s) level=%d\n",name.data(),level);
+  int i=0;
+  int p=0,l;
+  Definition *prevScope=Doxygen::globalScope;
   QCString fullScope;
-  while (i < level) {
-    int idx = getScopeFragment(name, p, &l);
-    if (idx == -1)
-      return prevScope;
-    QCString nsName = name.mid(idx, l);
-    if (nsName.isEmpty())
-      return prevScope;
-    if (!fullScope.isEmpty())
-      fullScope += "::";
-    fullScope += nsName;
-    NamespaceDef *nd = Doxygen::namespaceSDict->find(fullScope);
+  while (i<level)
+  {
+    int idx=getScopeFragment(name,p,&l);
+    if (idx==-1) return prevScope;
+    QCString nsName = name.mid(idx,l);
+    if (nsName.isEmpty()) return prevScope;
+    if (!fullScope.isEmpty()) fullScope+="::";
+    fullScope+=nsName;
+    NamespaceDef *nd=Doxygen::namespaceSDict->find(fullScope);
     Definition *innerScope = nd;
-    ClassDef *cd = 0;
-    if (nd == 0)
-      cd = getClass(fullScope);
-    if (nd == 0 && cd) // scope is a class
+    ClassDef *cd=0;
+    if (nd==0) cd = getClass(fullScope);
+    if (nd==0 && cd) // scope is a class
     {
       innerScope = cd;
-    } else if (nd == 0 && cd == 0 &&
-               fullScope.find('<') ==
-                   -1) // scope is not known and could be a namespace!
+    }
+    else if (nd==0 && cd==0 && fullScope.find('<')==-1) // scope is not known and could be a namespace!
     {
       // introduce bogus namespace
-      // printf("++ adding dummy namespace %s to %s
-      // tagInfo=%p\n",nsName.data(),prevScope->name().data(),tagInfo);
-      nd = new NamespaceDef("[generated]", 1, 1, fullScope,
-                            tagInfo ? tagInfo->tagName : QCString(),
-                            tagInfo ? tagInfo->fileName : QCString());
+      //printf("++ adding dummy namespace %s to %s tagInfo=%p\n",nsName.data(),prevScope->name().data(),tagInfo);
+      nd=new NamespaceDef(
+        "[generated]",1,1,fullScope,
+        tagInfo?tagInfo->tagName:QCString(),
+        tagInfo?tagInfo->fileName:QCString());
       nd->setLanguage(lang);
 
       // add namespace to the list
-      Doxygen::namespaceSDict->inSort(fullScope, nd);
+      Doxygen::namespaceSDict->inSort(fullScope,nd);
       innerScope = nd;
-    } else // scope is a namespace
+    }
+    else // scope is a namespace
     {
     }
-    if (innerScope) {
+    if (innerScope)
+    {
       // make the parent/child scope relation
       prevScope->addInnerCompound(innerScope);
       innerScope->setOuterScope(prevScope);
-    } else // current scope is a class, so return only the namespace part...
+    }
+    else // current scope is a class, so return only the namespace part...
     {
       return prevScope;
     }
     // proceed to the next scope fragment
-    p = idx + l + 2;
-    prevScope = innerScope;
+    p=idx+l+2;
+    prevScope=innerScope;
     i++;
   }
   return prevScope;
 }
 
-static Definition *findScopeFromQualifiedName(Definition *startScope,
-                                              const QCString &n,
-                                              FileDef *fileScope,
-                                              TagInfo *tagInfo) {
-  // printf("<findScopeFromQualifiedName(%s,%s)\n",startScope ?
-  // startScope->name().data() : 0, n.data());
-  Definition *resultScope = startScope;
-  if (resultScope == 0)
-    resultScope = Doxygen::globalScope;
-  QCString scope = stripTemplateSpecifiersFromScope(n, FALSE);
-  int l1 = 0, i1;
-  i1 = getScopeFragment(scope, 0, &l1);
-  if (i1 == -1) {
-    // printf(">no fragments!\n");
+static Definition *findScopeFromQualifiedName(Definition *startScope,const QCString &n,
+                                              FileDef *fileScope,TagInfo *tagInfo)
+{
+  //printf("<findScopeFromQualifiedName(%s,%s)\n",startScope ? startScope->name().data() : 0, n.data());
+  Definition *resultScope=startScope;
+  if (resultScope==0) resultScope=Doxygen::globalScope;
+  QCString scope=stripTemplateSpecifiersFromScope(n,FALSE);
+  int l1=0,i1;
+  i1=getScopeFragment(scope,0,&l1);
+  if (i1==-1)
+  {
+    //printf(">no fragments!\n");
     return resultScope;
   }
-  int p = i1 + l1, l2 = 0, i2;
-  while ((i2 = getScopeFragment(scope, p, &l2)) != -1) {
-    QCString nestedNameSpecifier = scope.mid(i1, l1);
+  int p=i1+l1,l2=0,i2;
+  while ((i2=getScopeFragment(scope,p,&l2))!=-1)
+  {
+    QCString nestedNameSpecifier = scope.mid(i1,l1);
     Definition *orgScope = resultScope;
-    // printf("  nestedNameSpecifier=%s\n",nestedNameSpecifier.data());
+    //printf("  nestedNameSpecifier=%s\n",nestedNameSpecifier.data());
     resultScope = resultScope->findInnerCompound(nestedNameSpecifier);
-    // printf("  resultScope=%p\n",resultScope);
-    if (resultScope == 0) {
+    //printf("  resultScope=%p\n",resultScope);
+    if (resultScope==0)
+    {
       NamespaceSDict *usedNamespaces;
-      if (orgScope == Doxygen::globalScope && fileScope &&
+      if (orgScope==Doxygen::globalScope && fileScope &&
           (usedNamespaces = fileScope->getUsedNamespaces()))
-      // also search for used namespaces
+        // also search for used namespaces
       {
         NamespaceSDict::Iterator ni(*usedNamespaces);
         NamespaceDef *nd;
-        for (ni.toFirst(); ((nd = ni.current()) && resultScope == 0); ++ni) {
+        for (ni.toFirst();((nd=ni.current()) && resultScope==0);++ni)
+        {
           // restart search within the used namespace
-          resultScope = findScopeFromQualifiedName(nd, n, fileScope, tagInfo);
+          resultScope = findScopeFromQualifiedName(nd,n,fileScope,tagInfo);
         }
-        if (resultScope) {
+        if (resultScope)
+        {
           // for a nested class A::I in used namespace N, we get
           // N::A::I while looking for A, so we should compare
           // resultScope->name() against scope.left(i2+l2)
-          // printf("  -> result=%s
-          // scope=%s\n",resultScope->name().data(),scope.data());
-          if (rightScopeMatch(resultScope->name(), scope.left(i2 + l2))) {
+          //printf("  -> result=%s scope=%s\n",resultScope->name().data(),scope.data());
+          if (rightScopeMatch(resultScope->name(),scope.left(i2+l2)))
+          {
             break;
           }
           goto nextFragment;
@@ -1059,278 +1115,278 @@ static Definition *findScopeFromQualifiedName(Definition *startScope,
       // scope match between the used class and nestedNameSpecifier.
       QDictIterator<FileDef> ui(g_usingDeclarations);
       FileDef *usedFd;
-      for (ui.toFirst(); (usedFd = ui.current()); ++ui) {
-        // printf("Checking using class %s\n",ui.currentKey());
-        if (rightScopeMatch(ui.currentKey(), nestedNameSpecifier)) {
+      for (ui.toFirst();(usedFd=ui.current());++ui)
+      {
+        //printf("Checking using class %s\n",ui.currentKey());
+        if (rightScopeMatch(ui.currentKey(),nestedNameSpecifier))
+        {
           // ui.currentKey() is the fully qualified name of nestedNameSpecifier
           // so use this instead.
-          QCString fqn =
-              QCString(ui.currentKey()) + scope.right(scope.length() - p);
-          resultScope = buildScopeFromQualifiedName(
-              fqn, fqn.contains("::"), startScope->getLanguage(), 0);
-          // printf("Creating scope from fqn=%s result
-          // %p\n",fqn.data(),resultScope);
-          if (resultScope) {
-            // printf("> Match! resultScope=%s\n",resultScope->name().data());
+          QCString fqn = QCString(ui.currentKey())+
+                         scope.right(scope.length()-p);
+          resultScope = buildScopeFromQualifiedName(fqn,fqn.contains("::"),
+                                                    startScope->getLanguage(),0);
+          //printf("Creating scope from fqn=%s result %p\n",fqn.data(),resultScope);
+          if (resultScope)
+          {
+            //printf("> Match! resultScope=%s\n",resultScope->name().data());
             return resultScope;
           }
         }
       }
 
-      // printf("> name %s not found in scope
-      // %s\n",nestedNameSpecifier.data(),orgScope->name().data());
+      //printf("> name %s not found in scope %s\n",nestedNameSpecifier.data(),orgScope->name().data());
       return 0;
     }
-  nextFragment:
-    i1 = i2;
-    l1 = l2;
-    p = i2 + l2;
+ nextFragment:
+    i1=i2;
+    l1=l2;
+    p=i2+l2;
   }
-  // printf(">findScopeFromQualifiedName scope
-  // %s\n",resultScope->name().data());
+  //printf(">findScopeFromQualifiedName scope %s\n",resultScope->name().data());
   return resultScope;
 }
 
-ArgumentList *
-getTemplateArgumentsFromName(const QCString &name,
-                             const QList<ArgumentList> *tArgLists) {
-  if (tArgLists == 0)
-    return 0;
+ArgumentList *getTemplateArgumentsFromName(
+                  const QCString &name,
+                  const QList<ArgumentList> *tArgLists)
+{
+  if (tArgLists==0) return 0;
 
   QListIterator<ArgumentList> ali(*tArgLists);
   // for each scope fragment, check if it is a template and advance through
   // the list if so.
-  int i, p = 0;
-  while ((i = name.find("::", p)) != -1) {
+  int i,p=0;
+  while ((i=name.find("::",p))!=-1)
+  {
     NamespaceDef *nd = Doxygen::namespaceSDict->find(name.left(i));
-    if (nd == 0) {
+    if (nd==0)
+    {
       ClassDef *cd = getClass(name.left(i));
-      if (cd) {
-        if (cd->templateArguments()) {
+      if (cd)
+      {
+        if (cd->templateArguments())
+        {
           ++ali;
         }
       }
     }
-    p = i + 2;
+    p=i+2;
   }
   return ali.current();
 }
 
-static ClassDef::CompoundType convertToCompoundType(int section,
-                                                    uint64 specifier) {
-  ClassDef::CompoundType sec = ClassDef::Class;
-  if (specifier & Entry::Struct)
-    sec = ClassDef::Struct;
-  else if (specifier & Entry::Union)
-    sec = ClassDef::Union;
-  else if (specifier & Entry::Category)
-    sec = ClassDef::Category;
-  else if (specifier & Entry::Interface)
-    sec = ClassDef::Interface;
-  else if (specifier & Entry::Protocol)
-    sec = ClassDef::Protocol;
-  else if (specifier & Entry::Exception)
-    sec = ClassDef::Exception;
-  else if (specifier & Entry::Service)
-    sec = ClassDef::Service;
-  else if (specifier & Entry::Singleton)
-    sec = ClassDef::Singleton;
-
-  switch (section) {
-  // case Entry::UNION_SEC:
-  case Entry::UNIONDOC_SEC:
-    sec = ClassDef::Union;
-    break;
-  // case Entry::STRUCT_SEC:
-  case Entry::STRUCTDOC_SEC:
-    sec = ClassDef::Struct;
-    break;
-  // case Entry::INTERFACE_SEC:
-  case Entry::INTERFACEDOC_SEC:
-    sec = ClassDef::Interface;
-    break;
-  // case Entry::PROTOCOL_SEC:
-  case Entry::PROTOCOLDOC_SEC:
-    sec = ClassDef::Protocol;
-    break;
-  // case Entry::CATEGORY_SEC:
-  case Entry::CATEGORYDOC_SEC:
-    sec = ClassDef::Category;
-    break;
-  // case Entry::EXCEPTION_SEC:
-  case Entry::EXCEPTIONDOC_SEC:
-    sec = ClassDef::Exception;
-    break;
-  case Entry::SERVICEDOC_SEC:
-    sec = ClassDef::Service;
-    break;
-  case Entry::SINGLETONDOC_SEC:
-    sec = ClassDef::Singleton;
-    break;
+static
+ClassDef::CompoundType convertToCompoundType(int section,uint64 specifier)
+{
+  ClassDef::CompoundType sec=ClassDef::Class;
+  if (specifier&Entry::Struct)
+    sec=ClassDef::Struct;
+  else if (specifier&Entry::Union)
+    sec=ClassDef::Union;
+  else if (specifier&Entry::Category)
+    sec=ClassDef::Category;
+  else if (specifier&Entry::Interface)
+    sec=ClassDef::Interface;
+  else if (specifier&Entry::Protocol)
+    sec=ClassDef::Protocol;
+  else if (specifier&Entry::Exception)
+    sec=ClassDef::Exception;
+  else if (specifier&Entry::Service)
+    sec=ClassDef::Service;
+  else if (specifier&Entry::Singleton)
+    sec=ClassDef::Singleton;
+
+  switch(section)
+  {
+    //case Entry::UNION_SEC:
+    case Entry::UNIONDOC_SEC:
+      sec=ClassDef::Union;
+      break;
+      //case Entry::STRUCT_SEC:
+    case Entry::STRUCTDOC_SEC:
+      sec=ClassDef::Struct;
+      break;
+      //case Entry::INTERFACE_SEC:
+    case Entry::INTERFACEDOC_SEC:
+      sec=ClassDef::Interface;
+      break;
+      //case Entry::PROTOCOL_SEC:
+    case Entry::PROTOCOLDOC_SEC:
+      sec=ClassDef::Protocol;
+      break;
+      //case Entry::CATEGORY_SEC:
+    case Entry::CATEGORYDOC_SEC:
+      sec=ClassDef::Category;
+      break;
+      //case Entry::EXCEPTION_SEC:
+    case Entry::EXCEPTIONDOC_SEC:
+      sec=ClassDef::Exception;
+      break;
+    case Entry::SERVICEDOC_SEC:
+      sec=ClassDef::Service;
+      break;
+    case Entry::SINGLETONDOC_SEC:
+      sec=ClassDef::Singleton;
+      break;
   }
   return sec;
 }
 
-static void addClassToContext(EntryNav *rootNav) {
-  // printf("Loading entry for rootNav=%p
-  // name=%s\n",rootNav,rootNav->name().data());
+
+static void addClassToContext(EntryNav *rootNav)
+{
+  //printf("Loading entry for rootNav=%p name=%s\n",rootNav,rootNav->name().data());
   rootNav->loadEntry(g_storage);
   Entry *root = rootNav->entry();
 
-  // NamespaceDef *nd = 0;
+  //NamespaceDef *nd = 0;
   FileDef *fd = rootNav->fileDef();
 
   QCString scName;
-  if (rootNav->parent()->section() & Entry::SCOPE_MASK) {
-    scName = rootNav->parent()->name();
+  if (rootNav->parent()->section()&Entry::SCOPE_MASK)
+  {
+     scName=rootNav->parent()->name();
   }
   // name without parent's scope
   QCString fullName = root->name;
 
   // strip off any template parameters (but not those for specializations)
-  fullName = stripTemplateSpecifiersFromScope(fullName);
+  fullName=stripTemplateSpecifiersFromScope(fullName);
 
   // name with scope (if not present already)
   QCString qualifiedName = fullName;
-  if (!scName.isEmpty() && !leftScopeMatch(fullName, scName)) {
-    qualifiedName.prepend(scName + "::");
+  if (!scName.isEmpty() && !leftScopeMatch(fullName,scName))
+  {
+    qualifiedName.prepend(scName+"::");
   }
 
   // see if we already found the class before
   ClassDef *cd = getClass(qualifiedName);
 
-  Debug::print(Debug::Classes, 0,
-               "  Found class with name %s (qualifiedName=%s -> cd=%p)\n",
-               cd ? qPrint(cd->name()) : qPrint(root->name),
-               qPrint(qualifiedName), cd);
+  Debug::print(Debug::Classes,0, "  Found class with name %s (qualifiedName=%s -> cd=%p)\n",
+      cd ? qPrint(cd->name()) : qPrint(root->name), qPrint(qualifiedName),cd);
 
-  if (cd) {
-    fullName = cd->name();
-    Debug::print(Debug::Classes, 0, "  Existing class %s!\n",
-                 qPrint(cd->name()));
-    // if (cd->templateArguments()==0)
+  if (cd)
+  {
+    fullName=cd->name();
+    Debug::print(Debug::Classes,0,"  Existing class %s!\n",qPrint(cd->name()));
+    //if (cd->templateArguments()==0)
     //{
-    //  //printf("existing ClassDef tempArgList=%p
-    //  specScope=%s\n",root->tArgList,root->scopeSpec.data());
+    //  //printf("existing ClassDef tempArgList=%p specScope=%s\n",root->tArgList,root->scopeSpec.data());
     //  cd->setTemplateArguments(tArgList);
     //}
 
-    cd->setDocumentation(root->doc, root->docFile, root->docLine);
-    cd->setBriefDescription(root->brief, root->briefFile, root->briefLine);
+    cd->setDocumentation(root->doc,root->docFile,root->docLine);
+    cd->setBriefDescription(root->brief,root->briefFile,root->briefLine);
 
-    if (root->bodyLine != -1 && cd->getStartBodyLine() == -1) {
-      cd->setBodySegment(root->bodyLine, root->endBodyLine);
+    if (root->bodyLine!=-1 && cd->getStartBodyLine()==-1)
+    {
+      cd->setBodySegment(root->bodyLine,root->endBodyLine);
       cd->setBodyDef(fd);
     }
-    // cd->setName(fullName); // change name to match docs
+    //cd->setName(fullName); // change name to match docs
 
-    if (cd->templateArguments() == 0 ||
-        (cd->isForwardDeclared() && (root->spec & Entry::ForwardDecl) == 0)) {
+    if (cd->templateArguments()==0 || (cd->isForwardDeclared() && (root->spec&Entry::ForwardDecl)==0))
+    {
       // this happens if a template class declared with @class is found
-      // before the actual definition or if a forward declaration has different
-      // template
+      // before the actual definition or if a forward declaration has different template
       // parameter names.
       ArgumentList *tArgList =
-          getTemplateArgumentsFromName(cd->name(), root->tArgLists);
+        getTemplateArgumentsFromName(cd->name(),root->tArgLists);
       cd->setTemplateArguments(tArgList);
     }
 
-    cd->setCompoundType(convertToCompoundType(root->section, root->spec));
-  } else // new class
+    cd->setCompoundType(convertToCompoundType(root->section,root->spec));
+  }
+  else // new class
   {
-    ClassDef::CompoundType sec =
-        convertToCompoundType(root->section, root->spec);
+    ClassDef::CompoundType sec = convertToCompoundType(root->section,root->spec);
 
     QCString className;
     QCString namespaceName;
-    extractNamespaceName(fullName, className, namespaceName);
+    extractNamespaceName(fullName,className,namespaceName);
 
-    // printf("New class: fullname %s namespace `%s' name=`%s' brief=`%s'
-    // docs=`%s'\n",
+    //printf("New class: fullname %s namespace `%s' name=`%s' brief=`%s' docs=`%s'\n",
     //    fullName.data(),namespaceName.data(),className.data(),root->brief.data(),root->doc.data());
 
     QCString tagName;
     QCString refFileName;
     TagInfo *tagInfo = rootNav->tagInfo();
     int i;
-    if (tagInfo) {
-      tagName = tagInfo->tagName;
+    if (tagInfo)
+    {
+      tagName     = tagInfo->tagName;
       refFileName = tagInfo->fileName;
-      if (fullName.find("::") != -1)
-      // symbols imported via tag files may come without the parent scope,
-      // so we artificially create it here
+      if (fullName.find("::")!=-1)
+        // symbols imported via tag files may come without the parent scope,
+        // so we artificially create it here
       {
-        buildScopeFromQualifiedName(fullName, fullName.contains("::"),
-                                    root->lang, tagInfo);
+        buildScopeFromQualifiedName(fullName,fullName.contains("::"),root->lang,tagInfo);
       }
     }
     ArgumentList *tArgList = 0;
-    if ((root->lang == SrcLangExt_CSharp || root->lang == SrcLangExt_Java) &&
-        (i = fullName.find('<')) != -1) {
-      // a Java/C# generic class looks like a C++ specialization, so we need to
-      // split the
+    if ((root->lang==SrcLangExt_CSharp || root->lang==SrcLangExt_Java) && (i=fullName.find('<'))!=-1)
+    {
+      // a Java/C# generic class looks like a C++ specialization, so we need to split the
       // name and template arguments here
       tArgList = new ArgumentList;
-      stringToArgumentList(fullName.mid(i), tArgList);
-      fullName = fullName.left(i);
-    } else {
-      tArgList = getTemplateArgumentsFromName(fullName, root->tArgLists);
-    }
-    cd = new ClassDef(tagInfo ? tagName : root->fileName, root->startLine,
-                      root->startColumn, fullName, sec, tagName, refFileName,
-                      TRUE, root->spec & Entry::Enum);
-    Debug::print(Debug::Classes, 0,
-                 "  New class `%s' (sec=0x%08x)! #tArgLists=%d tagInfo=%p\n",
-                 qPrint(fullName), sec,
-                 root->tArgLists ? (int)root->tArgLists->count() : -1, tagInfo);
-    cd->setDocumentation(root->doc, root->docFile,
-                         root->docLine); // copy docs to definition
-    cd->setBriefDescription(root->brief, root->briefFile, root->briefLine);
+      stringToArgumentList(fullName.mid(i),tArgList);
+      fullName=fullName.left(i);
+    }
+    else
+    {
+      tArgList = getTemplateArgumentsFromName(fullName,root->tArgLists);
+    }
+    cd=new ClassDef(tagInfo?tagName:root->fileName,root->startLine,root->startColumn,
+        fullName,sec,tagName,refFileName,TRUE,root->spec&Entry::Enum);
+    Debug::print(Debug::Classes,0,"  New class `%s' (sec=0x%08x)! #tArgLists=%d tagInfo=%p\n",
+        qPrint(fullName),sec,root->tArgLists ? (int)root->tArgLists->count() : -1, tagInfo);
+    cd->setDocumentation(root->doc,root->docFile,root->docLine); // copy docs to definition
+    cd->setBriefDescription(root->brief,root->briefFile,root->briefLine);
     cd->setLanguage(root->lang);
     cd->setId(root->id);
     cd->setHidden(root->hidden);
     cd->setArtificial(root->artificial);
     cd->setClassSpecifier(root->spec);
     cd->setTypeConstraints(root->typeConstr);
-    // printf("new ClassDef %s tempArgList=%p
-    // specScope=%s\n",fullName.data(),root->tArgList,root->scopeSpec.data());
+    //printf("new ClassDef %s tempArgList=%p specScope=%s\n",fullName.data(),root->tArgList,root->scopeSpec.data());
 
-    // printf("class %s template args=%s\n",fullName.data(),
-    //    tArgList ? tempArgListToString(tArgList,root->lang).data() :
-    //    "<none>");
+    //printf("class %s template args=%s\n",fullName.data(),
+    //    tArgList ? tempArgListToString(tArgList,root->lang).data() : "<none>");
     cd->setTemplateArguments(tArgList);
     cd->setProtection(root->protection);
     cd->setIsStatic(root->stat);
 
     // file definition containing the class cd
-    cd->setBodySegment(root->bodyLine, root->endBodyLine);
+    cd->setBodySegment(root->bodyLine,root->endBodyLine);
     cd->setBodyDef(fd);
 
     // see if the class is found inside a namespace
-    // bool found=addNamespace(root,cd);
+    //bool found=addNamespace(root,cd);
 
     cd->insertUsedFile(fd);
 
     // add class to the list
-    // printf("ClassDict.insert(%s)\n",fullName.data());
-    Doxygen::classSDict->append(fullName, cd);
+    //printf("ClassDict.insert(%s)\n",fullName.data());
+    Doxygen::classSDict->append(fullName,cd);
 
-    if (cd->isGeneric()) // generics are also stored in a separate dictionary
-                         // for fast lookup of instantions
+    if (cd->isGeneric()) // generics are also stored in a separate dictionary for fast lookup of instantions
     {
-      // printf("inserting generic '%s' cd=%p\n",fullName.data(),cd);
-      Doxygen::genericsDict->insert(fullName, cd);
+      //printf("inserting generic '%s' cd=%p\n",fullName.data(),cd);
+      Doxygen::genericsDict->insert(fullName,cd);
     }
   }
 
   cd->addSectionsToDefinition(root->anchors);
-  if (!root->subGrouping)
-    cd->setSubGrouping(FALSE);
-  if (cd->hasDocumentation()) {
-    addIncludeFile(cd, fd, root);
+  if (!root->subGrouping) cd->setSubGrouping(FALSE);
+  if (cd->hasDocumentation())
+  {
+    addIncludeFile(cd,fd,root);
   }
-  if (fd && (root->section & Entry::COMPOUND_MASK)) {
-    // printf(">> Inserting class `%s' in file `%s' (root->fileName=`%s')\n",
+  if (fd && (root->section & Entry::COMPOUND_MASK))
+  {
+    //printf(">> Inserting class `%s' in file `%s' (root->fileName=`%s')\n",
     //    cd->name().data(),
     //    fd->name().data(),
     //    root->fileName.data()
@@ -1338,7 +1394,7 @@ static void addClassToContext(EntryNav *rootNav) {
     cd->setFileDef(fd);
     fd->insertClass(cd);
   }
-  addClassToGroups(root, cd);
+  addClassToGroups(root,cd);
   cd->setRefItems(root->sli);
 
   rootNav->releaseEntry();
@@ -1347,177 +1403,189 @@ static void addClassToContext(EntryNav *rootNav) {
 //----------------------------------------------------------------------
 // build a list of all classes mentioned in the documentation
 // and all classes that have a documentation block before their definition.
-static void buildClassList(EntryNav *rootNav) {
-  if (((rootNav->section() & Entry::COMPOUND_MASK) ||
-       rootNav->section() == Entry::OBJCIMPL_SEC) &&
-      !rootNav->name().isEmpty()) {
+static void buildClassList(EntryNav *rootNav)
+{
+  if (
+        ((rootNav->section() & Entry::COMPOUND_MASK) ||
+         rootNav->section()==Entry::OBJCIMPL_SEC) && !rootNav->name().isEmpty()
+     )
+  {
     addClassToContext(rootNav);
   }
-  RECURSE_ENTRYTREE(buildClassList, rootNav);
+  RECURSE_ENTRYTREE(buildClassList,rootNav);
 }
 
-static void buildClassDocList(EntryNav *rootNav) {
-  if ((rootNav->section() & Entry::COMPOUNDDOC_MASK) &&
-      !rootNav->name().isEmpty()) {
+static void buildClassDocList(EntryNav *rootNav)
+{
+  if (
+       (rootNav->section() & Entry::COMPOUNDDOC_MASK) && !rootNav->name().isEmpty()
+     )
+  {
     addClassToContext(rootNav);
   }
-  RECURSE_ENTRYTREE(buildClassDocList, rootNav);
+  RECURSE_ENTRYTREE(buildClassDocList,rootNav);
 }
 
-static void resolveClassNestingRelations() {
+static void resolveClassNestingRelations()
+{
   ClassSDict::Iterator cli(*Doxygen::classSDict);
-  for (cli.toFirst(); cli.current(); ++cli)
-    cli.current()->visited = FALSE;
+  for (cli.toFirst();cli.current();++cli) cli.current()->visited=FALSE;
 
-  bool done = FALSE;
-  int iteration = 0;
-  while (!done) {
-    done = TRUE;
+  bool done=FALSE;
+  int iteration=0;
+  while (!done)
+  {
+    done=TRUE;
     ++iteration;
-    ClassDef *cd = 0;
-    for (cli.toFirst(); (cd = cli.current()); ++cli) {
-      if (!cd->visited) {
+    ClassDef *cd=0;
+    for (cli.toFirst();(cd=cli.current());++cli)
+    {
+      if (!cd->visited)
+      {
         QCString name = stripAnonymousNamespaceScope(cd->name());
-        // printf("processing=%s, iteration=%d\n",cd->name().data(),iteration);
+        //printf("processing=%s, iteration=%d\n",cd->name().data(),iteration);
         // also add class to the correct structural context
-        Definition *d = findScopeFromQualifiedName(Doxygen::globalScope, name,
-                                                   cd->getFileDef(), 0);
-        if (d) {
-          // printf("****** adding %s to scope %s in iteration
-          // %d\n",cd->name().data(),d->name().data(),iteration);
+        Definition *d = findScopeFromQualifiedName(Doxygen::globalScope,
+                                                 name,cd->getFileDef(),0);
+        if (d)
+        {
+          //printf("****** adding %s to scope %s in iteration %d\n",cd->name().data(),d->name().data(),iteration);
           d->addInnerCompound(cd);
           cd->setOuterScope(d);
-          cd->visited = TRUE;
-          done = FALSE;
+          cd->visited=TRUE;
+          done=FALSE;
         }
-        // else
+        //else
         //{
-        //  printf("****** ignoring %s: scope not (yet) found in iteration
-        //  %d\n",cd->name().data(),iteration);
+        //  printf("****** ignoring %s: scope not (yet) found in iteration %d\n",cd->name().data(),iteration);
         //}
       }
     }
   }
 
-  // give warnings for unresolved compounds
-  ClassDef *cd = 0;
-  for (cli.toFirst(); (cd = cli.current()); ++cli) {
-    if (!cd->visited) {
+  //give warnings for unresolved compounds
+  ClassDef *cd=0;
+  for (cli.toFirst();(cd=cli.current());++cli)
+  {
+    if (!cd->visited)
+    {
       QCString name = stripAnonymousNamespaceScope(cd->name());
-      // printf("processing unresolved=%s,
-      // iteration=%d\n",cd->name().data(),iteration);
+      //printf("processing unresolved=%s, iteration=%d\n",cd->name().data(),iteration);
       /// create the scope artificially
       // anyway, so we can at least relate scopes properly.
-      Definition *d = buildScopeFromQualifiedName(name, name.contains("::"),
-                                                  cd->getLanguage(), 0);
-      if (d != cd && !cd->getDefFileName().isEmpty())
-      // avoid recursion in case of redundant scopes, i.e: namespace N { class
-      // N::C {}; }
-      // for this case doxygen assumes the exitance of a namespace N::N in which
-      // C is to be found!
-      // also avoid warning for stuff imported via a tagfile.
+      Definition *d = buildScopeFromQualifiedName(name,name.contains("::"),cd->getLanguage(),0);
+      if (d!=cd && !cd->getDefFileName().isEmpty())
+                 // avoid recursion in case of redundant scopes, i.e: namespace N { class N::C {}; }
+                 // for this case doxygen assumes the exitance of a namespace N::N in which C is to be found!
+                 // also avoid warning for stuff imported via a tagfile.
       {
         d->addInnerCompound(cd);
         cd->setOuterScope(d);
-        warn(cd->getDefFileName(), cd->getDefLine(),
-             "Internal inconsistency: scope for class %s not "
-             "found!",
-             name.data());
+        warn(cd->getDefFileName(),cd->getDefLine(),
+            "Internal inconsistency: scope for class %s not "
+            "found!",name.data()
+            );
       }
     }
   }
 }
 
-void distributeClassGroupRelations() {
-  // static bool inlineGroupedClasses = Config_getBool(INLINE_GROUPED_CLASSES);
-  // if (!inlineGroupedClasses) return;
-  // printf("** distributeClassGroupRelations()\n");
+void distributeClassGroupRelations()
+{
+  //static bool inlineGroupedClasses = Config_getBool(INLINE_GROUPED_CLASSES);
+  //if (!inlineGroupedClasses) return;
+  //printf("** distributeClassGroupRelations()\n");
 
   ClassSDict::Iterator cli(*Doxygen::classSDict);
-  for (cli.toFirst(); cli.current(); ++cli)
-    cli.current()->visited = FALSE;
+  for (cli.toFirst();cli.current();++cli) cli.current()->visited=FALSE;
 
   ClassDef *cd;
-  for (cli.toFirst(); (cd = cli.current()); ++cli) {
-    // printf("Checking %s\n",cd->name().data());
+  for (cli.toFirst();(cd=cli.current());++cli)
+  {
+    //printf("Checking %s\n",cd->name().data());
     // distribute the group to nested classes as well
-    if (!cd->visited && cd->partOfGroups() != 0 && cd->getClassSDict()) {
-      // printf("  Candidate for merging\n");
+    if (!cd->visited && cd->partOfGroups()!=0 && cd->getClassSDict())
+    {
+      //printf("  Candidate for merging\n");
       ClassSDict::Iterator ncli(*cd->getClassSDict());
       ClassDef *ncd;
       GroupDef *gd = cd->partOfGroups()->at(0);
-      for (ncli.toFirst(); (ncd = ncli.current()); ++ncli) {
-        if (ncd->partOfGroups() == 0) {
-          // printf("  Adding %s to group '%s'\n",ncd->name().data(),
+      for (ncli.toFirst();(ncd=ncli.current());++ncli)
+      {
+        if (ncd->partOfGroups()==0)
+        {
+          //printf("  Adding %s to group '%s'\n",ncd->name().data(),
           //    gd->groupTitle());
           ncd->makePartOfGroup(gd);
           gd->addClass(ncd);
         }
       }
-      cd->visited = TRUE; // only visit every class once
+      cd->visited=TRUE; // only visit every class once
     }
   }
 }
 
 //----------------------------
 
-static ClassDef *createTagLessInstance(ClassDef *rootCd, ClassDef *templ,
-                                       const QCString &fieldName) {
+static ClassDef *createTagLessInstance(ClassDef *rootCd,ClassDef *templ,const QCString &fieldName)
+{
   QCString fullName = removeAnonymousScopes(templ->name());
-  if (fullName.right(2) == "::")
-    fullName = fullName.left(fullName.length() - 2);
-  fullName += "." + fieldName;
-  ClassDef *cd =
-      new ClassDef(templ->getDefFileName(), templ->getDefLine(),
-                   templ->getDefColumn(), fullName, templ->compoundType());
-  cd->setDocumentation(templ->documentation(), templ->docFile(),
-                       templ->docLine()); // copy docs to definition
-  cd->setBriefDescription(templ->briefDescription(), templ->briefFile(),
-                          templ->briefLine());
+  if (fullName.right(2)=="::") fullName=fullName.left(fullName.length()-2);
+  fullName+="."+fieldName;
+  ClassDef *cd = new ClassDef(templ->getDefFileName(),
+                              templ->getDefLine(),
+                              templ->getDefColumn(),
+                              fullName,
+                              templ->compoundType());
+  cd->setDocumentation(templ->documentation(),templ->docFile(),templ->docLine()); // copy docs to definition
+  cd->setBriefDescription(templ->briefDescription(),templ->briefFile(),templ->briefLine());
   cd->setLanguage(templ->getLanguage());
-  cd->setBodySegment(templ->getStartBodyLine(), templ->getEndBodyLine());
+  cd->setBodySegment(templ->getStartBodyLine(),templ->getEndBodyLine());
   cd->setBodyDef(templ->getBodyDef());
 
   cd->setOuterScope(rootCd->getOuterScope());
-  if (rootCd->getOuterScope() != Doxygen::globalScope) {
+  if (rootCd->getOuterScope()!=Doxygen::globalScope)
+  {
     rootCd->getOuterScope()->addInnerCompound(cd);
   }
 
   FileDef *fd = templ->getFileDef();
-  if (fd) {
+  if (fd)
+  {
     cd->setFileDef(fd);
     fd->insertClass(cd);
   }
   GroupList *groups = rootCd->partOfGroups();
-  if (groups != 0) {
+  if ( groups!=0 )
+  {
     GroupListIterator gli(*groups);
     GroupDef *gd;
-    for (gli.toFirst(); (gd = gli.current()); ++gli) {
+    for (gli.toFirst();(gd=gli.current());++gli)
+    {
       cd->makePartOfGroup(gd);
       gd->addClass(cd);
     }
   }
-  // printf("** adding class %s based on
-  // %s\n",fullName.data(),templ->name().data());
-  Doxygen::classSDict->append(fullName, cd);
+  //printf("** adding class %s based on %s\n",fullName.data(),templ->name().data());
+  Doxygen::classSDict->append(fullName,cd);
 
   MemberList *ml = templ->getMemberList(MemberListType_pubAttribs);
-  if (ml) {
+  if (ml)
+  {
     MemberListIterator li(*ml);
     MemberDef *md;
-    for (li.toFirst(); (md = li.current()); ++li) {
-      // printf("    Member %s type=%s\n",md->name().data(),md->typeString());
-      MemberDef *imd = new MemberDef(
-          md->getDefFileName(), md->getDefLine(), md->getDefColumn(),
-          md->typeString(), md->name(), md->argsString(), md->excpString(),
-          md->protection(), md->virtualness(), md->isStatic(), Member,
-          md->memberType(), 0, 0);
+    for (li.toFirst();(md=li.current());++li)
+    {
+      //printf("    Member %s type=%s\n",md->name().data(),md->typeString());
+      MemberDef *imd = new MemberDef(md->getDefFileName(),md->getDefLine(),md->getDefColumn(),
+                                     md->typeString(),md->name(),md->argsString(),md->excpString(),
+                                     md->protection(),md->virtualness(),md->isStatic(),Member,
+                                     md->memberType(),
+                                     0,0);
       imd->setMemberClass(cd);
-      imd->setDocumentation(md->documentation(), md->docFile(), md->docLine());
-      imd->setBriefDescription(md->briefDescription(), md->briefFile(),
-                               md->briefLine());
-      imd->setInbodyDocumentation(md->inbodyDocumentation(), md->inbodyFile(),
-                                  md->inbodyLine());
+      imd->setDocumentation(md->documentation(),md->docFile(),md->docLine());
+      imd->setBriefDescription(md->briefDescription(),md->briefFile(),md->briefLine());
+      imd->setInbodyDocumentation(md->inbodyDocumentation(),md->inbodyFile(),md->inbodyLine());
       imd->setMemberSpecifiers(md->getMemberSpecifiers());
       imd->setMemberGroupId(md->getMemberGroupId());
       imd->setInitializer(md->initializer());
@@ -1539,39 +1607,40 @@ static ClassDef *createTagLessInstance(ClassDef *rootCd, ClassDef *templ,
  *  recursively. Later on we need to patch the member types so we keep
  *  track of the hierarchy of classes we create.
  */
-static void processTagLessClasses(ClassDef *rootCd, ClassDef *cd,
-                                  ClassDef *tagParentCd, const QCString &prefix,
-                                  int count) {
-  // printf("%d: processTagLessClasses %s\n",count,cd->name().data());
-  // printf("checking members for %s\n",cd->name().data());
-  if (cd->getClassSDict()) {
+static void processTagLessClasses(ClassDef *rootCd,
+                                  ClassDef *cd,
+                                  ClassDef *tagParentCd,
+                                  const QCString &prefix,int count)
+{
+  //printf("%d: processTagLessClasses %s\n",count,cd->name().data());
+  //printf("checking members for %s\n",cd->name().data());
+  if (cd->getClassSDict())
+  {
     MemberList *ml = cd->getMemberList(MemberListType_pubAttribs);
-    if (ml) {
+    if (ml)
+    {
       MemberListIterator li(*ml);
       MemberDef *md;
-      for (li.toFirst(); (md = li.current()); ++li) {
+      for (li.toFirst();(md=li.current());++li)
+      {
         QCString type = md->typeString();
-        if (type.find("::@") != -1) // member of tag less struct/union
+        if (type.find("::@")!=-1) // member of tag less struct/union
         {
           ClassSDict::Iterator it(*cd->getClassSDict());
           ClassDef *icd;
-          for (it.toFirst(); (icd = it.current()); ++it) {
-            // printf("  member %s: type='%s'\n",md->name().data(),type.data());
-            // printf("  comparing
-            // '%s'<->'%s'\n",type.data(),icd->name().data());
-            if (type.find(icd->name()) != -1) // matching tag less struct/union
+          for (it.toFirst();(icd=it.current());++it)
+          {
+            //printf("  member %s: type='%s'\n",md->name().data(),type.data());
+            //printf("  comparing '%s'<->'%s'\n",type.data(),icd->name().data());
+            if (type.find(icd->name())!=-1) // matching tag less struct/union
             {
               QCString name = md->name();
-              if (name.at(0) == '@')
-                name = "__unnamed__";
-              if (!prefix.isEmpty())
-                name.prepend(prefix + ".");
-              // printf("    found %s for class
-              // %s\n",name.data(),cd->name().data());
-              ClassDef *ncd = createTagLessInstance(rootCd, icd, name);
-              processTagLessClasses(rootCd, icd, ncd, name, count + 1);
-              // printf("    addTagged %s to
-              // %s\n",ncd->name().data(),tagParentCd->name().data());
+              if (name.at(0)=='@') name = "__unnamed__";
+              if (!prefix.isEmpty()) name.prepend(prefix+".");
+              //printf("    found %s for class %s\n",name.data(),cd->name().data());
+              ClassDef *ncd = createTagLessInstance(rootCd,icd,name);
+              processTagLessClasses(rootCd,icd,ncd,name,count+1);
+              //printf("    addTagged %s to %s\n",ncd->name().data(),tagParentCd->name().data());
               tagParentCd->addTaggedInnerClass(ncd);
               ncd->setTagLessReference(icd);
 
@@ -1581,19 +1650,18 @@ static void processTagLessClasses(ClassDef *rootCd, ClassDef *cd,
               // for the initial call this is the same pointer, but for
               // recursive calls cd is the original tag-less struct (of which
               // there is only one instance) and tagParentCd is the newly
-              // generated tagged struct of which there can be multiple
-              // instances!
-              MemberList *pml =
-                  tagParentCd->getMemberList(MemberListType_pubAttribs);
-              if (pml) {
+              // generated tagged struct of which there can be multiple instances!
+              MemberList *pml = tagParentCd->getMemberList(MemberListType_pubAttribs);
+              if (pml)
+              {
                 MemberListIterator pli(*pml);
                 MemberDef *pmd;
-                for (pli.toFirst(); (pmd = pli.current()); ++pli) {
-                  if (pmd->name() == md->name()) {
-                    pmd->setAccessorType(ncd,
-                                         substitute(pmd->typeString(),
-                                                    icd->name(), ncd->name()));
-                    // pmd->setType(substitute(pmd->typeString(),icd->name(),ncd->name()));
+                for (pli.toFirst();(pmd=pli.current());++pli)
+                {
+                  if (pmd->name()==md->name())
+                  {
+                    pmd->setAccessorType(ncd,substitute(pmd->typeString(),icd->name(),ncd->name()));
+                    //pmd->setType(substitute(pmd->typeString(),icd->name(),ncd->name()));
                   }
                 }
               }
@@ -1605,141 +1673,147 @@ static void processTagLessClasses(ClassDef *rootCd, ClassDef *cd,
   }
 }
 
-static void findTagLessClasses(ClassDef *cd) {
-  if (cd->getClassSDict()) {
+static void findTagLessClasses(ClassDef *cd)
+{
+  if (cd->getClassSDict())
+  {
     ClassSDict::Iterator it(*cd->getClassSDict());
     ClassDef *icd;
-    for (it.toFirst(); (icd = it.current()); ++it) {
-      if (icd->name().find("@") ==
-          -1) // process all non-anonymous inner classes
+    for (it.toFirst();(icd=it.current());++it)
+    {
+      if (icd->name().find("@")==-1) // process all non-anonymous inner classes
       {
         findTagLessClasses(icd);
       }
     }
   }
 
-  processTagLessClasses(cd, cd, cd, "",
-                        0); // process tag less inner struct/classes (if any)
+  processTagLessClasses(cd,cd,cd,"",0); // process tag less inner struct/classes (if any)
 }
 
-static void findTagLessClasses() {
+static void findTagLessClasses()
+{
   ClassSDict::Iterator cli(*Doxygen::classSDict);
   ClassDef *cd;
-  for (cli.toFirst(); (cd = cli.current()); ++cli) // for each class
+  for (cli.toFirst();(cd=cli.current());++cli) // for each class
   {
     Definition *scope = cd->getOuterScope();
-    if (scope &&
-        scope->definitionType() != Definition::TypeClass) // that is not nested
+    if (scope && scope->definitionType()!=Definition::TypeClass) // that is not nested
     {
       findTagLessClasses(cd);
     }
   }
 }
 
+
 //----------------------------------------------------------------------
 // build a list of all namespaces mentioned in the documentation
 // and all namespaces that have a documentation block before their definition.
-static void buildNamespaceList(EntryNav *rootNav) {
-  if ((rootNav->section() == Entry::NAMESPACE_SEC ||
-       rootNav->section() == Entry::NAMESPACEDOC_SEC ||
-       rootNav->section() == Entry::PACKAGEDOC_SEC) &&
-      !rootNav->name().isEmpty()) {
+static void buildNamespaceList(EntryNav *rootNav)
+{
+  if (
+       (rootNav->section()==Entry::NAMESPACE_SEC ||
+        rootNav->section()==Entry::NAMESPACEDOC_SEC ||
+        rootNav->section()==Entry::PACKAGEDOC_SEC
+       ) &&
+       !rootNav->name().isEmpty()
+     )
+  {
     rootNav->loadEntry(g_storage);
     Entry *root = rootNav->entry();
 
-    // printf("** buildNamespaceList(%s)\n",root->name.data());
+    //printf("** buildNamespaceList(%s)\n",root->name.data());
 
     QCString fName = root->name;
-    if (root->section == Entry::PACKAGEDOC_SEC) {
-      fName = substitute(fName, ".", "::");
+    if (root->section==Entry::PACKAGEDOC_SEC)
+    {
+      fName=substitute(fName,".","::");
     }
 
     QCString fullName = stripAnonymousNamespaceScope(fName);
-    if (!fullName.isEmpty()) {
-      // printf("Found namespace %s in %s at line %d\n",root->name.data(),
+    if (!fullName.isEmpty())
+    {
+      //printf("Found namespace %s in %s at line %d\n",root->name.data(),
       //        root->fileName.data(), root->startLine);
       NamespaceDef *nd;
-      if ((nd = Doxygen::namespaceSDict->find(fullName))) // existing namespace
+      if ((nd=Doxygen::namespaceSDict->find(fullName))) // existing namespace
       {
-        nd->setDocumentation(root->doc, root->docFile, root->docLine);
+        nd->setDocumentation(root->doc,root->docFile,root->docLine);
         nd->setName(fullName); // change name to match docs
         nd->addSectionsToDefinition(root->anchors);
-        nd->setBriefDescription(root->brief, root->briefFile, root->briefLine);
-        if (nd->getLanguage() == SrcLangExt_Unknown) {
+        nd->setBriefDescription(root->brief,root->briefFile,root->briefLine);
+        if (nd->getLanguage()==SrcLangExt_Unknown)
+        {
           nd->setLanguage(root->lang);
         }
-        if (rootNav->tagInfo() == 0) // if we found the namespace in a tag file
-                                     // and also in a project file, then remove
-                                     // the tag file reference
+        if (rootNav->tagInfo()==0) // if we found the namespace in a tag file
+                                   // and also in a project file, then remove
+                                   // the tag file reference
         {
           nd->setReference("");
           nd->setFileName(fullName);
         }
 
         // file definition containing the namespace nd
-        FileDef *fd = rootNav->fileDef();
+        FileDef *fd=rootNav->fileDef();
         // insert the namespace in the file definition
-        if (fd)
-          fd->insertNamespace(nd);
-        addNamespaceToGroups(root, nd);
+        if (fd) fd->insertNamespace(nd);
+        addNamespaceToGroups(root,nd);
         nd->setRefItems(root->sli);
-      } else // fresh namespace
+      }
+      else // fresh namespace
       {
         QCString tagName;
         QCString tagFileName;
         TagInfo *tagInfo = rootNav->tagInfo();
-        if (tagInfo) {
-          tagName = tagInfo->tagName;
+        if (tagInfo)
+        {
+          tagName     = tagInfo->tagName;
           tagFileName = tagInfo->fileName;
         }
-        // printf("++ new namespace %s lang=%s
-        // tagName=%s\n",fullName.data(),langToString(root->lang).data(),tagName.data());
-        NamespaceDef *nd = new NamespaceDef(
-            tagInfo ? tagName : root->fileName, root->startLine,
-            root->startColumn, fullName, tagName, tagFileName, root->type,
-            root->spec & Entry::Published);
-        nd->setDocumentation(root->doc, root->docFile,
-                             root->docLine); // copy docs to definition
-        nd->setBriefDescription(root->brief, root->briefFile, root->briefLine);
+        //printf("++ new namespace %s lang=%s tagName=%s\n",fullName.data(),langToString(root->lang).data(),tagName.data());
+        NamespaceDef *nd=new NamespaceDef(tagInfo?tagName:root->fileName,root->startLine,
+                             root->startColumn,fullName,tagName,tagFileName,
+                             root->type,root->spec&Entry::Published);
+        nd->setDocumentation(root->doc,root->docFile,root->docLine); // copy docs to definition
+        nd->setBriefDescription(root->brief,root->briefFile,root->briefLine);
         nd->addSectionsToDefinition(root->anchors);
         nd->setHidden(root->hidden);
         nd->setArtificial(root->artificial);
         nd->setLanguage(root->lang);
         nd->setId(root->id);
 
-        // printf("Adding namespace to group\n");
-        addNamespaceToGroups(root, nd);
+        //printf("Adding namespace to group\n");
+        addNamespaceToGroups(root,nd);
         nd->setRefItems(root->sli);
 
         // file definition containing the namespace nd
-        FileDef *fd = rootNav->fileDef();
+        FileDef *fd=rootNav->fileDef();
         // insert the namespace in the file definition
-        if (fd)
-          fd->insertNamespace(nd);
+        if (fd) fd->insertNamespace(nd);
 
         // the empty string test is needed for extract all case
-        nd->setBriefDescription(root->brief, root->briefFile, root->briefLine);
+        nd->setBriefDescription(root->brief,root->briefFile,root->briefLine);
         nd->insertUsedFile(fd);
-        nd->setBodySegment(root->bodyLine, root->endBodyLine);
+        nd->setBodySegment(root->bodyLine,root->endBodyLine);
         nd->setBodyDef(fd);
         // add class to the list
-        Doxygen::namespaceSDict->inSort(fullName, nd);
+        Doxygen::namespaceSDict->inSort(fullName,nd);
 
         // also add namespace to the correct structural context
-        Definition *d = findScopeFromQualifiedName(Doxygen::globalScope,
-                                                   fullName, 0, tagInfo);
-        // printf("adding namespace %s to context
-        // %s\n",nd->name().data(),d?d->name().data():"<none>");
-        if (d == 0) // we didn't find anything, create the scope artificially
-                    // anyway, so we can at least relate scopes properly.
-        {
-          Definition *d = buildScopeFromQualifiedName(
-              fullName, fullName.contains("::"), nd->getLanguage(), tagInfo);
+        Definition *d = findScopeFromQualifiedName(Doxygen::globalScope,fullName,0,tagInfo);
+        //printf("adding namespace %s to context %s\n",nd->name().data(),d?d->name().data():"<none>");
+        if (d==0) // we didn't find anything, create the scope artificially
+                  // anyway, so we can at least relate scopes properly.
+        {
+          Definition *d = buildScopeFromQualifiedName(fullName,fullName.contains("::"),nd->getLanguage(),tagInfo);
           d->addInnerCompound(nd);
           nd->setOuterScope(d);
           // TODO: Due to the order in which the tag file is written
           // a nested class can be found before its parent!
-        } else {
+        }
+        else
+        {
           d->addInnerCompound(nd);
           nd->setOuterScope(d);
         }
@@ -1748,53 +1822,60 @@ static void buildNamespaceList(EntryNav *rootNav) {
 
     rootNav->releaseEntry();
   }
-  RECURSE_ENTRYTREE(buildNamespaceList, rootNav);
+  RECURSE_ENTRYTREE(buildNamespaceList,rootNav);
 }
 
 //----------------------------------------------------------------------
 
 static NamespaceDef *findUsedNamespace(NamespaceSDict *unl,
-                                       const QCString &name) {
-  NamespaceDef *usingNd = 0;
-  if (unl) {
-    // printf("Found namespace dict %d\n",unl->count());
+                              const QCString &name)
+{
+  NamespaceDef *usingNd =0;
+  if (unl)
+  {
+    //printf("Found namespace dict %d\n",unl->count());
     NamespaceSDict::Iterator unli(*unl);
     NamespaceDef *und;
-    for (unli.toFirst(); (und = unli.current()); ++unli) {
-      QCString uScope = und->name() + "::";
-      usingNd = getResolvedNamespace(uScope + name);
-      // printf("Also trying with scope=`%s'
-      // usingNd=%p\n",(uScope+name).data(),usingNd);
+    for (unli.toFirst();(und=unli.current());++unli)
+    {
+      QCString uScope=und->name()+"::";
+      usingNd = getResolvedNamespace(uScope+name);
+      //printf("Also trying with scope=`%s' usingNd=%p\n",(uScope+name).data(),usingNd);
     }
   }
   return usingNd;
 }
 
-static void findUsingDirectives(EntryNav *rootNav) {
-  if (rootNav->section() == Entry::USINGDIR_SEC) {
+static void findUsingDirectives(EntryNav *rootNav)
+{
+  if (rootNav->section()==Entry::USINGDIR_SEC)
+  {
     rootNav->loadEntry(g_storage);
     Entry *root = rootNav->entry();
 
-    // printf("Found using directive %s at line %d of %s\n",
+    //printf("Found using directive %s at line %d of %s\n",
     //    root->name.data(),root->startLine,root->fileName.data());
-    QCString name = substitute(root->name, ".", "::");
-    if (name.right(2) == "::") {
-      name = name.left(name.length() - 2);
+    QCString name=substitute(root->name,".","::");
+    if (name.right(2)=="::")
+    {
+      name=name.left(name.length()-2);
     }
-    if (!name.isEmpty()) {
+    if (!name.isEmpty())
+    {
       NamespaceDef *usingNd = 0;
       NamespaceDef *nd = 0;
-      FileDef *fd = rootNav->fileDef();
+      FileDef      *fd = rootNav->fileDef();
       QCString nsName;
 
       // see if the using statement was found inside a namespace or inside
       // the global file scope.
-      if (rootNav->parent() &&
-          rootNav->parent()->section() == Entry::NAMESPACE_SEC &&
-          (fd == 0 || fd->getLanguage() != SrcLangExt_Java) // not a .java file
-          ) {
-        nsName = stripAnonymousNamespaceScope(rootNav->parent()->name());
-        if (!nsName.isEmpty()) {
+      if (rootNav->parent() && rootNav->parent()->section()==Entry::NAMESPACE_SEC &&
+          (fd==0 || fd->getLanguage()!=SrcLangExt_Java) // not a .java file
+         )
+      {
+        nsName=stripAnonymousNamespaceScope(rootNav->parent()->name());
+        if (!nsName.isEmpty())
+        {
           nd = getResolvedNamespace(nsName);
         }
       }
@@ -1804,68 +1885,74 @@ static void findUsingDirectives(EntryNav *rootNav) {
       // with the most inner scope and going to the most outer scope (i.e.
       // file scope).
       int scopeOffset = nsName.length();
-      do {
-        QCString scope =
-            scopeOffset > 0 ? nsName.left(scopeOffset) + "::" : QCString();
-        usingNd = getResolvedNamespace(scope + name);
-        // printf("Trying with scope=`%s'
-        // usingNd=%p\n",(scope+name).data(),usingNd);
-        if (scopeOffset == 0) {
-          scopeOffset = -1;
-        } else if ((scopeOffset = nsName.findRev("::", scopeOffset - 1)) ==
-                   -1) {
-          scopeOffset = 0;
-        }
-      } while (scopeOffset >= 0 && usingNd == 0);
-
-      if (usingNd == 0 && nd) // not found, try used namespaces in this scope
-                              // or in one of the parent namespace scopes
+      do
+      {
+        QCString scope=scopeOffset>0 ?
+                      nsName.left(scopeOffset)+"::" : QCString();
+        usingNd = getResolvedNamespace(scope+name);
+        //printf("Trying with scope=`%s' usingNd=%p\n",(scope+name).data(),usingNd);
+        if (scopeOffset==0)
+        {
+          scopeOffset=-1;
+        }
+        else if ((scopeOffset=nsName.findRev("::",scopeOffset-1))==-1)
+        {
+          scopeOffset=0;
+        }
+      } while (scopeOffset>=0 && usingNd==0);
+
+      if (usingNd==0 && nd) // not found, try used namespaces in this scope
+                            // or in one of the parent namespace scopes
       {
         NamespaceDef *pnd = nd;
-        while (pnd && usingNd == 0) {
+        while (pnd && usingNd==0)
+        {
           // also try with one of the used namespaces found earlier
-          usingNd = findUsedNamespace(pnd->getUsedNamespaces(), name);
+          usingNd = findUsedNamespace(pnd->getUsedNamespaces(),name);
 
           // goto the parent
           Definition *s = pnd->getOuterScope();
-          if (s && s->definitionType() == Definition::TypeNamespace) {
-            pnd = (NamespaceDef *)s;
-          } else {
+          if (s && s->definitionType()==Definition::TypeNamespace)
+          {
+            pnd = (NamespaceDef*)s;
+          }
+          else
+          {
             pnd = 0;
           }
         }
       }
-      if (usingNd == 0 && fd) // still nothing, also try used namespace in the
-                              // global scope
+      if (usingNd==0 && fd) // still nothing, also try used namespace in the
+                            // global scope
       {
-        usingNd = findUsedNamespace(fd->getUsedNamespaces(), name);
+        usingNd = findUsedNamespace(fd->getUsedNamespaces(),name);
       }
 
-      // printf("%s ->
-      // %s\n",name.data(),usingNd?usingNd->name().data():"<none>");
+      //printf("%s -> %s\n",name.data(),usingNd?usingNd->name().data():"<none>");
 
       // add the namespace the correct scope
-      if (usingNd) {
-        // printf("using fd=%p nd=%p\n",fd,nd);
-        if (nd) {
-          // printf("Inside namespace %s\n",nd->name().data());
+      if (usingNd)
+      {
+        //printf("using fd=%p nd=%p\n",fd,nd);
+        if (nd)
+        {
+          //printf("Inside namespace %s\n",nd->name().data());
           nd->addUsingDirective(usingNd);
-        } else if (fd) {
-          // printf("Inside file %s\n",fd->name().data());
+        }
+        else if (fd)
+        {
+          //printf("Inside file %s\n",fd->name().data());
           fd->addUsingDirective(usingNd);
         }
-      } else // unknown namespace, but add it anyway.
+      }
+      else // unknown namespace, but add it anyway.
       {
-        // printf("++ new unknown namespace %s
-        // lang=%s\n",name.data(),langToString(root->lang).data());
-        NamespaceDef *nd = new NamespaceDef(root->fileName, root->startLine,
-                                            root->startColumn, name);
-        nd->setDocumentation(root->doc, root->docFile,
-                             root->docLine); // copy docs to definition
-        nd->setBriefDescription(root->brief, root->briefFile, root->briefLine);
+        //printf("++ new unknown namespace %s lang=%s\n",name.data(),langToString(root->lang).data());
+        NamespaceDef *nd=new NamespaceDef(root->fileName,root->startLine,root->startColumn,name);
+        nd->setDocumentation(root->doc,root->docFile,root->docLine); // copy docs to definition
+        nd->setBriefDescription(root->brief,root->briefFile,root->briefLine);
         nd->addSectionsToDefinition(root->anchors);
-        // printf("** Adding namespace %s
-        // hidden=%d\n",name.data(),root->hidden);
+        //printf("** Adding namespace %s hidden=%d\n",name.data(),root->hidden);
         nd->setHidden(root->hidden);
         nd->setArtificial(TRUE);
         nd->setLanguage(root->lang);
@@ -1873,79 +1960,88 @@ static void findUsingDirectives(EntryNav *rootNav) {
 
         QListIterator<Grouping> gli(*root->groups);
         Grouping *g;
-        for (; (g = gli.current()); ++gli) {
-          GroupDef *gd = 0;
-          if (!g->groupname.isEmpty() &&
-              (gd = Doxygen::groupSDict->find(g->groupname)))
+        for (;(g=gli.current());++gli)
+        {
+          GroupDef *gd=0;
+          if (!g->groupname.isEmpty() && (gd=Doxygen::groupSDict->find(g->groupname)))
             gd->addNamespace(nd);
         }
 
         // insert the namespace in the file definition
-        if (fd) {
+        if (fd)
+        {
           fd->insertNamespace(nd);
           fd->addUsingDirective(nd);
         }
 
         // the empty string test is needed for extract all case
-        nd->setBriefDescription(root->brief, root->briefFile, root->briefLine);
+        nd->setBriefDescription(root->brief,root->briefFile,root->briefLine);
         nd->insertUsedFile(fd);
         // add class to the list
-        Doxygen::namespaceSDict->inSort(name, nd);
+        Doxygen::namespaceSDict->inSort(name,nd);
         nd->setRefItems(root->sli);
       }
     }
 
     rootNav->releaseEntry();
   }
-  RECURSE_ENTRYTREE(findUsingDirectives, rootNav);
+  RECURSE_ENTRYTREE(findUsingDirectives,rootNav);
 }
 
 //----------------------------------------------------------------------
 
-static void buildListOfUsingDecls(EntryNav *rootNav) {
-  if (rootNav->section() == Entry::USINGDECL_SEC &&
-      !(rootNav->parent()->section() &
-        Entry::COMPOUND_MASK) // not a class/struct member
-      ) {
+static void buildListOfUsingDecls(EntryNav *rootNav)
+{
+  if (rootNav->section()==Entry::USINGDECL_SEC &&
+      !(rootNav->parent()->section()&Entry::COMPOUND_MASK) // not a class/struct member
+     )
+  {
     rootNav->loadEntry(g_storage);
     Entry *root = rootNav->entry();
 
-    QCString name = substitute(root->name, ".", "::");
+    QCString name = substitute(root->name,".","::");
 
-    if (g_usingDeclarations.find(name) == 0) {
+    if (g_usingDeclarations.find(name)==0)
+    {
       FileDef *fd = rootNav->fileDef();
-      if (fd) {
-        g_usingDeclarations.insert(name, fd);
+      if (fd)
+      {
+        g_usingDeclarations.insert(name,fd);
       }
     }
 
     rootNav->releaseEntry();
   }
-  RECURSE_ENTRYTREE(buildListOfUsingDecls, rootNav);
+  RECURSE_ENTRYTREE(buildListOfUsingDecls,rootNav);
 }
 
-static void findUsingDeclarations(EntryNav *rootNav) {
-  if (rootNav->section() == Entry::USINGDECL_SEC &&
-      !(rootNav->parent()->section() &
-        Entry::COMPOUND_MASK) // not a class/struct member
-      ) {
+
+static void findUsingDeclarations(EntryNav *rootNav)
+{
+  if (rootNav->section()==Entry::USINGDECL_SEC &&
+      !(rootNav->parent()->section()&Entry::COMPOUND_MASK) // not a class/struct member
+     )
+  {
     rootNav->loadEntry(g_storage);
     Entry *root = rootNav->entry();
 
-    // printf("Found using declaration %s at line %d of %s inside section %x\n",
+    //printf("Found using declaration %s at line %d of %s inside section %x\n",
     //   root->name.data(),root->startLine,root->fileName.data(),
     //   rootNav->parent()->section());
-    if (!root->name.isEmpty()) {
+    if (!root->name.isEmpty())
+    {
       ClassDef *usingCd = 0;
       NamespaceDef *nd = 0;
-      FileDef *fd = rootNav->fileDef();
+      FileDef      *fd = rootNav->fileDef();
       QCString scName;
 
       // see if the using statement was found inside a namespace or inside
       // the global file scope.
-      if (rootNav->parent()->section() == Entry::NAMESPACE_SEC) {
-        scName = rootNav->parent()->name();
-        if (!scName.isEmpty()) {
+      if (rootNav->parent()->section() == Entry::NAMESPACE_SEC)
+      {
+        scName=rootNav->parent()->name();
+        if (!scName.isEmpty())
+        {
           nd = getResolvedNamespace(scName);
         }
       }
@@ -1969,118 +2065,127 @@ static void findUsingDeclarations(EntryNav *rootNav) {
         usingCd = Doxygen::hiddenClasses->find(name); // check if it is already hidden
       }
 
-      // printf("%s -> %p\n",root->name.data(),usingCd);
-      if (usingCd ==
-          0) // definition not in the input => add an artificial class
+      //printf("%s -> %p\n",root->name.data(),usingCd);
+      if (usingCd==0) // definition not in the input => add an artificial class
       {
-        Debug::print(Debug::Classes, 0,
-                     "  New using class `%s' (sec=0x%08x)! #tArgLists=%d\n",
-                     qPrint(name), root->section,
-                     root->tArgLists ? (int)root->tArgLists->count() : -1);
-        usingCd = new ClassDef("<using>", 1, 1, name, ClassDef::Class);
-        Doxygen::hiddenClasses->append(root->name, usingCd);
+        Debug::print(Debug::Classes,0,"  New using class `%s' (sec=0x%08x)! #tArgLists=%d\n",
+             qPrint(name),root->section,root->tArgLists ? (int)root->tArgLists->count() : -1);
+        usingCd = new ClassDef(
+                     "<using>",1,1,
+                     name,
+                     ClassDef::Class);
+        Doxygen::hiddenClasses->append(root->name,usingCd);
         usingCd->setArtificial(TRUE);
         usingCd->setLanguage(root->lang);
-      } else {
-        Debug::print(Debug::Classes, 0, "  Found used class %s in scope=%s\n",
-                     qPrint(usingCd->name()),
-                     nd ? qPrint(nd->name())
-                        : fd ? qPrint(fd->name()) : "<unknown>");
+      }
+      else
+      {
+        Debug::print(Debug::Classes,0,"  Found used class %s in scope=%s\n",
+            qPrint(usingCd->name()),
+                        nd?qPrint(nd->name()):
+                        fd?qPrint(fd->name()):
+                        "<unknown>");
       }
 
-      if (nd) {
-        // printf("Inside namespace %s\n",nd->name().data());
+      if (nd)
+      {
+        //printf("Inside namespace %s\n",nd->name().data());
         nd->addUsingDeclaration(usingCd);
-      } else if (fd) {
-        // printf("Inside file %s\n",fd->name().data());
+      }
+      else if (fd)
+      {
+        //printf("Inside file %s\n",fd->name().data());
         fd->addUsingDeclaration(usingCd);
       }
     }
 
     rootNav->releaseEntry();
   }
-  RECURSE_ENTRYTREE(findUsingDeclarations, rootNav);
+  RECURSE_ENTRYTREE(findUsingDeclarations,rootNav);
 }
 
 //----------------------------------------------------------------------
 
-static void findUsingDeclImports(EntryNav *rootNav) {
-  if (rootNav->section() == Entry::USINGDECL_SEC &&
-      (rootNav->parent()->section() &
-       Entry::COMPOUND_MASK) // in a class/struct member
-      ) {
-    // printf("Found using declaration %s at line %d of %s inside section %x\n",
+static void findUsingDeclImports(EntryNav *rootNav)
+{
+  if (rootNav->section()==Entry::USINGDECL_SEC &&
+      (rootNav->parent()->section()&Entry::COMPOUND_MASK) // in a class/struct member
+     )
+  {
+    //printf("Found using declaration %s at line %d of %s inside section %x\n",
     //    root->name.data(),root->startLine,root->fileName.data(),
     //    root->parent->section);
-    QCString fullName = removeRedundantWhiteSpace(rootNav->parent()->name());
-    fullName = stripAnonymousNamespaceScope(fullName);
-    fullName = stripTemplateSpecifiersFromScope(fullName);
+    QCString fullName=removeRedundantWhiteSpace(rootNav->parent()->name());
+    fullName=stripAnonymousNamespaceScope(fullName);
+    fullName=stripTemplateSpecifiersFromScope(fullName);
     ClassDef *cd = getClass(fullName);
-    if (cd) {
-      // printf("found class %s\n",cd->name().data());
-      int i = rootNav->name().find("::");
-      if (i != -1) {
-        QCString scope = rootNav->name().left(i);
-        QCString memName =
-            rootNav->name().right(rootNav->name().length() - i - 2);
-        ClassDef *bcd =
-            getResolvedClass(cd, 0, scope); // todo: file in fileScope parameter
-        if (bcd) {
-          // printf("found class %s\n",bcd->name().data());
-          MemberNameInfoSDict *mndict = bcd->memberNameInfoSDict();
-          if (mndict) {
+    if (cd)
+    {
+      //printf("found class %s\n",cd->name().data());
+      int i=rootNav->name().find("::");
+      if (i!=-1)
+      {
+        QCString scope=rootNav->name().left(i);
+        QCString memName=rootNav->name().right(rootNav->name().length()-i-2);
+        ClassDef *bcd = getResolvedClass(cd,0,scope); // todo: file in fileScope parameter
+        if (bcd)
+        {
+          //printf("found class %s\n",bcd->name().data());
+          MemberNameInfoSDict *mndict=bcd->memberNameInfoSDict();
+          if (mndict)
+          {
             MemberNameInfo *mni = mndict->find(memName);
-            if (mni) {
+            if (mni)
+            {
               MemberNameInfoIterator mnii(*mni);
               MemberInfo *mi;
-              for (; (mi = mnii.current()); ++mnii) {
+              for ( ; (mi=mnii.current()) ; ++mnii )
+              {
                 MemberDef *md = mi->memberDef;
-                if (md && md->protection() != Private) {
+                if (md && md->protection()!=Private)
+                {
 
                   rootNav->loadEntry(g_storage);
                   Entry *root = rootNav->entry();
 
-                  // printf("found member %s\n",mni->memberName());
+                  //printf("found member %s\n",mni->memberName());
                   MemberDef *newMd = 0;
                   {
                     QCString fileName = root->fileName;
-                    if (fileName.isEmpty() && rootNav->tagInfo()) {
+                    if (fileName.isEmpty() && rootNav->tagInfo())
+                    {
                       fileName = rootNav->tagInfo()->tagName;
                     }
                     ArgumentList *templAl = md->templateArguments();
                     ArgumentList *al = md->templateArguments();
                     newMd = new MemberDef(
-                        fileName, root->startLine, root->startColumn,
-                        md->typeString(), memName, md->argsString(),
-                        md->excpString(), root->protection, root->virt,
-                        md->isStatic(), Member, md->memberType(), templAl, al);
+                      fileName,root->startLine,root->startColumn,
+                      md->typeString(),memName,md->argsString(),
+                      md->excpString(),root->protection,root->virt,
+                      md->isStatic(),Member,md->memberType(),
+                      templAl,al
+                      );
                   }
                   newMd->setMemberClass(cd);
                   cd->insertMember(newMd);
-                  if (!root->doc.isEmpty() || !root->brief.isEmpty()) {
-                    newMd->setDocumentation(root->doc, root->docFile,
-                                            root->docLine);
-                    newMd->setBriefDescription(root->brief, root->briefFile,
-                                               root->briefLine);
-                    newMd->setInbodyDocumentation(
-                        root->inbodyDocs, root->inbodyFile, root->inbodyLine);
-                  } else {
-                    newMd->setDocumentation(md->documentation(), md->docFile(),
-                                            md->docLine());
-                    newMd->setBriefDescription(md->briefDescription(),
-                                               md->briefFile(),
-                                               md->briefLine());
-                    newMd->setInbodyDocumentation(md->inbodyDocumentation(),
-                                                  md->inbodyFile(),
-                                                  md->inbodyLine());
+                  if (!root->doc.isEmpty() || !root->brief.isEmpty())
+                  {
+                    newMd->setDocumentation(root->doc,root->docFile,root->docLine);
+                    newMd->setBriefDescription(root->brief,root->briefFile,root->briefLine);
+                    newMd->setInbodyDocumentation(root->inbodyDocs,root->inbodyFile,root->inbodyLine);
+                  }
+                  else
+                  {
+                    newMd->setDocumentation(md->documentation(),md->docFile(),md->docLine());
+                    newMd->setBriefDescription(md->briefDescription(),md->briefFile(),md->briefLine());
+                    newMd->setInbodyDocumentation(md->inbodyDocumentation(),md->inbodyFile(),md->inbodyLine());
                   }
                   newMd->setDefinition(md->definition());
                   newMd->enableCallGraph(root->callGraph);
                   newMd->enableCallerGraph(root->callerGraph);
                   newMd->setBitfields(md->bitfieldString());
                   newMd->addSectionsToDefinition(root->anchors);
-                  newMd->setBodySegment(md->getStartBodyLine(),
-                                        md->getEndBodyLine());
+                  newMd->setBodySegment(md->getStartBodyLine(),md->getEndBodyLine());
                   newMd->setBodyDef(md->getBodyDef());
                   newMd->setInitializer(md->initializer());
                   newMd->setMaxInitLines(md->initializerLines());
@@ -2097,32 +2202,38 @@ static void findUsingDeclImports(EntryNav *rootNav) {
         }
       }
     }
+
   }
-  RECURSE_ENTRYTREE(findUsingDeclImports, rootNav);
+  RECURSE_ENTRYTREE(findUsingDeclImports,rootNav);
 }
 
 //----------------------------------------------------------------------
 
-static void findIncludedUsingDirectives() {
+static void findIncludedUsingDirectives()
+{
   // first mark all files as not visited
   FileNameListIterator fnli(*Doxygen::inputNameList);
   FileName *fn;
-  for (fnli.toFirst(); (fn = fnli.current()); ++fnli) {
+  for (fnli.toFirst();(fn=fnli.current());++fnli)
+  {
     FileNameIterator fni(*fn);
     FileDef *fd;
-    for (; (fd = fni.current()); ++fni) {
-      fd->visited = FALSE;
+    for (;(fd=fni.current());++fni)
+    {
+      fd->visited=FALSE;
     }
   }
   // then recursively add using directives found in #include files
   // to files that have not been visited.
-  for (fnli.toFirst(); (fn = fnli.current()); ++fnli) {
+  for (fnli.toFirst();(fn=fnli.current());++fnli)
+  {
     FileNameIterator fni(*fn);
     FileDef *fd;
-    for (fni.toFirst(); (fd = fni.current()); ++fni) {
-      if (!fd->visited) {
-        // printf("----- adding using directives for file
-        // %s\n",fd->name().data());
+    for (fni.toFirst();(fd=fni.current());++fni)
+    {
+      if (!fd->visited)
+      {
+        //printf("----- adding using directives for file %s\n",fd->name().data());
         fd->addIncludedUsingDirectives();
       }
     }
@@ -2131,54 +2242,73 @@ static void findIncludedUsingDirectives() {
 
 //----------------------------------------------------------------------
 
-static MemberDef *addVariableToClass(EntryNav *rootNav, ClassDef *cd,
-                                     MemberType mtype, const QCString &name,
-                                     bool fromAnnScope, MemberDef *fromAnnMemb,
-                                     Protection prot, Relationship related) {
+static MemberDef *addVariableToClass(
+    EntryNav *rootNav,
+    ClassDef *cd,
+    MemberType mtype,
+    const QCString &name,
+    bool fromAnnScope,
+    MemberDef *fromAnnMemb,
+    Protection prot,
+    Relationship related)
+{
   Entry *root = rootNav->entry();
 
   QCString qualScope = cd->qualifiedNameWithTemplateParameters();
-  QCString scopeSeparator = "::";
+  QCString scopeSeparator="::";
   SrcLangExt lang = cd->getLanguage();
-  if (lang == SrcLangExt_Java || lang == SrcLangExt_CSharp) {
-    qualScope = substitute(qualScope, "::", ".");
-    scopeSeparator = ".";
-  } else if (lang == SrcLangExt_Prolog) {
-    qualScope = substitute(qualScope, "::", ":");
-    scopeSeparator = ":";
-  }
-  Debug::print(Debug::Variables, 0,
-               "  class variable:\n"
-               "    `%s' `%s'::`%s' `%s' prot=`%d ann=%d init=`%s'\n",
-               qPrint(root->type), qPrint(qualScope), qPrint(name),
-               qPrint(root->args), root->protection, fromAnnScope,
-               qPrint(root->initializer));
+  if (lang==SrcLangExt_Java || lang==SrcLangExt_CSharp)
+  {
+    qualScope = substitute(qualScope,"::",".");
+    scopeSeparator=".";
+  }
+  Debug::print(Debug::Variables,0,
+      "  class variable:\n"
+      "    `%s' `%s'::`%s' `%s' prot=`%d ann=%d init=`%s'\n",
+      qPrint(root->type),
+      qPrint(qualScope),
+      qPrint(name),
+      qPrint(root->args),
+      root->protection,
+      fromAnnScope,
+      qPrint(root->initializer)
+              );
 
   QCString def;
-  if (!root->type.isEmpty()) {
-    if (related || mtype == MemberType_Friend ||
-        Config_getBool(HIDE_SCOPE_NAMES)) {
-      if (root->spec & Entry::Alias) // turn 'typedef B A' into 'using A = B'
+  if (!root->type.isEmpty())
+  {
+    if (related || mtype==MemberType_Friend || Config_getBool(HIDE_SCOPE_NAMES))
+    {
+      if (root->spec&Entry::Alias) // turn 'typedef B A' into 'using A = B'
+      {
+        def="using "+name+" = "+root->type.mid(7);
+      }
+      else
       {
-        def = "using " + name + " = " + root->type.mid(7);
-      } else {
-        def = root->type + " " + name + root->args;
+        def=root->type+" "+name+root->args;
       }
-    } else {
-      if (root->spec &
-          Entry::Alias) // turn 'typedef B C::A' into 'using C::A = B'
+    }
+    else
+    {
+      if (root->spec&Entry::Alias) // turn 'typedef B C::A' into 'using C::A = B'
+      {
+        def="using "+qualScope+scopeSeparator+name+" = "+root->type.mid(7);
+      }
+      else
       {
-        def = "using " + qualScope + scopeSeparator + name + " = " +
-              root->type.mid(7);
-      } else {
-        def = root->type + " " + qualScope + scopeSeparator + name + root->args;
+        def=root->type+" "+qualScope+scopeSeparator+name+root->args;
       }
     }
-  } else {
-    if (Config_getBool(HIDE_SCOPE_NAMES)) {
-      def = name + root->args;
-    } else {
-      def = qualScope + scopeSeparator + name + root->args;
+  }
+  else
+  {
+    if (Config_getBool(HIDE_SCOPE_NAMES))
+    {
+      def=name+root->args;
+    }
+    else
+    {
+      def=qualScope+scopeSeparator+name+root->args;
     }
   }
   def.stripPrefix("static ");
@@ -2186,57 +2316,61 @@ static MemberDef *addVariableToClass(EntryNav *rootNav, ClassDef *cd,
   // see if the member is already found in the same scope
   // (this may be the case for a static member that is initialized
   //  outside the class)
-  MemberName *mn = Doxygen::memberNameSDict->find(name);
-  if (mn) {
+  MemberName *mn=Doxygen::memberNameSDict->find(name);
+  if (mn)
+  {
     MemberNameIterator mni(*mn);
     MemberDef *md;
-    for (mni.toFirst(); (md = mni.current()); ++mni) {
-      // printf("md->getClassDef()=%p cd=%p type=[%s] md->typeString()=[%s]\n",
+    for (mni.toFirst();(md=mni.current());++mni)
+    {
+      //printf("md->getClassDef()=%p cd=%p type=[%s] md->typeString()=[%s]\n",
       //    md->getClassDef(),cd,root->type.data(),md->typeString());
-      if (md->getClassDef() == cd &&
-          removeRedundantWhiteSpace(root->type) == md->typeString())
-      // member already in the scope
+      if (md->getClassDef()==cd &&
+          removeRedundantWhiteSpace(root->type)==md->typeString())
+        // member already in the scope
       {
 
-        if (root->lang == SrcLangExt_ObjC && root->mtype == Property &&
-            md->memberType() ==
-                MemberType_Variable) { // Objective-C 2.0 property
+        if (root->lang==SrcLangExt_ObjC &&
+            root->mtype==Property &&
+            md->memberType()==MemberType_Variable)
+        { // Objective-C 2.0 property
           // turn variable into a property
           md->setProtection(root->protection);
-          cd->reclassifyMember(md, MemberType_Property);
+          cd->reclassifyMember(md,MemberType_Property);
         }
-        addMemberDocs(rootNav, md, def, 0, FALSE);
-        // printf("    Member already found!\n");
+        addMemberDocs(rootNav,md,def,0,FALSE);
+        //printf("    Member already found!\n");
         return md;
       }
     }
   }
 
   QCString fileName = root->fileName;
-  if (fileName.isEmpty() && rootNav->tagInfo()) {
+  if (fileName.isEmpty() && rootNav->tagInfo())
+  {
     fileName = rootNav->tagInfo()->tagName;
   }
 
   // new member variable, typedef or enum value
-  MemberDef *md = new MemberDef(
-      fileName, root->startLine, root->startColumn, root->type, name,
-      root->args, root->exception, prot, Normal, root->stat, related, mtype,
-      root->tArgLists ? root->tArgLists->getLast() : 0, 0);
+  MemberDef *md=new MemberDef(
+      fileName,root->startLine,root->startColumn,
+      root->type,name,root->args,root->exception,
+      prot,Normal,root->stat,related,
+      mtype,root->tArgLists ? root->tArgLists->getLast() : 0,0);
   md->setTagInfo(rootNav->tagInfo());
   md->setMemberClass(cd); // also sets outer scope (i.e. getOuterScope())
-  // md->setDefFile(root->fileName);
-  // md->setDefLine(root->startLine);
-  md->setDocumentation(root->doc, root->docFile, root->docLine);
-  md->setBriefDescription(root->brief, root->briefFile, root->briefLine);
-  md->setInbodyDocumentation(root->inbodyDocs, root->inbodyFile,
-                             root->inbodyLine);
+  //md->setDefFile(root->fileName);
+  //md->setDefLine(root->startLine);
+  md->setDocumentation(root->doc,root->docFile,root->docLine);
+  md->setBriefDescription(root->brief,root->briefFile,root->briefLine);
+  md->setInbodyDocumentation(root->inbodyDocs,root->inbodyFile,root->inbodyLine);
   md->setDefinition(def);
   md->setBitfields(root->bitfields);
   md->addSectionsToDefinition(root->anchors);
   md->setFromAnonymousScope(fromAnnScope);
   md->setFromAnonymousMember(fromAnnMemb);
-  // md->setIndentDepth(indentDepth);
-  md->setBodySegment(root->bodyLine, root->endBodyLine);
+  //md->setIndentDepth(indentDepth);
+  md->setBodySegment(root->bodyLine,root->endBodyLine);
   md->setInitializer(root->initializer);
   md->setMaxInitLines(root->initLines);
   md->setMemberGroupId(root->mGrpId);
@@ -2249,33 +2383,35 @@ static MemberDef *addVariableToClass(EntryNav *rootNav, ClassDef *cd,
   md->setArtificial(root->artificial);
   md->setLanguage(root->lang);
   md->setId(root->id);
-  addMemberToGroups(root, md);
-  // if (root->mGrpId!=-1)
+  addMemberToGroups(root,md);
+  //if (root->mGrpId!=-1)
   //{
   //  printf("memberdef %s in memberGroup %d\n",name.data(),root->mGrpId);
   //  md->setMemberGroup(memberGroupDict[root->mGrpId]);
   //
   md->setBodyDef(rootNav->fileDef());
 
-  // printf("    Adding member=%s\n",md->name().data());
+  //printf("    Adding member=%s\n",md->name().data());
   // add the member to the global list
-  if (mn) {
+  if (mn)
+  {
     mn->append(md);
-  } else // new variable name
+  }
+  else // new variable name
   {
     mn = new MemberName(name);
     mn->append(md);
-    // printf("Adding memberName=%s\n",mn->memberName());
-    // Doxygen::memberNameDict.insert(name,mn);
-    // Doxygen::memberNameList.append(mn);
-    Doxygen::memberNameSDict->append(name, mn);
+    //printf("Adding memberName=%s\n",mn->memberName());
+    //Doxygen::memberNameDict.insert(name,mn);
+    //Doxygen::memberNameList.append(mn);
+    Doxygen::memberNameSDict->append(name,mn);
     // add the member to the class
   }
-  // printf("    New member adding to %s (%p)!\n",cd->name().data(),cd);
+  //printf("    New member adding to %s (%p)!\n",cd->name().data(),cd);
   cd->insertMember(md);
   md->setRefItems(root->sli);
 
-  // TODO: insert FileDef instead of filename strings.
+  //TODO: insert FileDef instead of filename strings.
   cd->insertUsedFile(rootNav->fileDef());
   rootNav->changeSection(Entry::EMPTY_SEC);
   return md;
@@ -2283,40 +2419,53 @@ static MemberDef *addVariableToClass(EntryNav *rootNav, ClassDef *cd,
 
 //----------------------------------------------------------------------
 
-static MemberDef *addVariableToFile(EntryNav *rootNav, MemberType mtype,
-                                    const QCString &scope, const QCString &name,
-                                    bool fromAnnScope,
-                                    /*int indentDepth,*/
-                                    MemberDef *fromAnnMemb) {
+static MemberDef *addVariableToFile(
+    EntryNav *rootNav,
+    MemberType mtype,
+    const QCString &scope,
+    const QCString &name,
+    bool fromAnnScope,
+    /*int indentDepth,*/
+    MemberDef *fromAnnMemb)
+{
   Entry *root = rootNav->entry();
-  Debug::print(Debug::Variables, 0, "  global variable:\n"
-                                    "    type=`%s' scope=`%s' name=`%s' "
-                                    "args=`%s' prot=`%d mtype=%d lang=%d\n",
-               qPrint(root->type), qPrint(scope), qPrint(name),
-               qPrint(root->args), root->protection, mtype, root->lang);
+  Debug::print(Debug::Variables,0,
+      "  global variable:\n"
+      "    type=`%s' scope=`%s' name=`%s' args=`%s' prot=`%d mtype=%d lang=%d\n",
+      qPrint(root->type),
+      qPrint(scope),
+      qPrint(name),
+      qPrint(root->args),
+      root->protection,
+      mtype,
+      root->lang
+              );
 
   FileDef *fd = rootNav->fileDef();
 
   // see if we have a typedef that should hide a struct or union
-  if (mtype == MemberType_Typedef && Config_getBool(TYPEDEF_HIDES_STRUCT)) {
+  if (mtype==MemberType_Typedef && Config_getBool(TYPEDEF_HIDES_STRUCT))
+  {
     QCString type = root->type;
     type.stripPrefix("typedef ");
-    if (type.left(7) == "struct " || type.left(6) == "union ") {
+    if (type.left(7)=="struct " || type.left(6)=="union ")
+    {
       type.stripPrefix("struct ");
       type.stripPrefix("union ");
       static QRegExp re("[a-z_A-Z][a-z_A-Z0-9]*");
-      int l, s;
-      s = re.match(type, 0, &l);
-      if (s >= 0) {
-        QCString typeValue = type.mid(s, l);
+      int l,s;
+      s = re.match(type,0,&l);
+      if (s>=0)
+      {
+        QCString typeValue = type.mid(s,l);
         ClassDef *cd = getClass(typeValue);
-        if (cd) {
+        if (cd)
+        {
           // this typedef should hide compound name cd, so we
           // change the name that is displayed from cd.
           cd->setClassName(name);
-          cd->setDocumentation(root->doc, root->docFile, root->docLine);
-          cd->setBriefDescription(root->brief, root->briefFile,
-                                  root->briefLine);
+          cd->setDocumentation(root->doc,root->docFile,root->docLine);
+          cd->setBriefDescription(root->brief,root->briefFile,root->briefLine);
           return 0;
         }
       }
@@ -2325,11 +2474,11 @@ static MemberDef *addVariableToFile(EntryNav *rootNav, MemberType mtype,
 
   // see if the function is inside a namespace
   NamespaceDef *nd = 0;
-  if (!scope.isEmpty()) {
-    if (scope.find('@') != -1)
-      return 0; // anonymous scope!
-    // nscope=removeAnonymousScopes(scope);
-    // if (!nscope.isEmpty())
+  if (!scope.isEmpty())
+  {
+    if (scope.find('@')!=-1) return 0; // anonymous scope!
+    //nscope=removeAnonymousScopes(scope);
+    //if (!nscope.isEmpty())
     //{
     nd = getResolvedNamespace(scope);
     //}
@@ -2337,84 +2486,99 @@ static MemberDef *addVariableToFile(EntryNav *rootNav, MemberType mtype,
   QCString def;
 
   // determine the definition of the global variable
-  if (nd && !nd->name().isEmpty() && nd->name().at(0) != '@' &&
-      !Config_getBool(HIDE_SCOPE_NAMES))
-  // variable is inside a namespace, so put the scope before the name
+  if (nd && !nd->name().isEmpty() && nd->name().at(0)!='@' &&
+      !Config_getBool(HIDE_SCOPE_NAMES)
+     )
+    // variable is inside a namespace, so put the scope before the name
   {
     SrcLangExt lang = nd->getLanguage();
-    QCString sep = getLanguageSpecificSeparator(lang);
+    QCString sep=getLanguageSpecificSeparator(lang);
 
-    if (!root->type.isEmpty()) {
-      if (root->spec &
-          Entry::Alias) // turn 'typedef B NS::A' into 'using NS::A = B'
+    if (!root->type.isEmpty())
+    {
+      if (root->spec&Entry::Alias) // turn 'typedef B NS::A' into 'using NS::A = B'
       {
-        def = "using " + nd->name() + sep + name + " = " + root->type;
-      } else // normal member
+        def="using "+nd->name()+sep+name+" = "+root->type;
+      }
+      else // normal member
       {
-        def = root->type + " " + nd->name() + sep + name + root->args;
+        def=root->type+" "+nd->name()+sep+name+root->args;
       }
-    } else {
-      def = nd->name() + sep + name + root->args;
     }
-  } else {
-    if (!root->type.isEmpty() && !root->name.isEmpty()) {
-      if (name.at(0) == '@') // dummy variable representing anonymous union
+    else
+    {
+      def=nd->name()+sep+name+root->args;
+    }
+  }
+  else
+  {
+    if (!root->type.isEmpty() && !root->name.isEmpty())
+    {
+      if (name.at(0)=='@') // dummy variable representing anonymous union
+      {
+        def=root->type;
+      }
+      else
       {
-        def = root->type;
-      } else {
-        if (root->spec & Entry::Alias) // turn 'typedef B A' into 'using A = B'
+        if (root->spec&Entry::Alias) // turn 'typedef B A' into 'using A = B'
         {
-          def = "using " + root->name + " = " + root->type.mid(7);
-        } else // normal member
+          def="using "+root->name+" = "+root->type.mid(7);
+        }
+        else // normal member
         {
-          def = root->type + " " + name + root->args;
+          def=root->type+" "+name+root->args;
         }
       }
-    } else {
-      def = name + root->args;
+    }
+    else
+    {
+      def=name+root->args;
     }
   }
   def.stripPrefix("static ");
 
-  MemberName *mn = Doxygen::functionNameSDict->find(name);
-  if (mn) {
-    // QCString nscope=removeAnonymousScopes(scope);
-    // NamespaceDef *nd=0;
-    // if (!nscope.isEmpty())
-    if (!scope.isEmpty()) {
+  MemberName *mn=Doxygen::functionNameSDict->find(name);
+  if (mn)
+  {
+    //QCString nscope=removeAnonymousScopes(scope);
+    //NamespaceDef *nd=0;
+    //if (!nscope.isEmpty())
+    if (!scope.isEmpty())
+    {
       nd = getResolvedNamespace(scope);
     }
     MemberNameIterator mni(*mn);
     MemberDef *md;
-    for (mni.toFirst(); (md = mni.current()); ++mni) {
-      if (((nd == 0 && md->getNamespaceDef() == 0 && md->getFileDef() &&
-            root->fileName ==
-                md->getFileDef()
-                    ->absFilePath()) // both variable names in the same file
-           || (nd != 0 && md->getNamespaceDef() == nd) // both in same namespace
-           ) &&
-          !md->isDefine() // function style #define's can be "overloaded" by
-                          // typedefs or variables
-          && !md->isEnumerate() // in C# an enum value and enum can have the
-                                // same name
+    for (mni.toFirst();(md=mni.current());++mni)
+    {
+      if (
+          ((nd==0 && md->getNamespaceDef()==0 && md->getFileDef() &&
+            root->fileName==md->getFileDef()->absFilePath()
+           ) // both variable names in the same file
+           || (nd!=0 && md->getNamespaceDef()==nd) // both in same namespace
           )
-      // variable already in the scope
+          && !md->isDefine() // function style #define's can be "overloaded" by typedefs or variables
+          && !md->isEnumerate() // in C# an enum value and enum can have the same name
+         )
+        // variable already in the scope
       {
-        bool isPHPArray = md->getLanguage() == SrcLangExt_PHP &&
-                          md->argsString() != root->args &&
-                          root->args.find('[') != -1;
-        bool staticsInDifferentFiles = root->stat && md->isStatic() &&
-                                       root->fileName != md->getDefFileName();
-
-        if (md->getFileDef() && !isPHPArray && // not a php array
-            !staticsInDifferentFiles)
-        // not a php array variable
+        bool isPHPArray = md->getLanguage()==SrcLangExt_PHP &&
+                          md->argsString()!=root->args &&
+                          root->args.find('[')!=-1;
+        bool staticsInDifferentFiles =
+                          root->stat && md->isStatic() &&
+                          root->fileName!=md->getDefFileName();
+
+        if (md->getFileDef() &&
+            !isPHPArray && // not a php array
+            !staticsInDifferentFiles
+           )
+          // not a php array variable
         {
 
-          Debug::print(Debug::Variables, 0,
-                       "    variable already found: scope=%s\n",
-                       qPrint(md->getOuterScope()->name()));
-          addMemberDocs(rootNav, md, def, 0, FALSE);
+          Debug::print(Debug::Variables,0,
+              "    variable already found: scope=%s\n",qPrint(md->getOuterScope()->name()));
+          addMemberDocs(rootNav,md,def,0,FALSE);
           md->setRefItems(root->sli);
           return md;
         }
@@ -2423,23 +2587,24 @@ static MemberDef *addVariableToFile(EntryNav *rootNav, MemberType mtype,
   }
 
   QCString fileName = root->fileName;
-  if (fileName.isEmpty() && rootNav->tagInfo()) {
+  if (fileName.isEmpty() && rootNav->tagInfo())
+  {
     fileName = rootNav->tagInfo()->tagName;
   }
 
   Debug::print(Debug::Variables,0,
     "    new variable, nd=%s tagInfo=%p!\n",nd?qPrint(nd->name()):"<global>",rootNav->tagInfo());
   // new global variable, enum value or typedef
-  MemberDef *md = new MemberDef(
-      fileName, root->startLine, root->startColumn, root->type, name,
-      root->args, 0, root->protection, Normal, root->stat, Member, mtype,
-      root->tArgLists ? root->tArgLists->getLast() : 0, 0);
+  MemberDef *md=new MemberDef(
+      fileName,root->startLine,root->startColumn,
+      root->type,name,root->args,0,
+      root->protection, Normal,root->stat,Member,
+      mtype,root->tArgLists ? root->tArgLists->getLast() : 0,0);
   md->setTagInfo(rootNav->tagInfo());
   md->setMemberSpecifiers(root->spec);
-  md->setDocumentation(root->doc, root->docFile, root->docLine);
-  md->setBriefDescription(root->brief, root->briefFile, root->briefLine);
-  md->setInbodyDocumentation(root->inbodyDocs, root->inbodyFile,
-                             root->inbodyLine);
+  md->setDocumentation(root->doc,root->docFile,root->docLine);
+  md->setBriefDescription(root->brief,root->briefFile,root->briefLine);
+  md->setInbodyDocumentation(root->inbodyDocs,root->inbodyFile,root->inbodyLine);
   md->addSectionsToDefinition(root->anchors);
   md->setFromAnonymousScope(fromAnnScope);
   md->setFromAnonymousMember(fromAnnMemb);
@@ -2452,33 +2617,39 @@ static MemberDef *addVariableToFile(EntryNav *rootNav, MemberType mtype,
   md->enableCallGraph(root->callGraph);
   md->enableCallerGraph(root->callerGraph);
   md->setExplicitExternal(root->explicitExternal);
-  // md->setOuterScope(fd);
-  if (!root->explicitExternal) {
-    md->setBodySegment(root->bodyLine, root->endBodyLine);
+  //md->setOuterScope(fd);
+  if (!root->explicitExternal)
+  {
+    md->setBodySegment(root->bodyLine,root->endBodyLine);
     md->setBodyDef(fd);
   }
-  addMemberToGroups(root, md);
+  addMemberToGroups(root,md);
 
   md->setRefItems(root->sli);
-  if (nd && !nd->name().isEmpty() && nd->name().at(0) != '@') {
+  if (nd && !nd->name().isEmpty() && nd->name().at(0)!='@')
+  {
     md->setNamespace(nd);
     nd->insertMember(md);
   }
 
   // add member to the file (we do this even if we have already inserted
   // it into the namespace.
-  if (fd) {
+  if (fd)
+  {
     md->setFileDef(fd);
     fd->insertMember(md);
   }
 
   // add member definition to the list of globals
-  if (mn) {
+  if (mn)
+  {
     mn->append(md);
-  } else {
+  }
+  else
+  {
     mn = new MemberName(name);
     mn->append(md);
-    Doxygen::functionNameSDict->append(name, mn);
+    Doxygen::functionNameSDict->append(name,mn);
   }
   rootNav->changeSection(Entry::EMPTY_SEC);
   return md;
@@ -2488,147 +2659,166 @@ static MemberDef *addVariableToFile(EntryNav *rootNav, MemberType mtype,
  *  \returns -1 if this is not a function pointer variable or
  *           the index at which the closing brace of (...*name) was found.
  */
-static int findFunctionPtr(const QCString &type, int lang, int *pLength = 0) {
-  if (lang == SrcLangExt_Fortran || lang == SrcLangExt_VHDL) {
+static int findFunctionPtr(const QCString &type,int lang, int *pLength=0)
+{
+  if (lang == SrcLangExt_Fortran || lang == SrcLangExt_VHDL)
+  {
     return -1; // Fortran and VHDL do not have function pointers
   }
   static const QRegExp re("([^)]*[\\*\\^][^)]*)");
-  int i = -1, l;
-  int bb = type.find('<');
-  int be = type.findRev('>');
-  if (!type.isEmpty() &&                   // return type is non-empty
-      (i = re.match(type, 0, &l)) != -1 && // contains (...*...)
-      type.find("operator") == -1 &&       // not an operator
-      (type.find(")(") == -1 || type.find("typedef ") != -1) &&
-      // not a function pointer return type
-      !(bb < i && i < be) // bug665855: avoid treating "typedef A<void (T*)>
-                          // type" as a function pointer
-      ) {
-    if (pLength)
-      *pLength = l;
-    // printf("findFunctionPtr=%d\n",i);
+  int i=-1,l;
+  int bb=type.find('<');
+  int be=type.findRev('>');
+  if (!type.isEmpty() &&             // return type is non-empty
+      (i=re.match(type,0,&l))!=-1 && // contains (...*...)
+      type.find("operator")==-1 &&   // not an operator
+      (type.find(")(")==-1 || type.find("typedef ")!=-1) &&
+                                    // not a function pointer return type
+      !(bb<i && i<be) // bug665855: avoid treating "typedef A<void (T*)> type" as a function pointer
+     )
+  {
+    if (pLength) *pLength=l;
+    //printf("findFunctionPtr=%d\n",i);
     return i;
-  } else {
-    // printf("findFunctionPtr=%d\n",-1);
+  }
+  else
+  {
+    //printf("findFunctionPtr=%d\n",-1);
     return -1;
   }
 }
 
+
 /*! Returns TRUE iff \a type is a class within scope \a context.
  *  Used to detect variable declarations that look like function prototypes.
  */
-static bool isVarWithConstructor(EntryNav *rootNav) {
+static bool isVarWithConstructor(EntryNav *rootNav)
+{
   static QRegExp initChars("[0-9\"'&*!^]+");
   static QRegExp idChars("[a-z_A-Z][a-z_A-Z0-9]*");
-  bool result = FALSE;
+  bool result=FALSE;
   bool typeIsClass;
   QCString type;
   Definition *ctx = 0;
   FileDef *fd = 0;
   int ti;
 
-  // printf("isVarWithConstructor(%s)\n",rootNav->name().data());
+  //printf("isVarWithConstructor(%s)\n",rootNav->name().data());
   rootNav->loadEntry(g_storage);
   Entry *root = rootNav->entry();
 
-  if (rootNav->parent()->section() & Entry::COMPOUND_MASK) { // inside a class
-    result = FALSE;
+  if (rootNav->parent()->section() & Entry::COMPOUND_MASK)
+  { // inside a class
+    result=FALSE;
     goto done;
-  } else if ((fd = rootNav->fileDef()) &&
-             (fd->name().right(2) == ".c" ||
-              fd->name().right(2) == ".h")) { // inside a .c file
-    result = FALSE;
+  }
+  else if ((fd = rootNav->fileDef()) &&
+            (fd->name().right(2)==".c" || fd->name().right(2)==".h")
+          )
+  { // inside a .c file
+    result=FALSE;
     goto done;
   }
-  if (root->type.isEmpty()) {
-    result = FALSE;
+  if (root->type.isEmpty())
+  {
+    result=FALSE;
     goto done;
   }
-  if (!rootNav->parent()->name().isEmpty()) {
-    ctx = Doxygen::namespaceSDict->find(rootNav->parent()->name());
+  if (!rootNav->parent()->name().isEmpty())
+  {
+    ctx=Doxygen::namespaceSDict->find(rootNav->parent()->name());
   }
   type = root->type;
   // remove qualifiers
-  findAndRemoveWord(type, "const");
-  findAndRemoveWord(type, "static");
-  findAndRemoveWord(type, "volatile");
-  // if (type.left(6)=="const ") type=type.right(type.length()-6);
-  typeIsClass = getResolvedClass(ctx, fd, type) != 0;
-  if (!typeIsClass && (ti = type.find('<')) != -1) {
-    typeIsClass = getResolvedClass(ctx, fd, type.left(ti)) != 0;
+  findAndRemoveWord(type,"const");
+  findAndRemoveWord(type,"static");
+  findAndRemoveWord(type,"volatile");
+  //if (type.left(6)=="const ") type=type.right(type.length()-6);
+  typeIsClass=getResolvedClass(ctx,fd,type)!=0;
+  if (!typeIsClass && (ti=type.find('<'))!=-1)
+  {
+    typeIsClass=getResolvedClass(ctx,fd,type.left(ti))!=0;
   }
   if (typeIsClass) // now we still have to check if the arguments are
                    // types or values. Since we do not have complete type info
                    // we need to rely on heuristics :-(
   {
-    // printf("typeIsClass\n");
+    //printf("typeIsClass\n");
     ArgumentList *al = root->argList;
-    if (al == 0 || al->isEmpty()) {
-      result = FALSE; // empty arg list -> function prototype.
+    if (al==0 || al->isEmpty())
+    {
+      result=FALSE; // empty arg list -> function prototype.
       goto done;
     }
     ArgumentListIterator ali(*al);
     Argument *a;
-    for (ali.toFirst(); (a = ali.current()); ++ali) {
-      if (!a->name.isEmpty() || !a->defval.isEmpty()) {
-        if (a->name.find(initChars) == 0) {
-          result = TRUE;
-        } else {
-          result = FALSE; // arg has (type,name) pair -> function prototype
+    for (ali.toFirst();(a=ali.current());++ali)
+    {
+      if (!a->name.isEmpty() || !a->defval.isEmpty())
+      {
+        if (a->name.find(initChars)==0)
+        {
+          result=TRUE;
+        }
+        else
+        {
+          result=FALSE; // arg has (type,name) pair -> function prototype
         }
         goto done;
       }
-      if (a->type.isEmpty() || getResolvedClass(ctx, fd, a->type) != 0) {
-        result = FALSE; // arg type is a known type
+      if (a->type.isEmpty() || getResolvedClass(ctx,fd,a->type)!=0)
+      {
+        result=FALSE; // arg type is a known type
         goto done;
       }
-      if (checkIfTypedef(ctx, fd, a->type)) {
-        // printf("%s:%d: false (arg is typedef)\n",__FILE__,__LINE__);
-        result = FALSE; // argument is a typedef
-        goto done;
+      if (checkIfTypedef(ctx,fd,a->type))
+      {
+         //printf("%s:%d: false (arg is typedef)\n",__FILE__,__LINE__);
+         result=FALSE; // argument is a typedef
+         goto done;
       }
-      if (a->type.at(a->type.length() - 1) == '*' ||
-          a->type.at(a->type.length() - 1) == '&')
-      // type ends with * or & => pointer or reference
+      if (a->type.at(a->type.length()-1)=='*' ||
+          a->type.at(a->type.length()-1)=='&')
+                     // type ends with * or & => pointer or reference
       {
-        result = FALSE;
+        result=FALSE;
         goto done;
       }
-      if (a->type.find(initChars) == 0) {
-        result = TRUE; // argument type starts with typical initializer char
+      if (a->type.find(initChars)==0)
+      {
+        result=TRUE; // argument type starts with typical initializer char
         goto done;
       }
-      QCString resType = resolveTypeDef(ctx, a->type);
-      if (resType.isEmpty())
-        resType = a->type;
+      QCString resType=resolveTypeDef(ctx,a->type);
+      if (resType.isEmpty()) resType=a->type;
       int len;
-      if (idChars.match(resType, 0, &len) ==
-          0) // resType starts with identifier
-      {
-        resType = resType.left(len);
-        // printf("resType=%s\n",resType.data());
-        if (resType == "int" || resType == "long" || resType == "float" ||
-            resType == "double" || resType == "char" || resType == "signed" ||
-            resType == "const" || resType == "unsigned" || resType == "void") {
-          result = FALSE; // type keyword -> function prototype
+      if (idChars.match(resType,0,&len)==0) // resType starts with identifier
+      {
+        resType=resType.left(len);
+        //printf("resType=%s\n",resType.data());
+        if (resType=="int"    || resType=="long" || resType=="float" ||
+            resType=="double" || resType=="char" || resType=="signed" ||
+            resType=="const"  || resType=="unsigned" || resType=="void")
+        {
+          result=FALSE; // type keyword -> function prototype
           goto done;
         }
       }
     }
-    result = TRUE;
+    result=TRUE;
   }
 
 done:
-  // printf("isVarWithConstructor(%s,%s)=%d\n",rootNav->parent()->name().data(),
+  //printf("isVarWithConstructor(%s,%s)=%d\n",rootNav->parent()->name().data(),
   //                                          root->type.data(),result);
   rootNav->releaseEntry();
   return result;
 }
 
-static void addVariable(EntryNav *rootNav, int isFuncPtr = -1) {
-  rootNav->loadEntry(g_storage);
-  Entry *root = rootNav->entry();
-
+static void addVariable(EntryNav *rootNav,int isFuncPtr=-1)
+{
+    rootNav->loadEntry(g_storage);
+    Entry *root = rootNav->entry();
 
     Debug::print(Debug::Variables,0,
                   "VARIABLE_SEC: \n"
@@ -2689,166 +2879,170 @@ static void addVariable(EntryNav *rootNav, int isFuncPtr = -1) {
     EntryNav *p = rootNav->parent();
     while ((p->section() & Entry::SCOPE_MASK))
     {
-      root->type = root->type.left(root->type.length() - 1);
-      root->args.prepend(") ");
+      QCString scopeName = p->name();
+      if (!scopeName.isEmpty())
+      {
+        scope.prepend(scopeName);
+        break;
+      }
+      p=p->parent();
     }
-  }
 
-  QCString scope, name = removeRedundantWhiteSpace(root->name);
+    MemberType mtype;
+    QCString type=root->type.stripWhiteSpace();
+    ClassDef *cd=0;
+    bool isRelated=FALSE;
+    bool isMemberOf=FALSE;
 
-  // find the scope of this variable
-  EntryNav *p = rootNav->parent();
-  while ((p->section() & Entry::SCOPE_MASK)) {
-    QCString scopeName = p->name();
-    if (!scopeName.isEmpty()) {
-      scope.prepend(scopeName);
-      break;
+    QCString classScope=stripAnonymousNamespaceScope(scope);
+    classScope=stripTemplateSpecifiersFromScope(classScope,FALSE);
+    QCString annScopePrefix=scope.left(scope.length()-classScope.length());
+
+    if (root->name.findRev("::")!=-1)
+    {
+      if (root->type=="friend class" || root->type=="friend struct" ||
+          root->type=="friend union")
+      {
+         cd=getClass(scope);
+         if (cd)
+         {
+           addVariableToClass(rootNav,  // entry
+                              cd,    // class to add member to
+                              MemberType_Friend, // type of member
+                              name, // name of the member
+                              FALSE,  // from Anonymous scope
+                              0,      // anonymous member
+                              Public, // protection
+                              Member  // related to a class
+                             );
+         }
+      }
+      goto nextMember;
+               /* skip this member, because it is a
+                * static variable definition (always?), which will be
+                * found in a class scope as well, but then we know the
+                * correct protection level, so only then it will be
+                * inserted in the correct list!
+                */
+    }
+
+    if (type=="@")
+      mtype=MemberType_EnumValue;
+    else if (type.left(8)=="typedef ")
+      mtype=MemberType_Typedef;
+    else if (type.left(7)=="friend ")
+      mtype=MemberType_Friend;
+    else if (root->mtype==Property)
+      mtype=MemberType_Property;
+    else if (root->mtype==Event)
+      mtype=MemberType_Event;
+    else
+      mtype=MemberType_Variable;
+
+    if (!root->relates.isEmpty()) // related variable
+    {
+      isRelated=TRUE;
+      isMemberOf=(root->relatesType == MemberOf);
+      if (getClass(root->relates)==0 && !scope.isEmpty())
+        scope=mergeScopes(scope,root->relates);
+      else
+        scope=root->relates;
     }
-    p = p->parent();
-  }
 
-  MemberType mtype;
-  QCString type = root->type.stripWhiteSpace();
-  ClassDef *cd = 0;
-  bool isRelated = FALSE;
-  bool isMemberOf = FALSE;
-
-  QCString classScope = stripAnonymousNamespaceScope(scope);
-  classScope = stripTemplateSpecifiersFromScope(classScope, FALSE);
-  QCString annScopePrefix = scope.left(scope.length() - classScope.length());
-
-  if (root->name.findRev("::") != -1) {
-    if (root->type == "friend class" || root->type == "friend struct" ||
-        root->type == "friend union") {
-      cd = getClass(scope);
-      if (cd) {
-        addVariableToClass(rootNav,           // entry
-                           cd,                // class to add member to
-                           MemberType_Friend, // type of member
-                           name,              // name of the member
-                           FALSE,             // from Anonymous scope
-                           0,                 // anonymous member
-                           Public,            // protection
-                           Member             // related to a class
-                           );
-      }
-    }
-    goto nextMember;
-    /* skip this member, because it is a
-     * static variable definition (always?), which will be
-     * found in a class scope as well, but then we know the
-     * correct protection level, so only then it will be
-     * inserted in the correct list!
-     */
-  }
-
-  if (type == "@")
-    mtype = MemberType_EnumValue;
-  else if (type.left(8) == "typedef ")
-    mtype = MemberType_Typedef;
-  else if (type.left(7) == "friend ")
-    mtype = MemberType_Friend;
-  else if (root->mtype == Property)
-    mtype = MemberType_Property;
-  else if (root->mtype == Event)
-    mtype = MemberType_Event;
-  else
-    mtype = MemberType_Variable;
+    cd=getClass(scope);
+    if (cd==0 && classScope!=scope) cd=getClass(classScope);
+    if (cd)
+    {
+      MemberDef *md=0;
 
-  if (!root->relates.isEmpty()) // related variable
-  {
-    isRelated = TRUE;
-    isMemberOf = (root->relatesType == MemberOf);
-    if (getClass(root->relates) == 0 && !scope.isEmpty())
-      scope = mergeScopes(scope, root->relates);
-    else
-      scope = root->relates;
-  }
-
-  cd = getClass(scope);
-  if (cd == 0 && classScope != scope)
-    cd = getClass(classScope);
-  if (cd) {
-    MemberDef *md = 0;
-
-    // if cd is an anonymous (=tag less) scope we insert the member
-    // into a non-anonymous parent scope as well. This is needed to
-    // be able to refer to it using \var or \fn
-
-    // int indentDepth=0;
-    int si = scope.find('@');
-    // int anonyScopes = 0;
-    // bool added=FALSE;
-
-    static bool inlineSimpleStructs = Config_getBool(INLINE_SIMPLE_STRUCTS);
-    if (si != -1 && !inlineSimpleStructs) // anonymous scope or type
-    {
-      QCString pScope;
-      ClassDef *pcd = 0;
-      pScope = scope.left(QMAX(si - 2, 0)); // scope without tag less parts
-      if (!pScope.isEmpty())
-        pScope.prepend(annScopePrefix);
-      else if (annScopePrefix.length() > 2)
-        pScope = annScopePrefix.left(annScopePrefix.length() - 2);
-      if (name.at(0) != '@') {
-        if (!pScope.isEmpty() && (pcd = getClass(pScope))) {
-          md = addVariableToClass(rootNav, // entry
-                                  pcd,     // class to add member to
-                                  mtype,   // member type
-                                  name,    // member name
-                                  TRUE,    // from anonymous scope
-                                  0,       // from anonymous member
+      // if cd is an anonymous (=tag less) scope we insert the member
+      // into a non-anonymous parent scope as well. This is needed to
+      // be able to refer to it using \var or \fn
+
+      //int indentDepth=0;
+      int si=scope.find('@');
+      //int anonyScopes = 0;
+      //bool added=FALSE;
+
+      static bool inlineSimpleStructs = Config_getBool(INLINE_SIMPLE_STRUCTS);
+      if (si!=-1 && !inlineSimpleStructs) // anonymous scope or type
+      {
+        QCString pScope;
+        ClassDef *pcd=0;
+        pScope = scope.left(QMAX(si-2,0)); // scope without tag less parts
+        if (!pScope.isEmpty())
+          pScope.prepend(annScopePrefix);
+        else if (annScopePrefix.length()>2)
+          pScope=annScopePrefix.left(annScopePrefix.length()-2);
+        if (name.at(0)!='@')
+        {
+          if (!pScope.isEmpty() && (pcd=getClass(pScope)))
+          {
+            md=addVariableToClass(rootNav,  // entry
+                                  pcd,   // class to add member to
+                                  mtype, // member type
+                                  name,  // member name
+                                  TRUE,  // from anonymous scope
+                                  0,     // from anonymous member
                                   root->protection,
-                                  isMemberOf ? Foreign
-                                             : isRelated ? Related : Member);
-          // added=TRUE;
-        } else // anonymous scope inside namespace or file => put variable in
-               // the global scope
-        {
-          if (mtype == MemberType_Variable) {
-            md = addVariableToFile(rootNav, mtype, pScope, name, TRUE, 0);
+                                  isMemberOf ? Foreign : isRelated ? Related : Member
+                                 );
+            //added=TRUE;
+          }
+          else // anonymous scope inside namespace or file => put variable in the global scope
+          {
+            if (mtype==MemberType_Variable)
+            {
+              md=addVariableToFile(rootNav,mtype,pScope,name,TRUE,0);
+            }
+            //added=TRUE;
           }
-          // added=TRUE;
         }
       }
-    }
 
-    // printf("name=`%s' scope=%s scope.right=%s\n",
-    //                   name.data(),scope.data(),
-    //                   scope.right(scope.length()-si).data());
-    addVariableToClass(rootNav, // entry
-                       cd,      // class to add member to
-                       mtype,   // member type
-                       name,    // name of the member
-                       FALSE,   // from anonymous scope
-                       md,      // from anonymous member
-                       root->protection,
-                       isMemberOf ? Foreign : isRelated ? Related : Member);
-  } else if (!name.isEmpty()) // global variable
-  {
-    // printf("Inserting member in global scope %s!\n",scope.data());
-    addVariableToFile(rootNav, mtype, scope, name, FALSE, /*0,*/ 0);
-  }
+      //printf("name=`%s' scope=%s scope.right=%s\n",
+      //                   name.data(),scope.data(),
+      //                   scope.right(scope.length()-si).data());
+      addVariableToClass(rootNav,   // entry
+                         cd,     // class to add member to
+                         mtype,  // member type
+                         name,   // name of the member
+                         FALSE,  // from anonymous scope
+                         md,     // from anonymous member
+                         root->protection,
+                         isMemberOf ? Foreign : isRelated ? Related : Member);
+    }
+    else if (!name.isEmpty()) // global variable
+    {
+      //printf("Inserting member in global scope %s!\n",scope.data());
+      addVariableToFile(rootNav,mtype,scope,name,FALSE,/*0,*/0);
+    }
 
 nextMember:
-  rootNav->releaseEntry();
+    rootNav->releaseEntry();
 }
 
 //----------------------------------------------------------------------
 // Searches the Entry tree for typedef documentation sections.
 // If found they are stored in their class or in the global list.
-static void buildTypedefList(EntryNav *rootNav) {
-  // printf("buildVarList(%s)\n",rootNav->name().data());
-  if (!rootNav->name().isEmpty() && rootNav->section() == Entry::VARIABLE_SEC &&
-      rootNav->type().find("typedef ") != -1 // its a typedef
-      ) {
+static void buildTypedefList(EntryNav *rootNav)
+{
+  //printf("buildVarList(%s)\n",rootNav->name().data());
+  if (!rootNav->name().isEmpty() &&
+      rootNav->section()==Entry::VARIABLE_SEC &&
+      rootNav->type().find("typedef ")!=-1 // its a typedef
+     )
+  {
     addVariable(rootNav);
   }
-  if (rootNav->children()) {
+  if (rootNav->children())
+  {
     EntryNavListIterator eli(*rootNav->children());
     EntryNav *e;
-    for (; (e = eli.current()); ++eli) {
-      if (e->section() != Entry::ENUM_SEC) {
+    for (;(e=eli.current());++eli)
+    {
+      if (e->section()!=Entry::ENUM_SEC)
+      {
         buildTypedefList(e);
       }
     }
@@ -2859,30 +3053,34 @@ static void buildTypedefList(EntryNav *rootNav) {
 // Searches the Entry tree for Variable documentation sections.
 // If found they are stored in their class or in the global list.
 
-static void buildVarList(EntryNav *rootNav) {
-  // printf("buildVarList(%s)
-  // section=%08x\n",rootNav->name().data(),rootNav->section());
-  int isFuncPtr = -1;
+static void buildVarList(EntryNav *rootNav)
+{
+  //printf("buildVarList(%s) section=%08x\n",rootNav->name().data(),rootNav->section());
+  int isFuncPtr=-1;
   if (!rootNav->name().isEmpty() &&
-      (rootNav->type().isEmpty() ||
-       g_compoundKeywordDict.find(rootNav->type()) == 0) &&
-      ((rootNav->section() == Entry::VARIABLE_SEC // it's a variable
-        ) ||
-       (rootNav->section() ==
-            Entry::FUNCTION_SEC && // or maybe a function pointer variable
-        (isFuncPtr = findFunctionPtr(rootNav->type(), rootNav->lang())) !=
-            -1) ||
-       (rootNav->section() ==
-            Entry::FUNCTION_SEC && // class variable initialized by constructor
-        isVarWithConstructor(rootNav)))) // documented variable
-  {
-    addVariable(rootNav, isFuncPtr);
-  }
-  if (rootNav->children()) {
+      (rootNav->type().isEmpty() || g_compoundKeywordDict.find(rootNav->type())==0) &&
+      (
+       (rootNav->section()==Entry::VARIABLE_SEC    // it's a variable
+       ) ||
+       (rootNav->section()==Entry::FUNCTION_SEC && // or maybe a function pointer variable
+        (isFuncPtr=findFunctionPtr(rootNav->type(),rootNav->lang()))!=-1
+       ) ||
+       (rootNav->section()==Entry::FUNCTION_SEC && // class variable initialized by constructor
+        isVarWithConstructor(rootNav)
+       )
+      )
+     ) // documented variable
+  {
+    addVariable(rootNav,isFuncPtr);
+  }
+  if (rootNav->children())
+  {
     EntryNavListIterator eli(*rootNav->children());
     EntryNav *e;
-    for (; (e = eli.current()); ++eli) {
-      if (e->section() != Entry::ENUM_SEC) {
+    for (;(e=eli.current());++eli)
+    {
+      if (e->section()!=Entry::ENUM_SEC)
+      {
         buildVarList(e);
       }
     }
@@ -2894,30 +3092,32 @@ static void buildVarList(EntryNav *rootNav) {
 // If found they are stored in their service or in the global list.
 //
 
-static void addInterfaceOrServiceToServiceOrSingleton(EntryNav *const rootNav,
-                                                      ClassDef *const cd,
-                                                      QCString const &rname) {
+static void addInterfaceOrServiceToServiceOrSingleton(
+        EntryNav *const rootNav,
+        ClassDef *const cd,
+        QCString const& rname)
+{
   Entry *const root = rootNav->entry();
   FileDef *const fd = rootNav->fileDef();
-  enum MemberType const type =
-      (rootNav->section() == Entry::EXPORTED_INTERFACE_SEC)
-          ? MemberType_Interface
-          : MemberType_Service;
+  enum MemberType const type = (rootNav->section()==Entry::EXPORTED_INTERFACE_SEC)
+      ? MemberType_Interface
+      : MemberType_Service;
   QCString fileName = root->fileName;
-  if (fileName.isEmpty() && rootNav->tagInfo()) {
+  if (fileName.isEmpty() && rootNav->tagInfo())
+  {
     fileName = rootNav->tagInfo()->tagName;
   }
   MemberDef *const md = new MemberDef(
-      fileName, root->startLine, root->startColumn, root->type, rname, "", "",
-      root->protection, root->virt, root->stat, Member, type, 0, root->argList);
+      fileName, root->startLine, root->startColumn, root->type, rname,
+      "", "", root->protection, root->virt, root->stat, Member,
+      type, 0, root->argList);
   md->setTagInfo(rootNav->tagInfo());
   md->setMemberClass(cd);
-  md->setDocumentation(root->doc, root->docFile, root->docLine);
+  md->setDocumentation(root->doc,root->docFile,root->docLine);
   md->setDocsForDefinition(false);
-  md->setBriefDescription(root->brief, root->briefFile, root->briefLine);
-  md->setInbodyDocumentation(root->inbodyDocs, root->inbodyFile,
-                             root->inbodyLine);
-  md->setBodySegment(root->bodyLine, root->endBodyLine);
+  md->setBriefDescription(root->brief,root->briefFile,root->briefLine);
+  md->setInbodyDocumentation(root->inbodyDocs,root->inbodyFile,root->inbodyLine);
+  md->setBodySegment(root->bodyLine,root->endBodyLine);
   md->setMemberSpecifiers(root->spec);
   md->setMemberGroupId(root->mGrpId);
   md->setTypeConstraints(root->typeConstr);
@@ -2930,167 +3130,181 @@ static void addInterfaceOrServiceToServiceOrSingleton(EntryNav *const rootNav,
   md->enableCallGraph(root->callGraph);
   md->enableCallerGraph(root->callerGraph);
 
-  Debug::print(Debug::Functions, 0, "  Interface Member:\n"
-                                    "    `%s' `%s' proto=%d\n"
-                                    "    def=`%s'\n",
-               qPrint(root->type), qPrint(rname), root->proto, qPrint(def));
+  Debug::print(Debug::Functions,0,
+      "  Interface Member:\n"
+      "    `%s' `%s' proto=%d\n"
+      "    def=`%s'\n",
+      qPrint(root->type),
+      qPrint(rname),
+      root->proto,
+      qPrint(def)
+              );
 
   // add member to the global list of all members
   MemberName *mn;
-  if ((mn = Doxygen::memberNameSDict->find(rname))) {
+  if ((mn=Doxygen::memberNameSDict->find(rname)))
+  {
     mn->append(md);
-  } else {
+  }
+  else
+  {
     mn = new MemberName(rname);
     mn->append(md);
-    Doxygen::memberNameSDict->append(rname, mn);
+    Doxygen::memberNameSDict->append(rname,mn);
   }
 
   // add member to the class cd
   cd->insertMember(md);
   // also add the member as a "base" (to get nicer diagrams)
   // "optional" interface/service get Protected which turns into dashed line
-  BaseInfo base(rname, (root->spec & (Entry::Optional)) ? Protected : Public,
-                Normal);
-  findClassRelation(rootNav, cd, cd, &base, 0, DocumentedOnly, true) ||
-      findClassRelation(rootNav, cd, cd, &base, 0, Undocumented, true);
+  BaseInfo base(rname,
+          (root->spec & (Entry::Optional)) ? Protected : Public,Normal);
+  findClassRelation(rootNav,cd,cd,&base,0,DocumentedOnly,true)
+  || findClassRelation(rootNav,cd,cd,&base,0,Undocumented,true);
   // add file to list of used files
   cd->insertUsedFile(fd);
 
-  addMemberToGroups(root, md);
+  addMemberToGroups(root,md);
   rootNav->changeSection(Entry::EMPTY_SEC);
   md->setRefItems(root->sli);
 }
 
-static void buildInterfaceAndServiceList(EntryNav *const rootNav) {
-  if (rootNav->section() == Entry::EXPORTED_INTERFACE_SEC ||
-      rootNav->section() == Entry::INCLUDED_SERVICE_SEC) {
+static void buildInterfaceAndServiceList(EntryNav *const rootNav)
+{
+  if (rootNav->section()==Entry::EXPORTED_INTERFACE_SEC ||
+      rootNav->section()==Entry::INCLUDED_SERVICE_SEC)
+  {
     rootNav->loadEntry(g_storage);
     Entry *const root = rootNav->entry();
 
-    Debug::print(Debug::Functions, 0,
+    Debug::print(Debug::Functions,0,
                  "EXPORTED_INTERFACE_SEC:\n"
-                 "  `%s' `%s'::`%s' `%s' relates=`%s' relatesType=`%d' "
-                 "file=`%s' line=`%d' bodyLine=`%d' #tArgLists=%d mGrpId=%d "
-                 "spec=%lld proto=%d docFile=%s\n",
-                 qPrint(root->type), qPrint(rootNav->parent()->name()),
-                 qPrint(root->name), qPrint(root->args), qPrint(root->relates),
-                 root->relatesType, qPrint(root->fileName), root->startLine,
+                 "  `%s' `%s'::`%s' `%s' relates=`%s' relatesType=`%d' file=`%s' line=`%d' bodyLine=`%d' #tArgLists=%d mGrpId=%d spec=%lld proto=%d docFile=%s\n",
+                 qPrint(root->type),
+                 qPrint(rootNav->parent()->name()),
+                 qPrint(root->name),
+                 qPrint(root->args),
+                 qPrint(root->relates),
+                 root->relatesType,
+                 qPrint(root->fileName),
+                 root->startLine,
                  root->bodyLine,
                  root->tArgLists ? (int)root->tArgLists->count() : -1,
-                 root->mGrpId, root->spec, root->proto, qPrint(root->docFile));
+                 root->mGrpId,
+                 root->spec,
+                 root->proto,
+                 qPrint(root->docFile)
+                );
 
     QCString const rname = removeRedundantWhiteSpace(root->name);
 
-    fprintf(stderr, "  `%s'\n", root->name.data());
-
-    if (!rname.isEmpty()) {
+    if (!rname.isEmpty())
+    {
       QCString const scope = rootNav->parent()->name();
-      fprintf(stderr, "  `%s'\n", rootNav->parent()->name().data());
       ClassDef *const cd = getClass(scope);
       assert(cd);
       if (cd && ((ClassDef::Interface == cd->compoundType()) ||
-                 (ClassDef::Service == cd->compoundType()) ||
-                 (ClassDef::Singleton == cd->compoundType()))) {
-        addInterfaceOrServiceToServiceOrSingleton(rootNav, cd, rname);
-      } else {
+                 (ClassDef::Service   == cd->compoundType()) ||
+                 (ClassDef::Singleton == cd->compoundType())))
+      {
+        addInterfaceOrServiceToServiceOrSingleton(rootNav,cd,rname);
+      }
+      else
+      {
         assert(false); // was checked by scanner.l
       }
-    } else if (rname.isEmpty()) {
-      warn(root->fileName, root->startLine, "Illegal member name found.");
+    }
+    else if (rname.isEmpty())
+    {
+      warn(root->fileName,root->startLine,
+           "Illegal member name found.");
     }
 
     rootNav->releaseEntry();
   }
   // can only have these in IDL anyway
-  switch (rootNav->lang()) {
-  case SrcLangExt_Unknown: // fall through (root node always is Unknown)
-  case SrcLangExt_IDL:
-    RECURSE_ENTRYTREE(buildInterfaceAndServiceList, rootNav);
-    break;
-  default:
-    return; // nothing to do here
+  switch (rootNav->lang())
+  {
+    case SrcLangExt_Unknown: // fall through (root node always is Unknown)
+    case SrcLangExt_IDL:
+        RECURSE_ENTRYTREE(buildInterfaceAndServiceList,rootNav);
+        break;
+    default:
+        return; // nothing to do here
   }
 }
 
+
 //----------------------------------------------------------------------
 // Searches the Entry tree for Function sections.
 // If found they are stored in their class or in the global list.
 
-static void addMethodToClass(EntryNav *rootNav, ClassDef *cd,
-                             const QCString &rname, bool isFriend) {
+static void addMethodToClass(EntryNav *rootNav,ClassDef *cd,
+                  const QCString &rname,bool isFriend)
+{
   Entry *root = rootNav->entry();
-  FileDef *fd = rootNav->fileDef();
+  FileDef *fd=rootNav->fileDef();
 
   int l;
   static QRegExp re("([a-z_A-Z0-9: ]*[ &*]+[ ]*");
-  int ts = root->type.find('<');
-  int te = root->type.findRev('>');
-  int i = re.match(root->type, 0, &l);
-  if (i != -1 && ts != -1 && ts < te && ts < i &&
-      i < te) // avoid changing A<int(int*)>, see bug 677315
+  int ts=root->type.find('<');
+  int te=root->type.findRev('>');
+  int i=re.match(root->type,0,&l);
+  if (i!=-1 && ts!=-1 && ts<te && ts<i && i<te) // avoid changing A<int(int*)>, see bug 677315
   {
-    i = -1;
+    i=-1;
   }
 
-  if (cd->getLanguage() == SrcLangExt_Cpp && // only C has pointers
-      !root->type.isEmpty() && (root->spec & Entry::Alias) == 0 &&
-      i != -1) // function variable
+  if (cd->getLanguage()==SrcLangExt_Cpp && // only C has pointers
+      !root->type.isEmpty() && (root->spec&Entry::Alias)==0 && i!=-1) // function variable
   {
-    root->args += root->type.right(root->type.length() - i - l);
-    root->type = root->type.left(i + l);
+    root->args+=root->type.right(root->type.length()-i-l);
+    root->type=root->type.left(i+l);
   }
 
-  QCString name = removeRedundantWhiteSpace(rname);
-  if (name.left(2) == "::")
-    name = name.right(name.length() - 2);
+  QCString name=removeRedundantWhiteSpace(rname);
+  if (name.left(2)=="::") name=name.right(name.length()-2);
 
   MemberType mtype;
-  if (isFriend)
-    mtype = MemberType_Friend;
-  else if (root->mtype == Signal)
-    mtype = MemberType_Signal;
-  else if (root->mtype == Slot)
-    mtype = MemberType_Slot;
-  else if (root->mtype == DCOP)
-    mtype = MemberType_DCOP;
-  else if (cd->getLanguage() == SrcLangExt_Prolog)
-    mtype = MemberType_Clause;
-  else
-    mtype = MemberType_Function;
+  if (isFriend)                 mtype=MemberType_Friend;
+  else if (root->mtype==Signal) mtype=MemberType_Signal;
+  else if (root->mtype==Slot)   mtype=MemberType_Slot;
+  else if (root->mtype==DCOP)   mtype=MemberType_DCOP;
+  else                          mtype=MemberType_Function;
 
   // strip redundant template specifier for constructors
-  if ((fd == 0 || fd->getLanguage() == SrcLangExt_Cpp) &&
-      name.left(9) != "operator " && (i = name.find('<')) != -1 &&
-      name.find('>') != -1) {
-    name = name.left(i);
+  if ((fd==0 || fd->getLanguage()==SrcLangExt_Cpp) &&
+     name.left(9)!="operator " && (i=name.find('<'))!=-1 && name.find('>')!=-1)
+  {
+    name=name.left(i);
   }
 
   QCString fileName = root->fileName;
-  if (fileName.isEmpty() && rootNav->tagInfo()) {
+  if (fileName.isEmpty() && rootNav->tagInfo())
+  {
     fileName = rootNav->tagInfo()->tagName;
   }
 
-  // printf("root->name=`%s; root->args=`%s' root->argList=`%s'\n",
+  //printf("root->name=`%s; root->args=`%s' root->argList=`%s'\n",
   //    root->name.data(),root->args.data(),argListToString(root->argList).data()
   //   );
 
   // adding class member
-  MemberDef *md = new MemberDef(
-      fileName, root->startLine, root->startColumn, root->type, name,
-      root->args, root->exception, root->protection, root->virt,
+  MemberDef *md=new MemberDef(
+      fileName,root->startLine,root->startColumn,
+      root->type,name,root->args,root->exception,
+      root->protection,root->virt,
       root->stat && root->relatesType != MemberOf,
-      root->relates.isEmpty()
-          ? Member
-          : root->relatesType == MemberOf ? Foreign : Related,
-      mtype, root->tArgLists ? root->tArgLists->getLast() : 0, root->argList);
+      root->relates.isEmpty() ? Member :
+          root->relatesType == MemberOf ? Foreign : Related,
+      mtype,root->tArgLists ? root->tArgLists->getLast() : 0,root->argList);
   md->setTagInfo(rootNav->tagInfo());
   md->setMemberClass(cd);
-  md->setDocumentation(root->doc, root->docFile, root->docLine);
+  md->setDocumentation(root->doc,root->docFile,root->docLine);
   md->setDocsForDefinition(!root->proto);
-  md->setBriefDescription(root->brief, root->briefFile, root->briefLine);
-  md->setInbodyDocumentation(root->inbodyDocs, root->inbodyFile,
-                             root->inbodyLine);
-  md->setBodySegment(root->bodyLine, root->endBodyLine);
+  md->setBriefDescription(root->brief,root->briefFile,root->briefLine);
+  md->setInbodyDocumentation(root->inbodyDocs,root->inbodyFile,root->inbodyLine);
+  md->setBodySegment(root->bodyLine,root->endBodyLine);
   md->setMemberSpecifiers(root->spec);
   md->setMemberGroupId(root->mGrpId);
   md->setTypeConstraints(root->typeConstr);
@@ -3098,70 +3312,100 @@ static void addMethodToClass(EntryNav *rootNav, ClassDef *cd,
   md->setId(root->id);
   md->setBodyDef(fd);
   md->setFileDef(fd);
-  // md->setScopeTemplateArguments(root->tArgList);
+  //md->setScopeTemplateArguments(root->tArgList);
   md->addSectionsToDefinition(root->anchors);
   QCString def;
   QCString qualScope = cd->qualifiedNameWithTemplateParameters();
   SrcLangExt lang = cd->getLanguage();
-  QCString scopeSeparator = getLanguageSpecificSeparator(lang);
-  if (scopeSeparator != "::") {
-    qualScope = substitute(qualScope, "::", scopeSeparator);
+  QCString scopeSeparator=getLanguageSpecificSeparator(lang);
+  if (scopeSeparator!="::")
+  {
+    qualScope = substitute(qualScope,"::",scopeSeparator);
   }
-  if (lang == SrcLangExt_PHP) {
+  if (lang==SrcLangExt_PHP)
+  {
     // for PHP we use Class::method and Namespace\method
-    scopeSeparator = "::";
+    scopeSeparator="::";
+  }
+  if (!root->relates.isEmpty() || isFriend || Config_getBool(HIDE_SCOPE_NAMES))
+  {
+    if (!root->type.isEmpty())
+    {
+      if (root->argList)
+      {
+        def=root->type+" "+name;
+      }
+      else
+      {
+        def=root->type+" "+name+root->args;
+      }
+    }
+    else
+    {
+      if (root->argList)
+      {
+        def=name;
+      }
+      else
+      {
+        def=name+root->args;
+      }
+    }
   }
-  if (!root->relates.isEmpty() || isFriend ||
-      Config_getBool(HIDE_SCOPE_NAMES)) {
-    if (!root->type.isEmpty()) {
-      if (root->argList) {
-        def = root->type + " " + name;
-      } else {
-        def = root->type + " " + name + root->args;
+  else
+  {
+    if (!root->type.isEmpty())
+    {
+      if (root->argList)
+      {
+        def=root->type+" "+qualScope+scopeSeparator+name;
       }
-    } else {
-      if (root->argList) {
-        def = name;
-      } else {
-        def = name + root->args;
+      else
+      {
+        def=root->type+" "+qualScope+scopeSeparator+name+root->args;
       }
     }
-  } else {
-    if (!root->type.isEmpty()) {
-      if (root->argList) {
-        def = root->type + " " + qualScope + scopeSeparator + name;
-      } else {
-        def = root->type + " " + qualScope + scopeSeparator + name + root->args;
+    else
+    {
+      if (root->argList)
+      {
+        def=qualScope+scopeSeparator+name;
       }
-    } else {
-      if (root->argList) {
-        def = qualScope + scopeSeparator + name;
-      } else {
-        def = qualScope + scopeSeparator + name + root->args;
+      else
+      {
+        def=qualScope+scopeSeparator+name+root->args;
       }
     }
   }
-  if (def.left(7) == "friend ")
-    def = def.right(def.length() - 7);
+  if (def.left(7)=="friend ") def=def.right(def.length()-7);
   md->setDefinition(def);
   md->enableCallGraph(root->callGraph);
   md->enableCallerGraph(root->callerGraph);
 
-  Debug::print(Debug::Functions, 0, "  Func Member:\n"
-                                    "    `%s' `%s'::`%s' `%s' proto=%d\n"
-                                    "    def=`%s'\n",
-               qPrint(root->type), qPrint(qualScope), qPrint(rname),
-               qPrint(root->args), root->proto, qPrint(def));
+  Debug::print(Debug::Functions,0,
+      "  Func Member:\n"
+      "    `%s' `%s'::`%s' `%s' proto=%d\n"
+      "    def=`%s'\n",
+      qPrint(root->type),
+      qPrint(qualScope),
+      qPrint(rname),
+      qPrint(root->args),
+      root->proto,
+      qPrint(def)
+              );
 
   // add member to the global list of all members
-  // printf("Adding member=%s class=%s\n",md->name().data(),cd->name().data());
+  //printf("Adding member=%s class=%s\n",md->name().data(),cd->name().data());
   MemberName *mn;
-  if ((mn = Doxygen::memberNameSDict->find(name))) {
+  if ((mn=Doxygen::memberNameSDict->find(name)))
+  {
     mn->append(md);
-  } else {
+  }
+  else
+  {
     mn = new MemberName(name);
     mn->append(md);
-    Doxygen::memberNameSDict->append(name, mn);
+    Doxygen::memberNameSDict->append(name,mn);
   }
 
   // add member to the class cd
@@ -3169,139 +3413,147 @@ static void addMethodToClass(EntryNav *rootNav, ClassDef *cd,
   // add file to list of used files
   cd->insertUsedFile(fd);
 
-  addMemberToGroups(root, md);
+  addMemberToGroups(root,md);
   rootNav->changeSection(Entry::EMPTY_SEC);
   md->setRefItems(root->sli);
 }
 
-static void buildFunctionList(EntryNav *rootNav) {
-  if (rootNav->section() == Entry::FUNCTION_SEC ||
-      rootNav->section() == Entry::CLAUSE_SEC) {
+
+static void buildFunctionList(EntryNav *rootNav)
+{
+  if (rootNav->section()==Entry::FUNCTION_SEC)
+  {
     rootNav->loadEntry(g_storage);
     Entry *root = rootNav->entry();
 
-    Debug::print(Debug::Functions, 0,
+    Debug::print(Debug::Functions,0,
                  "FUNCTION_SEC:\n"
-                 "  `%s' `%s'::`%s' `%s' relates=`%s' relatesType=`%d' "
-                 "file=`%s' line=`%d' bodyLine=`%d' #tArgLists=%d mGrpId=%d "
-                 "spec=%lld proto=%d docFile=%s\n",
-                 qPrint(root->type), qPrint(rootNav->parent()->name()),
-                 qPrint(root->name), qPrint(root->args), qPrint(root->relates),
-                 root->relatesType, qPrint(root->fileName), root->startLine,
+                 "  `%s' `%s'::`%s' `%s' relates=`%s' relatesType=`%d' file=`%s' line=`%d' bodyLine=`%d' #tArgLists=%d mGrpId=%d spec=%lld proto=%d docFile=%s\n",
+                 qPrint(root->type),
+                 qPrint(rootNav->parent()->name()),
+                 qPrint(root->name),
+                 qPrint(root->args),
+                 qPrint(root->relates),
+                 root->relatesType,
+                 qPrint(root->fileName),
+                 root->startLine,
                  root->bodyLine,
                  root->tArgLists ? (int)root->tArgLists->count() : -1,
-                 root->mGrpId, root->spec, root->proto, qPrint(root->docFile));
+                 root->mGrpId,
+                 root->spec,
+                 root->proto,
+                 qPrint(root->docFile)
+                );
 
-    bool isFriend = root->type.find("friend ") != -1;
+    bool isFriend=root->type.find("friend ")!=-1;
     QCString rname = removeRedundantWhiteSpace(root->name);
-    // printf("rname=%s\n",rname.data());
+    //printf("rname=%s\n",rname.data());
 
-    QCString scope =
-        rootNav->parent()
-            ->name(); // stripAnonymousNamespaceScope(root->parent->name);
-    if (!rname.isEmpty() && scope.find('@') == -1) {
-      ClassDef *cd = 0;
+    QCString scope=rootNav->parent()->name(); //stripAnonymousNamespaceScope(root->parent->name);
+    if (!rname.isEmpty() && scope.find('@')==-1)
+    {
+      ClassDef *cd=0;
       // check if this function's parent is a class
-      scope = stripTemplateSpecifiersFromScope(scope, FALSE);
+      scope=stripTemplateSpecifiersFromScope(scope,FALSE);
 
-      FileDef *rfd = rootNav->fileDef();
+      FileDef *rfd=rootNav->fileDef();
 
-      int memIndex = rname.findRev("::");
+      int memIndex=rname.findRev("::");
 
-      cd = getClass(scope);
-      if (cd &&
-          scope + "::" == rname.left(scope.length() + 2)) // found A::f inside A
+      cd=getClass(scope);
+      if (cd && scope+"::"==rname.left(scope.length()+2)) // found A::f inside A
       {
         // strip scope from name
-        rname = rname.right(rname.length() -
-                            rootNav->parent()->name().length() - 2);
+        rname=rname.right(rname.length()-rootNav->parent()->name().length()-2);
       }
 
       NamespaceDef *nd = 0;
-      bool isMember = FALSE;
-      if (memIndex != -1) {
-        int ts = rname.find('<');
-        int te = rname.find('>');
-        if (memIndex > 0 && (ts == -1 || te == -1)) {
-          // note: the following code was replaced by inMember=TRUE to deal with
-          // a
-          // function rname='X::foo' of class X inside a namespace also called
-          // X...
+      bool isMember=FALSE;
+      if (memIndex!=-1)
+      {
+        int ts=rname.find('<');
+        int te=rname.find('>');
+        if (memIndex>0 && (ts==-1 || te==-1))
+        {
+          // note: the following code was replaced by inMember=TRUE to deal with a
+          // function rname='X::foo' of class X inside a namespace also called X...
           // bug id 548175
-          // nd = Doxygen::namespaceSDict->find(rname.left(memIndex));
-          // isMember = nd==0;
-          // if (nd)
+          //nd = Doxygen::namespaceSDict->find(rname.left(memIndex));
+          //isMember = nd==0;
+          //if (nd)
           //{
           //  // strip namespace scope from name
           //  scope=rname.left(memIndex);
           //  rname=rname.right(rname.length()-memIndex-2);
           //}
           isMember = TRUE;
-        } else {
-          isMember = memIndex < ts || memIndex > te;
+        }
+        else
+        {
+          isMember=memIndex<ts || memIndex>te;
         }
       }
 
       static QRegExp re("([a-z_A-Z0-9: ]*[ &*]+[ ]*");
-      int ts = root->type.find('<');
-      int te = root->type.findRev('>');
+      int ts=root->type.find('<');
+      int te=root->type.findRev('>');
       int ti;
       if (!rootNav->parent()->name().isEmpty() &&
-          (rootNav->parent()->section() & Entry::COMPOUND_MASK) && cd &&
+          (rootNav->parent()->section() & Entry::COMPOUND_MASK) &&
+          cd &&
           // do some fuzzy things to exclude function pointers
           (root->type.isEmpty() ||
-           ((ti = root->type.find(re, 0)) ==
-                -1 || // type does not contain ..(..*
-            (ts != -1 && ts < te && ts < ti && ti < te) || // outside of < ... >
-            root->args.find(")[") !=
-                -1) || // and args not )[.. -> function pointer
-           root->type.find(")(") != -1 ||
-           root->type.find("operator") !=
-               -1 || // type contains ..)(.. and not "operator"
-           cd->getLanguage() != SrcLangExt_Cpp // language other than C
-           )) {
-        Debug::print(Debug::Functions, 0, "  --> member %s of class %s!\n",
-                     qPrint(rname), qPrint(cd->name()));
-        addMethodToClass(rootNav, cd, rname, isFriend);
-      } else if (!((rootNav->parent()->section() & Entry::COMPOUND_MASK) ||
-                   rootNav->parent()->section() == Entry::OBJCIMPL_SEC) &&
-                 !isMember &&
-                 (root->relates.isEmpty() || root->relatesType == Duplicate) &&
-                 root->type.left(7) != "extern " &&
-                 root->type.left(8) != "typedef ")
+           ((ti=root->type.find(re,0))==-1 ||      // type does not contain ..(..*
+            (ts!=-1 && ts<te && ts<ti && ti<te) || // outside of < ... >
+           root->args.find(")[")!=-1) ||           // and args not )[.. -> function pointer
+           root->type.find(")(")!=-1 || root->type.find("operator")!=-1 || // type contains ..)(.. and not "operator"
+           cd->getLanguage()!=SrcLangExt_Cpp                               // language other than C
+          )
+         )
+      {
+        Debug::print(Debug::Functions,0,"  --> member %s of class %s!\n",
+            qPrint(rname),qPrint(cd->name()));
+        addMethodToClass(rootNav,cd,rname,isFriend);
+      }
+      else if (!((rootNav->parent()->section() & Entry::COMPOUND_MASK)
+                 || rootNav->parent()->section()==Entry::OBJCIMPL_SEC
+                ) &&
+               !isMember &&
+               (root->relates.isEmpty() || root->relatesType == Duplicate) &&
+               root->type.left(7)!="extern " && root->type.left(8)!="typedef "
+              )
       // no member => unrelated function
       {
         /* check the uniqueness of the function name in the file.
          * A file could contain a function prototype and a function definition
          * or even multiple function prototypes.
          */
-        bool found = FALSE;
+        bool found=FALSE;
         MemberName *mn;
-        MemberDef *md = 0;
-        if ((mn = Doxygen::functionNameSDict->find(rname))) {
-          Debug::print(Debug::Functions, 0,
-                       "  --> function %s already found!\n", qPrint(rname));
+        MemberDef *md=0;
+        if ((mn=Doxygen::functionNameSDict->find(rname)))
+        {
+          Debug::print(Debug::Functions,0,"  --> function %s already found!\n",qPrint(rname));
           MemberNameIterator mni(*mn);
-          for (mni.toFirst(); (!found && (md = mni.current())); ++mni) {
+          for (mni.toFirst();(!found && (md=mni.current()));++mni)
+          {
             NamespaceDef *mnd = md->getNamespaceDef();
             NamespaceDef *rnd = 0;
-            // printf("root namespace=%s\n",rootNav->parent()->name().data());
+            //printf("root namespace=%s\n",rootNav->parent()->name().data());
             QCString fullScope = scope;
             QCString parentScope = rootNav->parent()->name();
-            if (!parentScope.isEmpty() && !leftScopeMatch(parentScope, scope)) {
-              if (!scope.isEmpty())
-                fullScope.prepend("::");
+            if (!parentScope.isEmpty() && !leftScopeMatch(parentScope,scope))
+            {
+              if (!scope.isEmpty()) fullScope.prepend("::");
               fullScope.prepend(parentScope);
             }
-            // printf("fullScope=%s\n",fullScope.data());
+            //printf("fullScope=%s\n",fullScope.data());
             rnd = getResolvedNamespace(fullScope);
             FileDef *mfd = md->getFileDef();
-            QCString nsName, rnsName;
-            if (mnd)
-              nsName = mnd->name().copy();
-            if (rnd)
-              rnsName = rnd->name().copy();
-            // printf("matching arguments for %s%s %s%s\n",
+            QCString nsName,rnsName;
+            if (mnd)  nsName = mnd->name().copy();
+            if (rnd) rnsName = rnd->name().copy();
+            //printf("matching arguments for %s%s %s%s\n",
             //    md->name().data(),md->argsString(),rname.data(),argListToString(root->argList).data());
             ArgumentList *mdAl = md->argumentList();
             ArgumentList *mdTempl = md->templateArguments();
@@ -3310,107 +3562,112 @@ static void buildFunctionList(EntryNav *rootNav) {
             // functions have the same number of template parameters
             bool sameNumTemplateArgs = TRUE;
             bool matchingReturnTypes = TRUE;
-            if (mdTempl != 0 && root->tArgLists) {
-              if (mdTempl->count() != root->tArgLists->getLast()->count()) {
+            if (mdTempl!=0 && root->tArgLists)
+            {
+              if (mdTempl->count()!=root->tArgLists->getLast()->count())
+              {
                 sameNumTemplateArgs = FALSE;
               }
-              if (md->typeString() != removeRedundantWhiteSpace(root->type)) {
+              if (md->typeString()!=removeRedundantWhiteSpace(root->type))
+              {
                 matchingReturnTypes = FALSE;
               }
             }
 
             bool staticsInDifferentFiles =
-                root->stat && md->isStatic() &&
-                root->fileName != md->getDefFileName();
-
-            if (matchArguments2(md->getOuterScope(), mfd, mdAl,
-                                rnd ? rnd : Doxygen::globalScope, rfd,
-                                root->argList, FALSE) &&
-                sameNumTemplateArgs && matchingReturnTypes &&
-                !staticsInDifferentFiles) {
-              GroupDef *gd = 0;
-              if (root->groups->getFirst() != 0) {
-                gd = Doxygen::groupSDict->find(
-                    root->groups->getFirst()->groupname.data());
+                    root->stat && md->isStatic() && root->fileName!=md->getDefFileName();
+
+            if (
+                matchArguments2(md->getOuterScope(),mfd,mdAl,
+                                rnd ? rnd : Doxygen::globalScope,rfd,root->argList,
+                                FALSE) &&
+                sameNumTemplateArgs &&
+                matchingReturnTypes &&
+                !staticsInDifferentFiles
+               )
+            {
+              GroupDef *gd=0;
+              if (root->groups->getFirst()!=0)
+              {
+                gd = Doxygen::groupSDict->find(root->groups->getFirst()->groupname.data());
               }
-              // printf("match!\n");
-              // printf("mnd=%p rnd=%p nsName=%s
-              // rnsName=%s\n",mnd,rnd,nsName.data(),rnsName.data());
+              //printf("match!\n");
+              //printf("mnd=%p rnd=%p nsName=%s rnsName=%s\n",mnd,rnd,nsName.data(),rnsName.data());
               // see if we need to create a new member
-              found =
-                  (mnd && rnd &&
-                   nsName == rnsName) || // members are in the same namespace
-                  ((mnd == 0 && rnd == 0 &&
-                    mfd != 0 && // no external reference and
-                    mfd->absFilePath() ==
-                        root->fileName // prototype in the same file
-                    ));
-              // otherwise, allow a duplicate global member with the same
-              // argument list
-              if (!found && gd && gd == md->getGroupDef() &&
-                  nsName == rnsName) {
-                // member is already in the group, so we don't want to add it
-                // again.
-                found = TRUE;
+              found=(mnd && rnd && nsName==rnsName) ||   // members are in the same namespace
+                    ((mnd==0 && rnd==0 && mfd!=0 &&       // no external reference and
+                      mfd->absFilePath()==root->fileName // prototype in the same file
+                     )
+                    );
+              // otherwise, allow a duplicate global member with the same argument list
+              if (!found && gd && gd==md->getGroupDef() && nsName==rnsName)
+              {
+                // member is already in the group, so we don't want to add it again.
+                found=TRUE;
               }
 
-              // printf("combining function with prototype found=%d in namespace
-              // %s\n",
+              //printf("combining function with prototype found=%d in namespace %s\n",
               //    found,nsName.data());
 
-              if (found) {
+              if (found)
+              {
                 // merge argument lists
-                mergeArguments(mdAl, root->argList, !root->doc.isEmpty());
+                mergeArguments(mdAl,root->argList,!root->doc.isEmpty());
                 // merge documentation
-                if (md->documentation().isEmpty() && !root->doc.isEmpty()) {
+                if (md->documentation().isEmpty() && !root->doc.isEmpty())
+                {
                   ArgumentList *argList = new ArgumentList;
-                  stringToArgumentList(root->args, argList);
-                  if (root->proto) {
-                    // printf("setDeclArgumentList to %p\n",argList);
+                  stringToArgumentList(root->args,argList);
+                  if (root->proto)
+                  {
+                    //printf("setDeclArgumentList to %p\n",argList);
                     md->setDeclArgumentList(argList);
-                  } else {
+                  }
+                  else
+                  {
                     md->setArgumentList(argList);
                   }
                 }
 
-                md->setDocumentation(root->doc, root->docFile, root->docLine);
-                md->setInbodyDocumentation(root->inbodyDocs, root->inbodyFile,
-                                           root->inbodyLine);
+                md->setDocumentation(root->doc,root->docFile,root->docLine);
+                md->setInbodyDocumentation(root->inbodyDocs,root->inbodyFile,root->inbodyLine);
                 md->setDocsForDefinition(!root->proto);
-                if (md->getStartBodyLine() == -1 && root->bodyLine != -1) {
-                  md->setBodySegment(root->bodyLine, root->endBodyLine);
+                if (md->getStartBodyLine()==-1 && root->bodyLine!=-1)
+                {
+                  md->setBodySegment(root->bodyLine,root->endBodyLine);
                   md->setBodyDef(rfd);
                 }
 
-                if (md->briefDescription().isEmpty() &&
-                    !root->brief.isEmpty()) {
+                if (md->briefDescription().isEmpty() && !root->brief.isEmpty())
+                {
                   md->setArgsString(root->args);
                 }
-                md->setBriefDescription(root->brief, root->briefFile,
-                                        root->briefLine);
+                md->setBriefDescription(root->brief,root->briefFile,root->briefLine);
 
                 md->addSectionsToDefinition(root->anchors);
 
                 md->enableCallGraph(md->hasCallGraph() || root->callGraph);
-                md->enableCallerGraph(md->hasCallerGraph() ||
-                                      root->callerGraph);
+                md->enableCallerGraph(md->hasCallerGraph() || root->callerGraph);
 
                 // merge ingroup specifiers
-                if (md->getGroupDef() == 0 && root->groups->getFirst() != 0) {
-                  addMemberToGroups(root, md);
-                } else if (md->getGroupDef() != 0 &&
-                           root->groups->count() == 0) {
-                  // printf("existing member is grouped, new member not\n");
-                  root->groups->append(new Grouping(md->getGroupDef()->name(),
-                                                    md->getGroupPri()));
-                } else if (md->getGroupDef() != 0 &&
-                           root->groups->getFirst() != 0) {
-                  // printf("both members are grouped\n");
+                if (md->getGroupDef()==0 && root->groups->getFirst()!=0)
+                {
+                  addMemberToGroups(root,md);
+                }
+                else if (md->getGroupDef()!=0 && root->groups->count()==0)
+                {
+                  //printf("existing member is grouped, new member not\n");
+                  root->groups->append(new Grouping(md->getGroupDef()->name(), md->getGroupPri()));
+                }
+                else if (md->getGroupDef()!=0 && root->groups->getFirst()!=0)
+                {
+                  //printf("both members are grouped\n");
                 }
 
                 // if md is a declaration and root is the corresponding
                 // definition, then turn md into a definition.
-                if (md->isPrototype() && !root->proto) {
+                if (md->isPrototype() && !root->proto)
+                {
                   md->setPrototype(FALSE);
                 }
               }
@@ -3419,36 +3676,33 @@ static void buildFunctionList(EntryNav *rootNav) {
         }
         if (!found) /* global function is unique with respect to the file */
         {
-          Debug::print(Debug::Functions, 0, "  --> new function %s found!\n",
-                       qPrint(rname));
-          // printf("New function type=`%s' name=`%s' args=`%s' bodyLine=%d\n",
+          Debug::print(Debug::Functions,0,"  --> new function %s found!\n",qPrint(rname));
+          //printf("New function type=`%s' name=`%s' args=`%s' bodyLine=%d\n",
           //       root->type.data(),rname.data(),root->args.data(),root->bodyLine);
 
           // new global function
-          ArgumentList *tArgList =
-              root->tArgLists ? root->tArgLists->getLast() : 0;
-          QCString name = removeRedundantWhiteSpace(rname);
-          md = new MemberDef(root->fileName, root->startLine, root->startColumn,
-                             root->type, name, root->args, root->exception,
-                             root->protection, root->virt, root->stat, Member,
-                             MemberType_Function, tArgList, root->argList);
+          ArgumentList *tArgList = root->tArgLists ? root->tArgLists->getLast() : 0;
+          QCString name=removeRedundantWhiteSpace(rname);
+          md=new MemberDef(
+              root->fileName,root->startLine,root->startColumn,
+              root->type,name,root->args,root->exception,
+              root->protection,root->virt,root->stat,Member,
+              MemberType_Function,tArgList,root->argList);
 
           md->setTagInfo(rootNav->tagInfo());
           md->setLanguage(root->lang);
           md->setId(root->id);
-          // md->setDefFile(root->fileName);
-          // md->setDefLine(root->startLine);
-          md->setDocumentation(root->doc, root->docFile, root->docLine);
-          md->setBriefDescription(root->brief, root->briefFile,
-                                  root->briefLine);
-          md->setInbodyDocumentation(root->inbodyDocs, root->inbodyFile,
-                                     root->inbodyLine);
+          //md->setDefFile(root->fileName);
+          //md->setDefLine(root->startLine);
+          md->setDocumentation(root->doc,root->docFile,root->docLine);
+          md->setBriefDescription(root->brief,root->briefFile,root->briefLine);
+          md->setInbodyDocumentation(root->inbodyDocs,root->inbodyFile,root->inbodyLine);
           md->setPrototype(root->proto);
           md->setDocsForDefinition(!root->proto);
           md->setTypeConstraints(root->typeConstr);
-          // md->setBody(root->body);
-          md->setBodySegment(root->bodyLine, root->endBodyLine);
-          FileDef *fd = rootNav->fileDef();
+          //md->setBody(root->body);
+          md->setBodySegment(root->bodyLine,root->endBodyLine);
+          FileDef *fd=rootNav->fileDef();
           md->setBodyDef(fd);
           md->addSectionsToDefinition(root->anchors);
           md->setMemberSpecifiers(root->spec);
@@ -3456,57 +3710,77 @@ static void buildFunctionList(EntryNav *rootNav) {
 
           // see if the function is inside a namespace that was not part of
           // the name already (in that case nd should be non-zero already)
-          if (nd == 0 && rootNav->parent()->section() == Entry::NAMESPACE_SEC) {
-            // QCString nscope=removeAnonymousScopes(rootNav->parent()->name());
-            QCString nscope = rootNav->parent()->name();
-            if (!nscope.isEmpty()) {
+          if (nd==0 && rootNav->parent()->section() == Entry::NAMESPACE_SEC )
+          {
+            //QCString nscope=removeAnonymousScopes(rootNav->parent()->name());
+            QCString nscope=rootNav->parent()->name();
+            if (!nscope.isEmpty())
+            {
               nd = getResolvedNamespace(nscope);
             }
           }
 
-          if (!scope.isEmpty()) {
+          if (!scope.isEmpty())
+          {
             QCString sep = getLanguageSpecificSeparator(root->lang);
-            if (sep != "::") {
-              scope = substitute(scope, "::", sep);
+            if (sep!="::")
+            {
+              scope = substitute(scope,"::",sep);
             }
-            scope += sep;
+            scope+=sep;
           }
 
           QCString def;
-          if (!root->type.isEmpty()) {
-            if (root->argList) {
-              def = root->type + " " + scope + name;
-            } else {
-              def = root->type + " " + scope + name + root->args;
+          if (!root->type.isEmpty())
+          {
+            if (root->argList)
+            {
+              def=root->type+" "+scope+name;
+            }
+            else
+            {
+              def=root->type+" "+scope+name+root->args;
+            }
+          }
+          else
+          {
+            if (root->argList)
+            {
+              def=scope+name.copy();
             }
-          } else {
-            if (root->argList) {
-              def = scope + name.copy();
-            } else {
-              def = scope + name + root->args;
+            else
+            {
+              def=scope+name+root->args;
             }
           }
-          Debug::print(
-              Debug::Functions, 0, "  Global Function:\n"
-                                   "    `%s' `%s'::`%s' `%s' proto=%d\n"
-                                   "    def=`%s'\n",
-              qPrint(root->type), qPrint(rootNav->parent()->name()),
-              qPrint(rname), qPrint(root->args), root->proto, qPrint(def));
+          Debug::print(Debug::Functions,0,
+                     "  Global Function:\n"
+                     "    `%s' `%s'::`%s' `%s' proto=%d\n"
+                     "    def=`%s'\n",
+                     qPrint(root->type),
+                     qPrint(rootNav->parent()->name()),
+                     qPrint(rname),
+                     qPrint(root->args),
+                     root->proto,
+                     qPrint(def)
+                    );
           md->setDefinition(def);
           md->enableCallGraph(root->callGraph);
           md->enableCallerGraph(root->callerGraph);
-          // if (root->mGrpId!=-1)
+          //if (root->mGrpId!=-1)
           //{
           //  md->setMemberGroup(memberGroupDict[root->mGrpId]);
           //}
 
           md->setRefItems(root->sli);
-          if (nd && !nd->name().isEmpty() && nd->name().at(0) != '@') {
+          if (nd && !nd->name().isEmpty() && nd->name().at(0)!='@')
+          {
             // add member to namespace
             md->setNamespace(nd);
             nd->insertMember(md);
           }
-          if (fd) {
+          if (fd)
+          {
             // add member to the file (we do this even if we have already
             // inserted it into the namespace)
             md->setFileDef(fd);
@@ -3514,129 +3788,138 @@ static void buildFunctionList(EntryNav *rootNav) {
           }
 
           // add member to the list of file members
-          // printf("Adding member=%s\n",md->name().data());
+          //printf("Adding member=%s\n",md->name().data());
           MemberName *mn;
-          if ((mn = Doxygen::functionNameSDict->find(name))) {
+          if ((mn=Doxygen::functionNameSDict->find(name)))
+          {
             mn->append(md);
-          } else {
+          }
+          else
+          {
             mn = new MemberName(name);
             mn->append(md);
-            Doxygen::functionNameSDict->append(name, mn);
+            Doxygen::functionNameSDict->append(name,mn);
           }
-          addMemberToGroups(root, md);
+          addMemberToGroups(root,md);
           if (root->relatesType == Simple) // if this is a relatesalso command,
                                            // allow find Member to pick it up
           {
-            rootNav->changeSection(
-                Entry::EMPTY_SEC); // Otherwise we have finished
-                                   // with this entry.
+            rootNav->changeSection(Entry::EMPTY_SEC); // Otherwise we have finished
+                                                      // with this entry.
+
           }
-        } else {
-          FileDef *fd = rootNav->fileDef();
-          if (fd) {
+        }
+        else
+        {
+          FileDef *fd=rootNav->fileDef();
+          if (fd)
+          {
             // add member to the file (we do this even if we have already
             // inserted it into the namespace)
             fd->insertMember(md);
           }
         }
 
-        // printf("unrelated function %d `%s' `%s' `%s'\n",
+        //printf("unrelated function %d `%s' `%s' `%s'\n",
         //    root->parent->section,root->type.data(),rname.data(),root->args.data());
-      } else {
-        Debug::print(Debug::Functions, 0, "  --> %s not processed!\n",
-                     qPrint(rname));
       }
-    } else if (rname.isEmpty()) {
-      warn(root->fileName, root->startLine, "Illegal member name found.");
+      else
+      {
+          Debug::print(Debug::Functions,0,"  --> %s not processed!\n",qPrint(rname));
+      }
+    }
+    else if (rname.isEmpty())
+    {
+        warn(root->fileName,root->startLine,
+             "Illegal member name found."
+            );
     }
 
     rootNav->releaseEntry();
   }
-  RECURSE_ENTRYTREE(buildFunctionList, rootNav);
+  RECURSE_ENTRYTREE(buildFunctionList,rootNav);
 }
 
 //----------------------------------------------------------------------
 
-static void findFriends() {
-  // printf("findFriends()\n");
+static void findFriends()
+{
+  //printf("findFriends()\n");
   MemberNameSDict::Iterator fnli(*Doxygen::functionNameSDict);
   MemberName *fn;
-  for (; (fn = fnli.current()); ++fnli) // for each global function name
+  for (;(fn=fnli.current());++fnli) // for each global function name
   {
-    // printf("Function name=`%s'\n",fn->memberName());
+    //printf("Function name=`%s'\n",fn->memberName());
     MemberName *mn;
-    if ((mn = Doxygen::memberNameSDict->find(
-             fn->memberName()))) { // there are members with the same name
-      // printf("Function name is also a member name\n");
+    if ((mn=Doxygen::memberNameSDict->find(fn->memberName())))
+    { // there are members with the same name
+      //printf("Function name is also a member name\n");
       MemberNameIterator fni(*fn);
       MemberDef *fmd;
-      for (; (fmd = fni.current()); ++fni) // for each function with that name
+      for (;(fmd=fni.current());++fni) // for each function with that name
       {
         MemberNameIterator mni(*mn);
         MemberDef *mmd;
-        for (; (mmd = mni.current()); ++mni) // for each member with that name
+        for (;(mmd=mni.current());++mni) // for each member with that name
         {
-          // printf("Checking for matching arguments
-          //        mmd->isRelated()=%d mmd->isFriend()=%d
-          //        mmd->isFunction()=%d\n",
+          //printf("Checking for matching arguments
+          //        mmd->isRelated()=%d mmd->isFriend()=%d mmd->isFunction()=%d\n",
           //    mmd->isRelated(),mmd->isFriend(),mmd->isFunction());
           ArgumentList *mmdAl = mmd->argumentList();
           ArgumentList *fmdAl = fmd->argumentList();
           if ((mmd->isFriend() || (mmd->isRelated() && mmd->isFunction())) &&
               matchArguments2(mmd->getOuterScope(), mmd->getFileDef(), mmdAl,
                               fmd->getOuterScope(), fmd->getFileDef(), fmdAl,
-                              TRUE)
+                              TRUE
+                             )
 
-                  ) // if the member is related and the arguments match then the
-                    // function is actually a friend.
+             ) // if the member is related and the arguments match then the
+               // function is actually a friend.
           {
-            mergeArguments(mmdAl, fmdAl);
-            if (!fmd->documentation().isEmpty()) {
-              mmd->setDocumentation(fmd->documentation(), fmd->docFile(),
-                                    fmd->docLine());
-            } else if (!mmd->documentation().isEmpty()) {
-              fmd->setDocumentation(mmd->documentation(), mmd->docFile(),
-                                    mmd->docLine());
+            mergeArguments(mmdAl,fmdAl);
+            if (!fmd->documentation().isEmpty())
+            {
+              mmd->setDocumentation(fmd->documentation(),fmd->docFile(),fmd->docLine());
+            }
+            else if (!mmd->documentation().isEmpty())
+            {
+              fmd->setDocumentation(mmd->documentation(),mmd->docFile(),mmd->docLine());
+            }
+            if (mmd->briefDescription().isEmpty() && !fmd->briefDescription().isEmpty())
+            {
+              mmd->setBriefDescription(fmd->briefDescription(),fmd->briefFile(),fmd->briefLine());
+            }
+            else if (!mmd->briefDescription().isEmpty() && !fmd->briefDescription().isEmpty())
+            {
+              fmd->setBriefDescription(mmd->briefDescription(),mmd->briefFile(),mmd->briefLine());
             }
-            if (mmd->briefDescription().isEmpty() &&
-                !fmd->briefDescription().isEmpty()) {
-              mmd->setBriefDescription(fmd->briefDescription(),
-                                       fmd->briefFile(), fmd->briefLine());
-            } else if (!mmd->briefDescription().isEmpty() &&
-                       !fmd->briefDescription().isEmpty()) {
-              fmd->setBriefDescription(mmd->briefDescription(),
-                                       mmd->briefFile(), mmd->briefLine());
+            if (!fmd->inbodyDocumentation().isEmpty())
+            {
+              mmd->setInbodyDocumentation(fmd->inbodyDocumentation(),fmd->inbodyFile(),fmd->inbodyLine());
             }
-            if (!fmd->inbodyDocumentation().isEmpty()) {
-              mmd->setInbodyDocumentation(fmd->inbodyDocumentation(),
-                                          fmd->inbodyFile(), fmd->inbodyLine());
-            } else if (!mmd->inbodyDocumentation().isEmpty()) {
-              fmd->setInbodyDocumentation(mmd->inbodyDocumentation(),
-                                          mmd->inbodyFile(), mmd->inbodyLine());
+            else if (!mmd->inbodyDocumentation().isEmpty())
+            {
+              fmd->setInbodyDocumentation(mmd->inbodyDocumentation(),mmd->inbodyFile(),mmd->inbodyLine());
             }
-            // printf("body mmd %d fmd
-            // %d\n",mmd->getStartBodyLine(),fmd->getStartBodyLine());
-            if (mmd->getStartBodyLine() == -1 &&
-                fmd->getStartBodyLine() != -1) {
-              mmd->setBodySegment(fmd->getStartBodyLine(),
-                                  fmd->getEndBodyLine());
+            //printf("body mmd %d fmd %d\n",mmd->getStartBodyLine(),fmd->getStartBodyLine());
+            if (mmd->getStartBodyLine()==-1 && fmd->getStartBodyLine()!=-1)
+            {
+              mmd->setBodySegment(fmd->getStartBodyLine(),fmd->getEndBodyLine());
               mmd->setBodyDef(fmd->getBodyDef());
-              // mmd->setBodyMember(fmd);
-            } else if (mmd->getStartBodyLine() != -1 &&
-                       fmd->getStartBodyLine() == -1) {
-              fmd->setBodySegment(mmd->getStartBodyLine(),
-                                  mmd->getEndBodyLine());
+              //mmd->setBodyMember(fmd);
+            }
+            else if (mmd->getStartBodyLine()!=-1 && fmd->getStartBodyLine()==-1)
+            {
+              fmd->setBodySegment(mmd->getStartBodyLine(),mmd->getEndBodyLine());
               fmd->setBodyDef(mmd->getBodyDef());
-              // fmd->setBodyMember(mmd);
+              //fmd->setBodyMember(mmd);
             }
             mmd->setDocsForDefinition(fmd->isDocsForDefinition());
 
             mmd->enableCallGraph(mmd->hasCallGraph() || fmd->hasCallGraph());
-            mmd->enableCallerGraph(mmd->hasCallerGraph() ||
-                                   fmd->hasCallerGraph());
+            mmd->enableCallerGraph(mmd->hasCallerGraph() || fmd->hasCallerGraph());
             fmd->enableCallGraph(mmd->hasCallGraph() || fmd->hasCallGraph());
-            fmd->enableCallerGraph(mmd->hasCallerGraph() ||
-                                   fmd->hasCallerGraph());
+            fmd->enableCallerGraph(mmd->hasCallerGraph() || fmd->hasCallerGraph());
           }
         }
       }
@@ -3646,22 +3929,29 @@ static void findFriends() {
 
 //----------------------------------------------------------------------
 
-static void transferFunctionDocumentation() {
-  // printf("---- transferFunctionDocumentation()\n");
+static void transferFunctionDocumentation()
+{
+  //printf("---- transferFunctionDocumentation()\n");
 
   // find matching function declaration and definitions.
   MemberNameSDict::Iterator mnli(*Doxygen::functionNameSDict);
   MemberName *mn;
-  for (; (mn = mnli.current()); ++mnli) {
-    // printf("memberName=%s count=%d\n",mn->memberName(),mn->count());
-    MemberDef *mdef = 0, *mdec = 0;
+  for (;(mn=mnli.current());++mnli)
+  {
+    //printf("memberName=%s count=%d\n",mn->memberName(),mn->count());
+    MemberDef *mdef=0,*mdec=0;
     MemberNameIterator mni1(*mn);
     /* find a matching function declaration and definition for this function */
-    for (; (mdec = mni1.current()); ++mni1) {
-      if (mdec->isPrototype() || (mdec->isVariable() && mdec->isExternal())) {
+    for (;(mdec=mni1.current());++mni1)
+    {
+      if (mdec->isPrototype() ||
+          (mdec->isVariable() && mdec->isExternal())
+         )
+      {
         MemberNameIterator mni2(*mn);
-        for (; (mdef = mni2.current()); ++mni2) {
-          combineDeclarationAndDefinition(mdec, mdef);
+        for (;(mdef=mni2.current());++mni2)
+        {
+          combineDeclarationAndDefinition(mdec,mdef);
         }
       }
     }
@@ -3670,47 +3960,60 @@ static void transferFunctionDocumentation() {
 
 //----------------------------------------------------------------------
 
-static void transferFunctionReferences() {
+static void transferFunctionReferences()
+{
   MemberNameSDict::Iterator mnli(*Doxygen::functionNameSDict);
   MemberName *mn;
-  for (; (mn = mnli.current()); ++mnli) {
-    MemberDef *md, *mdef = 0, *mdec = 0;
+  for (;(mn=mnli.current());++mnli)
+  {
+    MemberDef *md,*mdef=0,*mdec=0;
     MemberNameIterator mni(*mn);
     /* find a matching function declaration and definition for this function */
-    for (; (md = mni.current()); ++mni) {
+    for (;(md=mni.current());++mni)
+    {
       if (md->isPrototype())
-        mdec = md;
+        mdec=md;
       else if (md->isVariable() && md->isExternal())
-        mdec = md;
+        mdec=md;
 
       if (md->isFunction() && !md->isStatic() && !md->isPrototype())
-        mdef = md;
+        mdef=md;
       else if (md->isVariable() && !md->isExternal() && !md->isStatic())
-        mdef = md;
+        mdef=md;
     }
-    if (mdef && mdec) {
+    if (mdef && mdec)
+    {
       ArgumentList *mdefAl = mdef->argumentList();
       ArgumentList *mdecAl = mdec->argumentList();
-      if (matchArguments2(mdef->getOuterScope(), mdef->getFileDef(), mdefAl,
-                          mdec->getOuterScope(), mdec->getFileDef(), mdecAl,
-                          TRUE)) /* match found */
+      if (
+          matchArguments2(mdef->getOuterScope(),mdef->getFileDef(),mdefAl,
+                          mdec->getOuterScope(),mdec->getFileDef(),mdecAl,
+                          TRUE
+            )
+         ) /* match found */
       {
         MemberSDict *defDict = mdef->getReferencesMembers();
         MemberSDict *decDict = mdec->getReferencesMembers();
-        if (defDict != 0) {
+        if (defDict!=0)
+        {
           MemberSDict::IteratorDict msdi(*defDict);
           MemberDef *rmd;
-          for (msdi.toFirst(); (rmd = msdi.current()); ++msdi) {
-            if (decDict == 0 || decDict->find(rmd->name()) == 0) {
+          for (msdi.toFirst();(rmd=msdi.current());++msdi)
+          {
+            if (decDict==0 || decDict->find(rmd->name())==0)
+            {
               mdec->addSourceReferences(rmd);
             }
           }
         }
-        if (decDict != 0) {
+        if (decDict!=0)
+        {
           MemberSDict::IteratorDict msdi(*decDict);
           MemberDef *rmd;
-          for (msdi.toFirst(); (rmd = msdi.current()); ++msdi) {
-            if (defDict == 0 || defDict->find(rmd->name()) == 0) {
+          for (msdi.toFirst();(rmd=msdi.current());++msdi)
+          {
+            if (defDict==0 || defDict->find(rmd->name())==0)
+            {
               mdef->addSourceReferences(rmd);
             }
           }
@@ -3718,20 +4021,26 @@ static void transferFunctionReferences() {
 
         defDict = mdef->getReferencedByMembers();
         decDict = mdec->getReferencedByMembers();
-        if (defDict != 0) {
+        if (defDict!=0)
+        {
           MemberSDict::IteratorDict msdi(*defDict);
           MemberDef *rmd;
-          for (msdi.toFirst(); (rmd = msdi.current()); ++msdi) {
-            if (decDict == 0 || decDict->find(rmd->name()) == 0) {
+          for (msdi.toFirst();(rmd=msdi.current());++msdi)
+          {
+            if (decDict==0 || decDict->find(rmd->name())==0)
+            {
               mdec->addSourceReferencedBy(rmd);
             }
           }
         }
-        if (decDict != 0) {
+        if (decDict!=0)
+        {
           MemberSDict::IteratorDict msdi(*decDict);
           MemberDef *rmd;
-          for (msdi.toFirst(); (rmd = msdi.current()); ++msdi) {
-            if (defDict == 0 || defDict->find(rmd->name()) == 0) {
+          for (msdi.toFirst();(rmd=msdi.current());++msdi)
+          {
+            if (defDict==0 || defDict->find(rmd->name())==0)
+            {
               mdef->addSourceReferencedBy(rmd);
             }
           }
@@ -3743,36 +4052,39 @@ static void transferFunctionReferences() {
 
 //----------------------------------------------------------------------
 
-static void transferRelatedFunctionDocumentation() {
+static void transferRelatedFunctionDocumentation()
+{
   // find match between function declaration and definition for
   // related functions
   MemberNameSDict::Iterator mnli(*Doxygen::functionNameSDict);
   MemberName *mn;
-  for (mnli.toFirst(); (mn = mnli.current()); ++mnli) {
+  for (mnli.toFirst();(mn=mnli.current());++mnli)
+  {
     MemberDef *md;
     MemberNameIterator mni(*mn);
     /* find a matching function declaration and definition for this function */
-    for (mni.toFirst(); (md = mni.current()); ++mni) // for each global function
+    for (mni.toFirst();(md=mni.current());++mni) // for each global function
     {
-      // printf("  Function `%s'\n",md->name().data());
+      //printf("  Function `%s'\n",md->name().data());
       MemberName *rmn;
-      if ((rmn = Doxygen::memberNameSDict->find(
-               md->name()))) // check if there is a member with the same name
+      if ((rmn=Doxygen::memberNameSDict->find(md->name()))) // check if there is a member with the same name
       {
-        // printf("  Member name found\n");
+        //printf("  Member name found\n");
         MemberDef *rmd;
         MemberNameIterator rmni(*rmn);
-        for (rmni.toFirst(); (rmd = rmni.current());
-             ++rmni) // for each member with the same name
+        for (rmni.toFirst();(rmd=rmni.current());++rmni) // for each member with the same name
         {
           ArgumentList *mdAl = md->argumentList();
           ArgumentList *rmdAl = rmd->argumentList();
-          // printf("  Member found: related=`%d'\n",rmd->isRelated());
+          //printf("  Member found: related=`%d'\n",rmd->isRelated());
           if ((rmd->isRelated() || rmd->isForeign()) && // related function
-              matchArguments2(md->getOuterScope(), md->getFileDef(), mdAl,
-                              rmd->getOuterScope(), rmd->getFileDef(), rmdAl,
-                              TRUE)) {
-            // printf("  Found related member `%s'\n",md->name().data());
+              matchArguments2( md->getOuterScope(), md->getFileDef(), mdAl,
+                              rmd->getOuterScope(),rmd->getFileDef(),rmdAl,
+                              TRUE
+                             )
+             )
+          {
+            //printf("  Found related member `%s'\n",md->name().data());
             if (rmd->relatedAlso())
               md->setRelatedAlso(rmd->relatedAlso());
             else if (rmd->isForeign())
@@ -3793,25 +4105,30 @@ static void transferRelatedFunctionDocumentation() {
  * Example: A template class A with template arguments <R,S,T>
  * that inherits from B<T,T,S> will have T and S in the dictionary.
  */
-static QDict<int> *getTemplateArgumentsInName(ArgumentList *templateArguments,
-                                              const QCString &name) {
+static QDict<int> *getTemplateArgumentsInName(ArgumentList *templateArguments,const QCString &name)
+{
   QDict<int> *templateNames = new QDict<int>(17);
   templateNames->setAutoDelete(TRUE);
   static QRegExp re("[a-z_A-Z][a-z_A-Z0-9:]*");
-  if (templateArguments) {
+  if (templateArguments)
+  {
     ArgumentListIterator ali(*templateArguments);
     Argument *arg;
-    int count = 0;
-    for (ali.toFirst(); (arg = ali.current()); ++ali, count++) {
-      int i, p = 0, l;
-      while ((i = re.match(name, p, &l)) != -1) {
-        QCString n = name.mid(i, l);
-        if (n == arg->name) {
-          if (templateNames->find(n) == 0) {
-            templateNames->insert(n, new int(count));
+    int count=0;
+    for (ali.toFirst();(arg=ali.current());++ali,count++)
+    {
+      int i,p=0,l;
+      while ((i=re.match(name,p,&l))!=-1)
+      {
+        QCString n = name.mid(i,l);
+        if (n==arg->name)
+        {
+          if (templateNames->find(n)==0)
+          {
+            templateNames->insert(n,new int(count));
           }
         }
-        p = i + l;
+        p=i+l;
       }
     }
   }
@@ -3821,31 +4138,33 @@ static QDict<int> *getTemplateArgumentsInName(ArgumentList *templateArguments,
 /*! Searches a class from within \a context and \a cd and returns its
  *  definition if found (otherwise 0 is returned).
  */
-static ClassDef *findClassWithinClassContext(Definition *context, ClassDef *cd,
-                                             const QCString &name) {
-  ClassDef *result = 0;
-  if (cd == 0) {
+static ClassDef *findClassWithinClassContext(Definition *context,ClassDef *cd,const QCString &name)
+{
+  ClassDef *result=0;
+  if (cd==0)
+  {
     return result;
   }
-  FileDef *fd = cd->getFileDef();
-  if (context && cd != context) {
-    result = getResolvedClass(context, 0, name, 0, 0, TRUE, TRUE);
+  FileDef *fd=cd->getFileDef();
+  if (context && cd!=context)
+  {
+    result = getResolvedClass(context,0,name,0,0,TRUE,TRUE);
   }
-  if (result == 0) {
-    result = getResolvedClass(cd, fd, name, 0, 0, TRUE, TRUE);
+  if (result==0)
+  {
+    result = getResolvedClass(cd,fd,name,0,0,TRUE,TRUE);
   }
-  if (result == 0) // try direct class, needed for namespaced classes imported
-                   // via tag files (see bug624095)
+  if (result==0) // try direct class, needed for namespaced classes imported via tag files (see bug624095)
   {
     result = getClass(name);
   }
-  if (result == 0 && (cd->getLanguage() == SrcLangExt_CSharp ||
-                      cd->getLanguage() == SrcLangExt_Java) &&
-      name.find('<') != -1) {
+  if (result==0 &&
+      (cd->getLanguage()==SrcLangExt_CSharp || cd->getLanguage()==SrcLangExt_Java) &&
+      name.find('<')!=-1)
+  {
     result = Doxygen::genericsDict->find(name);
   }
-  // printf("** Trying to find %s within context %s class %s result=%s
-  // lookup=%p\n",
+  //printf("** Trying to find %s within context %s class %s result=%s lookup=%p\n",
   //       name.data(),
   //       context ? context->name().data() : "<none>",
   //       cd      ? cd->name().data()      : "<none>",
@@ -3855,243 +4174,251 @@ static ClassDef *findClassWithinClassContext(Definition *context, ClassDef *cd,
   return result;
 }
 
-static void findUsedClassesForClass(EntryNav *rootNav, Definition *context,
-                                    ClassDef *masterCd, ClassDef *instanceCd,
-                                    bool isArtificial,
-                                    ArgumentList *actualArgs = 0,
-                                    QDict<int> *templateNames = 0) {
-  masterCd->visited = TRUE;
+
+static void findUsedClassesForClass(EntryNav *rootNav,
+                           Definition *context,
+                           ClassDef *masterCd,
+                           ClassDef *instanceCd,
+                           bool isArtificial,
+                           ArgumentList *actualArgs=0,
+                           QDict<int> *templateNames=0
+                           )
+{
+  masterCd->visited=TRUE;
   ArgumentList *formalArgs = masterCd->templateArguments();
-  if (masterCd->memberNameInfoSDict()) {
+  if (masterCd->memberNameInfoSDict())
+  {
     MemberNameInfoSDict::Iterator mnili(*masterCd->memberNameInfoSDict());
     MemberNameInfo *mni;
-    for (; (mni = mnili.current()); ++mnili) {
+    for (;(mni=mnili.current());++mnili)
+    {
       MemberNameInfoIterator mnii(*mni);
       MemberInfo *mi;
-      for (mnii.toFirst(); (mi = mnii.current()); ++mnii) {
-        MemberDef *md = mi->memberDef;
-        if (md->isVariable() ||
-            md->isObjCProperty()) // for each member variable in this class
-        {
-          // printf("    Found variable %s in class
-          // %s\n",md->name().data(),masterCd->name().data());
-          QCString type = normalizeNonTemplateArgumentsInString(
-              md->typeString(), masterCd, formalArgs);
-          QCString typedefValue = resolveTypeDef(masterCd, type);
-          if (!typedefValue.isEmpty()) {
+      for (mnii.toFirst();(mi=mnii.current());++mnii)
+      {
+        MemberDef *md=mi->memberDef;
+        if (md->isVariable() || md->isObjCProperty()) // for each member variable in this class
+        {
+          //printf("    Found variable %s in class %s\n",md->name().data(),masterCd->name().data());
+          QCString type = normalizeNonTemplateArgumentsInString(md->typeString(),masterCd,formalArgs);
+          QCString typedefValue = resolveTypeDef(masterCd,type);
+          if (!typedefValue.isEmpty())
+          {
             type = typedefValue;
           }
-          int pos = 0;
+          int pos=0;
           QCString usedClassName;
           QCString templSpec;
-          bool found = FALSE;
+          bool found=FALSE;
           // the type can contain template variables, replace them if present
-          if (actualArgs) {
-            type = substituteTemplateArgumentsInString(type, formalArgs,
-                                                       actualArgs);
+          if (actualArgs)
+          {
+            type = substituteTemplateArgumentsInString(type,formalArgs,actualArgs);
           }
 
-          // printf("      template substitution gives=%s\n",type.data());
-          while (!found &&
-                 extractClassNameFromType(type, pos, usedClassName, templSpec,
-                                          rootNav->lang()) != -1) {
+          //printf("      template substitution gives=%s\n",type.data());
+          while (!found && extractClassNameFromType(type,pos,usedClassName,templSpec,rootNav->lang())!=-1)
+          {
             // find the type (if any) that matches usedClassName
-            ClassDef *typeCd =
-                getResolvedClass(masterCd, masterCd->getFileDef(),
-                                 usedClassName, 0, 0, FALSE, TRUE);
-            // printf("====>  usedClassName=%s -> typeCd=%s\n",
+            ClassDef *typeCd = getResolvedClass(masterCd,
+                masterCd->getFileDef(),
+                usedClassName,
+                0,0,
+                FALSE,TRUE
+                );
+            //printf("====>  usedClassName=%s -> typeCd=%s\n",
             //     usedClassName.data(),typeCd?typeCd->name().data():"<none>");
-            if (typeCd) {
+            if (typeCd)
+            {
               usedClassName = typeCd->name();
             }
 
-            int sp = usedClassName.find('<');
-            if (sp == -1)
-              sp = 0;
-            int si = usedClassName.findRev("::", sp);
-            if (si != -1) {
+            int sp=usedClassName.find('<');
+            if (sp==-1) sp=0;
+            int si=usedClassName.findRev("::",sp);
+            if (si!=-1)
+            {
               // replace any namespace aliases
-              replaceNamespaceAliases(usedClassName, si);
+              replaceNamespaceAliases(usedClassName,si);
             }
             // add any template arguments to the class
-            QCString usedName =
-                removeRedundantWhiteSpace(usedClassName + templSpec);
-            // printf("    usedName=%s\n",usedName.data());
-
-            bool delTempNames = FALSE;
-            if (templateNames == 0) {
-              templateNames = getTemplateArgumentsInName(formalArgs, usedName);
-              delTempNames = TRUE;
+            QCString usedName = removeRedundantWhiteSpace(usedClassName+templSpec);
+            //printf("    usedName=%s\n",usedName.data());
+
+            bool delTempNames=FALSE;
+            if (templateNames==0)
+            {
+              templateNames = getTemplateArgumentsInName(formalArgs,usedName);
+              delTempNames=TRUE;
             }
-            BaseInfo bi(usedName, Public, Normal);
-            findClassRelation(rootNav, context, instanceCd, &bi, templateNames,
-                              TemplateInstances, isArtificial);
+            BaseInfo bi(usedName,Public,Normal);
+            findClassRelation(rootNav,context,instanceCd,&bi,templateNames,TemplateInstances,isArtificial);
 
-            if (masterCd->templateArguments()) {
+            if (masterCd->templateArguments())
+            {
               ArgumentListIterator ali(*masterCd->templateArguments());
               Argument *arg;
-              int count = 0;
-              for (ali.toFirst(); (arg = ali.current()); ++ali, ++count) {
-                if (arg->name == usedName) // type is a template argument
+              int count=0;
+              for (ali.toFirst();(arg=ali.current());++ali,++count)
+              {
+                if (arg->name==usedName) // type is a template argument
                 {
-                  found = TRUE;
-                  Debug::print(Debug::Classes, 0, "    New used class `%s'\n",
-                               qPrint(usedName));
+                  found=TRUE;
+                  Debug::print(Debug::Classes,0,"    New used class `%s'\n", qPrint(usedName));
 
                   ClassDef *usedCd = Doxygen::hiddenClasses->find(usedName);
-                  if (usedCd == 0) {
+                  if (usedCd==0)
+                  {
                     usedCd = new ClassDef(
-                        masterCd->getDefFileName(), masterCd->getDefLine(),
-                        masterCd->getDefColumn(), usedName, ClassDef::Class);
-                    // printf("making %s a template
-                    // argument!!!\n",usedCd->name().data());
+                        masterCd->getDefFileName(),masterCd->getDefLine(),
+                        masterCd->getDefColumn(),
+                        usedName,
+                        ClassDef::Class);
+                    //printf("making %s a template argument!!!\n",usedCd->name().data());
                     usedCd->makeTemplateArgument();
                     usedCd->setUsedOnly(TRUE);
                     usedCd->setLanguage(masterCd->getLanguage());
-                    Doxygen::hiddenClasses->append(usedName, usedCd);
+                    Doxygen::hiddenClasses->append(usedName,usedCd);
                   }
-                  if (isArtificial)
-                    usedCd->setArtificial(TRUE);
-                  Debug::print(Debug::Classes, 0,
-                               "      Adding used class `%s' (1)\n",
-                               qPrint(usedCd->name()));
-                  instanceCd->addUsedClass(usedCd, md->name(),
-                                           md->protection());
-                  usedCd->addUsedByClass(instanceCd, md->name(),
-                                         md->protection());
+                  if (isArtificial) usedCd->setArtificial(TRUE);
+                  Debug::print(Debug::Classes,0,"      Adding used class `%s' (1)\n", qPrint(usedCd->name()));
+                  instanceCd->addUsedClass(usedCd,md->name(),md->protection());
+                  usedCd->addUsedByClass(instanceCd,md->name(),md->protection());
                 }
               }
             }
 
-            if (!found) {
-              ClassDef *usedCd =
-                  findClassWithinClassContext(context, masterCd, usedName);
-              // printf("Looking for used class %s: result=%s master=%s\n",
+            if (!found)
+            {
+              ClassDef *usedCd=findClassWithinClassContext(context,masterCd,usedName);
+              //printf("Looking for used class %s: result=%s master=%s\n",
               //    usedName.data(),usedCd?usedCd->name().data():"<none>",masterCd?masterCd->name().data():"<none>");
 
-              if (usedCd) {
-                found = TRUE;
-                Debug::print(Debug::Classes, 0,
-                             "    Adding used class `%s' (2)\n",
-                             qPrint(usedCd->name()));
-                instanceCd->addUsedClass(usedCd, md->name(),
-                                         md->protection()); // class exists
-                usedCd->addUsedByClass(instanceCd, md->name(),
-                                       md->protection());
+              if (usedCd)
+              {
+                found=TRUE;
+                Debug::print(Debug::Classes,0,"    Adding used class `%s' (2)\n", qPrint(usedCd->name()));
+                instanceCd->addUsedClass(usedCd,md->name(),md->protection()); // class exists
+                usedCd->addUsedByClass(instanceCd,md->name(),md->protection());
               }
             }
-            if (delTempNames) {
+            if (delTempNames)
+            {
               delete templateNames;
-              templateNames = 0;
+              templateNames=0;
             }
           }
-          if (!found &&
-              !type.isEmpty()) // used class is not documented in any scope
+          if (!found && !type.isEmpty()) // used class is not documented in any scope
           {
             ClassDef *usedCd = Doxygen::hiddenClasses->find(type);
-            if (usedCd == 0 && !Config_getBool(HIDE_UNDOC_RELATIONS)) {
-              if (type.right(2) == "(*" ||
-                  type.right(2) == "(^") // type is a function pointer
+            if (usedCd==0 && !Config_getBool(HIDE_UNDOC_RELATIONS))
+            {
+              if (type.right(2)=="(*" || type.right(2)=="(^") // type is a function pointer
               {
-                type += md->argsString();
+                type+=md->argsString();
               }
-              Debug::print(Debug::Classes, 0,
-                           "  New undocumented used class `%s'\n",
-                           qPrint(type));
+              Debug::print(Debug::Classes,0,"  New undocumented used class `%s'\n", qPrint(type));
               usedCd = new ClassDef(
-                  masterCd->getDefFileName(), masterCd->getDefLine(),
-                  masterCd->getDefColumn(), type, ClassDef::Class);
+                  masterCd->getDefFileName(),masterCd->getDefLine(),
+                  masterCd->getDefColumn(),
+                  type,ClassDef::Class);
               usedCd->setUsedOnly(TRUE);
               usedCd->setLanguage(masterCd->getLanguage());
-              Doxygen::hiddenClasses->append(type, usedCd);
+              Doxygen::hiddenClasses->append(type,usedCd);
             }
-            if (usedCd) {
-              if (isArtificial)
-                usedCd->setArtificial(TRUE);
-              Debug::print(Debug::Classes, 0,
-                           "    Adding used class `%s' (3)\n",
-                           qPrint(usedCd->name()));
-              instanceCd->addUsedClass(usedCd, md->name(), md->protection());
-              usedCd->addUsedByClass(instanceCd, md->name(), md->protection());
+            if (usedCd)
+            {
+              if (isArtificial) usedCd->setArtificial(TRUE);
+              Debug::print(Debug::Classes,0,"    Adding used class `%s' (3)\n", qPrint(usedCd->name()));
+              instanceCd->addUsedClass(usedCd,md->name(),md->protection());
+              usedCd->addUsedByClass(instanceCd,md->name(),md->protection());
             }
           }
         }
       }
     }
-  } else {
-    // printf("no members for class %s
-    // (%p)\n",masterCd->name().data(),masterCd);
+  }
+  else
+  {
+    //printf("no members for class %s (%p)\n",masterCd->name().data(),masterCd);
   }
 }
 
-static void findBaseClassesForClass(EntryNav *rootNav, Definition *context,
-                                    ClassDef *masterCd, ClassDef *instanceCd,
-                                    FindBaseClassRelation_Mode mode,
-                                    bool isArtificial,
-                                    ArgumentList *actualArgs = 0,
-                                    QDict<int> *templateNames = 0) {
+static void findBaseClassesForClass(
+      EntryNav *rootNav,
+      Definition *context,
+      ClassDef *masterCd,
+      ClassDef *instanceCd,
+      FindBaseClassRelation_Mode mode,
+      bool isArtificial,
+      ArgumentList *actualArgs=0,
+      QDict<int> *templateNames=0
+    )
+{
   Entry *root = rootNav->entry();
-  // if (masterCd->visited) return;
-  masterCd->visited = TRUE;
+  //if (masterCd->visited) return;
+  masterCd->visited=TRUE;
   // The base class could ofcouse also be a non-nested class
   ArgumentList *formalArgs = masterCd->templateArguments();
   QListIterator<BaseInfo> bii(*root->extends);
-  BaseInfo *bi = 0;
-  for (bii.toFirst(); (bi = bii.current()); ++bii) {
-    // printf("masterCd=%s bi->name='%s' #actualArgs=%d\n",
+  BaseInfo *bi=0;
+  for (bii.toFirst();(bi=bii.current());++bii)
+  {
+    //printf("masterCd=%s bi->name='%s' #actualArgs=%d\n",
     //    masterCd->localName().data(),bi->name.data(),actualArgs?(int)actualArgs->count():-1);
-    bool delTempNames = FALSE;
-    if (templateNames == 0) {
-      templateNames = getTemplateArgumentsInName(formalArgs, bi->name);
-      delTempNames = TRUE;
+    bool delTempNames=FALSE;
+    if (templateNames==0)
+    {
+      templateNames = getTemplateArgumentsInName(formalArgs,bi->name);
+      delTempNames=TRUE;
     }
-    BaseInfo tbi(bi->name, bi->prot, bi->virt);
-    if (actualArgs) // substitute the formal template arguments of the base
-                    // class
+    BaseInfo tbi(bi->name,bi->prot,bi->virt);
+    if (actualArgs) // substitute the formal template arguments of the base class
     {
-      tbi.name =
-          substituteTemplateArgumentsInString(bi->name, formalArgs, actualArgs);
+      tbi.name = substituteTemplateArgumentsInString(bi->name,formalArgs,actualArgs);
     }
-    // printf("bi->name=%s tbi.name=%s\n",bi->name.data(),tbi.name.data());
+    //printf("bi->name=%s tbi.name=%s\n",bi->name.data(),tbi.name.data());
 
-    if (mode == DocumentedOnly) {
+    if (mode==DocumentedOnly)
+    {
       // find a documented base class in the correct scope
-      if (!findClassRelation(rootNav, context, instanceCd, &tbi, templateNames,
-                             DocumentedOnly, isArtificial)) {
+      if (!findClassRelation(rootNav,context,instanceCd,&tbi,templateNames,DocumentedOnly,isArtificial))
+      {
         // 1.8.2: decided to show inheritance relations even if not documented,
         //        we do make them artificial, so they do not appear in the index
-        // if (!Config_getBool(HIDE_UNDOC_RELATIONS))
+        //if (!Config_getBool(HIDE_UNDOC_RELATIONS))
         bool b = Config_getBool(HIDE_UNDOC_RELATIONS) ? TRUE : isArtificial;
         //{
-        // no documented base class -> try to find an undocumented one
-        findClassRelation(rootNav, context, instanceCd, &tbi, templateNames,
-                          Undocumented, b);
+          // no documented base class -> try to find an undocumented one
+          findClassRelation(rootNav,context,instanceCd,&tbi,templateNames,Undocumented,b);
         //}
       }
-    } else if (mode == TemplateInstances) {
-      findClassRelation(rootNav, context, instanceCd, &tbi, templateNames,
-                        TemplateInstances, isArtificial);
     }
-    if (delTempNames) {
+    else if (mode==TemplateInstances)
+    {
+      findClassRelation(rootNav,context,instanceCd,&tbi,templateNames,TemplateInstances,isArtificial);
+    }
+    if (delTempNames)
+    {
       delete templateNames;
-      templateNames = 0;
+      templateNames=0;
     }
   }
 }
 
 //----------------------------------------------------------------------
 
-static bool findTemplateInstanceRelation(Entry *root, Definition *context,
-                                         ClassDef *templateClass,
-                                         const QCString &templSpec,
-                                         QDict<int> *templateNames,
-                                         bool isArtificial) {
-  Debug::print(Debug::Classes, 0,
-               "    derived from template %s with parameters %s\n",
-               qPrint(templateClass->name()), qPrint(templSpec));
-  // printf("findTemplateInstanceRelation(base=%s templSpec=%s templateNames=",
+static bool findTemplateInstanceRelation(Entry *root,
+            Definition *context,
+            ClassDef *templateClass,const QCString &templSpec,
+            QDict<int> *templateNames,
+            bool isArtificial)
+{
+  Debug::print(Debug::Classes,0,"    derived from template %s with parameters %s\n",
+         qPrint(templateClass->name()),qPrint(templSpec));
+  //printf("findTemplateInstanceRelation(base=%s templSpec=%s templateNames=",
   //    templateClass->name().data(),templSpec.data());
-  // if (templateNames)
+  //if (templateNames)
   //{
   //  QDictIterator<int> qdi(*templateNames);
   //  int *tempArgIndex;
@@ -4100,82 +4427,81 @@ static bool findTemplateInstanceRelation(Entry *root, Definition *context,
   //    printf("(%s->%d) ",qdi.currentKey(),*tempArgIndex);
   //  }
   //}
-  // printf("\n");
+  //printf("\n");
 
-  bool existingClass =
-      (templSpec ==
-       tempArgListToString(templateClass->templateArguments(), root->lang));
-  if (existingClass)
-    return TRUE;
+  bool existingClass = (templSpec ==
+                        tempArgListToString(templateClass->templateArguments(),root->lang)
+                       );
+  if (existingClass) return TRUE;
 
-  bool freshInstance = FALSE;
+  bool freshInstance=FALSE;
   ClassDef *instanceClass = templateClass->insertTemplateInstance(
-      root->fileName, root->startLine, root->startColumn, templSpec,
-      freshInstance);
-  if (isArtificial)
-    instanceClass->setArtificial(TRUE);
+                     root->fileName,root->startLine,root->startColumn,templSpec,freshInstance);
+  if (isArtificial) instanceClass->setArtificial(TRUE);
   instanceClass->setLanguage(root->lang);
 
-  if (freshInstance) {
-    Debug::print(Debug::Classes, 0, "      found fresh instance '%s'!\n",
-                 qPrint(instanceClass->name()));
-    Doxygen::classSDict->append(instanceClass->name(), instanceClass);
+  if (freshInstance)
+  {
+    Debug::print(Debug::Classes,0,"      found fresh instance '%s'!\n",qPrint(instanceClass->name()));
+    Doxygen::classSDict->append(instanceClass->name(),instanceClass);
     instanceClass->setTemplateBaseClassNames(templateNames);
 
     // search for new template instances caused by base classes of
     // instanceClass
     EntryNav *templateRootNav = g_classEntries.find(templateClass->name());
-    if (templateRootNav) {
-      bool unloadNeeded = FALSE;
+    if (templateRootNav)
+    {
+      bool unloadNeeded=FALSE;
       Entry *templateRoot = templateRootNav->entry();
-      if (templateRoot == 0) // not yet loaded
+      if (templateRoot==0) // not yet loaded
       {
         templateRootNav->loadEntry(g_storage);
         templateRoot = templateRootNav->entry();
-        ASSERT(templateRoot != 0); // now it should really be loaded
-        unloadNeeded = TRUE;
+        ASSERT(templateRoot!=0); // now it should really be loaded
+        unloadNeeded=TRUE;
       }
 
-      Debug::print(Debug::Classes, 0,
-                   "        template root found %s templSpec=%s!\n",
-                   qPrint(templateRoot->name), qPrint(templSpec));
+      Debug::print(Debug::Classes,0,"        template root found %s templSpec=%s!\n",
+          qPrint(templateRoot->name),qPrint(templSpec));
       ArgumentList *templArgs = new ArgumentList;
-      stringToArgumentList(templSpec, templArgs);
-      findBaseClassesForClass(templateRootNav, context, templateClass,
-                              instanceClass, TemplateInstances, isArtificial,
-                              templArgs, templateNames);
-
-      findUsedClassesForClass(templateRootNav, context, templateClass,
-                              instanceClass, isArtificial, templArgs,
-                              templateNames);
+      stringToArgumentList(templSpec,templArgs);
+      findBaseClassesForClass(templateRootNav,context,templateClass,instanceClass,
+          TemplateInstances,isArtificial,templArgs,templateNames);
+
+      findUsedClassesForClass(templateRootNav,context,templateClass,instanceClass,
+          isArtificial,templArgs,templateNames);
       delete templArgs;
 
       if (unloadNeeded) // still cleanup to do
       {
         templateRootNav->releaseEntry();
       }
-    } else {
-      Debug::print(Debug::Classes, 0,
-                   "        no template root entry found!\n");
+    }
+    else
+    {
+      Debug::print(Debug::Classes,0,"        no template root entry found!\n");
       // TODO: what happened if we get here?
     }
 
-    // Debug::print(Debug::Classes,0,"    Template instance %s :
-    // \n",instanceClass->name().data());
-    // ArgumentList *tl = templateClass->templateArguments();
-  } else {
-    Debug::print(Debug::Classes, 0, "      instance already exists!\n");
+    //Debug::print(Debug::Classes,0,"    Template instance %s : \n",instanceClass->name().data());
+    //ArgumentList *tl = templateClass->templateArguments();
+  }
+  else
+  {
+    Debug::print(Debug::Classes,0,"      instance already exists!\n");
   }
   return TRUE;
 }
 
-static bool isRecursiveBaseClass(const QCString &scope, const QCString &name) {
-  QCString n = name;
-  int index = n.find('<');
-  if (index != -1) {
-    n = n.left(index);
+static bool isRecursiveBaseClass(const QCString &scope,const QCString &name)
+{
+  QCString n=name;
+  int index=n.find('<');
+  if (index!=-1)
+  {
+    n=n.left(index);
   }
-  bool result = rightScopeMatch(scope, n);
+  bool result = rightScopeMatch(scope,n);
   return result;
 }
 
@@ -4192,73 +4518,85 @@ static bool isRecursiveBaseClass(const QCString &scope, const QCString &name) {
  *    Class<(")<")>
  *  \endcode
  */
-static int findEndOfTemplate(const QCString &s, int startPos) {
+static int findEndOfTemplate(const QCString &s,int startPos)
+{
   // locate end of template
-  int e = startPos;
-  int brCount = 1;
-  int roundCount = 0;
+  int e=startPos;
+  int brCount=1;
+  int roundCount=0;
   int len = s.length();
-  bool insideString = FALSE;
-  bool insideChar = FALSE;
+  bool insideString=FALSE;
+  bool insideChar=FALSE;
   char pc = 0;
-  while (e < len && brCount != 0) {
-    char c = s.at(e);
-    switch (c) {
-    case '<':
-      if (!insideString && !insideChar) {
-        if (e < len - 1 && s.at(e + 1) == '<')
-          e++;
-        else if (roundCount == 0)
-          brCount++;
-      }
-      break;
-    case '>':
-      if (!insideString && !insideChar) {
-        if (e < len - 1 && s.at(e + 1) == '>')
-          e++;
-        else if (roundCount == 0)
-          brCount--;
-      }
-      break;
-    case '(':
-      if (!insideString && !insideChar)
-        roundCount++;
-      break;
-    case ')':
-      if (!insideString && !insideChar)
-        roundCount--;
-      break;
-    case '"':
-      if (!insideChar) {
-        if (insideString && pc != '\\')
-          insideString = FALSE;
-        else
-          insideString = TRUE;
-      }
-      break;
-    case '\'':
-      if (!insideString) {
-        if (insideChar && pc != '\\')
-          insideChar = FALSE;
-        else
-          insideChar = TRUE;
-      }
-      break;
+  while (e<len && brCount!=0)
+  {
+    char c=s.at(e);
+    switch(c)
+    {
+      case '<':
+        if (!insideString && !insideChar)
+        {
+          if (e<len-1 && s.at(e+1)=='<')
+            e++;
+          else if (roundCount==0)
+            brCount++;
+        }
+        break;
+      case '>':
+        if (!insideString && !insideChar)
+        {
+          if (e<len-1 && s.at(e+1)=='>')
+            e++;
+          else if (roundCount==0)
+            brCount--;
+        }
+        break;
+      case '(':
+        if (!insideString && !insideChar)
+          roundCount++;
+        break;
+      case ')':
+        if (!insideString && !insideChar)
+          roundCount--;
+        break;
+      case '"':
+        if (!insideChar)
+        {
+          if (insideString && pc!='\\')
+            insideString=FALSE;
+          else
+            insideString=TRUE;
+        }
+        break;
+      case '\'':
+        if (!insideString)
+        {
+          if (insideChar && pc!='\\')
+            insideChar=FALSE;
+          else
+            insideChar=TRUE;
+        }
+        break;
     }
     pc = c;
     e++;
   }
-  return brCount == 0 ? e : -1;
+  return brCount==0 ? e : -1;
 }
 
-static bool findClassRelation(EntryNav *rootNav, Definition *context,
-                              ClassDef *cd, BaseInfo *bi,
-                              QDict<int> *templateNames,
-                              FindBaseClassRelation_Mode mode,
-                              bool isArtificial) {
-  // printf("findClassRelation(class=%s base=%s templateNames=",
+static bool findClassRelation(
+                           EntryNav *rootNav,
+                           Definition *context,
+                           ClassDef *cd,
+                           BaseInfo *bi,
+                           QDict<int> *templateNames,
+                           FindBaseClassRelation_Mode mode,
+                           bool isArtificial
+                          )
+{
+  //printf("findClassRelation(class=%s base=%s templateNames=",
   //    cd->name().data(),bi->name.data());
-  // if (templateNames)
+  //if (templateNames)
   //{
   //  QDictIterator<int> qdi(*templateNames);
   //  int *tempArgIndex;
@@ -4267,178 +4605,184 @@ static bool findClassRelation(EntryNav *rootNav, Definition *context,
   //    printf("(%s->%d) ",qdi.currentKey(),*tempArgIndex);
   //  }
   //}
-  // printf("\n");
+  //printf("\n");
 
   Entry *root = rootNav->entry();
 
-  QCString biName = bi->name;
-  bool explicitGlobalScope = FALSE;
-  // printf("findClassRelation: biName=`%s'\n",biName.data());
-  if (biName.left(2) == "::") // explicit global scope
+  QCString biName=bi->name;
+  bool explicitGlobalScope=FALSE;
+  //printf("findClassRelation: biName=`%s'\n",biName.data());
+  if (biName.left(2)=="::") // explicit global scope
   {
-    biName = biName.right(biName.length() - 2);
-    explicitGlobalScope = TRUE;
+     biName=biName.right(biName.length()-2);
+     explicitGlobalScope=TRUE;
   }
 
-  EntryNav *parentNode = rootNav->parent();
-  bool lastParent = FALSE;
+  EntryNav *parentNode=rootNav->parent();
+  bool lastParent=FALSE;
   do // for each parent scope, starting with the largest scope
      // (in case of nested classes)
   {
-    QCString scopeName = parentNode ? parentNode->name().data() : "";
-    int scopeOffset = explicitGlobalScope ? 0 : scopeName.length();
+    QCString scopeName= parentNode ? parentNode->name().data() : "";
+    int scopeOffset=explicitGlobalScope ? 0 : scopeName.length();
     do // try all parent scope prefixes, starting with the largest scope
     {
-      // printf("scopePrefix=`%s' biName=`%s'\n",
+      //printf("scopePrefix=`%s' biName=`%s'\n",
       //    scopeName.left(scopeOffset).data(),biName.data());
 
-      QCString baseClassName = biName;
-      if (scopeOffset > 0) {
-        baseClassName.prepend(scopeName.left(scopeOffset) + "::");
+      QCString baseClassName=biName;
+      if (scopeOffset>0)
+      {
+        baseClassName.prepend(scopeName.left(scopeOffset)+"::");
       }
-      // QCString stripped;
-      // baseClassName=stripTemplateSpecifiersFromScope
+      //QCString stripped;
+      //baseClassName=stripTemplateSpecifiersFromScope
       //                    (removeRedundantWhiteSpace(baseClassName),TRUE,
       //                    &stripped);
-      MemberDef *baseClassTypeDef = 0;
+      MemberDef *baseClassTypeDef=0;
       QCString templSpec;
-      ClassDef *baseClass =
-          getResolvedClass(explicitGlobalScope ? Doxygen::globalScope : context,
-                           cd->getFileDef(), baseClassName, &baseClassTypeDef,
-                           &templSpec, mode == Undocumented, TRUE);
-      // printf("baseClassName=%s baseClass=%p cd=%p explicitGlobalScope=%d\n",
+      ClassDef *baseClass=getResolvedClass(explicitGlobalScope ? Doxygen::globalScope : context,
+                                           cd->getFileDef(),
+                                           baseClassName,
+                                           &baseClassTypeDef,
+                                           &templSpec,
+                                           mode==Undocumented,
+                                           TRUE
+                                          );
+      //printf("baseClassName=%s baseClass=%p cd=%p explicitGlobalScope=%d\n",
       //    baseClassName.data(),baseClass,cd,explicitGlobalScope);
-      // printf("    scope=`%s' baseClassName=`%s' baseClass=%s templSpec=%s\n",
+      //printf("    scope=`%s' baseClassName=`%s' baseClass=%s templSpec=%s\n",
       //                    cd ? cd->name().data():"<none>",
       //                    baseClassName.data(),
       //                    baseClass?baseClass->name().data():"<none>",
       //                    templSpec.data()
       //      );
-      // if (baseClassName.left(root->name.length())!=root->name ||
+      //if (baseClassName.left(root->name.length())!=root->name ||
       //    baseClassName.at(root->name.length())!='<'
       //   ) // Check for base class with the same name.
       //     // If found then look in the outer scope for a match
       //     // and prevent recursion.
-      if (!isRecursiveBaseClass(rootNav->name(), baseClassName) ||
-          explicitGlobalScope
+      if (!isRecursiveBaseClass(rootNav->name(),baseClassName)
+          || explicitGlobalScope
           // sadly isRecursiveBaseClass always true for UNO IDL ifc/svc members
           // (i.e. this is needed for addInterfaceOrServiceToServiceOrSingleton)
-          || (rootNav->lang() == SrcLangExt_IDL &&
-              (rootNav->section() == Entry::EXPORTED_INTERFACE_SEC ||
-               rootNav->section() == Entry::INCLUDED_SERVICE_SEC))) {
+          || (rootNav->lang()==SrcLangExt_IDL &&
+              (rootNav->section()==Entry::EXPORTED_INTERFACE_SEC ||
+               rootNav->section()==Entry::INCLUDED_SERVICE_SEC)))
+      {
         Debug::print(
-            Debug::Classes, 0, "    class relation %s inherited/used by %s "
-                               "found (%s and %s) templSpec='%s'\n",
-            qPrint(baseClassName), qPrint(rootNav->name()),
-            (bi->prot == Private)
-                ? "private"
-                : ((bi->prot == Protected) ? "protected" : "public"),
-            (bi->virt == Normal) ? "normal" : "virtual", qPrint(templSpec));
-
-        int i = baseClassName.find('<');
-        int si =
-            baseClassName.findRev("::", i == -1 ? baseClassName.length() : i);
-        if (si == -1)
-          si = 0;
-        if (baseClass == 0 && (root->lang == SrcLangExt_CSharp ||
-                               root->lang == SrcLangExt_Java)) {
+            Debug::Classes,0,"    class relation %s inherited/used by %s found (%s and %s) templSpec='%s'\n",
+            qPrint(baseClassName),
+            qPrint(rootNav->name()),
+            (bi->prot==Private)?"private":((bi->prot==Protected)?"protected":"public"),
+            (bi->virt==Normal)?"normal":"virtual",
+            qPrint(templSpec)
+           );
+
+        int i=baseClassName.find('<');
+        int si=baseClassName.findRev("::",i==-1 ? baseClassName.length() : i);
+        if (si==-1) si=0;
+        if (baseClass==0 && (root->lang==SrcLangExt_CSharp || root->lang==SrcLangExt_Java))
+        {
           // for Java/C# strip the template part before looking for matching
           baseClass = Doxygen::genericsDict->find(baseClassName.left(i));
-          // printf("looking for '%s'
-          // result=%p\n",baseClassName.data(),baseClass);
+          //printf("looking for '%s' result=%p\n",baseClassName.data(),baseClass);
         }
-        if (baseClass == 0 && i != -1)
-        // base class has template specifiers
+        if (baseClass==0 && i!=-1)
+          // base class has template specifiers
         {
-          // TODO: here we should try to find the correct template
-          // specialization
+          // TODO: here we should try to find the correct template specialization
           // but for now, we only look for the unspecializated base class.
-          int e = findEndOfTemplate(baseClassName, i + 1);
-          // printf("baseClass==0 i=%d e=%d\n",i,e);
-          if (e != -1) // end of template was found at e
+          int e=findEndOfTemplate(baseClassName,i+1);
+          //printf("baseClass==0 i=%d e=%d\n",i,e);
+          if (e!=-1) // end of template was found at e
           {
-            templSpec = removeRedundantWhiteSpace(baseClassName.mid(i, e - i));
-            baseClassName = baseClassName.left(i) +
-                            baseClassName.right(baseClassName.length() - e);
-            baseClass = getResolvedClass(
-                explicitGlobalScope ? Doxygen::globalScope : context,
-                cd->getFileDef(), baseClassName, &baseClassTypeDef,
+            templSpec=removeRedundantWhiteSpace(baseClassName.mid(i,e-i));
+            baseClassName=baseClassName.left(i)+baseClassName.right(baseClassName.length()-e);
+            baseClass=getResolvedClass(explicitGlobalScope ? Doxygen::globalScope : context,
+                cd->getFileDef(),
+                baseClassName,
+                &baseClassTypeDef,
                 0, //&templSpec,
-                mode == Undocumented, TRUE);
-            // printf("baseClass=%p -> baseClass=%s templSpec=%s\n",
+                mode==Undocumented,
+                TRUE
+                );
+            //printf("baseClass=%p -> baseClass=%s templSpec=%s\n",
             //      baseClass,baseClassName.data(),templSpec.data());
           }
-        } else if (baseClass &&
-                   !templSpec.isEmpty()) // we have a known class, but also
-                                         // know it is a template, so see if
-                                         // we can also link to the explicit
-                                         // instance (for instance if a class
-                                         // derived from a template argument)
-        {
-          // printf("baseClass=%p templSpec=%s\n",baseClass,templSpec.data());
-          ClassDef *templClass = getClass(baseClass->name() + templSpec);
-          if (templClass) {
+        }
+        else if (baseClass && !templSpec.isEmpty()) // we have a known class, but also
+                                                    // know it is a template, so see if
+                                                    // we can also link to the explicit
+                                                    // instance (for instance if a class
+                                                    // derived from a template argument)
+        {
+          //printf("baseClass=%p templSpec=%s\n",baseClass,templSpec.data());
+          ClassDef *templClass=getClass(baseClass->name()+templSpec);
+          if (templClass)
+          {
             // use the template instance instead of the template base.
             baseClass = templClass;
             templSpec.resize(0);
           }
         }
 
-        // printf("cd=%p baseClass=%p\n",cd,baseClass);
-        bool found =
-            baseClass != 0 && (baseClass != cd || mode == TemplateInstances);
-        // printf("1. found=%d\n",found);
-        if (!found && si != -1) {
+        //printf("cd=%p baseClass=%p\n",cd,baseClass);
+        bool found=baseClass!=0 && (baseClass!=cd || mode==TemplateInstances);
+        //printf("1. found=%d\n",found);
+        if (!found && si!=-1)
+        {
           QCString tmpTemplSpec;
           // replace any namespace aliases
-          replaceNamespaceAliases(baseClassName, si);
-          baseClass = getResolvedClass(
-              explicitGlobalScope ? Doxygen::globalScope : context,
-              cd->getFileDef(), baseClassName, &baseClassTypeDef, &tmpTemplSpec,
-              mode == Undocumented, TRUE);
-          found = baseClass != 0 && baseClass != cd;
-          if (found)
-            templSpec = tmpTemplSpec;
-        }
-        // printf("2. found=%d\n",found);
-
-        // printf("root->name=%s biName=%s baseClassName=%s\n",
+          replaceNamespaceAliases(baseClassName,si);
+          baseClass=getResolvedClass(explicitGlobalScope ? Doxygen::globalScope : context,
+                                     cd->getFileDef(),
+                                     baseClassName,
+                                     &baseClassTypeDef,
+                                     &tmpTemplSpec,
+                                     mode==Undocumented,
+                                     TRUE
+                                    );
+          found=baseClass!=0 && baseClass!=cd;
+          if (found) templSpec = tmpTemplSpec;
+        }
+        //printf("2. found=%d\n",found);
+
+        //printf("root->name=%s biName=%s baseClassName=%s\n",
         //        root->name.data(),biName.data(),baseClassName.data());
-        // if (cd->isCSharp() && i!=-1) // C# generic -> add internal -g postfix
+        //if (cd->isCSharp() && i!=-1) // C# generic -> add internal -g postfix
         //{
         //  baseClassName+="-g";
         //}
 
-        if (!found) {
-          baseClass = findClassWithinClassContext(context, cd, baseClassName);
-          // printf("findClassWithinClassContext(%s,%s)=%p\n",
+        if (!found)
+        {
+          baseClass=findClassWithinClassContext(context,cd,baseClassName);
+          //printf("findClassWithinClassContext(%s,%s)=%p\n",
           //    cd->name().data(),baseClassName.data(),baseClass);
-          found = baseClass != 0 && baseClass != cd;
+          found = baseClass!=0 && baseClass!=cd;
+
         }
-        if (!found) {
-          // for PHP the "use A\B as C" construct map class C to A::B, so we
-          // lookup
+        if (!found)
+        {
+          // for PHP the "use A\B as C" construct map class C to A::B, so we lookup
           // the class name also in the alias mapping.
           QCString *aliasName = Doxygen::namespaceAliasDict[baseClassName];
           if (aliasName) // see if it is indeed a class.
           {
-            baseClass = getClass(*aliasName);
-            found = baseClass != 0 && baseClass != cd;
+            baseClass=getClass(*aliasName);
+            found = baseClass!=0 && baseClass!=cd;
           }
         }
-        bool isATemplateArgument =
-            templateNames != 0 && templateNames->find(biName) != 0;
+        bool isATemplateArgument = templateNames!=0 && templateNames->find(biName)!=0;
         // make templSpec canonical
-        // warning: the following line doesn't work for Mixin classes (see bug
-        // 560623)
-        // templSpec = getCanonicalTemplateSpec(cd, cd->getFileDef(),
-        // templSpec);
-
-        // printf("3. found=%d\n",found);
-        if (found) {
-          Debug::print(Debug::Classes, 0,
-                       "    Documented base class `%s' templSpec=%s\n",
-                       qPrint(biName), qPrint(templSpec));
+        // warning: the following line doesn't work for Mixin classes (see bug 560623)
+        // templSpec = getCanonicalTemplateSpec(cd, cd->getFileDef(), templSpec);
+
+        //printf("3. found=%d\n",found);
+        if (found)
+        {
+          Debug::print(Debug::Classes,0,"    Documented base class `%s' templSpec=%s\n",qPrint(biName),qPrint(templSpec));
           // add base class to this class
 
           // if templSpec is not empty then we should "instantiate"
@@ -4450,130 +4794,144 @@ static bool findClassRelation(EntryNav *rootNav, Definition *context,
           // the instantiation process, should be done in a recursive way,
           // since instantiating a template may introduce new inheritance
           // relations.
-          if (!templSpec.isEmpty() && mode == TemplateInstances) {
+          if (!templSpec.isEmpty() && mode==TemplateInstances)
+          {
             // if baseClass is actually a typedef then we should not
             // instantiate it, since typedefs are in a different namespace
             // see bug531637 for an example where this would otherwise hang
             // doxygen
-            if (baseClassTypeDef == 0) {
-              // printf("       => findTemplateInstanceRelation:
-              // %p\n",baseClassTypeDef);
-              findTemplateInstanceRelation(root, context, baseClass, templSpec,
-                                           templateNames, isArtificial);
+            if (baseClassTypeDef==0)
+            {
+              //printf("       => findTemplateInstanceRelation: %p\n",baseClassTypeDef);
+              findTemplateInstanceRelation(root,context,baseClass,templSpec,templateNames,isArtificial);
             }
-          } else if (mode == DocumentedOnly || mode == Undocumented) {
-            // printf("       => insert base class\n");
+          }
+          else if (mode==DocumentedOnly || mode==Undocumented)
+          {
+            //printf("       => insert base class\n");
             QCString usedName;
-            if (baseClassTypeDef || cd->isCSharp()) {
-              usedName = biName;
-              // printf("***** usedName=%s
-              // templSpec=%s\n",usedName.data(),templSpec.data());
+            if (baseClassTypeDef || cd->isCSharp())
+            {
+              usedName=biName;
+              //printf("***** usedName=%s templSpec=%s\n",usedName.data(),templSpec.data());
             }
             static bool sipSupport = Config_getBool(SIP_SUPPORT);
-            if (sipSupport)
-              bi->prot = Public;
-            if (!cd->isSubClass(
-                    baseClass)) // check for recursion, see bug690787
+            if (sipSupport) bi->prot=Public;
+            if (!cd->isSubClass(baseClass)) // check for recursion, see bug690787
             {
-              cd->insertBaseClass(baseClass, usedName, bi->prot, bi->virt,
-                                  templSpec);
+              cd->insertBaseClass(baseClass,usedName,bi->prot,bi->virt,templSpec);
               // add this class as super class to the base class
-              baseClass->insertSubClass(cd, bi->prot, bi->virt, templSpec);
-            } else {
-              warn(root->fileName, root->startLine,
-                   "Detected potential recursive class relation "
-                   "between class %s and base class %s!",
-                   cd->name().data(), baseClass->name().data());
+              baseClass->insertSubClass(cd,bi->prot,bi->virt,templSpec);
+            }
+            else
+            {
+              warn(root->fileName,root->startLine,
+                  "Detected potential recursive class relation "
+                  "between class %s and base class %s!",
+                  cd->name().data(),baseClass->name().data()
+                  );
             }
           }
           return TRUE;
-        } else if (mode == Undocumented &&
-                   (scopeOffset == 0 || isATemplateArgument)) {
-          Debug::print(Debug::Classes, 0, "    New undocumented base class "
-                                          "`%s' baseClassName=%s templSpec=%s "
-                                          "isArtificial=%d\n",
-                       qPrint(biName), qPrint(baseClassName), qPrint(templSpec),
-                       isArtificial);
-          baseClass = 0;
-          if (isATemplateArgument) {
-            baseClass = Doxygen::hiddenClasses->find(baseClassName);
-            if (baseClass == 0) {
-              baseClass = new ClassDef(root->fileName, root->startLine,
-                                       root->startColumn, baseClassName,
-                                       ClassDef::Class);
-              Doxygen::hiddenClasses->append(baseClassName, baseClass);
-              if (isArtificial)
-                baseClass->setArtificial(TRUE);
+        }
+        else if (mode==Undocumented && (scopeOffset==0 || isATemplateArgument))
+        {
+          Debug::print(Debug::Classes,0,
+                       "    New undocumented base class `%s' baseClassName=%s templSpec=%s isArtificial=%d\n",
+                       qPrint(biName),qPrint(baseClassName),qPrint(templSpec),isArtificial
+                      );
+          baseClass=0;
+          if (isATemplateArgument)
+          {
+            baseClass=Doxygen::hiddenClasses->find(baseClassName);
+            if (baseClass==0)
+            {
+              baseClass=new ClassDef(root->fileName,root->startLine,root->startColumn,
+                                 baseClassName,
+                                 ClassDef::Class);
+              Doxygen::hiddenClasses->append(baseClassName,baseClass);
+              if (isArtificial) baseClass->setArtificial(TRUE);
               baseClass->setLanguage(root->lang);
             }
-          } else {
-            baseClass = Doxygen::classSDict->find(baseClassName);
-            // printf("*** classDDict->find(%s)=%p biName=%s templSpec=%s\n",
+          }
+          else
+          {
+            baseClass=Doxygen::classSDict->find(baseClassName);
+            //printf("*** classDDict->find(%s)=%p biName=%s templSpec=%s\n",
             //    baseClassName.data(),baseClass,biName.data(),templSpec.data());
-            if (baseClass == 0) {
-              baseClass = new ClassDef(root->fileName, root->startLine,
-                                       root->startColumn, baseClassName,
-                                       ClassDef::Class);
-              Doxygen::classSDict->append(baseClassName, baseClass);
-              if (isArtificial)
-                baseClass->setArtificial(TRUE);
+            if (baseClass==0)
+            {
+              baseClass=new ClassDef(root->fileName,root->startLine,root->startColumn,
+                  baseClassName,
+                  ClassDef::Class);
+              Doxygen::classSDict->append(baseClassName,baseClass);
+              if (isArtificial) baseClass->setArtificial(TRUE);
               baseClass->setLanguage(root->lang);
               int si = baseClassName.findRev("::");
-              if (si != -1) // class is nested
+              if (si!=-1) // class is nested
               {
-                Definition *sd = findScopeFromQualifiedName(
-                    Doxygen::globalScope, baseClassName.left(si), 0,
-                    rootNav->tagInfo());
-                if (sd == 0 ||
-                    sd == Doxygen::globalScope) // outer scope not found
+                Definition *sd = findScopeFromQualifiedName(Doxygen::globalScope,baseClassName.left(si),0,rootNav->tagInfo());
+                if (sd==0 || sd==Doxygen::globalScope) // outer scope not found
                 {
                   baseClass->setArtificial(TRUE); // see bug678139
                 }
               }
             }
           }
-          if (biName.right(2) == "-p") {
-            biName = "<" + biName.left(biName.length() - 2) + ">";
+          if (biName.right(2)=="-p")
+          {
+            biName="<"+biName.left(biName.length()-2)+">";
           }
           // add base class to this class
-          cd->insertBaseClass(baseClass, biName, bi->prot, bi->virt, templSpec);
+          cd->insertBaseClass(baseClass,biName,bi->prot,bi->virt,templSpec);
           // add this class as super class to the base class
-          baseClass->insertSubClass(cd, bi->prot, bi->virt, templSpec);
+          baseClass->insertSubClass(cd,bi->prot,bi->virt,templSpec);
           // the undocumented base was found in this file
           baseClass->insertUsedFile(rootNav->fileDef());
           baseClass->setOuterScope(Doxygen::globalScope);
-          if (baseClassName.right(2) == "-p") {
+          if (baseClassName.right(2)=="-p")
+          {
             baseClass->setCompoundType(ClassDef::Protocol);
           }
           return TRUE;
-        } else {
-          Debug::print(Debug::Classes, 0, "    Base class `%s' not found\n",
-                       qPrint(biName));
         }
-      } else {
-        if (mode != TemplateInstances) {
-          warn(root->fileName, root->startLine,
-               "Detected potential recursive class relation "
-               "between class %s and base class %s!\n",
-               root->name.data(), baseClassName.data());
+        else
+        {
+          Debug::print(Debug::Classes,0,"    Base class `%s' not found\n",qPrint(biName));
+        }
+      }
+      else
+      {
+        if (mode!=TemplateInstances)
+        {
+          warn(root->fileName,root->startLine,
+              "Detected potential recursive class relation "
+              "between class %s and base class %s!\n",
+              root->name.data(),baseClassName.data()
+              );
         }
         // for mode==TemplateInstance this case is quite common and
         // indicates a relation between a template class and a template
         // instance with the same name.
       }
-      if (scopeOffset == 0) {
-        scopeOffset = -1;
-      } else if ((scopeOffset = scopeName.findRev("::", scopeOffset - 1)) ==
-                 -1) {
-        scopeOffset = 0;
+      if (scopeOffset==0)
+      {
+        scopeOffset=-1;
+      }
+      else if ((scopeOffset=scopeName.findRev("::",scopeOffset-1))==-1)
+      {
+        scopeOffset=0;
       }
-      // printf("new scopeOffset=`%d'",scopeOffset);
-    } while (scopeOffset >= 0);
+      //printf("new scopeOffset=`%d'",scopeOffset);
+    } while (scopeOffset>=0);
 
-    if (parentNode == 0) {
-      lastParent = TRUE;
-    } else {
-      parentNode = parentNode->parent();
+    if (parentNode==0)
+    {
+      lastParent=TRUE;
+    }
+    else
+    {
+      parentNode=parentNode->parent();
     }
   } while (lastParent);
 
@@ -4583,47 +4941,52 @@ static bool findClassRelation(EntryNav *rootNav, Definition *context,
 //----------------------------------------------------------------------
 // Computes the base and super classes for each class in the tree
 
-static bool isClassSection(EntryNav *rootNav) {
-  if (!rootNav->name().isEmpty()) {
+static bool isClassSection(EntryNav *rootNav)
+{
+  if ( !rootNav->name().isEmpty() )
+  {
     if (rootNav->section() & Entry::COMPOUND_MASK)
-    // is it a compound (class, struct, union, interface ...)
+         // is it a compound (class, struct, union, interface ...)
     {
       return TRUE;
-    } else if (rootNav->section() & Entry::COMPOUNDDOC_MASK)
-    // is it a documentation block with inheritance info.
+    }
+    else if (rootNav->section() & Entry::COMPOUNDDOC_MASK)
+         // is it a documentation block with inheritance info.
     {
       rootNav->loadEntry(g_storage);
       Entry *root = rootNav->entry();
-      bool extends = root->extends->count() > 0;
+      bool extends = root->extends->count()>0;
       rootNav->releaseEntry();
-      if (extends)
-        return TRUE;
+      if (extends) return TRUE;
     }
   }
   return FALSE;
 }
 
+
 /*! Builds a dictionary of all entry nodes in the tree starting with \a root
  */
-static void findClassEntries(EntryNav *rootNav) {
-  if (isClassSection(rootNav)) {
-    g_classEntries.insert(rootNav->name(), rootNav);
+static void findClassEntries(EntryNav *rootNav)
+{
+  if (isClassSection(rootNav))
+  {
+    g_classEntries.insert(rootNav->name(),rootNav);
   }
-  RECURSE_ENTRYTREE(findClassEntries, rootNav);
+  RECURSE_ENTRYTREE(findClassEntries,rootNav);
 }
 
-static QCString extractClassName(EntryNav *rootNav) {
+static QCString extractClassName(EntryNav *rootNav)
+{
   // strip any anonymous scopes first
-  QCString bName = stripAnonymousNamespaceScope(rootNav->name());
-  bName = stripTemplateSpecifiersFromScope(bName);
+  QCString bName=stripAnonymousNamespaceScope(rootNav->name());
+  bName=stripTemplateSpecifiersFromScope(bName);
   int i;
-  if ((rootNav->lang() == SrcLangExt_CSharp ||
-       rootNav->lang() == SrcLangExt_Java) &&
-      (i = bName.find('<')) != -1) {
-    // a Java/C# generic class looks like a C++ specialization, so we need to
-    // strip the
+  if ((rootNav->lang()==SrcLangExt_CSharp || rootNav->lang()==SrcLangExt_Java) &&
+      (i=bName.find('<'))!=-1)
+  {
+    // a Java/C# generic class looks like a C++ specialization, so we need to strip the
     // template part before looking for matches
-    bName = bName.left(i);
+    bName=bName.left(i);
   }
   return bName;
 }
@@ -4633,146 +4996,154 @@ static QCString extractClassName(EntryNav *rootNav) {
  *  exists as inheritance relations only. These instances will be
  *  added to the template they are derived from.
  */
-static void findInheritedTemplateInstances() {
+static void findInheritedTemplateInstances()
+{
   ClassSDict::Iterator cli(*Doxygen::classSDict);
-  for (cli.toFirst(); cli.current(); ++cli)
-    cli.current()->visited = FALSE;
+  for (cli.toFirst();cli.current();++cli) cli.current()->visited=FALSE;
   QDictIterator<EntryNav> edi(g_classEntries);
   EntryNav *rootNav;
-  for (; (rootNav = edi.current()); ++edi) {
+  for (;(rootNav=edi.current());++edi)
+  {
     ClassDef *cd;
     QCString bName = extractClassName(rootNav);
-    Debug::print(Debug::Classes, 0, "  Inheritance: Class %s : \n",
-                 qPrint(bName));
-    if ((cd = getClass(bName))) {
+    Debug::print(Debug::Classes,0,"  Inheritance: Class %s : \n",qPrint(bName));
+    if ((cd=getClass(bName)))
+    {
       rootNav->loadEntry(g_storage);
-      // printf("Class %s %d\n",cd->name().data(),root->extends->count());
-      findBaseClassesForClass(rootNav, cd, cd, cd, TemplateInstances, FALSE);
+      //printf("Class %s %d\n",cd->name().data(),root->extends->count());
+      findBaseClassesForClass(rootNav,cd,cd,cd,TemplateInstances,FALSE);
       rootNav->releaseEntry();
     }
   }
 }
 
-static void findUsedTemplateInstances() {
+static void findUsedTemplateInstances()
+{
   ClassSDict::Iterator cli(*Doxygen::classSDict);
-  for (cli.toFirst(); cli.current(); ++cli)
-    cli.current()->visited = FALSE;
+  for (cli.toFirst();cli.current();++cli) cli.current()->visited=FALSE;
   QDictIterator<EntryNav> edi(g_classEntries);
   EntryNav *rootNav;
-  for (; (rootNav = edi.current()); ++edi) {
+  for (;(rootNav=edi.current());++edi)
+  {
     ClassDef *cd;
     QCString bName = extractClassName(rootNav);
-    Debug::print(Debug::Classes, 0, "  Usage: Class %s : \n", qPrint(bName));
-    if ((cd = getClass(bName))) {
+    Debug::print(Debug::Classes,0,"  Usage: Class %s : \n",qPrint(bName));
+    if ((cd=getClass(bName)))
+    {
       rootNav->loadEntry(g_storage);
-      findUsedClassesForClass(rootNav, cd, cd, cd, TRUE);
+      findUsedClassesForClass(rootNav,cd,cd,cd,TRUE);
       cd->addTypeConstraints();
       rootNav->releaseEntry();
     }
   }
 }
 
-static void computeClassRelations() {
+static void computeClassRelations()
+{
   ClassSDict::Iterator cli(*Doxygen::classSDict);
-  for (cli.toFirst(); cli.current(); ++cli)
-    cli.current()->visited = FALSE;
+  for (cli.toFirst();cli.current();++cli) cli.current()->visited=FALSE;
   QDictIterator<EntryNav> edi(g_classEntries);
   EntryNav *rootNav;
-  for (; (rootNav = edi.current()); ++edi) {
+  for (;(rootNav=edi.current());++edi)
+  {
     ClassDef *cd;
 
     rootNav->loadEntry(g_storage);
     Entry *root = rootNav->entry();
     QCString bName = extractClassName(rootNav);
-    Debug::print(Debug::Classes, 0, "  Relations: Class %s : \n",
-                 qPrint(bName));
-    if ((cd = getClass(bName))) {
-      findBaseClassesForClass(rootNav, cd, cd, cd, DocumentedOnly, FALSE);
-    }
-    int numMembers = cd && cd->memberNameInfoSDict()
-                         ? cd->memberNameInfoSDict()->count()
-                         : 0;
-    if ((cd == 0 || (!cd->hasDocumentation() && !cd->isReference())) &&
-        numMembers > 0 && bName.right(2) != "::") {
-      if (!root->name.isEmpty() && root->name.find('@') == -1 && // normal name
-          (guessSection(root->fileName) == Entry::HEADER_SEC ||
-           Config_getBool(
-               EXTRACT_LOCAL_CLASSES)) && // not defined in source file
-          protectionLevelVisible(root->protection) && // hidden by protection
-          !Config_getBool(HIDE_UNDOC_CLASSES) // undocumented class are visible
-          )
-        warn_undoc(root->fileName, root->startLine,
-                   "Compound %s is not documented.", root->name.data());
+    Debug::print(Debug::Classes,0,"  Relations: Class %s : \n",qPrint(bName));
+    if ((cd=getClass(bName)))
+    {
+      findBaseClassesForClass(rootNav,cd,cd,cd,DocumentedOnly,FALSE);
+    }
+    int numMembers = cd && cd->memberNameInfoSDict() ? cd->memberNameInfoSDict()->count() : 0;
+    if ((cd==0 || (!cd->hasDocumentation() && !cd->isReference())) && numMembers>0 &&
+        bName.right(2)!="::")
+    {
+      if (!root->name.isEmpty() && root->name.find('@')==-1 && // normal name
+          (guessSection(root->fileName)==Entry::HEADER_SEC ||
+           Config_getBool(EXTRACT_LOCAL_CLASSES)) && // not defined in source file
+           protectionLevelVisible(root->protection) && // hidden by protection
+           !Config_getBool(HIDE_UNDOC_CLASSES) // undocumented class are visible
+         )
+        warn_undoc(
+                   root->fileName,root->startLine,
+                   "Compound %s is not documented.",
+                   root->name.data()
+             );
     }
 
     rootNav->releaseEntry();
   }
 }
 
-static void computeTemplateClassRelations() {
+static void computeTemplateClassRelations()
+{
   QDictIterator<EntryNav> edi(g_classEntries);
   EntryNav *rootNav;
-  for (; (rootNav = edi.current()); ++edi) {
+  for (;(rootNav=edi.current());++edi)
+  {
     rootNav->loadEntry(g_storage);
     Entry *root = rootNav->entry();
 
-    QCString bName = stripAnonymousNamespaceScope(root->name);
-    bName = stripTemplateSpecifiersFromScope(bName);
-    ClassDef *cd = getClass(bName);
+    QCString bName=stripAnonymousNamespaceScope(root->name);
+    bName=stripTemplateSpecifiersFromScope(bName);
+    ClassDef *cd=getClass(bName);
     // strip any anonymous scopes first
     QDict<ClassDef> *templInstances = 0;
-    if (cd && (templInstances = cd->getTemplateInstances())) {
-      Debug::print(Debug::Classes, 0, "  Template class %s : \n",
-                   qPrint(cd->name()));
+    if (cd && (templInstances=cd->getTemplateInstances()))
+    {
+      Debug::print(Debug::Classes,0,"  Template class %s : \n",qPrint(cd->name()));
       QDictIterator<ClassDef> tdi(*templInstances);
       ClassDef *tcd;
-      for (tdi.toFirst(); (tcd = tdi.current());
-           ++tdi) // for each template instance
+      for (tdi.toFirst();(tcd=tdi.current());++tdi) // for each template instance
       {
-        Debug::print(Debug::Classes, 0, "    Template instance %s : \n",
-                     qPrint(tcd->name()));
+        Debug::print(Debug::Classes,0,"    Template instance %s : \n",qPrint(tcd->name()));
         QCString templSpec = tdi.currentKey();
         ArgumentList *templArgs = new ArgumentList;
-        stringToArgumentList(templSpec, templArgs);
-        QList<BaseInfo> *baseList = root->extends;
+        stringToArgumentList(templSpec,templArgs);
+        QList<BaseInfo> *baseList=root->extends;
         QListIterator<BaseInfo> it(*baseList);
         BaseInfo *bi;
-        for (; (bi = it.current()); ++it) // for each base class of the template
+        for (;(bi=it.current());++it) // for each base class of the template
         {
           // check if the base class is a template argument
-          BaseInfo tbi(bi->name, bi->prot, bi->virt);
+          BaseInfo tbi(bi->name,bi->prot,bi->virt);
           ArgumentList *tl = cd->templateArguments();
-          if (tl) {
+          if (tl)
+          {
             QDict<int> *baseClassNames = tcd->getTemplateBaseClassNames();
-            QDict<int> *templateNames =
-                getTemplateArgumentsInName(tl, bi->name);
+            QDict<int> *templateNames = getTemplateArgumentsInName(tl,bi->name);
             // for each template name that we inherit from we need to
             // substitute the formal with the actual arguments
             QDict<int> *actualTemplateNames = new QDict<int>(17);
             actualTemplateNames->setAutoDelete(TRUE);
             QDictIterator<int> qdi(*templateNames);
-            for (qdi.toFirst(); qdi.current(); ++qdi) {
+            for (qdi.toFirst();qdi.current();++qdi)
+            {
               int templIndex = *qdi.current();
               Argument *actArg = 0;
-              if (templIndex < (int)templArgs->count()) {
-                actArg = templArgs->at(templIndex);
+              if (templIndex<(int)templArgs->count())
+              {
+                actArg=templArgs->at(templIndex);
               }
-              if (actArg != 0 && baseClassNames != 0 &&
-                  baseClassNames->find(actArg->type) != 0 &&
-                  actualTemplateNames->find(actArg->type) == 0) {
-                actualTemplateNames->insert(actArg->type, new int(templIndex));
+              if (actArg!=0 &&
+                  baseClassNames!=0 &&
+                  baseClassNames->find(actArg->type)!=0 &&
+                  actualTemplateNames->find(actArg->type)==0
+                 )
+              {
+                actualTemplateNames->insert(actArg->type,new int(templIndex));
               }
             }
             delete templateNames;
 
-            tbi.name =
-                substituteTemplateArgumentsInString(bi->name, tl, templArgs);
+            tbi.name = substituteTemplateArgumentsInString(bi->name,tl,templArgs);
             // find a documented base class in the correct scope
-            if (!findClassRelation(rootNav, cd, tcd, &tbi, actualTemplateNames,
-                                   DocumentedOnly, FALSE)) {
+            if (!findClassRelation(rootNav,cd,tcd,&tbi,actualTemplateNames,DocumentedOnly,FALSE))
+            {
               // no documented base class -> try to find an undocumented one
-              findClassRelation(rootNav, cd, tcd, &tbi, actualTemplateNames,
-                                Undocumented, TRUE);
+              findClassRelation(rootNav,cd,tcd,&tbi,actualTemplateNames,Undocumented,TRUE);
             }
             delete actualTemplateNames;
           }
@@ -4788,116 +5159,141 @@ static void computeTemplateClassRelations() {
 //-----------------------------------------------------------------------
 // compute the references (anchors in HTML) for each function in the file
 
-static void computeMemberReferences() {
+static void computeMemberReferences()
+{
   ClassSDict::Iterator cli(*Doxygen::classSDict);
-  ClassDef *cd = 0;
-  for (cli.toFirst(); (cd = cli.current()); ++cli) {
+  ClassDef *cd=0;
+  for (cli.toFirst();(cd=cli.current());++cli)
+  {
     cd->computeAnchors();
   }
   FileNameListIterator fnli(*Doxygen::inputNameList);
   FileName *fn;
-  for (fnli.toFirst(); (fn = fnli.current()); ++fnli) {
+  for (fnli.toFirst();(fn=fnli.current());++fnli)
+  {
     FileNameIterator fni(*fn);
     FileDef *fd;
-    for (; (fd = fni.current()); ++fni) {
+    for (;(fd=fni.current());++fni)
+    {
       fd->computeAnchors();
     }
   }
   NamespaceSDict::Iterator nli(*Doxygen::namespaceSDict);
-  NamespaceDef *nd = 0;
-  for (nli.toFirst(); (nd = nli.current()); ++nli) {
+  NamespaceDef *nd=0;
+  for (nli.toFirst();(nd=nli.current());++nli)
+  {
     nd->computeAnchors();
   }
   GroupSDict::Iterator gli(*Doxygen::groupSDict);
   GroupDef *gd;
-  for (gli.toFirst(); (gd = gli.current()); ++gli) {
+  for (gli.toFirst();(gd=gli.current());++gli)
+  {
     gd->computeAnchors();
   }
 }
 
 //----------------------------------------------------------------------
 
-static void addListReferences() {
+static void addListReferences()
+{
   MemberNameSDict::Iterator mnli(*Doxygen::memberNameSDict);
-  MemberName *mn = 0;
-  for (mnli.toFirst(); (mn = mnli.current()); ++mnli) {
+  MemberName *mn=0;
+  for (mnli.toFirst();(mn=mnli.current());++mnli)
+  {
     MemberNameIterator mni(*mn);
-    MemberDef *md = 0;
-    for (mni.toFirst(); (md = mni.current()); ++mni) {
-      md->visited = FALSE;
+    MemberDef *md=0;
+    for (mni.toFirst();(md=mni.current());++mni)
+    {
+      md->visited=FALSE;
     }
   }
   MemberNameSDict::Iterator fmnli(*Doxygen::functionNameSDict);
-  for (fmnli.toFirst(); (mn = fmnli.current()); ++fmnli) {
+  for (fmnli.toFirst();(mn=fmnli.current());++fmnli)
+  {
     MemberNameIterator mni(*mn);
-    MemberDef *md = 0;
-    for (mni.toFirst(); (md = mni.current()); ++mni) {
-      md->visited = FALSE;
+    MemberDef *md=0;
+    for (mni.toFirst();(md=mni.current());++mni)
+    {
+      md->visited=FALSE;
     }
   }
 
   ClassSDict::Iterator cli(*Doxygen::classSDict);
-  ClassDef *cd = 0;
-  for (cli.toFirst(); (cd = cli.current()); ++cli) {
+  ClassDef *cd=0;
+  for (cli.toFirst();(cd=cli.current());++cli)
+  {
     cd->addListReferences();
   }
 
   FileNameListIterator fnli(*Doxygen::inputNameList);
   FileName *fn;
-  for (fnli.toFirst(); (fn = fnli.current()); ++fnli) {
+  for (fnli.toFirst();(fn=fnli.current());++fnli)
+  {
     FileNameIterator fni(*fn);
     FileDef *fd;
-    for (; (fd = fni.current()); ++fni) {
+    for (;(fd=fni.current());++fni)
+    {
       fd->addListReferences();
     }
   }
 
   NamespaceSDict::Iterator nli(*Doxygen::namespaceSDict);
-  NamespaceDef *nd = 0;
-  for (nli.toFirst(); (nd = nli.current()); ++nli) {
+  NamespaceDef *nd=0;
+  for (nli.toFirst();(nd=nli.current());++nli)
+  {
     nd->addListReferences();
   }
 
   GroupSDict::Iterator gli(*Doxygen::groupSDict);
   GroupDef *gd;
-  for (gli.toFirst(); (gd = gli.current()); ++gli) {
+  for (gli.toFirst();(gd=gli.current());++gli)
+  {
     gd->addListReferences();
   }
 
   PageSDict::Iterator pdi(*Doxygen::pageSDict);
-  PageDef *pd = 0;
-  for (pdi.toFirst(); (pd = pdi.current()); ++pdi) {
+  PageDef *pd=0;
+  for (pdi.toFirst();(pd=pdi.current());++pdi)
+  {
     QCString name = pd->getOutputFileBase();
-    if (pd->getGroupDef()) {
+    if (pd->getGroupDef())
+    {
       name = pd->getGroupDef()->getOutputFileBase();
     }
     {
       QList<ListItemInfo> *xrefItems = pd->xrefListItems();
-      addRefItem(xrefItems, name, theTranslator->trPage(TRUE, TRUE), name,
-                 pd->title(), 0, 0);
+      addRefItem(xrefItems,
+          name,
+          theTranslator->trPage(TRUE,TRUE),
+          name,pd->title(),0,0);
     }
   }
 
   DirSDict::Iterator ddi(*Doxygen::directories);
   DirDef *dd = 0;
-  for (ddi.toFirst(); (dd = ddi.current()); ++ddi) {
+  for (ddi.toFirst();(dd=ddi.current());++ddi)
+  {
     QCString name = dd->getOutputFileBase();
-    // if (dd->getGroupDef())
+    //if (dd->getGroupDef())
     //{
     //  name = dd->getGroupDef()->getOutputFileBase();
     //}
     QList<ListItemInfo> *xrefItems = dd->xrefListItems();
-    addRefItem(xrefItems, name, theTranslator->trDir(TRUE, TRUE), name,
-               dd->displayName(), 0, 0);
+    addRefItem(xrefItems,
+        name,
+        theTranslator->trDir(TRUE,TRUE),
+        name,dd->displayName(),0,0);
   }
 }
 
 //----------------------------------------------------------------------
 
-static void generateXRefPages() {
+static void generateXRefPages()
+{
   QDictIterator<RefList> di(*Doxygen::xrefLists);
   RefList *rl;
-  for (di.toFirst(); (rl = di.current()); ++di) {
+  for (di.toFirst();(rl=di.current());++di)
+  {
     rl->generatePage();
   }
 }
@@ -4907,88 +5303,106 @@ static void generateXRefPages() {
 // set the function declaration of the member to `funcDecl'. If the boolean
 // over_load is set the standard overload text is added.
 
-static void addMemberDocs(EntryNav *rootNav, MemberDef *md,
-                          const char *funcDecl, ArgumentList *al,
-                          bool over_load, NamespaceSDict *) {
+static void addMemberDocs(EntryNav *rootNav,
+                   MemberDef *md, const char *funcDecl,
+                   ArgumentList *al,
+                   bool over_load,
+                   NamespaceSDict *
+                  )
+{
   Entry *root = rootNav->entry();
-  // printf("addMemberDocs: `%s'::`%s' `%s' funcDecl=`%s' mSpec=%d\n",
+  //printf("addMemberDocs: `%s'::`%s' `%s' funcDecl=`%s' mSpec=%d\n",
   //     root->parent->name.data(),md->name().data(),md->argsString(),funcDecl,root->spec);
-  QCString fDecl = funcDecl;
+  QCString fDecl=funcDecl;
   // strip extern specifier
   fDecl.stripPrefix("extern ");
   md->setDefinition(fDecl);
   md->enableCallGraph(root->callGraph);
   md->enableCallerGraph(root->callerGraph);
-  ClassDef *cd = md->getClassDef();
-  NamespaceDef *nd = md->getNamespaceDef();
+  ClassDef     *cd=md->getClassDef();
+  NamespaceDef *nd=md->getNamespaceDef();
   QCString fullName;
   if (cd)
     fullName = cd->name();
   else if (nd)
     fullName = nd->name();
 
-  if (!fullName.isEmpty())
-    fullName += "::";
-  fullName += md->name();
-  FileDef *rfd = rootNav->fileDef();
+  if (!fullName.isEmpty()) fullName+="::";
+  fullName+=md->name();
+  FileDef *rfd=rootNav->fileDef();
 
   // TODO determine scope based on root not md
   Definition *rscope = md->getOuterScope();
 
   ArgumentList *mdAl = md->argumentList();
-  if (al) {
-    // printf("merging arguments (1) docs=%d\n",root->doc.isEmpty());
-    mergeArguments(mdAl, al, !root->doc.isEmpty());
-  } else {
-    if (matchArguments2(md->getOuterScope(), md->getFileDef(), mdAl, rscope,
-                        rfd, root->argList, TRUE)) {
-      // printf("merging arguments (2)\n");
-      mergeArguments(mdAl, root->argList, !root->doc.isEmpty());
-    }
-  }
-  if (over_load) // the \overload keyword was used
-  {
-    QCString doc = getOverloadDocs();
-    if (!root->doc.isEmpty()) {
-      doc += "<p>";
-      doc += root->doc;
-    }
-    md->setDocumentation(doc, root->docFile, root->docLine);
-    md->setInbodyDocumentation(root->inbodyDocs, root->inbodyFile,
-                               root->inbodyLine);
+  if (al)
+  {
+    //printf("merging arguments (1) docs=%d\n",root->doc.isEmpty());
+    mergeArguments(mdAl,al,!root->doc.isEmpty());
+  }
+  else
+  {
+    if (
+          matchArguments2( md->getOuterScope(), md->getFileDef(), mdAl,
+                           rscope,rfd,root->argList,
+                           TRUE
+                         )
+       )
+    {
+      //printf("merging arguments (2)\n");
+      mergeArguments(mdAl,root->argList,!root->doc.isEmpty());
+    }
+  }
+  if (over_load)  // the \overload keyword was used
+  {
+    QCString doc=getOverloadDocs();
+    if (!root->doc.isEmpty())
+    {
+      doc+="<p>";
+      doc+=root->doc;
+    }
+    md->setDocumentation(doc,root->docFile,root->docLine);
+    md->setInbodyDocumentation(root->inbodyDocs,root->inbodyFile,root->inbodyLine);
     md->setDocsForDefinition(!root->proto);
-  } else {
-    // printf("overwrite!\n");
-    md->setDocumentation(root->doc, root->docFile, root->docLine);
+  }
+  else
+  {
+    //printf("overwrite!\n");
+    md->setDocumentation(root->doc,root->docFile,root->docLine);
     md->setDocsForDefinition(!root->proto);
 
-    // printf("overwrite!\n");
-    md->setBriefDescription(root->brief, root->briefFile, root->briefLine);
+    //printf("overwrite!\n");
+    md->setBriefDescription(root->brief,root->briefFile,root->briefLine);
 
-    if ((md->inbodyDocumentation().isEmpty() ||
-         !rootNav->parent()->name().isEmpty()) &&
-        !root->inbodyDocs.isEmpty()) {
-      md->setInbodyDocumentation(root->inbodyDocs, root->inbodyFile,
-                                 root->inbodyLine);
+    if (
+        (md->inbodyDocumentation().isEmpty() ||
+         !rootNav->parent()->name().isEmpty()
+        ) && !root->inbodyDocs.isEmpty()
+       )
+    {
+      md->setInbodyDocumentation(root->inbodyDocs,root->inbodyFile,root->inbodyLine);
     }
   }
 
-  // printf("initializer: '%s'(isEmpty=%d) '%s'(isEmpty=%d)\n",
+  //printf("initializer: '%s'(isEmpty=%d) '%s'(isEmpty=%d)\n",
   //    md->initializer().data(),md->initializer().isEmpty(),
   //    root->initializer.data(),root->initializer.isEmpty()
   //   );
-  if (md->initializer().isEmpty() && !root->initializer.isEmpty()) {
-    // printf("setInitializer\n");
+  if (md->initializer().isEmpty() && !root->initializer.isEmpty())
+  {
+    //printf("setInitializer\n");
     md->setInitializer(root->initializer);
   }
 
   md->setMaxInitLines(root->initLines);
 
-  if (rfd) {
-    if ((md->getStartBodyLine() == -1 && root->bodyLine != -1)) {
-      // printf("Setting new body segment
-      // [%d,%d]\n",root->bodyLine,root->endBodyLine);
-      md->setBodySegment(root->bodyLine, root->endBodyLine);
+  if (rfd)
+  {
+    if ((md->getStartBodyLine()==-1 && root->bodyLine!=-1)
+       )
+    {
+      //printf("Setting new body segment [%d,%d]\n",root->bodyLine,root->endBodyLine);
+      md->setBodySegment(root->bodyLine,root->endBodyLine);
       md->setBodyDef(rfd);
     }
 
@@ -5000,21 +5414,26 @@ static void addMemberDocs(EntryNav *rootNav, MemberDef *md,
 
   md->mergeMemberSpecifiers(root->spec);
   md->addSectionsToDefinition(root->anchors);
-  addMemberToGroups(root, md);
-  if (cd)
-    cd->insertUsedFile(rfd);
-  // printf("root->mGrpId=%d\n",root->mGrpId);
-  if (root->mGrpId != -1) {
-    if (md->getMemberGroupId() != -1) {
-      if (md->getMemberGroupId() != root->mGrpId) {
-        warn(root->fileName, root->startLine,
+  addMemberToGroups(root,md);
+  if (cd) cd->insertUsedFile(rfd);
+  //printf("root->mGrpId=%d\n",root->mGrpId);
+  if (root->mGrpId!=-1)
+  {
+    if (md->getMemberGroupId()!=-1)
+    {
+      if (md->getMemberGroupId()!=root->mGrpId)
+      {
+        warn(
+             root->fileName,root->startLine,
              "member %s belongs to two different groups. The second "
              "one found here will be ignored.",
-             md->name().data());
+             md->name().data()
+            );
       }
-    } else // set group id
+    }
+    else // set group id
     {
-      // printf("setMemberGroupId=%d md=%s\n",root->mGrpId,md->name().data());
+      //printf("setMemberGroupId=%d md=%s\n",root->mGrpId,md->name().data());
       md->setMemberGroupId(root->mGrpId);
     }
   }
@@ -5024,93 +5443,98 @@ static void addMemberDocs(EntryNav *rootNav, MemberDef *md,
 // find a class definition given the scope name and (optionally) a
 // template list specifier
 
-static ClassDef *findClassDefinition(FileDef *fd, NamespaceDef *nd,
-                                     const char *scopeName) {
-  ClassDef *tcd = getResolvedClass(nd, fd, scopeName, 0, 0, TRUE, TRUE);
+static ClassDef *findClassDefinition(FileDef *fd,NamespaceDef *nd,
+                         const char *scopeName)
+{
+  ClassDef *tcd = getResolvedClass(nd,fd,scopeName,0,0,TRUE,TRUE);
   return tcd;
 }
 
+
 //----------------------------------------------------------------------
 // Adds the documentation contained in `root' to a global function
 // with name `name' and argument list `args' (for overloading) and
 // function declaration `decl' to the corresponding member definition.
 
-static bool findGlobalMember(EntryNav *rootNav, const QCString &namespaceName,
-                             const char *type, const char *name,
-                             const char *tempArg, const char *,
-                             const char *decl) {
+static bool findGlobalMember(EntryNav *rootNav,
+                           const QCString &namespaceName,
+                           const char *type,
+                           const char *name,
+                           const char *tempArg,
+                           const char *,
+                           const char *decl)
+{
   Entry *root = rootNav->entry();
-  Debug::print(
-      Debug::FindMembers, 0,
-      "2. findGlobalMember(namespace=%s,type=%s,name=%s,tempArg=%s,decl=%s)\n",
-      qPrint(namespaceName), qPrint(type), qPrint(name), qPrint(tempArg),
-      qPrint(decl));
-  QCString n = name;
-  if (n.isEmpty())
-    return FALSE;
-  if (n.find("::") != -1)
-    return FALSE; // skip undefined class members
-  MemberName *mn = Doxygen::functionNameSDict->find(
-      n + tempArg); // look in function dictionary
-  if (mn == 0) {
-    mn = Doxygen::functionNameSDict->find(n); // try without template arguments
+  Debug::print(Debug::FindMembers,0,
+       "2. findGlobalMember(namespace=%s,type=%s,name=%s,tempArg=%s,decl=%s)\n",
+          qPrint(namespaceName),qPrint(type),qPrint(name),qPrint(tempArg),qPrint(decl));
+  QCString n=name;
+  if (n.isEmpty()) return FALSE;
+  if (n.find("::")!=-1) return FALSE; // skip undefined class members
+  MemberName *mn=Doxygen::functionNameSDict->find(n+tempArg); // look in function dictionary
+  if (mn==0)
+  {
+    mn=Doxygen::functionNameSDict->find(n); // try without template arguments
   }
   if (mn) // function name defined
   {
-    Debug::print(Debug::FindMembers, 0, "3. Found symbol scope\n");
-    // int count=0;
+    Debug::print(Debug::FindMembers,0,"3. Found symbol scope\n");
+    //int count=0;
     MemberNameIterator mni(*mn);
     MemberDef *md;
-    bool found = FALSE;
-    for (mni.toFirst(); (md = mni.current()) && !found; ++mni) {
-      NamespaceDef *nd = md->getNamespaceDef();
+    bool found=FALSE;
+    for (mni.toFirst();(md=mni.current()) && !found;++mni)
+    {
+      NamespaceDef *nd=md->getNamespaceDef();
 
-      // printf("Namespace namespaceName=%s nd=%s\n",
+      //printf("Namespace namespaceName=%s nd=%s\n",
       //    namespaceName.data(),nd ? nd->name().data() : "<none>");
 
-      FileDef *fd = rootNav->fileDef();
-      // printf("File %s\n",fd ? fd->name().data() : "<none>");
+      FileDef *fd=rootNav->fileDef();
+      //printf("File %s\n",fd ? fd->name().data() : "<none>");
       NamespaceSDict *nl = fd ? fd->getUsedNamespaces() : 0;
-      // SDict<Definition> *cl = fd ? fd->getUsedClasses()    : 0;
-      // printf("NamespaceList %p\n",nl);
+      //SDict<Definition> *cl = fd ? fd->getUsedClasses()    : 0;
+      //printf("NamespaceList %p\n",nl);
 
       // search in the list of namespaces that are imported via a
       // using declaration
-      bool viaUsingDirective = nl && nd && nl->find(nd->qualifiedName()) != 0;
+      bool viaUsingDirective = nl && nd && nl->find(nd->qualifiedName())!=0;
 
-      if ((namespaceName.isEmpty() && nd == 0) || // not in a namespace
-          (nd && nd->name() == namespaceName) ||  // or in the same namespace
-          viaUsingDirective                       // member in `using' namespace
-          ) {
-        Debug::print(Debug::FindMembers, 0,
-                     "4. Try to add member `%s' to scope `%s'\n",
-                     qPrint(md->name()), qPrint(namespaceName));
+      if ((namespaceName.isEmpty() && nd==0) ||  // not in a namespace
+          (nd && nd->name()==namespaceName) ||   // or in the same namespace
+          viaUsingDirective                      // member in `using' namespace
+         )
+      {
+        Debug::print(Debug::FindMembers,0,"4. Try to add member `%s' to scope `%s'\n",
+            qPrint(md->name()),qPrint(namespaceName));
 
         NamespaceDef *rnd = 0;
-        if (!namespaceName.isEmpty())
-          rnd = Doxygen::namespaceSDict->find(namespaceName);
+        if (!namespaceName.isEmpty()) rnd = Doxygen::namespaceSDict->find(namespaceName);
 
         ArgumentList *mdAl = md->argumentList();
-        bool matching = (mdAl == 0 && root->argList->count() == 0) ||
-                        md->isVariable() ||
-                        md->isTypedef() || /* in case of function pointers */
-                        matchArguments2(md->getOuterScope(), md->getFileDef(),
-                                        mdAl, rnd ? rnd : Doxygen::globalScope,
-                                        fd, root->argList, FALSE);
+        bool matching=
+          (mdAl==0 && root->argList->count()==0) ||
+          md->isVariable() || md->isTypedef() || /* in case of function pointers */
+          matchArguments2(md->getOuterScope(),md->getFileDef(),mdAl,
+                          rnd ? rnd : Doxygen::globalScope,fd,root->argList,
+                          FALSE);
 
         // for template members we need to check if the number of
         // template arguments is the same, otherwise we are dealing with
         // different functions.
-        if (matching && root->tArgLists) {
+        if (matching && root->tArgLists)
+        {
           ArgumentList *mdTempl = md->templateArguments();
-          if (mdTempl) {
-            if (root->tArgLists->getLast()->count() != mdTempl->count()) {
-              matching = FALSE;
+          if (mdTempl)
+          {
+            if (root->tArgLists->getLast()->count()!=mdTempl->count())
+            {
+              matching=FALSE;
             }
           }
         }
 
-        // printf("%s<->%s\n",
+        //printf("%s<->%s\n",
         //    argListToString(md->argumentList()).data(),
         //    argListToString(root->argList).data());
 
@@ -5119,80 +5543,92 @@ static bool findGlobalMember(EntryNav *rootNav, const QCString &namespaceName,
         // name can be in different files. Thus it would be wrong to just
         // put the comment block at the first syntactically matching member.
         if (matching && md->isStatic() &&
-            md->getDefFileName() != root->fileName && mn->count() > 1) {
+            md->getDefFileName()!=root->fileName &&
+            mn->count()>1)
+        {
           matching = FALSE;
         }
 
         // for template member we also need to check the return type
-        if (md->templateArguments() != 0 && root->tArgLists != 0) {
-          // printf("Comparing return types '%s'<->'%s'\n",
+        if (md->templateArguments()!=0 && root->tArgLists!=0)
+        {
+          //printf("Comparing return types '%s'<->'%s'\n",
           //    md->typeString(),type);
-          if (md->templateArguments()->count() !=
-                  root->tArgLists->getLast()->count() ||
-              qstrcmp(md->typeString(), type) != 0) {
-            // printf(" ---> no matching\n");
+          if (md->templateArguments()->count()!=root->tArgLists->getLast()->count() ||
+              qstrcmp(md->typeString(),type)!=0)
+          {
+            //printf(" ---> no matching\n");
             matching = FALSE;
           }
         }
 
         if (matching) // add docs to the member
         {
-          Debug::print(Debug::FindMembers, 0, "5. Match found\n");
-          addMemberDocs(rootNav, md, decl, root->argList, FALSE);
-          found = TRUE;
+          Debug::print(Debug::FindMembers,0,"5. Match found\n");
+          addMemberDocs(rootNav,md,decl,root->argList,FALSE);
+          found=TRUE;
         }
       }
     }
-    if (!found && root->relatesType != Duplicate &&
-        root->section == Entry::FUNCTION_SEC) // no match
+    if (!found && root->relatesType != Duplicate && root->section==Entry::FUNCTION_SEC) // no match
     {
-      QCString fullFuncDecl = decl;
-      if (root->argList)
-        fullFuncDecl += argListToString(root->argList, TRUE);
-      QCString warnMsg = QCString("no matching file member found for \n") +
-                         substitute(fullFuncDecl, "%", "%%");
-      if (mn->count() > 0) {
-        warnMsg += "\nPossible candidates:\n";
-        for (mni.toFirst(); (md = mni.current()); ++mni) {
-          warnMsg += " '";
-          warnMsg += substitute(md->declaration(), "%", "%%");
-          warnMsg += "' at line " + QCString().setNum(md->getDefLine()) +
-                     " of file" + md->getDefFileName() + "\n";
+      QCString fullFuncDecl=decl;
+      if (root->argList) fullFuncDecl+=argListToString(root->argList,TRUE);
+      QCString warnMsg =
+         QCString("no matching file member found for \n")+substitute(fullFuncDecl,"%","%%");
+      if (mn->count()>0)
+      {
+        warnMsg+="\nPossible candidates:\n";
+        for (mni.toFirst();(md=mni.current());++mni)
+        {
+          warnMsg+=" '";
+          warnMsg+=substitute(md->declaration(),"%","%%");
+          warnMsg+="' at line "+QCString().setNum(md->getDefLine())+
+                   " of file"+md->getDefFileName()+"\n";
         }
       }
-      warn(root->fileName, root->startLine, warnMsg);
+      warn(root->fileName,root->startLine,warnMsg);
     }
-  } else // got docs for an undefined member!
+  }
+  else // got docs for an undefined member!
   {
-    if (root->type != "friend class" && root->type != "friend struct" &&
-        root->type != "friend union" &&
+    if (root->type!="friend class" &&
+        root->type!="friend struct" &&
+        root->type!="friend union" &&
         (!Config_getBool(TYPEDEF_HIDES_STRUCT) ||
-         root->type.find("typedef ") == -1)) {
-      warn(root->fileName, root->startLine,
-           "documented symbol `%s' was not declared or defined.", decl);
+         root->type.find("typedef ")==-1)
+       )
+    {
+      warn(root->fileName,root->startLine,
+           "documented symbol `%s' was not declared or defined.",decl
+          );
     }
   }
   return TRUE;
 }
 
-static bool isSpecialization(const QList<ArgumentList> &srcTempArgLists,
-                             const QList<ArgumentList> &dstTempArgLists) {
-  QListIterator<ArgumentList> srclali(srcTempArgLists);
-  QListIterator<ArgumentList> dstlali(dstTempArgLists);
-  for (; srclali.current(); ++srclali, ++dstlali) {
-    ArgumentList *sal = srclali.current();
-    ArgumentList *dal = dstlali.current();
-    if (!(sal && dal && sal->count() == dal->count()))
-      return TRUE;
-  }
-  return FALSE;
+static bool isSpecialization(
+                  const QList<ArgumentList> &srcTempArgLists,
+                  const QList<ArgumentList> &dstTempArgLists
+    )
+{
+    QListIterator<ArgumentList> srclali(srcTempArgLists);
+    QListIterator<ArgumentList> dstlali(dstTempArgLists);
+    for (;srclali.current();++srclali,++dstlali)
+    {
+      ArgumentList *sal = srclali.current();
+      ArgumentList *dal = dstlali.current();
+      if (!(sal && dal && sal->count()==dal->count())) return TRUE;
+    }
+    return FALSE;
 }
 
-static bool scopeIsTemplate(Definition *d) {
-  bool result = FALSE;
-  if (d && d->definitionType() == Definition::TypeClass) {
-    result = ((ClassDef *)d)->templateArguments() ||
-             scopeIsTemplate(d->getOuterScope());
+static bool scopeIsTemplate(Definition *d)
+{
+  bool result=FALSE;
+  if (d && d->definitionType()==Definition::TypeClass)
+  {
+    result = ((ClassDef*)d)->templateArguments() || scopeIsTemplate(d->getOuterScope());
   }
   return result;
 }
@@ -5200,120 +5636,135 @@ static bool scopeIsTemplate(Definition *d) {
 static QCString substituteTemplatesInString(
     const QList<ArgumentList> &srcTempArgLists,
     const QList<ArgumentList> &dstTempArgLists,
-    ArgumentList
-        *funcTempArgList, // can be used to match template specializations
-    const QCString &src) {
+    ArgumentList *funcTempArgList, // can be used to match template specializations
+    const QCString &src
+    )
+{
   QCString dst;
-  QRegExp re("[A-Za-z_][A-Za-z_0-9]*");
-  // printf("type=%s\n",sa->type.data());
-  int i, p = 0, l;
-  while ((i = re.match(src, p, &l)) != -1) // for each word in srcType
+  QRegExp re( "[A-Za-z_][A-Za-z_0-9]*");
+  //printf("type=%s\n",sa->type.data());
+  int i,p=0,l;
+  while ((i=re.match(src,p,&l))!=-1) // for each word in srcType
   {
-    bool found = FALSE;
-    dst += src.mid(p, i - p);
-    QCString name = src.mid(i, l);
+    bool found=FALSE;
+    dst+=src.mid(p,i-p);
+    QCString name=src.mid(i,l);
 
     QListIterator<ArgumentList> srclali(srcTempArgLists);
     QListIterator<ArgumentList> dstlali(dstTempArgLists);
-    for (; srclali.current() && !found; ++srclali, ++dstlali) {
+    for (;srclali.current() && !found;++srclali,++dstlali)
+    {
       ArgumentListIterator tsali(*srclali.current());
       ArgumentListIterator tdali(*dstlali.current());
-      ArgumentListIterator *fali = 0;
-      Argument *tsa = 0, *tda = 0, *fa = 0;
-      if (funcTempArgList) {
+      ArgumentListIterator *fali=0;
+      Argument *tsa =0,*tda=0, *fa=0;
+      if (funcTempArgList)
+      {
         fali = new ArgumentListIterator(*funcTempArgList);
         fa = fali->current();
       }
 
-      for (tsali.toFirst(); (tsa = tsali.current()) && !found; ++tsali) {
+      for (tsali.toFirst();(tsa=tsali.current()) && !found;++tsali)
+      {
         tda = tdali.current();
-        // if (tda) printf("tsa=%s|%s tda=%s|%s\n",
+        //if (tda) printf("tsa=%s|%s tda=%s|%s\n",
         //    tsa->type.data(),tsa->name.data(),
         //    tda->type.data(),tda->name.data());
-        if (name == tsa->name) {
-          if (tda && tda->name.isEmpty()) {
-            int vc = 0;
-            if (tda->type.left(6) == "class ")
-              vc = 6;
-            else if (tda->type.left(9) == "typename ")
-              vc = 9;
-            if (vc > 0) // convert type=="class T" to type=="class" name=="T"
+        if (name==tsa->name)
+        {
+          if (tda && tda->name.isEmpty())
+          {
+            int vc=0;
+            if (tda->type.left(6)=="class ") vc=6;
+            else if (tda->type.left(9)=="typename ") vc=9;
+            if (vc>0) // convert type=="class T" to type=="class" name=="T"
             {
               tda->name = tda->type.mid(vc);
-              tda->type = tda->type.left(vc - 1);
+              tda->type = tda->type.left(vc-1);
             }
           }
-          if (tda && !tda->name.isEmpty()) {
-            name = tda->name; // substitute
-            found = TRUE;
-          } else if (fa) {
-            name = fa->type;
-            found = TRUE;
+          if (tda && !tda->name.isEmpty())
+          {
+            name=tda->name; // substitute
+            found=TRUE;
+          }
+          else if (fa)
+          {
+            name=fa->type;
+            found=TRUE;
           }
         }
         if (tda)
           ++tdali;
-        else if (fali) {
-          ++(*fali);
-          fa = fali->current();
-        }
+        else if (fali)
+        { ++(*fali); fa=fali->current(); }
       }
 
       delete fali;
-      // printf("   srcList='%s' dstList='%s faList='%s'\n",
+      //printf("   srcList='%s' dstList='%s faList='%s'\n",
       //  argListToString(srclali.current()).data(),
       //  argListToString(dstlali.current()).data(),
       //  funcTempArgList ? argListToString(funcTempArgList).data() : "<none>");
     }
-    dst += name;
-    p = i + l;
+    dst+=name;
+    p=i+l;
   }
-  dst += src.right(src.length() - p);
-  // printf("  substituteTemplatesInString(%s)=%s\n",
+  dst+=src.right(src.length()-p);
+  //printf("  substituteTemplatesInString(%s)=%s\n",
   //    src.data(),dst.data());
   return dst;
 }
 
-static void
-substituteTemplatesInArgList(const QList<ArgumentList> &srcTempArgLists,
-                             const QList<ArgumentList> &dstTempArgLists,
-                             ArgumentList *src, ArgumentList *dst,
-                             ArgumentList *funcTempArgs = 0) {
+static void substituteTemplatesInArgList(
+                  const QList<ArgumentList> &srcTempArgLists,
+                  const QList<ArgumentList> &dstTempArgLists,
+                  ArgumentList *src,
+                  ArgumentList *dst,
+                  ArgumentList *funcTempArgs = 0
+                 )
+{
   ArgumentListIterator sali(*src);
   ArgumentListIterator dali(*dst);
-  Argument *sa = 0;
-  Argument *da = dali.current();
+  Argument *sa=0;
+  Argument *da=dali.current();
 
-  for (sali.toFirst(); (sa = sali.current());
-       ++sali) // for each member argument
+  for (sali.toFirst();(sa=sali.current());++sali) // for each member argument
   {
     QCString dstType = substituteTemplatesInString(
-        srcTempArgLists, dstTempArgLists, funcTempArgs, sa->type);
+                                  srcTempArgLists,dstTempArgLists,funcTempArgs,
+                                  sa->type);
     QCString dstArray = substituteTemplatesInString(
-        srcTempArgLists, dstTempArgLists, funcTempArgs, sa->array);
-    if (da == 0) {
-      da = new Argument(*sa);
+                                  srcTempArgLists,dstTempArgLists,funcTempArgs,
+                                  sa->array);
+    if (da==0)
+    {
+      da=new Argument(*sa);
       dst->append(da);
-      da->type = dstType;
-      da->array = dstArray;
-      da = 0;
-    } else {
-      da->type = dstType;
-      da->type = dstArray;
+      da->type=dstType;
+      da->array=dstArray;
+      da=0;
+    }
+    else
+    {
+      da->type=dstType;
+      da->type=dstArray;
       ++dali;
-      da = dali.current();
+      da=dali.current();
     }
   }
-  dst->constSpecifier = src->constSpecifier;
-  dst->volatileSpecifier = src->volatileSpecifier;
-  dst->pureSpecifier = src->pureSpecifier;
+  dst->constSpecifier     = src->constSpecifier;
+  dst->volatileSpecifier  = src->volatileSpecifier;
+  dst->pureSpecifier      = src->pureSpecifier;
   dst->trailingReturnType = substituteTemplatesInString(
-      srcTempArgLists, dstTempArgLists, funcTempArgs, src->trailingReturnType);
-  // printf("substituteTemplatesInArgList: replacing %s with %s\n",
+                             srcTempArgLists,dstTempArgLists,
+                             funcTempArgs,src->trailingReturnType);
+  //printf("substituteTemplatesInArgList: replacing %s with %s\n",
   //    argListToString(src).data(),argListToString(dst).data()
   //    );
 }
 
+
+
 /*! This function tries to find a member (in a documented class/file/namespace)
  * that corresponds to the function/variable declaration given in \a funcDecl.
  *
@@ -5323,18 +5774,22 @@ substituteTemplatesInArgList(const QList<ArgumentList> &srcTempArgLists,
  * The boolean \a isFunc is a hint that indicates that this is a function
  * instead of a variable or typedef.
  */
-static void findMember(EntryNav *rootNav, QCString funcDecl, bool overloaded,
-                       bool isFunc) {
+static void findMember(EntryNav *rootNav,
+                       QCString funcDecl,
+                       bool overloaded,
+                       bool isFunc
+                      )
+{
   Entry *root = rootNav->entry();
 
-  Debug::print(Debug::FindMembers, 0,
+  Debug::print(Debug::FindMembers,0,
                "findMember(root=%p,funcDecl=`%s',related=`%s',overload=%d,"
                "isFunc=%d mGrpId=%d tArgList=%p (#=%d) "
                "spec=%lld lang=%x\n",
-               root, qPrint(funcDecl), qPrint(root->relates), overloaded,
-               isFunc, root->mGrpId, root->tArgLists,
-               root->tArgLists ? root->tArgLists->count() : 0, root->spec,
-               root->lang);
+               root,qPrint(funcDecl),qPrint(root->relates),overloaded,isFunc,root->mGrpId,
+               root->tArgLists,root->tArgLists ? root->tArgLists->count() : 0,
+               root->spec,root->lang
+              );
 
   QCString scopeName;
   QCString className;
@@ -5345,589 +5800,639 @@ static void findMember(EntryNav *rootNav, QCString funcDecl, bool overloaded,
   QCString funcTempList;
   QCString exceptions;
   QCString funcSpec;
-  bool isRelated = FALSE;
-  bool isMemberOf = FALSE;
-  bool isFriend = FALSE;
+  bool isRelated=FALSE;
+  bool isMemberOf=FALSE;
+  bool isFriend=FALSE;
   bool done;
-  do {
-    done = TRUE;
+  do
+  {
+    done=TRUE;
     if (funcDecl.stripPrefix("friend ")) // treat friends as related members
     {
-      isFriend = TRUE;
-      done = FALSE;
+      isFriend=TRUE;
+      done=FALSE;
     }
-    if (funcDecl.stripPrefix("inline ")) {
-      root->spec |= Entry::Inline;
-      done = FALSE;
+    if (funcDecl.stripPrefix("inline "))
+    {
+      root->spec|=Entry::Inline;
+      done=FALSE;
     }
-    if (funcDecl.stripPrefix("explicit ")) {
-      root->spec |= Entry::Explicit;
-      done = FALSE;
+    if (funcDecl.stripPrefix("explicit "))
+    {
+      root->spec|=Entry::Explicit;
+      done=FALSE;
     }
-    if (funcDecl.stripPrefix("mutable ")) {
-      root->spec |= Entry::Mutable;
-      done = FALSE;
+    if (funcDecl.stripPrefix("mutable "))
+    {
+      root->spec|=Entry::Mutable;
+      done=FALSE;
     }
-    if (funcDecl.stripPrefix("virtual ")) {
-      done = FALSE;
+    if (funcDecl.stripPrefix("virtual "))
+    {
+      done=FALSE;
     }
   } while (!done);
 
   // delete any ; from the function declaration
   int sep;
-  while ((sep = funcDecl.find(';')) != -1) {
-    funcDecl =
-        (funcDecl.left(sep) + funcDecl.right(funcDecl.length() - sep - 1))
-            .stripWhiteSpace();
+  while ((sep=funcDecl.find(';'))!=-1)
+  {
+    funcDecl=(funcDecl.left(sep)+funcDecl.right(funcDecl.length()-sep-1)).stripWhiteSpace();
   }
 
   // make sure the first character is a space to simplify searching.
-  if (!funcDecl.isEmpty() && funcDecl[0] != ' ')
-    funcDecl.prepend(" ");
+  if (!funcDecl.isEmpty() && funcDecl[0]!=' ') funcDecl.prepend(" ");
 
   // remove some superfluous spaces
-  funcDecl =
-      substitute(substitute(substitute(funcDecl, "~ ", "~"), ":: ", "::"),
-                 " ::", "::")
-          .stripWhiteSpace();
-
-  // printf("funcDecl=`%s'\n",funcDecl.data());
-  if (isFriend && funcDecl.left(6) == "class ") {
-    // printf("friend class\n");
-    funcDecl = funcDecl.right(funcDecl.length() - 6);
+  funcDecl= substitute(
+              substitute(
+                substitute(funcDecl,"~ ","~"),
+                ":: ","::"
+              ),
+              " ::","::"
+            ).stripWhiteSpace();
+
+  //printf("funcDecl=`%s'\n",funcDecl.data());
+  if (isFriend && funcDecl.left(6)=="class ")
+  {
+    //printf("friend class\n");
+    funcDecl=funcDecl.right(funcDecl.length()-6);
     funcName = funcDecl.copy();
-  } else if (isFriend && funcDecl.left(7) == "struct ") {
-    funcDecl = funcDecl.right(funcDecl.length() - 7);
+  }
+  else if (isFriend && funcDecl.left(7)=="struct ")
+  {
+    funcDecl=funcDecl.right(funcDecl.length()-7);
     funcName = funcDecl.copy();
-  } else {
+  }
+  else
+  {
     // extract information from the declarations
-    parseFuncDecl(funcDecl, root->lang == SrcLangExt_ObjC, scopeName, funcType,
-                  funcName, funcArgs, funcTempList, exceptions);
+    parseFuncDecl(funcDecl,root->lang==SrcLangExt_ObjC,scopeName,funcType,funcName,
+                funcArgs,funcTempList,exceptions
+               );
   }
-  // printf("scopeName=`%s' funcType=`%s' funcName=`%s' funcArgs=`%s'\n",
+  //printf("scopeName=`%s' funcType=`%s' funcName=`%s' funcArgs=`%s'\n",
   //    scopeName.data(),funcType.data(),funcName.data(),funcArgs.data());
 
   // the class name can also be a namespace name, we decide this later.
   // if a related class name is specified and the class name could
   // not be derived from the function declaration, then use the
   // related field.
-  // printf("scopeName=`%s' className=`%s' namespaceName=`%s'\n",
+  //printf("scopeName=`%s' className=`%s' namespaceName=`%s'\n",
   //    scopeName.data(),className.data(),namespaceName.data());
-  if (!root->relates.isEmpty()) { // related member, prefix user specified scope
-    isRelated = TRUE;
-    isMemberOf = (root->relatesType == MemberOf);
-    if (getClass(root->relates) == 0 && !scopeName.isEmpty()) {
-      scopeName = mergeScopes(scopeName, root->relates);
-    } else {
+  if (!root->relates.isEmpty())
+  {                             // related member, prefix user specified scope
+    isRelated=TRUE;
+    isMemberOf=(root->relatesType == MemberOf);
+    if (getClass(root->relates)==0 && !scopeName.isEmpty())
+    {
+      scopeName= mergeScopes(scopeName,root->relates);
+    }
+    else
+    {
       scopeName = root->relates;
     }
   }
 
   if (root->relates.isEmpty() && rootNav->parent() &&
-      ((rootNav->parent()->section() & Entry::SCOPE_MASK) ||
-       (rootNav->parent()->section() == Entry::OBJCIMPL_SEC)) &&
+      ((rootNav->parent()->section()&Entry::SCOPE_MASK) ||
+       (rootNav->parent()->section()==Entry::OBJCIMPL_SEC)
+      ) &&
       !rootNav->parent()->name().isEmpty()) // see if we can combine scopeName
-  // with the scope in which it was found
+                                     // with the scope in which it was found
   {
-    QCString joinedName = rootNav->parent()->name() + "::" + scopeName;
+    QCString joinedName = rootNav->parent()->name()+"::"+scopeName;
     if (!scopeName.isEmpty() &&
-        (getClass(joinedName) || Doxygen::namespaceSDict->find(joinedName))) {
+        (getClass(joinedName) || Doxygen::namespaceSDict->find(joinedName)))
+    {
       scopeName = joinedName;
-    } else {
-      scopeName = mergeScopes(rootNav->parent()->name(), scopeName);
-    }
-  } else // see if we can prefix a namespace or class that is used from the file
-  {
-    FileDef *fd = rootNav->fileDef();
-    if (fd) {
-      NamespaceSDict *fnl = fd->getUsedNamespaces();
-      if (fnl) {
-        QCString joinedName;
-        NamespaceDef *fnd;
-        NamespaceSDict::Iterator nsdi(*fnl);
-        for (nsdi.toFirst(); (fnd = nsdi.current()); ++nsdi) {
-          joinedName = fnd->name() + "::" + scopeName;
-          if (Doxygen::namespaceSDict->find(joinedName)) {
-            scopeName = joinedName;
-            break;
-          }
-        }
-      }
+    }
+    else
+    {
+      scopeName = mergeScopes(rootNav->parent()->name(),scopeName);
     }
   }
-  scopeName = stripTemplateSpecifiersFromScope(
-      removeRedundantWhiteSpace(scopeName), FALSE, &funcSpec);
+  else // see if we can prefix a namespace or class that is used from the file
+  {
+     FileDef *fd=rootNav->fileDef();
+     if (fd)
+     {
+       NamespaceSDict *fnl = fd->getUsedNamespaces();
+       if (fnl)
+       {
+         QCString joinedName;
+         NamespaceDef *fnd;
+         NamespaceSDict::Iterator nsdi(*fnl);
+         for (nsdi.toFirst();(fnd=nsdi.current());++nsdi)
+         {
+           joinedName = fnd->name()+"::"+scopeName;
+           if (Doxygen::namespaceSDict->find(joinedName))
+           {
+             scopeName=joinedName;
+             break;
+           }
+         }
+       }
+     }
+  }
+  scopeName=stripTemplateSpecifiersFromScope(
+      removeRedundantWhiteSpace(scopeName),FALSE,&funcSpec);
 
   // funcSpec contains the last template specifiers of the given scope.
   // If this method does not have any template arguments or they are
   // empty while funcSpec is not empty we assume this is a
   // specialization of a method. If not, we clear the funcSpec and treat
   // this as a normal method of a template class.
-  if (!(root->tArgLists && root->tArgLists->count() > 0 &&
-        root->tArgLists->getFirst()->count() == 0)) {
+  if (!(root->tArgLists &&
+        root->tArgLists->count()>0 &&
+        root->tArgLists->getFirst()->count()==0
+       )
+     )
+  {
     funcSpec.resize(0);
   }
 
   // split scope into a namespace and a class part
-  extractNamespaceName(scopeName, className, namespaceName, TRUE);
-  // printf("scopeName=`%s' className=`%s' namespaceName=`%s'\n",
+  extractNamespaceName(scopeName,className,namespaceName,TRUE);
+  //printf("scopeName=`%s' className=`%s' namespaceName=`%s'\n",
   //       scopeName.data(),className.data(),namespaceName.data());
 
-  // namespaceName=removeAnonymousScopes(namespaceName);
-  if (namespaceName.find('@') != -1)
-    return; // skip stuff in anonymous namespace...
+  //namespaceName=removeAnonymousScopes(namespaceName);
+  if (namespaceName.find('@')!=-1) return; // skip stuff in anonymous namespace...
 
-  // printf("namespaceName=`%s'
-  // className=`%s'\n",namespaceName.data(),className.data());
+  //printf("namespaceName=`%s' className=`%s'\n",namespaceName.data(),className.data());
   // merge class and namespace scopes again
   scopeName.resize(0);
-  if (!namespaceName.isEmpty()) {
-    if (className.isEmpty()) {
-      scopeName = namespaceName;
-    } else if (!root->relates
-                    .isEmpty() ||    // relates command with explicit scope
-               !getClass(className)) // class name only exists in a namespace
-    {
-      scopeName = namespaceName + "::" + className;
-    } else {
-      scopeName = className;
-    }
-  } else if (!className.isEmpty()) {
-    scopeName = className;
-  }
-  // printf("new scope=`%s'\n",scopeName.data());
-
-  QCString tempScopeName = scopeName;
-  ClassDef *cd = getClass(scopeName);
-  if (cd) {
-    if (funcSpec.isEmpty()) {
-      int argListIndex = 0;
-      tempScopeName = cd->qualifiedNameWithTemplateParameters(root->tArgLists,
-                                                              &argListIndex);
-    } else {
-      tempScopeName = scopeName + funcSpec;
-    }
-  }
-  // printf("scopeName=%s cd=%p root->tArgLists=%p result=%s\n",
+  if (!namespaceName.isEmpty())
+  {
+    if (className.isEmpty())
+    {
+      scopeName=namespaceName;
+    }
+    else if (!root->relates.isEmpty() || // relates command with explicit scope
+             !getClass(className)) // class name only exists in a namespace
+    {
+      scopeName=namespaceName+"::"+className;
+    }
+    else
+    {
+      scopeName=className;
+    }
+  }
+  else if (!className.isEmpty())
+  {
+    scopeName=className;
+  }
+  //printf("new scope=`%s'\n",scopeName.data());
+
+  QCString tempScopeName=scopeName;
+  ClassDef *cd=getClass(scopeName);
+  if (cd)
+  {
+    if (funcSpec.isEmpty())
+    {
+      int argListIndex=0;
+      tempScopeName=cd->qualifiedNameWithTemplateParameters(root->tArgLists,&argListIndex);
+    }
+    else
+    {
+      tempScopeName=scopeName+funcSpec;
+    }
+  }
+  //printf("scopeName=%s cd=%p root->tArgLists=%p result=%s\n",
   //    scopeName.data(),cd,root->tArgLists,tempScopeName.data());
 
-  // printf("scopeName=`%s'
-  // className=`%s'\n",scopeName.data(),className.data());
+  //printf("scopeName=`%s' className=`%s'\n",scopeName.data(),className.data());
   // rebuild the function declaration (needed to get the scope right).
-  if (!scopeName.isEmpty() && !isRelated && !isFriend &&
-      !Config_getBool(HIDE_SCOPE_NAMES)) {
-    if (!funcType.isEmpty()) {
+  if (!scopeName.isEmpty() && !isRelated && !isFriend && !Config_getBool(HIDE_SCOPE_NAMES))
+  {
+    if (!funcType.isEmpty())
+    {
       if (isFunc) // a function -> we use argList for the arguments
       {
-        funcDecl =
-            funcType + " " + tempScopeName + "::" + funcName + funcTempList;
-      } else {
-        funcDecl = funcType + " " + tempScopeName + "::" + funcName + funcArgs;
+        funcDecl=funcType+" "+tempScopeName+"::"+funcName+funcTempList;
+      }
+      else
+      {
+        funcDecl=funcType+" "+tempScopeName+"::"+funcName+funcArgs;
       }
-    } else {
+    }
+    else
+    {
       if (isFunc) // a function => we use argList for the arguments
       {
-        funcDecl = tempScopeName + "::" + funcName + funcTempList;
-      } else // variable => add `argument' list
+        funcDecl=tempScopeName+"::"+funcName+funcTempList;
+      }
+      else // variable => add `argument' list
       {
-        funcDecl = tempScopeName + "::" + funcName + funcArgs;
+        funcDecl=tempScopeName+"::"+funcName+funcArgs;
       }
     }
-  } else // build declaration without scope
+  }
+  else // build declaration without scope
   {
     if (!funcType.isEmpty()) // but with a type
     {
       if (isFunc) // function => omit argument list
       {
-        funcDecl = funcType + " " + funcName + funcTempList;
-      } else // variable => add `argument' list
+        funcDecl=funcType+" "+funcName+funcTempList;
+      }
+      else // variable => add `argument' list
       {
-        funcDecl = funcType + " " + funcName + funcArgs;
+        funcDecl=funcType+" "+funcName+funcArgs;
       }
-    } else // no type
+    }
+    else // no type
     {
-      if (isFunc) {
-        funcDecl = funcName + funcTempList;
-      } else {
-        funcDecl = funcName + funcArgs;
+      if (isFunc)
+      {
+        funcDecl=funcName+funcTempList;
       }
-    }
-  }
-
-  if (funcType == "template class" && !funcTempList.isEmpty())
-    return; // ignore explicit template instantiations
-
-  Debug::print(Debug::FindMembers, 0, "findMember() Parse results:\n"
-                                      "  namespaceName=`%s'\n"
-                                      "  className=`%s`\n"
-                                      "  funcType=`%s'\n"
-                                      "  funcSpec=`%s'\n"
-                                      "  funcName=`%s'\n"
-                                      "  funcArgs=`%s'\n"
-                                      "  funcTempList=`%s'\n"
-                                      "  funcDecl=`%s'\n"
-                                      "  related=`%s'\n"
-                                      "  exceptions=`%s'\n"
-                                      "  isRelated=%d\n"
-                                      "  isMemberOf=%d\n"
-                                      "  isFriend=%d\n"
-                                      "  isFunc=%d\n\n",
-               qPrint(namespaceName), qPrint(className), qPrint(funcType),
-               qPrint(funcSpec), qPrint(funcName), qPrint(funcArgs),
-               qPrint(funcTempList), qPrint(funcDecl), qPrint(root->relates),
-               qPrint(exceptions), isRelated, isMemberOf, isFriend, isFunc);
-
-  MemberName *mn = 0;
+      else
+      {
+        funcDecl=funcName+funcArgs;
+      }
+    }
+  }
+
+  if (funcType=="template class" && !funcTempList.isEmpty())
+    return;   // ignore explicit template instantiations
+
+  Debug::print(Debug::FindMembers,0,
+           "findMember() Parse results:\n"
+           "  namespaceName=`%s'\n"
+           "  className=`%s`\n"
+           "  funcType=`%s'\n"
+           "  funcSpec=`%s'\n"
+           "  funcName=`%s'\n"
+           "  funcArgs=`%s'\n"
+           "  funcTempList=`%s'\n"
+           "  funcDecl=`%s'\n"
+           "  related=`%s'\n"
+           "  exceptions=`%s'\n"
+           "  isRelated=%d\n"
+           "  isMemberOf=%d\n"
+           "  isFriend=%d\n"
+           "  isFunc=%d\n\n",
+           qPrint(namespaceName),qPrint(className),
+           qPrint(funcType),qPrint(funcSpec),qPrint(funcName),qPrint(funcArgs),qPrint(funcTempList),
+           qPrint(funcDecl),qPrint(root->relates),qPrint(exceptions),isRelated,isMemberOf,isFriend,
+           isFunc
+          );
+
+  MemberName *mn=0;
   if (!funcName.isEmpty()) // function name is valid
   {
-    Debug::print(Debug::FindMembers, 0, "1. funcName=`%s'\n", funcName.data());
-    if (funcName.left(9) == "operator ") // strip class scope from cast operator
+    Debug::print(Debug::FindMembers,0,
+                 "1. funcName=`%s'\n",funcName.data());
+    if (funcName.left(9)=="operator ") // strip class scope from cast operator
     {
-      funcName = substitute(funcName, className + "::", "");
+      funcName = substitute(funcName,className+"::","");
     }
     if (!funcTempList.isEmpty()) // try with member specialization
     {
-      mn = Doxygen::memberNameSDict->find(funcName + funcTempList);
+      mn=Doxygen::memberNameSDict->find(funcName+funcTempList);
     }
-    if (mn == 0) // try without specialization
+    if (mn==0) // try without specialization
     {
-      mn = Doxygen::memberNameSDict->find(funcName);
+      mn=Doxygen::memberNameSDict->find(funcName);
     }
     if (!isRelated && mn) // function name already found
     {
-      Debug::print(Debug::FindMembers, 0,
-                   "2. member name exists (%d members with this name)\n",
-                   mn->count());
+      Debug::print(Debug::FindMembers,0,
+                   "2. member name exists (%d members with this name)\n",mn->count());
       if (!className.isEmpty()) // class name is valid
       {
         if (funcSpec.isEmpty()) // not a member specialization
         {
-          int count = 0;
-          int noMatchCount = 0;
+          int count=0;
+          int noMatchCount=0;
           MemberNameIterator mni(*mn);
           MemberDef *md;
-          bool memFound = FALSE;
-          for (mni.toFirst(); !memFound && (md = mni.current()); ++mni) {
-            ClassDef *cd = md->getClassDef();
-            Debug::print(Debug::FindMembers, 0,
-                         "3. member definition found, "
-                         "scope needed=`%s' scope=`%s' args=`%s' fileName=%s\n",
-                         qPrint(scopeName), cd ? qPrint(cd->name()) : "<none>",
-                         qPrint(md->argsString()), qPrint(root->fileName));
-            // printf("Member %s (member scopeName=%s) (this scopeName=%s)
-            // classTempList=%s\n",md->name().data(),cd->name().data(),scopeName.data(),classTempList.data());
-            FileDef *fd = rootNav->fileDef();
-            NamespaceDef *nd = 0;
-            if (!namespaceName.isEmpty())
-              nd = getResolvedNamespace(namespaceName);
-
-            // printf("scopeName %s->%s\n",scopeName.data(),
+          bool memFound=FALSE;
+          for (mni.toFirst();!memFound && (md=mni.current());++mni)
+          {
+            ClassDef *cd=md->getClassDef();
+            Debug::print(Debug::FindMembers,0,
+                "3. member definition found, "
+                "scope needed=`%s' scope=`%s' args=`%s' fileName=%s\n",
+                qPrint(scopeName),cd ? qPrint(cd->name()) : "<none>",
+                qPrint(md->argsString()),
+                qPrint(root->fileName));
+            //printf("Member %s (member scopeName=%s) (this scopeName=%s) classTempList=%s\n",md->name().data(),cd->name().data(),scopeName.data(),classTempList.data());
+            FileDef *fd=rootNav->fileDef();
+            NamespaceDef *nd=0;
+            if (!namespaceName.isEmpty()) nd=getResolvedNamespace(namespaceName);
+
+            //printf("scopeName %s->%s\n",scopeName.data(),
             //       stripTemplateSpecifiersFromScope(scopeName,FALSE).data());
 
-            ClassDef *tcd = findClassDefinition(fd, nd, scopeName);
-            if (tcd == 0 && cd &&
-                stripAnonymousNamespaceScope(cd->name()) == scopeName) {
+            ClassDef *tcd=findClassDefinition(fd,nd,scopeName);
+            if (tcd==0 && cd && stripAnonymousNamespaceScope(cd->name())==scopeName)
+            {
               // don't be fooled by anonymous scopes
-              tcd = cd;
+              tcd=cd;
             }
-            // printf("Looking for %s inside nd=%s result=%p (%s) cd=%p\n",
+            //printf("Looking for %s inside nd=%s result=%p (%s) cd=%p\n",
             //    scopeName.data(),nd?nd->name().data():"<none>",tcd,tcd?tcd->name().data():"",cd);
 
-            if (cd && tcd == cd) // member's classes match
+            if (cd && tcd==cd) // member's classes match
             {
-              Debug::print(Debug::FindMembers, 0,
-                           "4. class definition %s found\n", cd->name().data());
+              Debug::print(Debug::FindMembers,0,
+                  "4. class definition %s found\n",cd->name().data());
 
-              // get the template parameter lists found at the member
-              // declaration
+              // get the template parameter lists found at the member declaration
               QList<ArgumentList> declTemplArgs;
               cd->getTemplateParameterLists(declTemplArgs);
               ArgumentList *templAl = md->templateArguments();
-              if (templAl) {
+              if (templAl)
+              {
                 declTemplArgs.append(templAl);
               }
 
               // get the template parameter lists found at the member definition
               QList<ArgumentList> *defTemplArgs = root->tArgLists;
-              // printf("defTemplArgs=%p\n",defTemplArgs);
+              //printf("defTemplArgs=%p\n",defTemplArgs);
 
-              // do we replace the decl argument lists with the def argument
-              // lists?
-              bool substDone = FALSE;
-              ArgumentList *argList = 0;
+              // do we replace the decl argument lists with the def argument lists?
+              bool substDone=FALSE;
+              ArgumentList *argList=0;
 
               /* substitute the occurrences of class template names in the
                * argument list before matching
                */
               ArgumentList *mdAl = md->argumentList();
-              if (declTemplArgs.count() > 0 && defTemplArgs &&
-                  declTemplArgs.count() == defTemplArgs->count() && mdAl) {
+              if (declTemplArgs.count()>0 && defTemplArgs &&
+                  declTemplArgs.count()==defTemplArgs->count() &&
+                  mdAl
+                 )
+              {
                 /* the function definition has template arguments
                  * and the class definition also has template arguments, so
                  * we must substitute the template names of the class by that
                  * of the function definition before matching.
                  */
                 argList = new ArgumentList;
-                substituteTemplatesInArgList(declTemplArgs, *defTemplArgs, mdAl,
-                                             argList);
+                substituteTemplatesInArgList(declTemplArgs,*defTemplArgs,
+                    mdAl,argList);
 
-                substDone = TRUE;
-              } else /* no template arguments, compare argument lists directly
-                        */
+                substDone=TRUE;
+              }
+              else /* no template arguments, compare argument lists directly */
               {
                 argList = mdAl;
               }
 
-              Debug::print(
-                  Debug::FindMembers, 0,
+              Debug::print(Debug::FindMembers,0,
                   "5. matching `%s'<=>`%s' className=%s namespaceName=%s\n",
-                  qPrint(argListToString(argList, TRUE)),
-                  qPrint(argListToString(root->argList, TRUE)),
-                  qPrint(className), qPrint(namespaceName));
-
-              bool matching =
-                  md->isVariable() ||
-                  md->isTypedef() || // needed for function pointers
-                  (mdAl == 0 && root->argList->count() == 0) ||
-                  matchArguments2(md->getClassDef(), md->getFileDef(), argList,
-                                  cd, fd, root->argList, TRUE);
-
-              if (md->getLanguage() == SrcLangExt_ObjC && md->isVariable() &&
-                  (root->section & Entry::FUNCTION_SEC)) {
-                matching = FALSE; // don't match methods and attributes with the
-                                  // same name
+                  qPrint(argListToString(argList,TRUE)),qPrint(argListToString(root->argList,TRUE)),
+                  qPrint(className),qPrint(namespaceName)
+                  );
+
+              bool matching=
+                md->isVariable() || md->isTypedef() || // needed for function pointers
+                (mdAl==0 && root->argList->count()==0) ||
+                matchArguments2(
+                    md->getClassDef(),md->getFileDef(),argList,
+                    cd,fd,root->argList,
+                    TRUE);
+
+              if (md->getLanguage()==SrcLangExt_ObjC && md->isVariable() && (root->section&Entry::FUNCTION_SEC))
+              {
+                matching = FALSE; // don't match methods and attributes with the same name
               }
 
               // for template member we also need to check the return type
-              if (md->templateArguments() != 0 && root->tArgLists != 0) {
+              if (md->templateArguments()!=0 && root->tArgLists!=0)
+              {
                 QCString memType = md->typeString();
                 memType.stripPrefix("static "); // see bug700696
-                funcType = substitute(
-                    stripTemplateSpecifiersFromScope(funcType, TRUE),
-                    className + "::", ""); // see bug700693 & bug732594
-                memType =
-                    substitute(stripTemplateSpecifiersFromScope(memType, TRUE),
-                               className + "::", ""); // see bug758900
-                Debug::print(
-                    Debug::FindMembers, 0,
-                    "5b. Comparing return types '%s'<->'%s' #args %d<->%d\n",
-                    qPrint(md->typeString()), qPrint(funcType),
-                    md->templateArguments()->count(),
-                    root->tArgLists->getLast()->count());
-                if (md->templateArguments()->count() !=
-                        root->tArgLists->getLast()->count() ||
-                    qstrcmp(memType, funcType)) {
-                  // printf(" ---> no matching\n");
+                funcType=substitute(stripTemplateSpecifiersFromScope(funcType,TRUE),
+                                    className+"::",""); // see bug700693 & bug732594
+                memType=substitute(stripTemplateSpecifiersFromScope(memType,TRUE),
+                                    className+"::",""); // see bug758900
+                Debug::print(Debug::FindMembers,0,
+                   "5b. Comparing return types '%s'<->'%s' #args %d<->%d\n",
+                    qPrint(md->typeString()),qPrint(funcType),
+                    md->templateArguments()->count(),root->tArgLists->getLast()->count());
+                if (md->templateArguments()->count()!=root->tArgLists->getLast()->count() ||
+                    qstrcmp(memType,funcType))
+                {
+                  //printf(" ---> no matching\n");
                   matching = FALSE;
                 }
               }
-              bool rootIsUserDoc = (root->section & Entry::MEMBERDOC_SEC) != 0;
+              bool rootIsUserDoc = (root->section&Entry::MEMBERDOC_SEC)!=0;
               bool classIsTemplate = scopeIsTemplate(md->getClassDef());
-              bool mdIsTemplate = md->templateArguments() != 0;
+              bool mdIsTemplate    = md->templateArguments()!=0;
               bool classOrMdIsTemplate = mdIsTemplate || classIsTemplate;
-              bool rootIsTemplate = root->tArgLists != 0;
-              // printf("classIsTemplate=%d mdIsTemplate=%d
-              // rootIsTemplate=%d\n",classIsTemplate,mdIsTemplate,rootIsTemplate);
-              if (!rootIsUserDoc && // don't check out-of-line @fn references,
-                                    // see bug722457
-                  (mdIsTemplate ||
-                   rootIsTemplate) && // either md or root is a template
-                  ((classOrMdIsTemplate && !rootIsTemplate) ||
-                   (!classOrMdIsTemplate && rootIsTemplate))) {
-                // Method with template return type does not match method
-                // without return type
+              bool rootIsTemplate  = root->tArgLists!=0;
+              //printf("classIsTemplate=%d mdIsTemplate=%d rootIsTemplate=%d\n",classIsTemplate,mdIsTemplate,rootIsTemplate);
+              if (!rootIsUserDoc && // don't check out-of-line @fn references, see bug722457
+                  (mdIsTemplate || rootIsTemplate) && // either md or root is a template
+                  ((classOrMdIsTemplate && !rootIsTemplate) || (!classOrMdIsTemplate && rootIsTemplate))
+                 )
+              {
+                // Method with template return type does not match method without return type
                 // even if the parameters are the same. See also bug709052
-                Debug::print(
-                    Debug::FindMembers, 0,
+                Debug::print(Debug::FindMembers,0,
                     "5b. Comparing return types: template v.s. non-template\n");
                 matching = FALSE;
               }
 
-              Debug::print(Debug::FindMembers, 0,
-                           "6. match results of matchArguments2 = %d\n",
-                           matching);
+
+              Debug::print(Debug::FindMembers,0,
+                  "6. match results of matchArguments2 = %d\n",matching);
 
               if (substDone) // found a new argument list
               {
                 if (matching) // replace member's argument list
                 {
                   md->setDefinitionTemplateParameterLists(root->tArgLists);
-                  md->setArgumentList(
-                      argList); // new owner of the list => no delete
-                } else          // no match
+                  md->setArgumentList(argList); // new owner of the list => no delete
+                }
+                else // no match
                 {
                   if (!funcTempList.isEmpty() &&
-                      isSpecialization(declTemplArgs, *defTemplArgs)) {
+                      isSpecialization(declTemplArgs,*defTemplArgs))
+                  {
                     // check if we are dealing with a partial template
                     // specialization. In this case we add it to the class
                     // even though the member arguments do not match.
 
                     // TODO: copy other aspects?
-                    root->protection =
-                        md->protection(); // copy protection level
-                    addMethodToClass(rootNav, cd, md->name(), isFriend);
+                    root->protection=md->protection(); // copy protection level
+                    addMethodToClass(rootNav,cd,md->name(),isFriend);
                     return;
                   }
                   delete argList;
                 }
               }
-              if (matching) {
-                addMemberDocs(rootNav, md, funcDecl, 0, overloaded,
-                              0 /* TODO */);
+              if (matching)
+              {
+                addMemberDocs(rootNav,md,funcDecl,0,overloaded,0/* TODO */);
                 count++;
-                memFound = TRUE;
+                memFound=TRUE;
               }
-            } else if (cd &&
-                       cd !=
-                           tcd) // we did find a class with the same name as cd
-                                // but in a different namespace
+            }
+            else if (cd && cd!=tcd) // we did find a class with the same name as cd
+                                    // but in a different namespace
             {
               noMatchCount++;
             }
           }
-          if (count == 0 && rootNav->parent() &&
-              rootNav->parent()->section() == Entry::OBJCIMPL_SEC) {
+          if (count==0 && rootNav->parent() &&
+              rootNav->parent()->section()==Entry::OBJCIMPL_SEC)
+          {
             goto localObjCMethod;
           }
-          if (count == 0 && !(isFriend && funcType == "class")) {
-            int candidates = 0;
+          if (count==0 && !(isFriend && funcType=="class"))
+          {
+            int candidates=0;
             ClassDef *ecd = 0, *ucd = 0;
             MemberDef *emd = 0, *umd = 0;
-            if (mn->count() > 0) {
-              // printf("Assume template class\n");
-              for (mni.toFirst(); (md = mni.current()); ++mni) {
-                ClassDef *ccd = md->getClassDef();
-                MemberDef *cmd = md;
-                // printf("ccd->name()==%s
-                // className=%s\n",ccd->name().data(),className.data());
-                if (ccd != 0 && rightScopeMatch(ccd->name(), className)) {
+            if (mn->count()>0)
+            {
+              //printf("Assume template class\n");
+              for (mni.toFirst();(md=mni.current());++mni)
+              {
+                ClassDef *ccd=md->getClassDef();
+                MemberDef *cmd=md;
+                //printf("ccd->name()==%s className=%s\n",ccd->name().data(),className.data());
+                if (ccd!=0 && rightScopeMatch(ccd->name(),className))
+                {
                   ArgumentList *templAl = md->templateArguments();
-                  if (root->tArgLists && templAl != 0 &&
-                      root->tArgLists->getLast()->count() <= templAl->count()) {
-                    addMethodToClass(rootNav, ccd, md->name(), isFriend);
+                  if (root->tArgLists && templAl!=0 &&
+                      root->tArgLists->getLast()->count()<=templAl->count())
+                  {
+                    addMethodToClass(rootNav,ccd,md->name(),isFriend);
                     return;
                   }
-                  if (md->argsString() ==
-                      argListToString(
-                          root->argList, TRUE,
-                          FALSE)) { // exact argument list match -> remember
+                  if (md->argsString()==argListToString(root->argList,TRUE,FALSE))
+                  { // exact argument list match -> remember
                     ucd = ecd = ccd;
                     umd = emd = cmd;
-                    Debug::print(Debug::FindMembers, 0, "7. new candidate "
-                                                        "className=%s scope=%s "
-                                                        "args=%s exact match\n",
-                                 qPrint(className), qPrint(ccd->name()),
-                                 qPrint(md->argsString()));
-                  } else // arguments do not match, but member name and scope do
-                         // -> remember
+                    Debug::print(Debug::FindMembers,0,
+                     "7. new candidate className=%s scope=%s args=%s exact match\n",
+                         qPrint(className),qPrint(ccd->name()),qPrint(md->argsString()));
+                  }
+                  else // arguments do not match, but member name and scope do -> remember
                   {
                     ucd = ccd;
                     umd = cmd;
-                    Debug::print(Debug::FindMembers, 0, "7. new candidate "
-                                                        "className=%s scope=%s "
-                                                        "args=%s no match\n",
-                                 qPrint(className), qPrint(ccd->name()),
-                                 qPrint(md->argsString()));
+                    Debug::print(Debug::FindMembers,0,
+                     "7. new candidate className=%s scope=%s args=%s no match\n",
+                         qPrint(className),qPrint(ccd->name()),qPrint(md->argsString()));
                   }
                   candidates++;
                 }
               }
             }
-            static bool strictProtoMatching =
-                Config_getBool(STRICT_PROTO_MATCHING);
-            if (!strictProtoMatching) {
-              if (candidates == 1 && ucd && umd) {
-                // we didn't find an actual match on argument lists, but there
-                // is only 1 member with this
+            static bool strictProtoMatching = Config_getBool(STRICT_PROTO_MATCHING);
+            if (!strictProtoMatching)
+            {
+              if (candidates==1 && ucd && umd)
+              {
+                // we didn't find an actual match on argument lists, but there is only 1 member with this
                 // name in the same scope, so that has to be the one.
-                addMemberDocs(rootNav, umd, funcDecl, 0, overloaded, 0);
+                addMemberDocs(rootNav,umd,funcDecl,0,overloaded,0);
                 return;
-              } else if (candidates > 1 && ecd && emd) {
+              }
+              else if (candidates>1 && ecd && emd)
+              {
                 // we didn't find a unique match using type resolution,
                 // but one of the matches has the exact same signature so
                 // we take that one.
-                addMemberDocs(rootNav, emd, funcDecl, 0, overloaded, 0);
+                addMemberDocs(rootNav,emd,funcDecl,0,overloaded,0);
                 return;
               }
             }
 
             QCString warnMsg = "no ";
-            if (noMatchCount > 1)
-              warnMsg += "uniquely ";
-            warnMsg += "matching class member found for \n";
+            if (noMatchCount>1) warnMsg+="uniquely ";
+            warnMsg+="matching class member found for \n";
 
-            if (root->tArgLists) {
+            if (root->tArgLists)
+            {
               QListIterator<ArgumentList> alli(*root->tArgLists);
               ArgumentList *al;
-              for (; (al = alli.current()); ++alli) {
-                warnMsg += "  template ";
-                warnMsg += tempArgListToString(al, root->lang);
-                warnMsg += '\n';
+              for (;(al=alli.current());++alli)
+              {
+                warnMsg+="  template ";
+                warnMsg+=tempArgListToString(al,root->lang);
+                warnMsg+='\n';
               }
             }
-            QCString fullFuncDecl = funcDecl.copy();
-            if (isFunc)
-              fullFuncDecl += argListToString(root->argList, TRUE);
-
-            warnMsg += "  ";
-            warnMsg += fullFuncDecl;
-            warnMsg += '\n';
-
-            if (candidates > 0) {
-              warnMsg += "Possible candidates:\n";
-              for (mni.toFirst(); (md = mni.current()); ++mni) {
-                ClassDef *cd = md->getClassDef();
-                if (cd != 0 && rightScopeMatch(cd->name(), className)) {
+            QCString fullFuncDecl=funcDecl.copy();
+            if (isFunc) fullFuncDecl+=argListToString(root->argList,TRUE);
+
+            warnMsg+="  ";
+            warnMsg+=fullFuncDecl;
+            warnMsg+='\n';
+
+            if (candidates>0)
+            {
+              warnMsg+="Possible candidates:\n";
+              for (mni.toFirst();(md=mni.current());++mni)
+              {
+                ClassDef *cd=md->getClassDef();
+                if (cd!=0 && rightScopeMatch(cd->name(),className))
+                {
                   ArgumentList *templAl = md->templateArguments();
-                  if (templAl != 0) {
-                    warnMsg += "  'template ";
-                    warnMsg += tempArgListToString(templAl, root->lang);
-                    warnMsg += '\n';
+                  if (templAl!=0)
+                  {
+                    warnMsg+="  'template ";
+                    warnMsg+=tempArgListToString(templAl,root->lang);
+                    warnMsg+='\n';
                   }
-                  warnMsg += "  ";
-                  if (md->typeString()) {
-                    warnMsg += md->typeString();
-                    warnMsg += ' ';
+                  warnMsg+="  ";
+                  if (md->typeString())
+                  {
+                    warnMsg+=md->typeString();
+                    warnMsg+=' ';
                   }
                   QCString qScope = cd->qualifiedNameWithTemplateParameters();
                   if (!qScope.isEmpty())
-                    warnMsg += qScope + "::" + md->name();
+                    warnMsg+=qScope+"::"+md->name();
                   if (md->argsString())
-                    warnMsg += md->argsString();
-                  if (noMatchCount > 1) {
-                    warnMsg += "' at line " +
-                               QCString().setNum(md->getDefLine()) +
-                               " of file " + md->getDefFileName();
+                    warnMsg+=md->argsString();
+                  if (noMatchCount>1)
+                  {
+                    warnMsg+="' at line "+QCString().setNum(md->getDefLine()) +
+                             " of file "+md->getDefFileName();
                   }
 
-                  warnMsg += '\n';
+                  warnMsg+='\n';
                 }
               }
             }
-            warn_simple(root->fileName, root->startLine, warnMsg);
+            warn_simple(root->fileName,root->startLine,warnMsg);
           }
-        } else if (cd) // member specialization
+        }
+        else if (cd) // member specialization
         {
           MemberNameIterator mni(*mn);
-          MemberDef *declMd = 0;
-          MemberDef *md = 0;
-          for (mni.toFirst(); (md = mni.current()); ++mni) {
-            if (md->getClassDef() == cd) {
+          MemberDef *declMd=0;
+          MemberDef *md=0;
+          for (mni.toFirst();(md=mni.current());++mni)
+          {
+            if (md->getClassDef()==cd)
+            {
               // TODO: we should probably also check for matching arguments
               declMd = md;
               break;
             }
           }
-          MemberType mtype = MemberType_Function;
+          MemberType mtype=MemberType_Function;
           ArgumentList *tArgList = new ArgumentList;
           //  getTemplateArgumentsFromName(cd->name()+"::"+funcName,root->tArgLists);
-          md = new MemberDef(root->fileName, root->startLine, root->startColumn,
-                             funcType, funcName, funcArgs, exceptions,
-                             declMd ? declMd->protection() : root->protection,
-                             root->virt, root->stat, Member, mtype, tArgList,
-                             root->argList);
-          // printf("new specialized member %s
-          // args=`%s'\n",md->name().data(),funcArgs.data());
+          md=new MemberDef(
+              root->fileName,root->startLine,root->startColumn,
+              funcType,funcName,funcArgs,exceptions,
+              declMd ? declMd->protection() : root->protection,
+              root->virt,root->stat,Member,
+              mtype,tArgList,root->argList);
+          //printf("new specialized member %s args=`%s'\n",md->name().data(),funcArgs.data());
           md->setTagInfo(rootNav->tagInfo());
           md->setLanguage(root->lang);
           md->setId(root->id);
@@ -5937,16 +6442,14 @@ static void findMember(EntryNav *rootNav, QCString funcDecl, bool overloaded,
           md->setDefinition(funcDecl);
           md->enableCallGraph(root->callGraph);
           md->enableCallerGraph(root->callerGraph);
-          md->setDocumentation(root->doc, root->docFile, root->docLine);
-          md->setBriefDescription(root->brief, root->briefFile,
-                                  root->briefLine);
-          md->setInbodyDocumentation(root->inbodyDocs, root->inbodyFile,
-                                     root->inbodyLine);
+          md->setDocumentation(root->doc,root->docFile,root->docLine);
+          md->setBriefDescription(root->brief,root->briefFile,root->briefLine);
+          md->setInbodyDocumentation(root->inbodyDocs,root->inbodyFile,root->inbodyLine);
           md->setDocsForDefinition(!root->proto);
           md->setPrototype(root->proto);
           md->addSectionsToDefinition(root->anchors);
-          md->setBodySegment(root->bodyLine, root->endBodyLine);
-          FileDef *fd = rootNav->fileDef();
+          md->setBodySegment(root->bodyLine,root->endBodyLine);
+          FileDef *fd=rootNav->fileDef();
           md->setBodyDef(fd);
           md->setMemberSpecifiers(root->spec);
           md->setMemberGroupId(root->mGrpId);
@@ -5954,48 +6457,48 @@ static void findMember(EntryNav *rootNav, QCString funcDecl, bool overloaded,
           cd->insertMember(md);
           md->setRefItems(root->sli);
           delete tArgList;
-        } else {
-          // printf("*** Specialized member %s of unknown scope %s%s found!\n",
+        }
+        else
+        {
+          //printf("*** Specialized member %s of unknown scope %s%s found!\n",
           //        scopeName.data(),funcName.data(),funcArgs.data());
         }
-      } else if (overloaded) // check if the function belongs to only one class
+      }
+      else if (overloaded) // check if the function belongs to only one class
       {
         // for unique overloaded member we allow the class to be
         // omitted, this is to be Qt compatible. Using this should
         // however be avoided, because it is error prone
         MemberNameIterator mni(*mn);
-        MemberDef *md = mni.toFirst();
+        MemberDef *md=mni.toFirst();
         ASSERT(md);
-        ClassDef *cd = md->getClassDef();
+        ClassDef *cd=md->getClassDef();
         ASSERT(cd);
-        QCString className = cd->name().copy();
+        QCString className=cd->name().copy();
         ++mni;
-        bool unique = TRUE;
-        for (; (md = mni.current()); ++mni) {
-          ClassDef *cd = md->getClassDef();
-          if (className != cd->name())
-            unique = FALSE;
+        bool unique=TRUE;
+        for (;(md=mni.current());++mni)
+        {
+          ClassDef *cd=md->getClassDef();
+          if (className!=cd->name()) unique=FALSE;
         }
-        if (unique) {
+        if (unique)
+        {
           MemberType mtype;
-          if (root->mtype == Signal)
-            mtype = MemberType_Signal;
-          else if (root->mtype == Slot)
-            mtype = MemberType_Slot;
-          else if (root->mtype == DCOP)
-            mtype = MemberType_DCOP;
-          else
-            mtype = MemberType_Function;
+          if      (root->mtype==Signal)  mtype=MemberType_Signal;
+          else if (root->mtype==Slot)    mtype=MemberType_Slot;
+          else if (root->mtype==DCOP)    mtype=MemberType_DCOP;
+          else                           mtype=MemberType_Function;
 
           // new overloaded member function
-          ArgumentList *tArgList = getTemplateArgumentsFromName(
-              cd->name() + "::" + funcName, root->tArgLists);
-          // printf("new related member %s
-          // args=`%s'\n",md->name().data(),funcArgs.data());
-          MemberDef *md = new MemberDef(
-              root->fileName, root->startLine, root->startColumn, funcType,
-              funcName, funcArgs, exceptions, root->protection, root->virt,
-              root->stat, Related, mtype, tArgList, root->argList);
+          ArgumentList *tArgList =
+            getTemplateArgumentsFromName(cd->name()+"::"+funcName,root->tArgLists);
+          //printf("new related member %s args=`%s'\n",md->name().data(),funcArgs.data());
+          MemberDef *md=new MemberDef(
+              root->fileName,root->startLine,root->startColumn,
+              funcType,funcName,funcArgs,exceptions,
+              root->protection,root->virt,root->stat,Related,
+              mtype,tArgList,root->argList);
           md->setTagInfo(rootNav->tagInfo());
           md->setLanguage(root->lang);
           md->setId(root->id);
@@ -6004,19 +6507,17 @@ static void findMember(EntryNav *rootNav, QCString funcDecl, bool overloaded,
           md->setDefinition(funcDecl);
           md->enableCallGraph(root->callGraph);
           md->enableCallerGraph(root->callerGraph);
-          QCString doc = getOverloadDocs();
-          doc += "<p>";
-          doc += root->doc;
-          md->setDocumentation(doc, root->docFile, root->docLine);
-          md->setBriefDescription(root->brief, root->briefFile,
-                                  root->briefLine);
-          md->setInbodyDocumentation(root->inbodyDocs, root->inbodyFile,
-                                     root->inbodyLine);
+          QCString doc=getOverloadDocs();
+          doc+="<p>";
+          doc+=root->doc;
+          md->setDocumentation(doc,root->docFile,root->docLine);
+          md->setBriefDescription(root->brief,root->briefFile,root->briefLine);
+          md->setInbodyDocumentation(root->inbodyDocs,root->inbodyFile,root->inbodyLine);
           md->setDocsForDefinition(!root->proto);
           md->setPrototype(root->proto);
           md->addSectionsToDefinition(root->anchors);
-          md->setBodySegment(root->bodyLine, root->endBodyLine);
-          FileDef *fd = rootNav->fileDef();
+          md->setBodySegment(root->bodyLine,root->endBodyLine);
+          FileDef *fd=rootNav->fileDef();
           md->setBodyDef(fd);
           md->setMemberSpecifiers(root->spec);
           md->setMemberGroupId(root->mGrpId);
@@ -6025,73 +6526,74 @@ static void findMember(EntryNav *rootNav, QCString funcDecl, bool overloaded,
           cd->insertUsedFile(fd);
           md->setRefItems(root->sli);
         }
-      } else // unrelated function with the same name as a member
+      }
+      else // unrelated function with the same name as a member
       {
-        if (!findGlobalMember(rootNav, namespaceName, funcType, funcName,
-                              funcTempList, funcArgs, funcDecl)) {
-          QCString fullFuncDecl = funcDecl.copy();
-          if (isFunc)
-            fullFuncDecl += argListToString(root->argList, TRUE);
-          warn(root->fileName, root->startLine,
-               "Cannot determine class for function\n%s", fullFuncDecl.data());
+        if (!findGlobalMember(rootNav,namespaceName,funcType,funcName,funcTempList,funcArgs,funcDecl))
+        {
+          QCString fullFuncDecl=funcDecl.copy();
+          if (isFunc) fullFuncDecl+=argListToString(root->argList,TRUE);
+          warn(root->fileName,root->startLine,
+               "Cannot determine class for function\n%s",
+               fullFuncDecl.data()
+              );
         }
       }
-    } else if (isRelated && !root->relates.isEmpty()) {
-      Debug::print(Debug::FindMembers, 0, "2. related function\n"
-                                          "  scopeName=%s className=%s\n",
-                   qPrint(scopeName), qPrint(className));
-      if (className.isEmpty())
-        className = root->relates;
+    }
+    else if (isRelated && !root->relates.isEmpty())
+    {
+      Debug::print(Debug::FindMembers,0,"2. related function\n"
+              "  scopeName=%s className=%s\n",qPrint(scopeName),qPrint(className));
+      if (className.isEmpty()) className=root->relates;
       ClassDef *cd;
-      // printf("scopeName=`%s'
-      // className=`%s'\n",scopeName.data(),className.data());
-      if ((cd = getClass(scopeName))) {
-        bool newMember = TRUE; // assume we have a new member
-        bool newMemberName = FALSE;
-        MemberDef *mdDefine = 0;
-        bool isDefine = FALSE;
+      //printf("scopeName=`%s' className=`%s'\n",scopeName.data(),className.data());
+      if ((cd=getClass(scopeName)))
+      {
+        bool newMember=TRUE; // assume we have a new member
+        bool newMemberName=FALSE;
+        MemberDef *mdDefine=0;
+        bool isDefine=FALSE;
         {
           MemberName *mn = Doxygen::functionNameSDict->find(funcName);
-          if (mn) {
+          if (mn)
+          {
             MemberNameIterator mni(*mn);
             mdDefine = mni.current();
-            while (mdDefine && !isDefine) {
+            while (mdDefine && !isDefine)
+            {
               isDefine = isDefine || mdDefine->isDefine();
-              if (!isDefine) {
-                ++mni;
-                mdDefine = mni.current();
-              }
+              if (!isDefine) { ++mni; mdDefine=mni.current(); }
             }
           }
         }
 
-        FileDef *fd = rootNav->fileDef();
+        FileDef *fd=rootNav->fileDef();
 
-        if ((mn = Doxygen::memberNameSDict->find(funcName)) == 0) {
-          mn = new MemberName(funcName);
-          newMemberName = TRUE; // we create a new member name
-        } else {
+        if ((mn=Doxygen::memberNameSDict->find(funcName))==0)
+        {
+          mn=new MemberName(funcName);
+          newMemberName=TRUE; // we create a new member name
+        }
+        else
+        {
           MemberNameIterator mni(*mn);
           MemberDef *rmd;
-          while (
-              (rmd = mni.current()) &&
-              newMember) // see if we got another member with matching arguments
+          while ((rmd=mni.current()) && newMember) // see if we got another member with matching arguments
           {
             ArgumentList *rmdAl = rmd->argumentList();
 
-            newMember =
-                className != rmd->getOuterScope()->name() ||
-                !matchArguments2(rmd->getOuterScope(), rmd->getFileDef(), rmdAl,
-                                 cd, fd, root->argList, TRUE);
-            if (newMember)
-              ++mni;
+            newMember=
+              className!=rmd->getOuterScope()->name() ||
+              !matchArguments2(rmd->getOuterScope(),rmd->getFileDef(),rmdAl,
+                               cd,fd,root->argList,
+                               TRUE);
+            if (newMember) ++mni;
           }
           if (!newMember && rmd) // member already exists as rmd -> add docs
           {
-            // printf("addMemberDocs for related member
-            // %s\n",root->name.data());
-            // rmd->setMemberDefTemplateArguments(root->mtArgList);
-            addMemberDocs(rootNav, rmd, funcDecl, 0, overloaded);
+            //printf("addMemberDocs for related member %s\n",root->name.data());
+            //rmd->setMemberDefTemplateArguments(root->mtArgList);
+            addMemberDocs(rootNav,rmd,funcDecl,0,overloaded);
           }
         }
 
@@ -6099,24 +6601,25 @@ static void findMember(EntryNav *rootNav, QCString funcDecl, bool overloaded,
         {
           MemberType mtype;
           if (isDefine)
-            mtype = MemberType_Define;
-          else if (root->mtype == Signal)
-            mtype = MemberType_Signal;
-          else if (root->mtype == Slot)
-            mtype = MemberType_Slot;
-          else if (root->mtype == DCOP)
-            mtype = MemberType_DCOP;
+            mtype=MemberType_Define;
+          else if (root->mtype==Signal)
+            mtype=MemberType_Signal;
+          else if (root->mtype==Slot)
+            mtype=MemberType_Slot;
+          else if (root->mtype==DCOP)
+            mtype=MemberType_DCOP;
           else
-            mtype = MemberType_Function;
+            mtype=MemberType_Function;
 
-          if (isDefine && mdDefine) {
+          if (isDefine && mdDefine)
+          {
             mdDefine->setHidden(TRUE);
-            funcType = "#define";
-            funcArgs = mdDefine->argsString();
-            funcDecl = funcType + " " + funcName;
+            funcType="#define";
+            funcArgs=mdDefine->argsString();
+            funcDecl=funcType + " " + funcName;
           }
 
-          // printf("New related name `%s' `%d'\n",funcName.data(),
+          //printf("New related name `%s' `%d'\n",funcName.data(),
           //    root->argList ? (int)root->argList->count() : -1);
 
           // first note that we pass:
@@ -6125,14 +6628,18 @@ static void findMember(EntryNav *rootNav, QCString funcDecl, bool overloaded,
           // this accurately reflects the template arguments of
           // the related function, which don't have to do with
           // those of the related class.
-          MemberDef *md = new MemberDef(
-              root->fileName, root->startLine, root->startColumn, funcType,
-              funcName, funcArgs, exceptions, root->protection, root->virt,
-              root->stat && !isMemberOf, isMemberOf ? Foreign : Related, mtype,
+          MemberDef *md=new MemberDef(
+              root->fileName,root->startLine,root->startColumn,
+              funcType,funcName,funcArgs,exceptions,
+              root->protection,root->virt,
+              root->stat && !isMemberOf,
+              isMemberOf ? Foreign : Related,
+              mtype,
               (root->tArgLists ? root->tArgLists->getLast() : 0),
               funcArgs.isEmpty() ? 0 : root->argList);
 
-          if (isDefine && mdDefine) {
+          if (isDefine && mdDefine)
+          {
             md->setInitializer(mdDefine->initializer());
           }
 
@@ -6151,47 +6658,51 @@ static void findMember(EntryNav *rootNav, QCString funcDecl, bool overloaded,
 
           md->setTagInfo(rootNav->tagInfo());
 
-          // printf("Related member name=`%s' decl=`%s' bodyLine=`%d'\n",
+
+
+          //printf("Related member name=`%s' decl=`%s' bodyLine=`%d'\n",
           //       funcName.data(),funcDecl.data(),root->bodyLine);
 
           // try to find the matching line number of the body from the
           // global function list
-          bool found = FALSE;
-          if (root->bodyLine == -1) {
-            MemberName *rmn = Doxygen::functionNameSDict->find(funcName);
-            if (rmn) {
+          bool found=FALSE;
+          if (root->bodyLine==-1)
+          {
+            MemberName *rmn=Doxygen::functionNameSDict->find(funcName);
+            if (rmn)
+            {
               MemberNameIterator rmni(*rmn);
               MemberDef *rmd;
-              while ((rmd = rmni.current()) && !found) // see if we got another
-                                                       // member with matching
-                                                       // arguments
+              while ((rmd=rmni.current()) && !found) // see if we got another member with matching arguments
               {
                 ArgumentList *rmdAl = rmd->argumentList();
                 // check for matching argument lists
-                if (matchArguments2(rmd->getOuterScope(), rmd->getFileDef(),
-                                    rmdAl, cd, fd, root->argList, TRUE)) {
-                  found = TRUE;
+                if (
+                    matchArguments2(rmd->getOuterScope(),rmd->getFileDef(),rmdAl,
+                                    cd,fd,root->argList,
+                                    TRUE)
+                   )
+                {
+                  found=TRUE;
                 }
-                if (!found)
-                  ++rmni;
+                if (!found) ++rmni;
               }
               if (rmd) // member found -> copy line number info
               {
-                md->setBodySegment(rmd->getStartBodyLine(),
-                                   rmd->getEndBodyLine());
+                md->setBodySegment(rmd->getStartBodyLine(),rmd->getEndBodyLine());
                 md->setBodyDef(rmd->getBodyDef());
-                // md->setBodyMember(rmd);
+                //md->setBodyMember(rmd);
               }
             }
           }
           if (!found) // line number could not be found or is available in this
                       // entry
           {
-            md->setBodySegment(root->bodyLine, root->endBodyLine);
+            md->setBodySegment(root->bodyLine,root->endBodyLine);
             md->setBodyDef(fd);
           }
 
-          // if (root->mGrpId!=-1)
+          //if (root->mGrpId!=-1)
           //{
           //  md->setMemberGroup(memberGroupDict[root->mGrpId]);
           //}
@@ -6200,67 +6711,70 @@ static void findMember(EntryNav *rootNav, QCString funcDecl, bool overloaded,
           md->setDefinition(funcDecl);
           md->enableCallGraph(root->callGraph);
           md->enableCallerGraph(root->callerGraph);
-          md->setDocumentation(root->doc, root->docFile, root->docLine);
-          md->setInbodyDocumentation(root->inbodyDocs, root->inbodyFile,
-                                     root->inbodyLine);
+          md->setDocumentation(root->doc,root->docFile,root->docLine);
+          md->setInbodyDocumentation(root->inbodyDocs,root->inbodyFile,root->inbodyLine);
           md->setDocsForDefinition(!root->proto);
           md->setPrototype(root->proto);
-          md->setBriefDescription(root->brief, root->briefFile,
-                                  root->briefLine);
+          md->setBriefDescription(root->brief,root->briefFile,root->briefLine);
           md->addSectionsToDefinition(root->anchors);
           md->setMemberGroupId(root->mGrpId);
           md->setLanguage(root->lang);
           md->setId(root->id);
-          // md->setMemberDefTemplateArguments(root->mtArgList);
+          //md->setMemberDefTemplateArguments(root->mtArgList);
           mn->append(md);
           cd->insertMember(md);
           cd->insertUsedFile(fd);
           md->setRefItems(root->sli);
-          if (root->relatesType == Duplicate)
-            md->setRelatedAlso(cd);
-          if (!isDefine) {
-            addMemberToGroups(root, md);
+          if (root->relatesType == Duplicate) md->setRelatedAlso(cd);
+          if (!isDefine)
+          {
+            addMemberToGroups(root,md);
           }
-          // printf("Adding member=%s\n",md->name().data());
-          if (newMemberName) {
-            // Doxygen::memberNameList.append(mn);
-            // Doxygen::memberNameDict.insert(funcName,mn);
-            Doxygen::memberNameSDict->append(funcName, mn);
+          //printf("Adding member=%s\n",md->name().data());
+          if (newMemberName)
+          {
+            //Doxygen::memberNameList.append(mn);
+            //Doxygen::memberNameDict.insert(funcName,mn);
+            Doxygen::memberNameSDict->append(funcName,mn);
           }
         }
-        if (root->relatesType == Duplicate) {
-          if (!findGlobalMember(rootNav, namespaceName, funcType, funcName,
-                                funcTempList, funcArgs, funcDecl)) {
-            QCString fullFuncDecl = funcDecl.copy();
-            if (isFunc)
-              fullFuncDecl += argListToString(root->argList, TRUE);
-            warn(root->fileName, root->startLine,
-                 "Cannot determine file/namespace for relatedalso function\n%s",
-                 fullFuncDecl.data());
+        if (root->relatesType == Duplicate)
+        {
+          if (!findGlobalMember(rootNav,namespaceName,funcType,funcName,funcTempList,funcArgs,funcDecl))
+          {
+            QCString fullFuncDecl=funcDecl.copy();
+            if (isFunc) fullFuncDecl+=argListToString(root->argList,TRUE);
+            warn(root->fileName,root->startLine,
+               "Cannot determine file/namespace for relatedalso function\n%s",
+               fullFuncDecl.data()
+              );
           }
         }
-      } else {
-        warn_undoc(root->fileName, root->startLine,
+      }
+      else
+      {
+        warn_undoc(root->fileName,root->startLine,
                    "class `%s' for related function `%s' is not "
                    "documented.",
-                   className.data(), funcName.data());
+                   className.data(),funcName.data()
+                  );
       }
-    } else if (rootNav->parent() &&
-               rootNav->parent()->section() == Entry::OBJCIMPL_SEC) {
-    localObjCMethod:
+    }
+    else if (rootNav->parent() && rootNav->parent()->section()==Entry::OBJCIMPL_SEC)
+    {
+localObjCMethod:
       ClassDef *cd;
-      // printf("scopeName=`%s'
-      // className=`%s'\n",scopeName.data(),className.data());
-      if (Config_getBool(EXTRACT_LOCAL_METHODS) && (cd = getClass(scopeName))) {
-        Debug::print(Debug::FindMembers, 0, "4. Local objective C method %s\n"
-                                            "  scopeName=%s className=%s\n",
-                     qPrint(root->name), qPrint(scopeName), qPrint(className));
-        // printf("Local objective C method `%s' of class `%s'
-        // found\n",root->name.data(),cd->name().data());
-        MemberDef *md = new MemberDef(
-            root->fileName, root->startLine, root->startColumn, funcType,
-            funcName, funcArgs, exceptions, root->protection, root->virt,
-            root->stat, Member, MemberType_Function, 0, root->argList);
+      //printf("scopeName=`%s' className=`%s'\n",scopeName.data(),className.data());
+      if (Config_getBool(EXTRACT_LOCAL_METHODS) && (cd=getClass(scopeName)))
+      {
+        Debug::print(Debug::FindMembers,0,"4. Local objective C method %s\n"
+              "  scopeName=%s className=%s\n",qPrint(root->name),qPrint(scopeName),qPrint(className));
+        //printf("Local objective C method `%s' of class `%s' found\n",root->name.data(),cd->name().data());
+        MemberDef *md=new MemberDef(
+            root->fileName,root->startLine,root->startColumn,
+            funcType,funcName,funcArgs,exceptions,
+            root->protection,root->virt,root->stat,Member,
+            MemberType_Function,0,root->argList);
         md->setTagInfo(rootNav->tagInfo());
         md->setLanguage(root->lang);
         md->setId(root->id);
@@ -6269,49 +6783,59 @@ static void findMember(EntryNav *rootNav, QCString funcDecl, bool overloaded,
         md->setDefinition(funcDecl);
         md->enableCallGraph(root->callGraph);
         md->enableCallerGraph(root->callerGraph);
-        md->setDocumentation(root->doc, root->docFile, root->docLine);
-        md->setBriefDescription(root->brief, root->briefFile, root->briefLine);
-        md->setInbodyDocumentation(root->inbodyDocs, root->inbodyFile,
-                                   root->inbodyLine);
+        md->setDocumentation(root->doc,root->docFile,root->docLine);
+        md->setBriefDescription(root->brief,root->briefFile,root->briefLine);
+        md->setInbodyDocumentation(root->inbodyDocs,root->inbodyFile,root->inbodyLine);
         md->setDocsForDefinition(!root->proto);
         md->setPrototype(root->proto);
         md->addSectionsToDefinition(root->anchors);
-        md->setBodySegment(root->bodyLine, root->endBodyLine);
-        FileDef *fd = rootNav->fileDef();
+        md->setBodySegment(root->bodyLine,root->endBodyLine);
+        FileDef *fd=rootNav->fileDef();
         md->setBodyDef(fd);
         md->setMemberSpecifiers(root->spec);
         md->setMemberGroupId(root->mGrpId);
         cd->insertMember(md);
         cd->insertUsedFile(fd);
         md->setRefItems(root->sli);
-        if ((mn = Doxygen::memberNameSDict->find(root->name))) {
+        if ((mn=Doxygen::memberNameSDict->find(root->name)))
+        {
           mn->append(md);
-        } else {
+        }
+        else
+        {
           mn = new MemberName(root->name);
           mn->append(md);
-          Doxygen::memberNameSDict->append(root->name, mn);
+          Doxygen::memberNameSDict->append(root->name,mn);
         }
-      } else {
+      }
+      else
+      {
         // local objective C method found for class without interface
       }
-    } else // unrelated not overloaded member found
+    }
+    else // unrelated not overloaded member found
     {
-      bool globMem =
-          findGlobalMember(rootNav, namespaceName, funcType, funcName,
-                           funcTempList, funcArgs, funcDecl);
-      if (className.isEmpty() && !globMem) {
-        warn(root->fileName, root->startLine, "class for member `%s' cannot "
-                                              "be found.",
-             funcName.data());
-      } else if (!className.isEmpty() && !globMem) {
-        warn(root->fileName, root->startLine,
-             "member `%s' of class `%s' cannot be found", funcName.data(),
-             className.data());
+      bool globMem = findGlobalMember(rootNav,namespaceName,funcType,funcName,funcTempList,funcArgs,funcDecl);
+      if (className.isEmpty() && !globMem)
+      {
+        warn(root->fileName,root->startLine,
+             "class for member `%s' cannot "
+             "be found.", funcName.data()
+            );
+      }
+      else if (!className.isEmpty() && !globMem)
+      {
+        warn(root->fileName,root->startLine,
+             "member `%s' of class `%s' cannot be found",
+             funcName.data(),className.data());
       }
     }
-  } else {
+  }
+  else
+  {
     // this should not be called
-    warn(root->fileName, root->startLine, "member with no name found.");
+    warn(root->fileName,root->startLine,
+         "member with no name found.");
   }
   return;
 }
@@ -6320,19 +6844,19 @@ static void findMember(EntryNav *rootNav, QCString funcDecl, bool overloaded,
 // find the members corresponding to the different documentation blocks
 // that are extracted from the sources.
 
-static void filterMemberDocumentation(EntryNav *rootNav) {
+static void filterMemberDocumentation(EntryNav *rootNav)
+{
   Entry *root = rootNav->entry();
-  int i = -1, l;
-  Debug::print(Debug::FindMembers, 0,
-               "findMemberDocumentation(): root->type=`%s' root->inside=`%s' "
-               "root->name=`%s' root->args=`%s' section=%x root->spec=%lld "
-               "root->mGrpId=%d\n",
-               qPrint(root->type), qPrint(root->inside), qPrint(root->name),
-               qPrint(root->args), root->section, root->spec, root->mGrpId);
-  // printf("rootNav->parent()->name()=%s\n",rootNav->parent()->name().data());
-  bool isFunc = TRUE;
-
-  if (root->relatesType == Duplicate && !root->relates.isEmpty()) {
+  int i=-1,l;
+  Debug::print(Debug::FindMembers,0,
+      "findMemberDocumentation(): root->type=`%s' root->inside=`%s' root->name=`%s' root->args=`%s' section=%x root->spec=%lld root->mGrpId=%d\n",
+      qPrint(root->type),qPrint(root->inside),qPrint(root->name),qPrint(root->args),root->section,root->spec,root->mGrpId
+      );
+  //printf("rootNav->parent()->name()=%s\n",rootNav->parent()->name().data());
+  bool isFunc=TRUE;
+
+  if (root->relatesType == Duplicate && !root->relates.isEmpty())
+  {
     QCString tmp = root->relates;
     root->relates.resize(0);
     filterMemberDocumentation(rootNav);
@@ -6340,128 +6864,162 @@ static void filterMemberDocumentation(EntryNav *rootNav) {
   }
 
   if ( // detect func variable/typedef to func ptr
-      (i = findFunctionPtr(root->type, root->lang, &l)) != -1) {
-    // printf("Fixing function pointer!\n");
+      (i=findFunctionPtr(root->type,root->lang,&l))!=-1
+     )
+  {
+    //printf("Fixing function pointer!\n");
     // fix type and argument
-    root->args.prepend(root->type.right(root->type.length() - i - l));
-    root->type = root->type.left(i + l);
-    // printf("Results
-    // type=%s,name=%s,args=%s\n",root->type.data(),root->name.data(),root->args.data());
-    isFunc = FALSE;
-  } else if ((root->type.left(8) == "typedef " && root->args.find('(') != -1))
-  // detect function types marked as functions
+    root->args.prepend(root->type.right(root->type.length()-i-l));
+    root->type=root->type.left(i+l);
+    //printf("Results type=%s,name=%s,args=%s\n",root->type.data(),root->name.data(),root->args.data());
+    isFunc=FALSE;
+  }
+  else if ((root->type.left(8)=="typedef " && root->args.find('(')!=-1))
+    // detect function types marked as functions
   {
-    isFunc = FALSE;
+    isFunc=FALSE;
   }
 
-  // printf("Member %s isFunc=%d\n",root->name.data(),isFunc);
-  if (root->section == Entry::MEMBERDOC_SEC) {
-    // printf("Documentation for inline member `%s' found args=`%s'\n",
+  //printf("Member %s isFunc=%d\n",root->name.data(),isFunc);
+  if (root->section==Entry::MEMBERDOC_SEC)
+  {
+    //printf("Documentation for inline member `%s' found args=`%s'\n",
     //    root->name.data(),root->args.data());
-    // if (root->relates.length()) printf("  Relates
-    // %s\n",root->relates.data());
-    if (root->type.isEmpty()) {
-      findMember(rootNav, root->name + root->args + root->exception, FALSE,
-                 isFunc);
-    } else {
-      findMember(rootNav,
-                 root->type + " " + root->name + root->args + root->exception,
-                 FALSE, isFunc);
-    }
-  } else if (root->section == Entry::OVERLOADDOC_SEC) {
-    // printf("Overloaded member %s found\n",root->name.data());
-    findMember(rootNav, root->name, TRUE, isFunc);
-  } else if ((root->section == Entry::FUNCTION_SEC        // function
-              || (root->section == Entry::VARIABLE_SEC && // variable
-                  !root->type.isEmpty() &&                // with a type
-                  g_compoundKeywordDict.find(root->type) ==
-                      0 // that is not a keyword
-                        // (to skip forward declaration of class etc.)
-                  ))) {
-    // printf("Documentation for member `%s' found args=`%s' excp=`%s'\n",
-    //    root->name.data(),root->args.data(),root->exception.data());
-    // if (root->relates.length()) printf("  Relates
-    // %s\n",root->relates.data());
-    // printf("Inside=%s\n
-    // Relates=%s\n",root->inside.data(),root->relates.data());
-    if (root->type == "friend class" || root->type == "friend struct" ||
-        root->type == "friend union") {
-      findMember(rootNav, root->type + " " + root->name, FALSE, FALSE);
-
-    } else if (!root->type.isEmpty()) {
-      findMember(rootNav, root->type + " " + root->inside + root->name +
-                              root->args + root->exception,
-                 FALSE, isFunc);
-    } else {
-      findMember(rootNav,
-                 root->inside + root->name + root->args + root->exception,
-                 FALSE, isFunc);
-    }
-  } else if (root->section == Entry::DEFINE_SEC && !root->relates.isEmpty()) {
-    findMember(rootNav, root->name + root->args, FALSE, !root->args.isEmpty());
-  } else if (root->section == Entry::VARIABLEDOC_SEC) {
-    // printf("Documentation for variable %s found\n",root->name.data());
-    // if (!root->relates.isEmpty()) printf("  Relates
-    // %s\n",root->relates.data());
-    findMember(rootNav, root->name, FALSE, FALSE);
-  } else if (root->section == Entry::EXPORTED_INTERFACE_SEC ||
-             root->section == Entry::INCLUDED_SERVICE_SEC) {
-    findMember(rootNav, root->type + " " + root->name, FALSE, FALSE);
-  } else {
+    //if (root->relates.length()) printf("  Relates %s\n",root->relates.data());
+    if (root->type.isEmpty())
+    {
+      findMember(rootNav,root->name+root->args+root->exception,FALSE,isFunc);
+    }
+    else
+    {
+      findMember(rootNav,root->type+" "+root->name+root->args+root->exception,FALSE,isFunc);
+    }
+  }
+  else if (root->section==Entry::OVERLOADDOC_SEC)
+  {
+    //printf("Overloaded member %s found\n",root->name.data());
+    findMember(rootNav,root->name,TRUE,isFunc);
+  }
+  else if
+    ((root->section==Entry::FUNCTION_SEC      // function
+      ||
+      (root->section==Entry::VARIABLE_SEC &&  // variable
+       !root->type.isEmpty() &&                // with a type
+       g_compoundKeywordDict.find(root->type)==0 // that is not a keyword
+       // (to skip forward declaration of class etc.)
+      )
+     )
+    )
+    {
+      //printf("Documentation for member `%s' found args=`%s' excp=`%s'\n",
+      //    root->name.data(),root->args.data(),root->exception.data());
+      //if (root->relates.length()) printf("  Relates %s\n",root->relates.data());
+      //printf("Inside=%s\n Relates=%s\n",root->inside.data(),root->relates.data());
+      if (root->type=="friend class" || root->type=="friend struct" ||
+          root->type=="friend union")
+      {
+        findMember(rootNav,
+            root->type+" "+
+            root->name,
+            FALSE,FALSE);
+
+      }
+      else if (!root->type.isEmpty())
+      {
+        findMember(rootNav,
+            root->type+" "+
+            root->inside+
+            root->name+
+            root->args+
+            root->exception,
+            FALSE,isFunc);
+      }
+      else
+      {
+        findMember(rootNav,
+            root->inside+
+            root->name+
+            root->args+
+            root->exception,
+            FALSE,isFunc);
+      }
+    }
+  else if (root->section==Entry::DEFINE_SEC && !root->relates.isEmpty())
+  {
+    findMember(rootNav,root->name+root->args,FALSE,!root->args.isEmpty());
+  }
+  else if (root->section==Entry::VARIABLEDOC_SEC)
+  {
+    //printf("Documentation for variable %s found\n",root->name.data());
+    //if (!root->relates.isEmpty()) printf("  Relates %s\n",root->relates.data());
+    findMember(rootNav,root->name,FALSE,FALSE);
+  }
+  else if (root->section==Entry::EXPORTED_INTERFACE_SEC ||
+           root->section==Entry::INCLUDED_SERVICE_SEC)
+  {
+    findMember(rootNav,root->type + " " + root->name,FALSE,FALSE);
+  }
+  else
+  {
     // skip section
-    // printf("skip section\n");
+    //printf("skip section\n");
   }
 }
 
-static void findMemberDocumentation(EntryNav *rootNav) {
-  if (rootNav->section() == Entry::MEMBERDOC_SEC ||
-      rootNav->section() == Entry::OVERLOADDOC_SEC ||
-      rootNav->section() == Entry::FUNCTION_SEC ||
-      rootNav->section() == Entry::CLAUSE_SEC ||
-      rootNav->section() == Entry::VARIABLE_SEC ||
-      rootNav->section() == Entry::VARIABLEDOC_SEC ||
-      rootNav->section() == Entry::DEFINE_SEC ||
-      rootNav->section() == Entry::INCLUDED_SERVICE_SEC ||
-      rootNav->section() == Entry::EXPORTED_INTERFACE_SEC) {
+static void findMemberDocumentation(EntryNav *rootNav)
+{
+  if (rootNav->section()==Entry::MEMBERDOC_SEC ||
+      rootNav->section()==Entry::OVERLOADDOC_SEC ||
+      rootNav->section()==Entry::FUNCTION_SEC ||
+      rootNav->section()==Entry::VARIABLE_SEC ||
+      rootNav->section()==Entry::VARIABLEDOC_SEC ||
+      rootNav->section()==Entry::DEFINE_SEC ||
+      rootNav->section()==Entry::INCLUDED_SERVICE_SEC ||
+      rootNav->section()==Entry::EXPORTED_INTERFACE_SEC
+     )
+  {
     rootNav->loadEntry(g_storage);
 
     filterMemberDocumentation(rootNav);
 
     rootNav->releaseEntry();
   }
-  if (rootNav->children()) {
+  if (rootNav->children())
+  {
     EntryNavListIterator eli(*rootNav->children());
     EntryNav *e;
-    for (; (e = eli.current()); ++eli) {
-      if (e->section() != Entry::ENUM_SEC)
-        findMemberDocumentation(e);
+    for (;(e=eli.current());++eli)
+    {
+      if (e->section()!=Entry::ENUM_SEC) findMemberDocumentation(e);
     }
   }
 }
 
 //----------------------------------------------------------------------
 
-static void findObjCMethodDefinitions(EntryNav *rootNav) {
-  if (rootNav->children()) {
+static void findObjCMethodDefinitions(EntryNav *rootNav)
+{
+  if (rootNav->children())
+  {
     EntryNavListIterator eli(*rootNav->children());
     EntryNav *objCImplNav;
-    for (; (objCImplNav = eli.current()); ++eli) {
-      if (objCImplNav->section() == Entry::OBJCIMPL_SEC &&
-          objCImplNav->children()) {
+    for (;(objCImplNav=eli.current());++eli)
+    {
+      if (objCImplNav->section()==Entry::OBJCIMPL_SEC && objCImplNav->children())
+      {
         EntryNavListIterator seli(*objCImplNav->children());
         EntryNav *objCMethodNav;
-        for (; (objCMethodNav = seli.current()); ++seli) {
-          if (objCMethodNav->section() == Entry::FUNCTION_SEC) {
+        for (;(objCMethodNav=seli.current());++seli)
+        {
+          if (objCMethodNav->section()==Entry::FUNCTION_SEC)
+          {
             objCMethodNav->loadEntry(g_storage);
             Entry *objCMethod = objCMethodNav->entry();
 
-            // Printf("  Found ObjC method definition
-            // %s\n",objCMethod->name.data());
-            findMember(objCMethodNav,
-                       objCMethod->type + " " + objCImplNav->name() + "::" +
-                           objCMethod->name + " " + objCMethod->args,
-                       FALSE, TRUE);
-            objCMethod->section = Entry::EMPTY_SEC;
+            //Printf("  Found ObjC method definition %s\n",objCMethod->name.data());
+            findMember(objCMethodNav, objCMethod->type+" "+objCImplNav->name()+"::"+
+                       objCMethod->name+" "+objCMethod->args, FALSE,TRUE);
+            objCMethod->section=Entry::EMPTY_SEC;
 
             objCMethodNav->releaseEntry();
           }
@@ -6474,117 +7032,122 @@ static void findObjCMethodDefinitions(EntryNav *rootNav) {
 //----------------------------------------------------------------------
 // find and add the enumeration to their classes, namespaces or files
 
-static void findEnums(EntryNav *rootNav) {
-  if (rootNav->section() == Entry::ENUM_SEC) {
+static void findEnums(EntryNav *rootNav)
+{
+  if (rootNav->section()==Entry::ENUM_SEC)
+  {
     rootNav->loadEntry(g_storage);
     Entry *root = rootNav->entry();
 
-    MemberDef *md = 0;
-    ClassDef *cd = 0;
-    FileDef *fd = 0;
-    NamespaceDef *nd = 0;
-    MemberNameSDict *mnsd = 0;
+    MemberDef      *md=0;
+    ClassDef       *cd=0;
+    FileDef        *fd=0;
+    NamespaceDef   *nd=0;
+    MemberNameSDict *mnsd=0;
     bool isGlobal;
-    bool isRelated = FALSE;
-    bool isMemberOf = FALSE;
-    // printf("Found enum with name `%s'
-    // relates=%s\n",root->name.data(),root->relates.data());
+    bool isRelated=FALSE;
+    bool isMemberOf=FALSE;
+    //printf("Found enum with name `%s' relates=%s\n",root->name.data(),root->relates.data());
     int i;
 
     QCString name;
     QCString scope;
 
-    if ((i = root->name.findRev("::")) != -1) // scope is specified
+    if ((i=root->name.findRev("::"))!=-1) // scope is specified
     {
-      scope = root->name.left(i);                           // extract scope
-      name = root->name.right(root->name.length() - i - 2); // extract name
-      if ((cd = getClass(scope)) == 0)
-        nd = getResolvedNamespace(scope);
-    } else // no scope, check the scope in which the docs where found
+      scope=root->name.left(i); // extract scope
+      name=root->name.right(root->name.length()-i-2); // extract name
+      if ((cd=getClass(scope))==0) nd=getResolvedNamespace(scope);
+    }
+    else // no scope, check the scope in which the docs where found
     {
-      if ((rootNav->parent()->section() & Entry::SCOPE_MASK) &&
-          !rootNav->parent()
-               ->name()
-               .isEmpty()) // found enum docs inside a compound
+      if (( rootNav->parent()->section() & Entry::SCOPE_MASK )
+          && !rootNav->parent()->name().isEmpty()
+         ) // found enum docs inside a compound
       {
-        scope = rootNav->parent()->name();
-        if ((cd = getClass(scope)) == 0)
-          nd = getResolvedNamespace(scope);
+        scope=rootNav->parent()->name();
+        if ((cd=getClass(scope))==0) nd=getResolvedNamespace(scope);
       }
-      name = root->name;
+      name=root->name;
     }
 
-    if (!root->relates
-             .isEmpty()) { // related member, prefix user specified scope
-      isRelated = TRUE;
-      isMemberOf = (root->relatesType == MemberOf);
-      if (getClass(root->relates) == 0 && !scope.isEmpty())
-        scope = mergeScopes(scope, root->relates);
+    if (!root->relates.isEmpty())
+    {   // related member, prefix user specified scope
+      isRelated=TRUE;
+      isMemberOf=(root->relatesType == MemberOf);
+      if (getClass(root->relates)==0 && !scope.isEmpty())
+        scope=mergeScopes(scope,root->relates);
       else
-        scope = root->relates.copy();
-      if ((cd = getClass(scope)) == 0)
-        nd = getResolvedNamespace(scope);
+        scope=root->relates.copy();
+      if ((cd=getClass(scope))==0) nd=getResolvedNamespace(scope);
     }
 
     if (cd && !name.isEmpty()) // found a enum inside a compound
     {
-      // printf("Enum `%s'::`%s'\n",cd->name().data(),name.data());
-      fd = 0;
-      mnsd = Doxygen::memberNameSDict;
-      isGlobal = FALSE;
-    } else if (nd && !nd->name().isEmpty() &&
-               nd->name().at(0) != '@') // found enum inside namespace
+      //printf("Enum `%s'::`%s'\n",cd->name().data(),name.data());
+      fd=0;
+      mnsd=Doxygen::memberNameSDict;
+      isGlobal=FALSE;
+    }
+    else if (nd && !nd->name().isEmpty() && nd->name().at(0)!='@') // found enum inside namespace
     {
-      mnsd = Doxygen::functionNameSDict;
-      isGlobal = TRUE;
-    } else // found a global enum
+      mnsd=Doxygen::functionNameSDict;
+      isGlobal=TRUE;
+    }
+    else // found a global enum
     {
-      fd = rootNav->fileDef();
-      mnsd = Doxygen::functionNameSDict;
-      isGlobal = TRUE;
+      fd=rootNav->fileDef();
+      mnsd=Doxygen::functionNameSDict;
+      isGlobal=TRUE;
     }
 
-    if (!name.isEmpty()) {
+    if (!name.isEmpty())
+    {
       // new enum type
-      md = new MemberDef(root->fileName, root->startLine, root->startColumn, 0,
-                         name, 0, 0, root->protection, Normal, FALSE,
-                         isMemberOf ? Foreign : isRelated ? Related : Member,
-                         MemberType_Enumeration, 0, 0);
+      md = new MemberDef(
+          root->fileName,root->startLine,root->startColumn,
+          0,name,0,0,
+          root->protection,Normal,FALSE,
+          isMemberOf ? Foreign : isRelated ? Related : Member,
+          MemberType_Enumeration,
+          0,0);
       md->setTagInfo(rootNav->tagInfo());
       md->setLanguage(root->lang);
       md->setId(root->id);
-      if (!isGlobal)
-        md->setMemberClass(cd);
-      else
-        md->setFileDef(fd);
-      md->setBodySegment(root->bodyLine, root->endBodyLine);
+      if (!isGlobal) md->setMemberClass(cd); else md->setFileDef(fd);
+      md->setBodySegment(root->bodyLine,root->endBodyLine);
       md->setBodyDef(rootNav->fileDef());
       md->setMemberSpecifiers(root->spec);
       md->setEnumBaseType(root->args);
-      // printf("Enum %s definition at line %d of %s: protection=%d scope=%s\n",
+      //printf("Enum %s definition at line %d of %s: protection=%d scope=%s\n",
       //    root->name.data(),root->bodyLine,root->fileName.data(),root->protection,cd?cd->name().data():"<none>");
       md->addSectionsToDefinition(root->anchors);
       md->setMemberGroupId(root->mGrpId);
       md->enableCallGraph(root->callGraph);
       md->enableCallerGraph(root->callerGraph);
-      // printf("%s::setRefItems(%d)\n",md->name().data(),root->sli?root->sli->count():-1);
+      //printf("%s::setRefItems(%d)\n",md->name().data(),root->sli?root->sli->count():-1);
       md->setRefItems(root->sli);
-      // printf("found enum %s nd=%p\n",md->name().data(),nd);
-      bool defSet = FALSE;
+      //printf("found enum %s nd=%p\n",md->name().data(),nd);
+      bool defSet=FALSE;
 
       QCString baseType = root->args;
-      if (!baseType.isEmpty()) {
+      if (!baseType.isEmpty())
+      {
         baseType.prepend(" : ");
       }
 
-      if (nd && !nd->name().isEmpty() && nd->name().at(0) != '@') {
-        if (isRelated || Config_getBool(HIDE_SCOPE_NAMES)) {
-          md->setDefinition(name + baseType);
-        } else {
-          md->setDefinition(nd->name() + "::" + name + baseType);
+      if (nd && !nd->name().isEmpty() && nd->name().at(0)!='@')
+      {
+        if (isRelated || Config_getBool(HIDE_SCOPE_NAMES))
+        {
+          md->setDefinition(name+baseType);
         }
-        // printf("definition=%s\n",md->definition());
-        defSet = TRUE;
+        else
+        {
+          md->setDefinition(nd->name()+"::"+name+baseType);
+        }
+        //printf("definition=%s\n",md->definition());
+        defSet=TRUE;
         md->setNamespace(nd);
         nd->insertMember(md);
       }
@@ -6592,186 +7155,193 @@ static void findEnums(EntryNav *rootNav) {
       // even if we have already added the enum to a namespace, we still
       // also want to add it to other appropriate places such as file
       // or class.
-      if (isGlobal) {
-        if (!defSet)
-          md->setDefinition(name + baseType);
-        if (fd == 0 && rootNav->parent()) {
-          fd = rootNav->parent()->fileDef();
+      if (isGlobal)
+      {
+        if (!defSet) md->setDefinition(name+baseType);
+        if (fd==0 && rootNav->parent())
+        {
+          fd=rootNav->parent()->fileDef();
         }
-        if (fd) {
+        if (fd)
+        {
           md->setFileDef(fd);
           fd->insertMember(md);
         }
-      } else if (cd) {
-        if (isRelated || Config_getBool(HIDE_SCOPE_NAMES)) {
-          md->setDefinition(name + baseType);
-        } else {
-          md->setDefinition(cd->name() + "::" + name + baseType);
+      }
+      else if (cd)
+      {
+        if (isRelated || Config_getBool(HIDE_SCOPE_NAMES))
+        {
+          md->setDefinition(name+baseType);
+        }
+        else
+        {
+          md->setDefinition(cd->name()+"::"+name+baseType);
         }
         cd->insertMember(md);
         cd->insertUsedFile(fd);
       }
-      md->setDocumentation(root->doc, root->docFile, root->docLine);
+      md->setDocumentation(root->doc,root->docFile,root->docLine);
       md->setDocsForDefinition(!root->proto);
-      md->setBriefDescription(root->brief, root->briefFile, root->briefLine);
-      md->setInbodyDocumentation(root->inbodyDocs, root->inbodyFile,
-                                 root->inbodyLine);
+      md->setBriefDescription(root->brief,root->briefFile,root->briefLine);
+      md->setInbodyDocumentation(root->inbodyDocs,root->inbodyFile,root->inbodyLine);
 
-      // printf("Adding member=%s\n",md->name().data());
+      //printf("Adding member=%s\n",md->name().data());
       MemberName *mn;
-      if ((mn = (*mnsd)[name])) {
+      if ((mn=(*mnsd)[name]))
+      {
         // this is used if the same enum is in multiple namespaces/classes
         mn->append(md);
-      } else // new enum name
+      }
+      else // new enum name
       {
         mn = new MemberName(name);
         mn->append(md);
-        mnsd->append(name, mn);
-        // printf("add %s to new memberName. Now %d members\n",
+        mnsd->append(name,mn);
+        //printf("add %s to new memberName. Now %d members\n",
         //       name.data(),mn->count());
       }
-      addMemberToGroups(root, md);
+      addMemberToGroups(root,md);
     }
     rootNav->releaseEntry();
-  } else {
-    RECURSE_ENTRYTREE(findEnums, rootNav);
+  }
+  else
+  {
+    RECURSE_ENTRYTREE(findEnums,rootNav);
   }
 }
 
 //----------------------------------------------------------------------
 
-static void addEnumValuesToEnums(EntryNav *rootNav) {
-  if (rootNav->section() == Entry::ENUM_SEC)
-  // non anonymous enumeration
+static void addEnumValuesToEnums(EntryNav *rootNav)
+{
+  if (rootNav->section()==Entry::ENUM_SEC)
+    // non anonymous enumeration
   {
     rootNav->loadEntry(g_storage);
     Entry *root = rootNav->entry();
 
-    ClassDef *cd = 0;
-    FileDef *fd = 0;
-    NamespaceDef *nd = 0;
-    MemberNameSDict *mnsd = 0;
+    ClassDef       *cd=0;
+    FileDef        *fd=0;
+    NamespaceDef   *nd=0;
+    MemberNameSDict *mnsd=0;
     bool isGlobal;
-    bool isRelated = FALSE;
-    // printf("Found enum with name `%s'
-    // relates=%s\n",root->name.data(),root->relates.data());
+    bool isRelated=FALSE;
+    //printf("Found enum with name `%s' relates=%s\n",root->name.data(),root->relates.data());
     int i;
 
     QCString name;
     QCString scope;
 
-    if ((i = root->name.findRev("::")) != -1) // scope is specified
+    if ((i=root->name.findRev("::"))!=-1) // scope is specified
     {
-      scope = root->name.left(i);                           // extract scope
-      name = root->name.right(root->name.length() - i - 2); // extract name
-      if ((cd = getClass(scope)) == 0)
-        nd = getResolvedNamespace(scope);
-    } else // no scope, check the scope in which the docs where found
+      scope=root->name.left(i); // extract scope
+      name=root->name.right(root->name.length()-i-2); // extract name
+      if ((cd=getClass(scope))==0) nd=getResolvedNamespace(scope);
+    }
+    else // no scope, check the scope in which the docs where found
     {
-      if ((rootNav->parent()->section() & Entry::SCOPE_MASK) &&
-          !rootNav->parent()
-               ->name()
-               .isEmpty()) // found enum docs inside a compound
+      if (( rootNav->parent()->section() & Entry::SCOPE_MASK )
+          && !rootNav->parent()->name().isEmpty()
+         ) // found enum docs inside a compound
       {
-        scope = rootNav->parent()->name();
-        if ((cd = getClass(scope)) == 0)
-          nd = getResolvedNamespace(scope);
+        scope=rootNav->parent()->name();
+        if ((cd=getClass(scope))==0) nd=getResolvedNamespace(scope);
       }
-      name = root->name;
+      name=root->name;
     }
 
-    if (!root->relates
-             .isEmpty()) { // related member, prefix user specified scope
-      isRelated = TRUE;
-      if (getClass(root->relates) == 0 && !scope.isEmpty())
-        scope = mergeScopes(scope, root->relates);
+    if (!root->relates.isEmpty())
+    {   // related member, prefix user specified scope
+      isRelated=TRUE;
+      if (getClass(root->relates)==0 && !scope.isEmpty())
+        scope=mergeScopes(scope,root->relates);
       else
-        scope = root->relates.copy();
-      if ((cd = getClass(scope)) == 0)
-        nd = getResolvedNamespace(scope);
+        scope=root->relates.copy();
+      if ((cd=getClass(scope))==0) nd=getResolvedNamespace(scope);
     }
 
     if (cd && !name.isEmpty()) // found a enum inside a compound
     {
-      // printf("Enum in class `%s'::`%s'\n",cd->name().data(),name.data());
-      fd = 0;
-      mnsd = Doxygen::memberNameSDict;
-      isGlobal = FALSE;
-    } else if (nd && !nd->name().isEmpty() &&
-               nd->name().at(0) != '@') // found enum inside namespace
+      //printf("Enum in class `%s'::`%s'\n",cd->name().data(),name.data());
+      fd=0;
+      mnsd=Doxygen::memberNameSDict;
+      isGlobal=FALSE;
+    }
+    else if (nd && !nd->name().isEmpty() && nd->name().at(0)!='@') // found enum inside namespace
     {
-      // printf("Enum in namespace `%s'::`%s'\n",nd->name().data(),name.data());
-      mnsd = Doxygen::functionNameSDict;
-      isGlobal = TRUE;
-    } else // found a global enum
+      //printf("Enum in namespace `%s'::`%s'\n",nd->name().data(),name.data());
+      mnsd=Doxygen::functionNameSDict;
+      isGlobal=TRUE;
+    }
+    else // found a global enum
     {
-      fd = rootNav->fileDef();
-      // printf("Enum in file `%s': `%s'\n",fd->name().data(),name.data());
-      mnsd = Doxygen::functionNameSDict;
-      isGlobal = TRUE;
+      fd=rootNav->fileDef();
+      //printf("Enum in file `%s': `%s'\n",fd->name().data(),name.data());
+      mnsd=Doxygen::functionNameSDict;
+      isGlobal=TRUE;
     }
 
-    if (!name.isEmpty()) {
-      // printf("** name=%s\n",name.data());
+    if (!name.isEmpty())
+    {
+      //printf("** name=%s\n",name.data());
       MemberName *mn = mnsd->find(name); // for all members with this name
-      if (mn) {
+      if (mn)
+      {
         MemberNameIterator mni(*mn);
         MemberDef *md;
-        for (mni.toFirst(); (md = mni.current());
-             ++mni) // for each enum in this list
-        {
-          if (md->isEnumerate() && rootNav->children()) {
-            // printf("   enum with %d
-            // children\n",rootNav->children()->count());
-            EntryNavListIterator eli(
-                *rootNav->children()); // for each enum value
+        for (mni.toFirst(); (md=mni.current()) ; ++mni)  // for each enum in this list
+        {
+          if (md->isEnumerate() && rootNav->children())
+          {
+            //printf("   enum with %d children\n",rootNav->children()->count());
+            EntryNavListIterator eli(*rootNav->children()); // for each enum value
             EntryNav *e;
-            for (; (e = eli.current()); ++eli) {
+            for (;(e=eli.current());++eli)
+            {
               SrcLangExt sle;
-              if ((sle = rootNav->lang()) == SrcLangExt_CSharp ||
-                  sle == SrcLangExt_Java || sle == SrcLangExt_XML ||
-                  (root->spec & Entry::Strong)) {
+              if (
+                   (sle=rootNav->lang())==SrcLangExt_CSharp ||
+                   sle==SrcLangExt_Java ||
+                   sle==SrcLangExt_XML ||
+                   (root->spec&Entry::Strong)
+                 )
+              {
                 // Unlike classic C/C++ enums, for C++11, C# & Java enum
-                // values are only visible inside the enum scope, so we must
-                // create
+                // values are only visible inside the enum scope, so we must create
                 // them here and only add them to the enum
                 e->loadEntry(g_storage);
                 Entry *root = e->entry();
-                // printf("md->qualifiedName()=%s rootNav->name()=%s tagInfo=%p
-                // name=%s\n",
+                //printf("md->qualifiedName()=%s rootNav->name()=%s tagInfo=%p name=%s\n",
                 //    md->qualifiedName().data(),rootNav->name().data(),rootNav->tagInfo(),root->name.data());
-                QCString qualifiedName = substitute(rootNav->name(), "::", ".");
-                if (!scope.isEmpty() && rootNav->tagInfo()) {
-                  qualifiedName =
-                      substitute(scope, "::", ".") + "." + qualifiedName;
+                QCString qualifiedName = substitute(rootNav->name(),"::",".");
+                if (!scope.isEmpty() && rootNav->tagInfo())
+                {
+                  qualifiedName=substitute(scope,"::",".")+"."+qualifiedName;
                 }
-                if (substitute(md->qualifiedName(), "::",
-                               ".") == // TODO: add function to get canonical
-                                       // representation
-                    qualifiedName // enum value scope matches that of the enum
-                    ) {
+                if (substitute(md->qualifiedName(),"::",".")== // TODO: add function to get canonical representation
+                    qualifiedName       // enum value scope matches that of the enum
+                   )
+                {
                   QCString fileName = root->fileName;
-                  if (fileName.isEmpty() && rootNav->tagInfo()) {
+                  if (fileName.isEmpty() && rootNav->tagInfo())
+                  {
                     fileName = rootNav->tagInfo()->tagName;
                   }
-                  MemberDef *fmd = new MemberDef(
-                      fileName, root->startLine, root->startColumn, root->type,
-                      root->name, root->args, 0, root->protection, Normal,
-                      root->stat, Member, MemberType_EnumValue, 0, 0);
-                  if (md->getClassDef())
-                    fmd->setMemberClass(md->getClassDef());
-                  else if (md->getNamespaceDef())
-                    fmd->setNamespace(md->getNamespaceDef());
-                  else if (md->getFileDef())
-                    fmd->setFileDef(md->getFileDef());
+                  MemberDef *fmd=new MemberDef(
+                      fileName,root->startLine,root->startColumn,
+                      root->type,root->name,root->args,0,
+                      root->protection, Normal,root->stat,Member,
+                      MemberType_EnumValue,0,0);
+                  if      (md->getClassDef())     fmd->setMemberClass(md->getClassDef());
+                  else if (md->getNamespaceDef()) fmd->setNamespace(md->getNamespaceDef());
+                  else if (md->getFileDef())      fmd->setFileDef(md->getFileDef());
                   fmd->setOuterScope(md->getOuterScope());
                   fmd->setTagInfo(e->tagInfo());
                   fmd->setLanguage(root->lang);
                   fmd->setId(root->id);
-                  fmd->setDocumentation(root->doc, root->docFile,
-                                        root->docLine);
-                  fmd->setBriefDescription(root->brief, root->briefFile,
-                                           root->briefLine);
+                  fmd->setDocumentation(root->doc,root->docFile,root->docLine);
+                  fmd->setBriefDescription(root->brief,root->briefFile,root->briefLine);
                   fmd->addSectionsToDefinition(root->anchors);
                   fmd->setInitializer(root->initializer);
                   fmd->setMaxInitLines(root->initLines);
@@ -6780,53 +7350,57 @@ static void addEnumValuesToEnums(EntryNav *rootNav) {
                   fmd->setRefItems(root->sli);
                   fmd->setAnchor();
                   md->insertEnumField(fmd);
-                  fmd->setEnumScope(md, TRUE);
-                  MemberName *mn = mnsd->find(root->name);
-                  if (mn) {
+                  fmd->setEnumScope(md,TRUE);
+                  MemberName *mn=mnsd->find(root->name);
+                  if (mn)
+                  {
                     mn->append(fmd);
-                  } else {
+                  }
+                  else
+                  {
                     mn = new MemberName(root->name);
                     mn->append(fmd);
-                    mnsd->append(root->name, mn);
+                    mnsd->append(root->name,mn);
                   }
                 }
                 e->releaseEntry();
-              } else {
-                // printf("e->name=%s
-                // isRelated=%d\n",e->name().data(),isRelated);
-                MemberName *fmn = 0;
-                MemberNameSDict *emnsd =
-                    isRelated ? Doxygen::functionNameSDict : mnsd;
-                if (!e->name().isEmpty() && (fmn = (*emnsd)[e->name()]))
-                // get list of members with the same name as the field
+              }
+              else
+              {
+                //printf("e->name=%s isRelated=%d\n",e->name().data(),isRelated);
+                MemberName *fmn=0;
+                MemberNameSDict *emnsd = isRelated ? Doxygen::functionNameSDict : mnsd;
+                if (!e->name().isEmpty() && (fmn=(*emnsd)[e->name()]))
+                  // get list of members with the same name as the field
                 {
                   MemberNameIterator fmni(*fmn);
                   MemberDef *fmd;
-                  for (fmni.toFirst(); (fmd = fmni.current()); ++fmni) {
-                    if (fmd->isEnumValue() &&
-                        fmd->getOuterScope() ==
-                            md->getOuterScope()) // in same scope
+                  for (fmni.toFirst(); (fmd=fmni.current()) ; ++fmni)
+                  {
+                    if (fmd->isEnumValue() && fmd->getOuterScope()==md->getOuterScope()) // in same scope
                     {
-                      // printf("found enum value with same name %s in scope
-                      // %s\n",
+                      //printf("found enum value with same name %s in scope %s\n",
                       //    fmd->name().data(),fmd->getOuterScope()->name().data());
-                      if (nd && !nd->name().isEmpty() &&
-                          nd->name().at(0) != '@') {
-                        NamespaceDef *fnd = fmd->getNamespaceDef();
-                        if (fnd == nd) // enum value is inside a namespace
+                      if (nd && !nd->name().isEmpty() && nd->name().at(0)!='@')
+                      {
+                        NamespaceDef *fnd=fmd->getNamespaceDef();
+                        if (fnd==nd) // enum value is inside a namespace
                         {
                           md->insertEnumField(fmd);
                           fmd->setEnumScope(md);
                         }
-                      } else if (isGlobal) {
-                        FileDef *ffd = fmd->getFileDef();
-                        if (ffd == fd) // enum value has file scope
+                      }
+                      else if (isGlobal)
+                      {
+                        FileDef *ffd=fmd->getFileDef();
+                        if (ffd==fd) // enum value has file scope
                         {
                           md->insertEnumField(fmd);
                           fmd->setEnumScope(md);
                         }
-                      } else if (isRelated && cd) // reparent enum value to
-                                                  // match the enum's scope
+                      }
+                      else if (isRelated && cd) // reparent enum value to
+                                                // match the enum's scope
                       {
                         md->insertEnumField(fmd);   // add field def to list
                         fmd->setEnumScope(md);      // cross ref with enum name
@@ -6834,12 +7408,13 @@ static void addEnumValuesToEnums(EntryNav *rootNav) {
                         fmd->setOuterScope(cd);
                         fmd->makeRelated();
                         cd->insertMember(fmd);
-                      } else {
-                        ClassDef *fcd = fmd->getClassDef();
-                        if (fcd == cd) // enum value is inside a class
+                      }
+                      else
+                      {
+                        ClassDef *fcd=fmd->getClassDef();
+                        if (fcd==cd) // enum value is inside a class
                         {
-                          // printf("Inserting enum field %s in enum scope
-                          // %s\n",
+                          //printf("Inserting enum field %s in enum scope %s\n",
                           //    fmd->name().data(),md->name().data());
                           md->insertEnumField(fmd); // add field def to list
                           fmd->setEnumScope(md);    // cross ref with enum name
@@ -6856,175 +7431,188 @@ static void addEnumValuesToEnums(EntryNav *rootNav) {
     }
 
     rootNav->releaseEntry();
-  } else {
-    RECURSE_ENTRYTREE(addEnumValuesToEnums, rootNav);
+  }
+  else
+  {
+    RECURSE_ENTRYTREE(addEnumValuesToEnums,rootNav);
   }
 }
 
+
 //----------------------------------------------------------------------
 // find the documentation blocks for the enumerations
 
-static void findEnumDocumentation(EntryNav *rootNav) {
-  if (rootNav->section() == Entry::ENUMDOC_SEC && !rootNav->name().isEmpty() &&
-      rootNav->name().at(0) != '@' // skip anonymous enums
-      ) {
+static void findEnumDocumentation(EntryNav *rootNav)
+{
+  if (rootNav->section()==Entry::ENUMDOC_SEC
+      && !rootNav->name().isEmpty()
+      && rootNav->name().at(0)!='@'        // skip anonymous enums
+     )
+  {
     rootNav->loadEntry(g_storage);
     Entry *root = rootNav->entry();
 
-    // printf("Found docs for enum with name `%s' in context %s\n",
+    //printf("Found docs for enum with name `%s' in context %s\n",
     //    root->name.data(),root->parent->name.data());
     int i;
     QCString name;
     QCString scope;
-    if ((i = root->name.findRev("::")) !=
-        -1) // scope is specified as part of the name
+    if ((i=root->name.findRev("::"))!=-1) // scope is specified as part of the name
     {
-      name = root->name.right(root->name.length() - i - 2); // extract name
-      scope = root->name.left(i);                           // extract scope
-      // printf("Scope=`%s' Name=`%s'\n",scope.data(),name.data());
-    } else // just the name
+      name=root->name.right(root->name.length()-i-2); // extract name
+      scope=root->name.left(i); // extract scope
+      //printf("Scope=`%s' Name=`%s'\n",scope.data(),name.data());
+    }
+    else // just the name
     {
-      name = root->name;
+      name=root->name;
     }
-    if ((rootNav->parent()->section() & Entry::SCOPE_MASK) &&
-        !rootNav->parent()
-             ->name()
-             .isEmpty()) // found enum docs inside a compound
+    if (( rootNav->parent()->section() & Entry::SCOPE_MASK )
+        && !rootNav->parent()->name().isEmpty()
+       ) // found enum docs inside a compound
     {
-      if (!scope.isEmpty())
-        scope.prepend("::");
+      if (!scope.isEmpty()) scope.prepend("::");
       scope.prepend(rootNav->parent()->name());
     }
-    ClassDef *cd = getClass(scope);
+    ClassDef *cd=getClass(scope);
 
-    if (!name.isEmpty()) {
-      bool found = FALSE;
-      if (cd) {
-        // printf("Enum: scope=`%s' name=`%s'\n",cd->name(),name.data());
-        QCString className = cd->name().copy();
-        MemberName *mn = Doxygen::memberNameSDict->find(name);
-        if (mn) {
+    if (!name.isEmpty())
+    {
+      bool found=FALSE;
+      if (cd)
+      {
+        //printf("Enum: scope=`%s' name=`%s'\n",cd->name(),name.data());
+        QCString className=cd->name().copy();
+        MemberName *mn=Doxygen::memberNameSDict->find(name);
+        if (mn)
+        {
           MemberNameIterator mni(*mn);
           MemberDef *md;
-          for (mni.toFirst(); (md = mni.current()) && !found; ++mni) {
-            ClassDef *cd = md->getClassDef();
-            if (cd && cd->name() == className && md->isEnumerate()) {
-// documentation outside a compound overrides the documentation inside it
+          for (mni.toFirst();(md=mni.current()) && !found;++mni)
+          {
+            ClassDef *cd=md->getClassDef();
+            if (cd && cd->name()==className && md->isEnumerate())
+            {
+              // documentation outside a compound overrides the documentation inside it
 #if 0
               if (!md->documentation() || rootNav->parent()->name().isEmpty())
 #endif
               {
-                md->setDocumentation(root->doc, root->docFile, root->docLine);
+                md->setDocumentation(root->doc,root->docFile,root->docLine);
                 md->setDocsForDefinition(!root->proto);
               }
 
-// brief descriptions inside a compound override the documentation
-// outside it
+              // brief descriptions inside a compound override the documentation
+              // outside it
 #if 0
               if (!md->briefDescription() || !rootNav->parent()->name().isEmpty())
 #endif
               {
-                md->setBriefDescription(root->brief, root->briefFile,
-                                        root->briefLine);
+                md->setBriefDescription(root->brief,root->briefFile,root->briefLine);
               }
 
-              if (!md->inbodyDocumentation() ||
-                  !rootNav->parent()->name().isEmpty()) {
-                md->setInbodyDocumentation(root->inbodyDocs, root->inbodyFile,
-                                           root->inbodyLine);
+              if (!md->inbodyDocumentation() || !rootNav->parent()->name().isEmpty())
+              {
+                md->setInbodyDocumentation(root->inbodyDocs,root->inbodyFile,root->inbodyLine);
               }
 
-              if (root->mGrpId != -1 && md->getMemberGroupId() == -1) {
+              if (root->mGrpId!=-1 && md->getMemberGroupId()==-1)
+              {
                 md->setMemberGroupId(root->mGrpId);
               }
 
               md->addSectionsToDefinition(root->anchors);
               md->setRefItems(root->sli);
 
-              GroupDef *gd = md->getGroupDef();
-              if (gd == 0 &&
-                  root->groups->getFirst() !=
-                      0) // member not grouped but out-of-line documentation is
+              GroupDef *gd=md->getGroupDef();
+              if (gd==0 &&root->groups->getFirst()!=0) // member not grouped but out-of-line documentation is
               {
-                addMemberToGroups(root, md);
+                addMemberToGroups(root,md);
               }
 
-              found = TRUE;
+              found=TRUE;
             }
           }
-        } else {
-          // printf("MemberName %s not found!\n",name.data());
         }
-      } else // enum outside class
+        else
+        {
+          //printf("MemberName %s not found!\n",name.data());
+        }
+      }
+      else // enum outside class
       {
-        // printf("Enum outside class: %s grpId=%d\n",name.data(),root->mGrpId);
-        MemberName *mn = Doxygen::functionNameSDict->find(name);
-        if (mn) {
+        //printf("Enum outside class: %s grpId=%d\n",name.data(),root->mGrpId);
+        MemberName *mn=Doxygen::functionNameSDict->find(name);
+        if (mn)
+        {
           MemberNameIterator mni(*mn);
           MemberDef *md;
-          for (mni.toFirst(); (md = mni.current()) && !found; ++mni) {
-            if (md->isEnumerate()) {
-              md->setDocumentation(root->doc, root->docFile, root->docLine);
+          for (mni.toFirst();(md=mni.current()) && !found;++mni)
+          {
+            if (md->isEnumerate())
+            {
+              md->setDocumentation(root->doc,root->docFile,root->docLine);
               md->setDocsForDefinition(!root->proto);
-              md->setBriefDescription(root->brief, root->briefFile,
-                                      root->briefLine);
-              md->setInbodyDocumentation(root->inbodyDocs, root->inbodyFile,
-                                         root->inbodyLine);
+              md->setBriefDescription(root->brief,root->briefFile,root->briefLine);
+              md->setInbodyDocumentation(root->inbodyDocs,root->inbodyFile,root->inbodyLine);
               md->addSectionsToDefinition(root->anchors);
               md->setMemberGroupId(root->mGrpId);
 
-              GroupDef *gd = md->getGroupDef();
-              if (gd == 0 &&
-                  root->groups->getFirst() !=
-                      0) // member not grouped but out-of-line documentation is
+              GroupDef *gd=md->getGroupDef();
+              if (gd==0 && root->groups->getFirst()!=0) // member not grouped but out-of-line documentation is
               {
-                addMemberToGroups(root, md);
+                addMemberToGroups(root,md);
               }
 
-              found = TRUE;
+              found=TRUE;
             }
           }
         }
       }
-      if (!found) {
-        warn(root->fileName, root->startLine,
-             "Documentation for undefined enum `%s' found.", name.data());
+      if (!found)
+      {
+        warn(root->fileName,root->startLine,
+             "Documentation for undefined enum `%s' found.",
+             name.data()
+            );
       }
     }
 
     rootNav->releaseEntry();
   }
-  RECURSE_ENTRYTREE(findEnumDocumentation, rootNav);
+  RECURSE_ENTRYTREE(findEnumDocumentation,rootNav);
 }
 
 // search for each enum (member or function) in mnl if it has documented
 // enum values.
-static void findDEV(const MemberNameSDict &mnsd) {
+static void findDEV(const MemberNameSDict &mnsd)
+{
   MemberName *mn;
   MemberNameSDict::Iterator mnli(mnsd);
   // for each member name
-  for (mnli.toFirst(); (mn = mnli.current()); ++mnli) {
+  for (mnli.toFirst();(mn=mnli.current());++mnli)
+  {
     MemberDef *md;
     MemberNameIterator mni(*mn);
     // for each member definition
-    for (mni.toFirst(); (md = mni.current()); ++mni) {
+    for (mni.toFirst();(md=mni.current());++mni)
+    {
       if (md->isEnumerate()) // member is an enum
       {
         MemberList *fmdl = md->enumFieldList();
-        int documentedEnumValues = 0;
+        int documentedEnumValues=0;
         if (fmdl) // enum has values
         {
           MemberListIterator fmni(*fmdl);
           MemberDef *fmd;
           // for each enum value
-          for (fmni.toFirst(); (fmd = fmni.current()); ++fmni) {
-            if (fmd->isLinkableInProject())
-              documentedEnumValues++;
+          for (fmni.toFirst();(fmd=fmni.current());++fmni)
+          {
+            if (fmd->isLinkableInProject()) documentedEnumValues++;
           }
         }
         // at least one enum value is documented
-        if (documentedEnumValues > 0)
-          md->setDocumentedEnumValues(TRUE);
+        if (documentedEnumValues>0) md->setDocumentedEnumValues(TRUE);
       }
     }
   }
@@ -7032,35 +7620,44 @@ static void findDEV(const MemberNameSDict &mnsd) {
 
 // search for each enum (member or function) if it has documented enum
 // values.
-static void findDocumentedEnumValues() {
+static void findDocumentedEnumValues()
+{
   findDEV(*Doxygen::memberNameSDict);
   findDEV(*Doxygen::functionNameSDict);
 }
 
 //----------------------------------------------------------------------
 
-static void addMembersToIndex() {
+static void addMembersToIndex()
+{
   MemberName *mn;
   MemberNameSDict::Iterator mnli(*Doxygen::memberNameSDict);
   // for each member name
-  for (mnli.toFirst(); (mn = mnli.current()); ++mnli) {
+  for (mnli.toFirst();(mn=mnli.current());++mnli)
+  {
     MemberDef *md;
     MemberNameIterator mni(*mn);
     // for each member definition
-    for (mni.toFirst(); (md = mni.current()); ++mni) {
+    for (mni.toFirst();(md=mni.current());++mni)
+    {
       addClassMemberNameToIndex(md);
     }
   }
   MemberNameSDict::Iterator fnli(*Doxygen::functionNameSDict);
   // for each member name
-  for (fnli.toFirst(); (mn = fnli.current()); ++fnli) {
+  for (fnli.toFirst();(mn=fnli.current());++fnli)
+  {
     MemberDef *md;
     MemberNameIterator mni(*mn);
     // for each member definition
-    for (mni.toFirst(); (md = mni.current()); ++mni) {
-      if (md->getNamespaceDef()) {
+    for (mni.toFirst();(md=mni.current());++mni)
+    {
+      if (md->getNamespaceDef())
+      {
         addNamespaceMemberNameToIndex(md);
-      } else {
+      }
+      else
+      {
         addFileMemberNameToIndex(md);
       }
     }
@@ -7072,53 +7669,61 @@ static void addMembersToIndex() {
 // the members that override the implementation of `m' are searched and
 // the member that `m' overrides is searched.
 
-static void computeMemberRelations() {
+static void computeMemberRelations()
+{
   MemberNameSDict::Iterator mnli(*Doxygen::memberNameSDict);
   MemberName *mn;
-  for (; (mn = mnli.current()); ++mnli) // for each member name
+  for ( ; (mn=mnli.current()) ; ++mnli ) // for each member name
   {
     MemberNameIterator mdi(*mn);
     MemberNameIterator bmdi(*mn);
     MemberDef *md;
     MemberDef *bmd;
-    for (; (md = mdi.current()); ++mdi) // for each member with a specific name
+    for ( ; (md=mdi.current()) ; ++mdi ) // for each member with a specific name
     {
-      for (bmdi.toFirst(); (bmd = bmdi.current());
-           ++bmdi) // for each other member with the same name
+      for ( bmdi.toFirst() ; (bmd=bmdi.current()); ++bmdi ) // for each other member with the same name
       {
-        ClassDef *mcd = md->getClassDef();
-        if (mcd && mcd->baseClasses()) {
+        ClassDef *mcd  = md->getClassDef();
+        if (mcd && mcd->baseClasses())
+        {
           ClassDef *bmcd = bmd->getClassDef();
-          // printf("Check relation between `%s'::`%s' (%p) and `%s'::`%s'
-          // (%p)\n",
+          //printf("Check relation between `%s'::`%s' (%p) and `%s'::`%s' (%p)\n",
           //      mcd->name().data(),md->name().data(),md,
           //       bmcd->name().data(),bmd->name().data(),bmd
           //      );
-          if (md != bmd && bmcd && mcd && bmcd != mcd &&
-              (bmd->virtualness() != Normal ||
-               bmcd->compoundType() == ClassDef::Interface ||
-               bmcd->compoundType() == ClassDef::Protocol) &&
-              md->isFunction() && mcd->isLinkable() && bmcd->isLinkable() &&
-              mcd->isBaseClass(bmcd, TRUE)) {
-            // printf("  derived scope\n");
+          if (md!=bmd && bmcd && mcd && bmcd!=mcd &&
+              (bmd->virtualness()!=Normal ||
+               bmcd->compoundType()==ClassDef::Interface ||
+               bmcd->compoundType()==ClassDef::Protocol
+              ) &&
+              md->isFunction() &&
+              mcd->isLinkable() &&
+              bmcd->isLinkable() &&
+              mcd->isBaseClass(bmcd,TRUE))
+          {
+            //printf("  derived scope\n");
             ArgumentList *bmdAl = bmd->argumentList();
-            ArgumentList *mdAl = md->argumentList();
-            // printf(" Base argList=`%s'\n Super argList=`%s'\n",
+            ArgumentList *mdAl =  md->argumentList();
+            //printf(" Base argList=`%s'\n Super argList=`%s'\n",
             //        argListToString(bmdAl.pointer()).data(),
             //        argListToString(mdAl.pointer()).data()
             //      );
-            if (matchArguments2(bmd->getOuterScope(), bmd->getFileDef(), bmdAl,
-                                md->getOuterScope(), md->getFileDef(), mdAl,
-                                TRUE)) {
+            if (
+                matchArguments2(bmd->getOuterScope(),bmd->getFileDef(),bmdAl,
+                  md->getOuterScope(), md->getFileDef(), mdAl,
+                  TRUE
+                  )
+               )
+            {
               MemberDef *rmd;
-              if ((rmd = md->reimplements()) == 0 ||
-                  minClassDistance(mcd, bmcd) <
-                      minClassDistance(mcd, rmd->getClassDef())) {
-                // printf("setting (new) reimplements member\n");
+              if ((rmd=md->reimplements())==0 ||
+                  minClassDistance(mcd,bmcd)<minClassDistance(mcd,rmd->getClassDef())
+                 )
+              {
+                //printf("setting (new) reimplements member\n");
                 md->setReimplements(bmd);
               }
-              // printf("%s: add reimplementedBy member
-              // %s\n",bmcd->name().data(),mcd->name().data());
+              //printf("%s: add reimplementedBy member %s\n",bmcd->name().data(),mcd->name().data());
               bmd->insertReimplementedBy(md);
             }
           }
@@ -7128,8 +7733,9 @@ static void computeMemberRelations() {
   }
 }
 
+
 //----------------------------------------------------------------------------
-// static void computeClassImplUsageRelations()
+//static void computeClassImplUsageRelations()
 //{
 //  ClassDef *cd;
 //  ClassSDict::Iterator cli(*Doxygen::classSDict);
@@ -7141,19 +7747,23 @@ static void computeMemberRelations() {
 
 //----------------------------------------------------------------------------
 
-static void createTemplateInstanceMembers() {
+static void createTemplateInstanceMembers()
+{
   ClassSDict::Iterator cli(*Doxygen::classSDict);
   ClassDef *cd;
   // for each class
-  for (cli.toFirst(); (cd = cli.current()); ++cli) {
+  for (cli.toFirst();(cd=cli.current());++cli)
+  {
     // that is a template
     QDict<ClassDef> *templInstances = cd->getTemplateInstances();
-    if (templInstances) {
+    if (templInstances)
+    {
       QDictIterator<ClassDef> qdi(*templInstances);
-      ClassDef *tcd = 0;
+      ClassDef *tcd=0;
       // for each instance of the template
-      for (qdi.toFirst(); (tcd = qdi.current()); ++qdi) {
-        tcd->addMembersToTemplateInstance(cd, qdi.currentKey());
+      for (qdi.toFirst();(tcd=qdi.current());++qdi)
+      {
+        tcd->addMembersToTemplateInstance(cd,qdi.currentKey());
       }
     }
   }
@@ -7161,18 +7771,21 @@ static void createTemplateInstanceMembers() {
 
 //----------------------------------------------------------------------------
 
-static void mergeCategories() {
+static void mergeCategories()
+{
   ClassDef *cd;
   ClassSDict::Iterator cli(*Doxygen::classSDict);
   // merge members of categories into the class they extend
-  for (cli.toFirst(); (cd = cli.current()); ++cli) {
-    int i = cd->name().find('(');
-    if (i != -1) // it is an Objective-C category
-    {
-      QCString baseName = cd->name().left(i);
-      ClassDef *baseClass = Doxygen::classSDict->find(baseName);
-      if (baseClass) {
-        // printf("*** merging members of category %s into %s\n",
+  for (cli.toFirst();(cd=cli.current());++cli)
+  {
+    int i=cd->name().find('(');
+    if (i!=-1) // it is an Objective-C category
+    {
+      QCString baseName=cd->name().left(i);
+      ClassDef *baseClass=Doxygen::classSDict->find(baseName);
+      if (baseClass)
+      {
+        //printf("*** merging members of category %s into %s\n",
         //    cd->name().data(),baseClass->name().data());
         baseClass->mergeCategory(cd);
       }
@@ -7182,149 +7795,162 @@ static void mergeCategories() {
 
 // builds the list of all members for each class
 
-static void buildCompleteMemberLists() {
+static void buildCompleteMemberLists()
+{
   ClassDef *cd;
   ClassSDict::Iterator cli(*Doxygen::classSDict);
   // merge the member list of base classes into the inherited classes.
-  for (cli.toFirst(); (cd = cli.current()); ++cli) {
-    if ( // !cd->isReference() && // not an external class
-        cd->subClasses() == 0 && // is a root of the hierarchy
-        cd->baseClasses())       // and has at least one base class
+  for (cli.toFirst();(cd=cli.current());++cli)
+  {
+    if (// !cd->isReference() && // not an external class
+         cd->subClasses()==0 && // is a root of the hierarchy
+         cd->baseClasses()) // and has at least one base class
     {
-      // printf("*** merging members for %s\n",cd->name().data());
+      //printf("*** merging members for %s\n",cd->name().data());
       cd->mergeMembers();
     }
   }
   // now sort the member list of all classes.
-  for (cli.toFirst(); (cd = cli.current()); ++cli) {
-    if (cd->memberNameInfoSDict())
-      cd->memberNameInfoSDict()->sort();
+  for (cli.toFirst();(cd=cli.current());++cli)
+  {
+    if (cd->memberNameInfoSDict()) cd->memberNameInfoSDict()->sort();
   }
 }
 
 //----------------------------------------------------------------------------
 
-static void generateFileSources() {
-  if (Doxygen::inputNameList->count() > 0) {
+static void generateFileSources()
+{
+  if (Doxygen::inputNameList->count()>0)
+  {
 #if USE_LIBCLANG
     static bool clangAssistedParsing = Config_getBool(CLANG_ASSISTED_PARSING);
-    if (clangAssistedParsing) {
+    if (clangAssistedParsing)
+    {
       QDict<void> g_processedFiles(10007);
 
       // create a dictionary with files to process
       QDict<void> g_filesToProcess(10007);
       FileNameListIterator fnli(*Doxygen::inputNameList);
       FileName *fn;
-      for (fnli.toFirst(); (fn = fnli.current()); ++fnli) {
+      for (fnli.toFirst();(fn=fnli.current());++fnli)
+      {
         FileNameIterator fni(*fn);
         FileDef *fd;
-        for (; (fd = fni.current()); ++fni) {
-          g_filesToProcess.insert(fd->absFilePath(), (void *)0x8);
+        for (;(fd=fni.current());++fni)
+        {
+          g_filesToProcess.insert(fd->absFilePath(),(void*)0x8);
         }
       }
       // process source files (and their include dependencies)
-      for (fnli.toFirst(); (fn = fnli.current()); ++fnli) {
+      for (fnli.toFirst();(fn=fnli.current());++fnli)
+      {
         FileNameIterator fni(*fn);
         FileDef *fd;
-        for (; (fd = fni.current()); ++fni) {
-          if (fd->isSource() && !fd->isReference()) {
+        for (;(fd=fni.current());++fni)
+        {
+          if (fd->isSource() && !fd->isReference())
+          {
             QStrList filesInSameTu;
             fd->getAllIncludeFilesRecursively(filesInSameTu);
             fd->startParsing();
-            if (fd->generateSourceFile() &&
-                !g_useOutputTemplate) // sources need to be shown in the output
+            if (fd->generateSourceFile() && !g_useOutputTemplate) // sources need to be shown in the output
             {
-              msg("Generating code for file %s...\n", fd->docName().data());
-              fd->writeSource(*g_outputList, FALSE, filesInSameTu);
+              msg("Generating code for file %s...\n",fd->docName().data());
+              fd->writeSource(*g_outputList,FALSE,filesInSameTu);
 
-            } else if (!fd->isReference() && Doxygen::parseSourcesNeeded)
-            // we needed to parse the sources even if we do not show them
+            }
+            else if (!fd->isReference() && Doxygen::parseSourcesNeeded)
+              // we needed to parse the sources even if we do not show them
             {
-              msg("Parsing code for file %s...\n", fd->docName().data());
-              fd->parseSource(FALSE, filesInSameTu);
+              msg("Parsing code for file %s...\n",fd->docName().data());
+              fd->parseSource(FALSE,filesInSameTu);
             }
 
             char *incFile = filesInSameTu.first();
-            while (incFile && g_filesToProcess.find(incFile)) {
-              if (fd->absFilePath() != incFile &&
-                  !g_processedFiles.find(incFile)) {
+            while (incFile && g_filesToProcess.find(incFile))
+            {
+              if (fd->absFilePath()!=incFile && !g_processedFiles.find(incFile))
+              {
                 QStrList moreFiles;
                 bool ambig;
-                FileDef *ifd =
-                    findFileDef(Doxygen::inputNameDict, incFile, ambig);
-                if (ifd && !ifd->isReference()) {
-                  if (ifd->generateSourceFile() &&
-                      !g_useOutputTemplate) // sources need to be shown in the
-                                            // output
+                FileDef *ifd=findFileDef(Doxygen::inputNameDict,incFile,ambig);
+                if (ifd && !ifd->isReference())
+                {
+                  if (ifd->generateSourceFile() && !g_useOutputTemplate) // sources need to be shown in the output
                   {
-                    msg(" Generating code for file %s...\n",
-                        ifd->docName().data());
-                    ifd->writeSource(*g_outputList, TRUE, moreFiles);
+                    msg(" Generating code for file %s...\n",ifd->docName().data());
+                    ifd->writeSource(*g_outputList,TRUE,moreFiles);
 
-                  } else if (!ifd->isReference() && Doxygen::parseSourcesNeeded)
-                  // we needed to parse the sources even if we do not show them
+                  }
+                  else if (!ifd->isReference() && Doxygen::parseSourcesNeeded)
+                    // we needed to parse the sources even if we do not show them
                   {
-                    msg(" Parsing code for file %s...\n",
-                        ifd->docName().data());
-                    ifd->parseSource(TRUE, moreFiles);
+                    msg(" Parsing code for file %s...\n",ifd->docName().data());
+                    ifd->parseSource(TRUE,moreFiles);
                   }
-                  g_processedFiles.insert(incFile, (void *)0x8);
+                  g_processedFiles.insert(incFile,(void*)0x8);
                 }
               }
               incFile = filesInSameTu.next();
             }
             fd->finishParsing();
-            g_processedFiles.insert(fd->absFilePath(), (void *)0x8);
+            g_processedFiles.insert(fd->absFilePath(),(void*)0x8);
           }
         }
       }
       // process remaining files
-      for (fnli.toFirst(); (fn = fnli.current()); ++fnli) {
+      for (fnli.toFirst();(fn=fnli.current());++fnli)
+      {
         FileNameIterator fni(*fn);
         FileDef *fd;
-        for (; (fd = fni.current()); ++fni) {
+        for (;(fd=fni.current());++fni)
+        {
           if (!g_processedFiles.find(fd->absFilePath())) // not yet processed
           {
             QStrList filesInSameTu;
             fd->startParsing();
-            if (fd->generateSourceFile() &&
-                !g_useOutputTemplate) // sources need to be shown in the output
+            if (fd->generateSourceFile() && !g_useOutputTemplate) // sources need to be shown in the output
             {
-              msg("Generating code for file %s...\n", fd->docName().data());
-              fd->writeSource(*g_outputList, FALSE, filesInSameTu);
+              msg("Generating code for file %s...\n",fd->docName().data());
+              fd->writeSource(*g_outputList,FALSE,filesInSameTu);
 
-            } else if (!fd->isReference() && Doxygen::parseSourcesNeeded)
-            // we needed to parse the sources even if we do not show them
+            }
+            else if (!fd->isReference() && Doxygen::parseSourcesNeeded)
+              // we needed to parse the sources even if we do not show them
             {
-              msg("Parsing code for file %s...\n", fd->docName().data());
-              fd->parseSource(FALSE, filesInSameTu);
+              msg("Parsing code for file %s...\n",fd->docName().data());
+              fd->parseSource(FALSE,filesInSameTu);
             }
             fd->finishParsing();
           }
         }
       }
-    } else
+    }
+    else
 #endif
     {
       FileNameListIterator fnli(*Doxygen::inputNameList);
       FileName *fn;
-      for (; (fn = fnli.current()); ++fnli) {
+      for (;(fn=fnli.current());++fnli)
+      {
         FileNameIterator fni(*fn);
         FileDef *fd;
-        for (; (fd = fni.current()); ++fni) {
+        for (;(fd=fni.current());++fni)
+        {
           QStrList filesInSameTu;
           fd->startParsing();
-          if (fd->generateSourceFile() &&
-              !g_useOutputTemplate) // sources need to be shown in the output
+          if (fd->generateSourceFile() && !g_useOutputTemplate) // sources need to be shown in the output
           {
-            msg("Generating code for file %s...\n", fd->docName().data());
-            fd->writeSource(*g_outputList, FALSE, filesInSameTu);
+            msg("Generating code for file %s...\n",fd->docName().data());
+            fd->writeSource(*g_outputList,FALSE,filesInSameTu);
 
-          } else if (!fd->isReference() && Doxygen::parseSourcesNeeded)
-          // we needed to parse the sources even if we do not show them
+          }
+          else if (!fd->isReference() && Doxygen::parseSourcesNeeded)
+            // we needed to parse the sources even if we do not show them
           {
-            msg("Parsing code for file %s...\n", fd->docName().data());
-            fd->parseSource(FALSE, filesInSameTu);
+            msg("Parsing code for file %s...\n",fd->docName().data());
+            fd->parseSource(FALSE,filesInSameTu);
           }
           fd->finishParsing();
         }
@@ -7335,20 +7961,24 @@ static void generateFileSources() {
 
 //----------------------------------------------------------------------------
 
-static void generateFileDocs() {
-  if (documentedHtmlFiles == 0)
-    return;
+static void generateFileDocs()
+{
+  if (documentedHtmlFiles==0) return;
 
-  if (Doxygen::inputNameList->count() > 0) {
+  if (Doxygen::inputNameList->count()>0)
+  {
     FileNameListIterator fnli(*Doxygen::inputNameList);
     FileName *fn;
-    for (fnli.toFirst(); (fn = fnli.current()); ++fnli) {
+    for (fnli.toFirst();(fn=fnli.current());++fnli)
+    {
       FileNameIterator fni(*fn);
       FileDef *fd;
-      for (fni.toFirst(); (fd = fni.current()); ++fni) {
+      for (fni.toFirst();(fd=fni.current());++fni)
+      {
         bool doc = fd->isLinkableInProject();
-        if (doc) {
-          msg("Generating docs for file %s...\n", fd->docName().data());
+        if (doc)
+        {
+          msg("Generating docs for file %s...\n",fd->docName().data());
           fd->writeDocumentation(*g_outputList);
         }
       }
@@ -7358,62 +7988,79 @@ static void generateFileDocs() {
 
 //----------------------------------------------------------------------------
 
-static void addSourceReferences() {
+static void addSourceReferences()
+{
   // add source references for class definitions
   ClassSDict::Iterator cli(*Doxygen::classSDict);
-  ClassDef *cd = 0;
-  for (cli.toFirst(); (cd = cli.current()); ++cli) {
-    FileDef *fd = cd->getBodyDef();
-    if (fd && cd->isLinkableInProject() && cd->getStartBodyLine() != -1) {
-      fd->addSourceRef(cd->getStartBodyLine(), cd, 0);
+  ClassDef *cd=0;
+  for (cli.toFirst();(cd=cli.current());++cli)
+  {
+    FileDef *fd=cd->getBodyDef();
+    if (fd && cd->isLinkableInProject() && cd->getStartBodyLine()!=-1)
+    {
+      fd->addSourceRef(cd->getStartBodyLine(),cd,0);
     }
   }
   // add source references for namespace definitions
   NamespaceSDict::Iterator nli(*Doxygen::namespaceSDict);
-  NamespaceDef *nd = 0;
-  for (nli.toFirst(); (nd = nli.current()); ++nli) {
-    FileDef *fd = nd->getBodyDef();
-    if (fd && nd->isLinkableInProject() && nd->getStartBodyLine() != -1) {
-      fd->addSourceRef(nd->getStartBodyLine(), nd, 0);
+  NamespaceDef *nd=0;
+  for (nli.toFirst();(nd=nli.current());++nli)
+  {
+    FileDef *fd=nd->getBodyDef();
+    if (fd && nd->isLinkableInProject() && nd->getStartBodyLine()!=-1)
+    {
+      fd->addSourceRef(nd->getStartBodyLine(),nd,0);
     }
   }
 
   // add source references for member names
   MemberNameSDict::Iterator mnli(*Doxygen::memberNameSDict);
-  MemberName *mn = 0;
-  for (mnli.toFirst(); (mn = mnli.current()); ++mnli) {
+  MemberName *mn=0;
+  for (mnli.toFirst();(mn=mnli.current());++mnli)
+  {
     MemberNameIterator mni(*mn);
-    MemberDef *md = 0;
-    for (mni.toFirst(); (md = mni.current()); ++mni) {
-      // printf("class member %s: def=%s body=%d link?=%d\n",
+    MemberDef *md=0;
+    for (mni.toFirst();(md=mni.current());++mni)
+    {
+      //printf("class member %s: def=%s body=%d link?=%d\n",
       //    md->name().data(),
       //    md->getBodyDef()?md->getBodyDef()->name().data():"<none>",
       //    md->getStartBodyLine(),md->isLinkableInProject());
-      FileDef *fd = md->getBodyDef();
-      if (fd && md->getStartBodyLine() != -1 && md->isLinkableInProject() &&
-          (fd->generateSourceFile() || Doxygen::parseSourcesNeeded)) {
-        // printf("Found member `%s' in file `%s' at line `%d' def=%s\n",
+      FileDef *fd=md->getBodyDef();
+      if (fd &&
+          md->getStartBodyLine()!=-1 &&
+          md->isLinkableInProject() &&
+          (fd->generateSourceFile() || Doxygen::parseSourcesNeeded)
+         )
+      {
+        //printf("Found member `%s' in file `%s' at line `%d' def=%s\n",
         //    md->name().data(),fd->name().data(),md->getStartBodyLine(),md->getOuterScope()->name().data());
-        fd->addSourceRef(md->getStartBodyLine(), md->getOuterScope(), md);
+        fd->addSourceRef(md->getStartBodyLine(),md->getOuterScope(),md);
       }
     }
   }
   MemberNameSDict::Iterator fnli(*Doxygen::functionNameSDict);
-  for (fnli.toFirst(); (mn = fnli.current()); ++fnli) {
+  for (fnli.toFirst();(mn=fnli.current());++fnli)
+  {
     MemberNameIterator mni(*mn);
-    MemberDef *md = 0;
-    for (mni.toFirst(); (md = mni.current()); ++mni) {
-      FileDef *fd = md->getBodyDef();
-      // printf("member %s body=[%d,%d] fd=%p link=%d parseSources=%d\n",
+    MemberDef *md=0;
+    for (mni.toFirst();(md=mni.current());++mni)
+    {
+      FileDef *fd=md->getBodyDef();
+      //printf("member %s body=[%d,%d] fd=%p link=%d parseSources=%d\n",
       //    md->name().data(),
       //    md->getStartBodyLine(),md->getEndBodyLine(),fd,
       //    md->isLinkableInProject(),
       //    Doxygen::parseSourcesNeeded);
-      if (fd && md->getStartBodyLine() != -1 && md->isLinkableInProject() &&
-          (fd->generateSourceFile() || Doxygen::parseSourcesNeeded)) {
-        // printf("Found member `%s' in file `%s' at line `%d' def=%s\n",
+      if (fd &&
+          md->getStartBodyLine()!=-1 &&
+          md->isLinkableInProject() &&
+          (fd->generateSourceFile() || Doxygen::parseSourcesNeeded)
+         )
+      {
+        //printf("Found member `%s' in file `%s' at line `%d' def=%s\n",
         //    md->name().data(),fd->name().data(),md->getStartBodyLine(),md->getOuterScope()->name().data());
-        fd->addSourceRef(md->getStartBodyLine(), md->getOuterScope(), md);
+        fd->addSourceRef(md->getStartBodyLine(),md->getOuterScope(),md);
       }
     }
   }
@@ -7421,28 +8068,33 @@ static void addSourceReferences() {
 
 //----------------------------------------------------------------------------
 
-static void sortMemberLists() {
+static void sortMemberLists()
+{
   // sort class member lists
   ClassSDict::Iterator cli(*Doxygen::classSDict);
-  ClassDef *cd = 0;
-  for (cli.toFirst(); (cd = cli.current()); ++cli) {
+  ClassDef *cd=0;
+  for (cli.toFirst();(cd=cli.current());++cli)
+  {
     cd->sortMemberLists();
   }
 
   // sort namespace member lists
   NamespaceSDict::Iterator nli(*Doxygen::namespaceSDict);
-  NamespaceDef *nd = 0;
-  for (nli.toFirst(); (nd = nli.current()); ++nli) {
+  NamespaceDef *nd=0;
+  for (nli.toFirst();(nd=nli.current());++nli)
+  {
     nd->sortMemberLists();
   }
 
   // sort file member lists
   FileNameListIterator fnli(*Doxygen::inputNameList);
   FileName *fn;
-  for (; (fn = fnli.current()); ++fnli) {
+  for (;(fn=fnli.current());++fnli)
+  {
     FileNameIterator fni(*fn);
     FileDef *fd;
-    for (; (fd = fni.current()); ++fni) {
+    for (;(fd=fni.current());++fni)
+    {
       fd->sortMemberLists();
     }
   }
@@ -7450,7 +8102,8 @@ static void sortMemberLists() {
   // sort group member lists
   GroupSDict::Iterator gli(*Doxygen::groupSDict);
   GroupDef *gd;
-  for (gli.toFirst(); (gd = gli.current()); ++gli) {
+  for (gli.toFirst();(gd=gli.current());++gli)
+  {
     gd->sortMemberLists();
   }
 }
@@ -7458,24 +8111,25 @@ static void sortMemberLists() {
 //----------------------------------------------------------------------------
 // generate the documentation of all classes
 
-static void generateClassList(ClassSDict &classSDict) {
+static void generateClassList(ClassSDict &classSDict)
+{
   ClassSDict::Iterator cli(classSDict);
-  for (; cli.current(); ++cli) {
-    ClassDef *cd = cli.current();
+  for ( ; cli.current() ; ++cli )
+  {
+    ClassDef *cd=cli.current();
 
-    // printf("cd=%s getOuterScope=%p
-    // global=%p\n",cd->name().data(),cd->getOuterScope(),Doxygen::globalScope);
+    //printf("cd=%s getOuterScope=%p global=%p\n",cd->name().data(),cd->getOuterScope(),Doxygen::globalScope);
     if (cd &&
-        (cd->getOuterScope() ==
-             0 || // <-- should not happen, but can if we read an old tag file
-         cd->getOuterScope() ==
-             Doxygen::globalScope // only look at global classes
-         ) &&
-        !cd->isHidden() && !cd->isEmbeddedInOuterScope()) {
+        (cd->getOuterScope()==0 || // <-- should not happen, but can if we read an old tag file
+         cd->getOuterScope()==Doxygen::globalScope // only look at global classes
+        ) && !cd->isHidden() && !cd->isEmbeddedInOuterScope()
+       )
+    {
       // skip external references, anonymous compounds and
       // template instances
-      if (cd->isLinkableInProject() && cd->templateMaster() == 0) {
-        msg("Generating docs for compound %s...\n", cd->name().data());
+      if ( cd->isLinkableInProject() && cd->templateMaster()==0)
+      {
+        msg("Generating docs for compound %s...\n",cd->name().data());
 
         cd->writeDocumentation(*g_outputList);
         cd->writeMemberList(*g_outputList);
@@ -7486,44 +8140,44 @@ static void generateClassList(ClassSDict &classSDict) {
   }
 }
 
-static void generateClassDocs() {
+static void generateClassDocs()
+{
   generateClassList(*Doxygen::classSDict);
   generateClassList(*Doxygen::hiddenClasses);
 }
 
 //----------------------------------------------------------------------------
 
-static void inheritDocumentation() {
+static void inheritDocumentation()
+{
   MemberNameSDict::Iterator mnli(*Doxygen::memberNameSDict);
   MemberName *mn;
-  // int count=0;
-  for (; (mn = mnli.current()); ++mnli) {
+  //int count=0;
+  for (;(mn=mnli.current());++mnli)
+  {
     MemberNameIterator mni(*mn);
     MemberDef *md;
-    for (; (md = mni.current()); ++mni) {
-      // printf("%04d Member `%s'\n",count++,md->name().data());
-      if (md->documentation().isEmpty() &&
-          md->briefDescription().isEmpty()) { // no documentation yet
+    for (;(md=mni.current());++mni)
+    {
+      //printf("%04d Member `%s'\n",count++,md->name().data());
+      if (md->documentation().isEmpty() && md->briefDescription().isEmpty())
+      { // no documentation yet
         MemberDef *bmd = md->reimplements();
         while (bmd && bmd->documentation().isEmpty() &&
-               bmd->briefDescription().isEmpty()) { // search up the inheritance
-                                                    // tree for a documentation
-                                                    // member
-          // printf("bmd=%s
-          // class=%s\n",bmd->name().data(),bmd->getClassDef()->name().data());
+                      bmd->briefDescription().isEmpty()
+              )
+        { // search up the inheritance tree for a documentation member
+          //printf("bmd=%s class=%s\n",bmd->name().data(),bmd->getClassDef()->name().data());
           bmd = bmd->reimplements();
         }
         if (bmd) // copy the documentation from the reimplemented member
         {
           md->setInheritsDocsFrom(bmd);
-          md->setDocumentation(bmd->documentation(), bmd->docFile(),
-                               bmd->docLine());
+          md->setDocumentation(bmd->documentation(),bmd->docFile(),bmd->docLine());
           md->setDocsForDefinition(bmd->isDocsForDefinition());
-          md->setBriefDescription(bmd->briefDescription(), bmd->briefFile(),
-                                  bmd->briefLine());
+          md->setBriefDescription(bmd->briefDescription(),bmd->briefFile(),bmd->briefLine());
           md->copyArgumentNames(bmd);
-          md->setInbodyDocumentation(bmd->inbodyDocumentation(),
-                                     bmd->inbodyFile(), bmd->inbodyLine());
+          md->setInbodyDocumentation(bmd->inbodyDocumentation(),bmd->inbodyFile(),bmd->inbodyLine());
         }
       }
     }
@@ -7532,21 +8186,26 @@ static void inheritDocumentation() {
 
 //----------------------------------------------------------------------------
 
-static void combineUsingRelations() {
+static void combineUsingRelations()
+{
   // for each file
   FileNameListIterator fnli(*Doxygen::inputNameList);
   FileName *fn;
-  for (fnli.toFirst(); (fn = fnli.current()); ++fnli) {
+  for (fnli.toFirst();(fn=fnli.current());++fnli)
+  {
     FileNameIterator fni(*fn);
     FileDef *fd;
-    for (fni.toFirst(); (fd = fni.current()); ++fni) {
-      fd->visited = FALSE;
+    for (fni.toFirst();(fd=fni.current());++fni)
+    {
+      fd->visited=FALSE;
     }
   }
-  for (fnli.toFirst(); (fn = fnli.current()); ++fnli) {
+  for (fnli.toFirst();(fn=fnli.current());++fnli)
+  {
     FileNameIterator fni(*fn);
     FileDef *fd;
-    for (fni.toFirst(); (fd = fni.current()); ++fni) {
+    for (fni.toFirst();(fd=fni.current());++fni)
+    {
       fd->combineUsingRelations();
     }
   }
@@ -7554,130 +8213,153 @@ static void combineUsingRelations() {
   // for each namespace
   NamespaceSDict::Iterator nli(*Doxygen::namespaceSDict);
   NamespaceDef *nd;
-  for (nli.toFirst(); (nd = nli.current()); ++nli) {
-    nd->visited = FALSE;
+  for (nli.toFirst() ; (nd=nli.current()) ; ++nli )
+  {
+    nd->visited=FALSE;
   }
-  for (nli.toFirst(); (nd = nli.current()); ++nli) {
+  for (nli.toFirst() ; (nd=nli.current()) ; ++nli )
+  {
     nd->combineUsingRelations();
   }
 }
 
 //----------------------------------------------------------------------------
 
-static void addMembersToMemberGroup() {
+static void addMembersToMemberGroup()
+{
   // for each class
   ClassSDict::Iterator cli(*Doxygen::classSDict);
   ClassDef *cd;
-  for (; (cd = cli.current()); ++cli) {
+  for ( ; (cd=cli.current()) ; ++cli )
+  {
     cd->addMembersToMemberGroup();
   }
   // for each file
   FileNameListIterator fnli(*Doxygen::inputNameList);
   FileName *fn;
-  for (fnli.toFirst(); (fn = fnli.current()); ++fnli) {
+  for (fnli.toFirst();(fn=fnli.current());++fnli)
+  {
     FileNameIterator fni(*fn);
     FileDef *fd;
-    for (fni.toFirst(); (fd = fni.current()); ++fni) {
+    for (fni.toFirst();(fd=fni.current());++fni)
+    {
       fd->addMembersToMemberGroup();
     }
   }
   // for each namespace
   NamespaceSDict::Iterator nli(*Doxygen::namespaceSDict);
   NamespaceDef *nd;
-  for (; (nd = nli.current()); ++nli) {
+  for ( ; (nd=nli.current()) ; ++nli )
+  {
     nd->addMembersToMemberGroup();
   }
   // for each group
   GroupSDict::Iterator gli(*Doxygen::groupSDict);
   GroupDef *gd;
-  for (gli.toFirst(); (gd = gli.current()); ++gli) {
+  for (gli.toFirst();(gd=gli.current());++gli)
+  {
     gd->addMembersToMemberGroup();
   }
 }
 
 //----------------------------------------------------------------------------
 
-static void distributeMemberGroupDocumentation() {
+static void distributeMemberGroupDocumentation()
+{
   // for each class
   ClassSDict::Iterator cli(*Doxygen::classSDict);
   ClassDef *cd;
-  for (; (cd = cli.current()); ++cli) {
+  for ( ; (cd=cli.current()) ; ++cli )
+  {
     cd->distributeMemberGroupDocumentation();
   }
   // for each file
   FileNameListIterator fnli(*Doxygen::inputNameList);
   FileName *fn;
-  for (fnli.toFirst(); (fn = fnli.current()); ++fnli) {
+  for (fnli.toFirst();(fn=fnli.current());++fnli)
+  {
     FileNameIterator fni(*fn);
     FileDef *fd;
-    for (fni.toFirst(); (fd = fni.current()); ++fni) {
+    for (fni.toFirst();(fd=fni.current());++fni)
+    {
       fd->distributeMemberGroupDocumentation();
     }
   }
   // for each namespace
   NamespaceSDict::Iterator nli(*Doxygen::namespaceSDict);
   NamespaceDef *nd;
-  for (; (nd = nli.current()); ++nli) {
+  for ( ; (nd=nli.current()) ; ++nli )
+  {
     nd->distributeMemberGroupDocumentation();
   }
   // for each group
   GroupSDict::Iterator gli(*Doxygen::groupSDict);
   GroupDef *gd;
-  for (gli.toFirst(); (gd = gli.current()); ++gli) {
+  for (gli.toFirst();(gd=gli.current());++gli)
+  {
     gd->distributeMemberGroupDocumentation();
   }
 }
 
 //----------------------------------------------------------------------------
 
-static void findSectionsInDocumentation() {
+static void findSectionsInDocumentation()
+{
   // for each class
   ClassSDict::Iterator cli(*Doxygen::classSDict);
   ClassDef *cd;
-  for (; (cd = cli.current()); ++cli) {
+  for ( ; (cd=cli.current()) ; ++cli )
+  {
     cd->findSectionsInDocumentation();
   }
   // for each file
   FileNameListIterator fnli(*Doxygen::inputNameList);
   FileName *fn;
-  for (fnli.toFirst(); (fn = fnli.current()); ++fnli) {
+  for (fnli.toFirst();(fn=fnli.current());++fnli)
+  {
     FileNameIterator fni(*fn);
     FileDef *fd;
-    for (fni.toFirst(); (fd = fni.current()); ++fni) {
+    for (fni.toFirst();(fd=fni.current());++fni)
+    {
       fd->findSectionsInDocumentation();
     }
   }
   // for each namespace
   NamespaceSDict::Iterator nli(*Doxygen::namespaceSDict);
   NamespaceDef *nd;
-  for (; (nd = nli.current()); ++nli) {
+  for ( ; (nd=nli.current()) ; ++nli )
+  {
     nd->findSectionsInDocumentation();
   }
   // for each group
   GroupSDict::Iterator gli(*Doxygen::groupSDict);
   GroupDef *gd;
-  for (gli.toFirst(); (gd = gli.current()); ++gli) {
+  for (gli.toFirst();(gd=gli.current());++gli)
+  {
     gd->findSectionsInDocumentation();
   }
   // for each page
   PageSDict::Iterator pdi(*Doxygen::pageSDict);
-  PageDef *pd = 0;
-  for (pdi.toFirst(); (pd = pdi.current()); ++pdi) {
+  PageDef *pd=0;
+  for (pdi.toFirst();(pd=pdi.current());++pdi)
+  {
     pd->findSectionsInDocumentation();
   }
-  if (Doxygen::mainPage)
-    Doxygen::mainPage->findSectionsInDocumentation();
+  if (Doxygen::mainPage) Doxygen::mainPage->findSectionsInDocumentation();
 }
 
-static void flushCachedTemplateRelations() {
+static void flushCachedTemplateRelations()
+{
   // remove all references to classes from the cache
   // as there can be new template instances in the inheritance path
   // to this class. Optimization: only remove those classes that
   // have inheritance instances as direct or indirect sub classes.
   QCacheIterator<LookupInfo> ci(*Doxygen::lookupCache);
-  LookupInfo *li = 0;
-  for (ci.toFirst(); (li = ci.current()); ++ci) {
-    if (li->classDef) {
+  LookupInfo *li=0;
+  for (ci.toFirst();(li=ci.current());++ci)
+  {
+    if (li->classDef)
+    {
       Doxygen::lookupCache->remove(ci.currentKey());
     }
   }
@@ -7685,30 +8367,30 @@ static void flushCachedTemplateRelations() {
   // template class as this may now be a template instance
   MemberNameSDict::Iterator fnli(*Doxygen::functionNameSDict);
   MemberName *fn;
-  for (; (fn = fnli.current()); ++fnli) // for each global function name
+  for (;(fn=fnli.current());++fnli) // for each global function name
   {
     MemberNameIterator fni(*fn);
     MemberDef *fmd;
-    for (; (fmd = fni.current()); ++fni) // for each function with that name
+    for (;(fmd=fni.current());++fni) // for each function with that name
     {
-      if (fmd->isTypedefValCached()) {
+      if (fmd->isTypedefValCached())
+      {
         ClassDef *cd = fmd->getCachedTypedefVal();
-        if (cd->isTemplate())
-          fmd->invalidateTypedefValCache();
+        if (cd->isTemplate()) fmd->invalidateTypedefValCache();
       }
     }
   }
   MemberNameSDict::Iterator mnli(*Doxygen::memberNameSDict);
-  for (; (fn = mnli.current()); ++mnli) // for each class method name
+  for (;(fn=mnli.current());++mnli) // for each class method name
   {
     MemberNameIterator mni(*fn);
     MemberDef *fmd;
-    for (; (fmd = mni.current()); ++mni) // for each function with that name
+    for (;(fmd=mni.current());++mni) // for each function with that name
     {
-      if (fmd->isTypedefValCached()) {
+      if (fmd->isTypedefValCached())
+      {
         ClassDef *cd = fmd->getCachedTypedefVal();
-        if (cd->isTemplate())
-          fmd->invalidateTypedefValCache();
+        if (cd->isTemplate()) fmd->invalidateTypedefValCache();
       }
     }
   }
@@ -7716,7 +8398,8 @@ static void flushCachedTemplateRelations() {
 
 //----------------------------------------------------------------------------
 
-static void flushUnresolvedRelations() {
+static void flushUnresolvedRelations()
+{
   // Remove all unresolved references to classes from the cache.
   // This is needed before resolving the inheritance relations, since
   // it would otherwise not find the inheritance relation
@@ -7728,337 +8411,389 @@ static void flushUnresolvedRelations() {
   // class C : public B::I {};
   //
   QCacheIterator<LookupInfo> ci(*Doxygen::lookupCache);
-  LookupInfo *li = 0;
-  for (ci.toFirst(); (li = ci.current()); ++ci) {
-    if (li->classDef == 0 && li->typeDef == 0) {
+  LookupInfo *li=0;
+  for (ci.toFirst();(li=ci.current());++ci)
+  {
+    if (li->classDef==0 && li->typeDef==0)
+    {
       Doxygen::lookupCache->remove(ci.currentKey());
     }
   }
 
   MemberNameSDict::Iterator fnli(*Doxygen::functionNameSDict);
   MemberName *fn;
-  for (; (fn = fnli.current()); ++fnli) // for each global function name
+  for (;(fn=fnli.current());++fnli) // for each global function name
   {
     MemberNameIterator fni(*fn);
     MemberDef *fmd;
-    for (; (fmd = fni.current()); ++fni) // for each function with that name
+    for (;(fmd=fni.current());++fni) // for each function with that name
     {
       fmd->invalidateCachedArgumentTypes();
     }
   }
   MemberNameSDict::Iterator mnli(*Doxygen::memberNameSDict);
-  for (; (fn = mnli.current()); ++mnli) // for each class method name
+  for (;(fn=mnli.current());++mnli) // for each class method name
   {
     MemberNameIterator mni(*fn);
     MemberDef *fmd;
-    for (; (fmd = mni.current()); ++mni) // for each function with that name
+    for (;(fmd=mni.current());++mni) // for each function with that name
     {
       fmd->invalidateCachedArgumentTypes();
     }
   }
+
 }
 
 //----------------------------------------------------------------------------
 
-static void findDefineDocumentation(EntryNav *rootNav) {
-  if ((rootNav->section() == Entry::DEFINEDOC_SEC ||
-       rootNav->section() == Entry::DEFINE_SEC) &&
-      !rootNav->name().isEmpty()) {
+static void findDefineDocumentation(EntryNav *rootNav)
+{
+  if ((rootNav->section()==Entry::DEFINEDOC_SEC ||
+       rootNav->section()==Entry::DEFINE_SEC) && !rootNav->name().isEmpty()
+     )
+  {
     rootNav->loadEntry(g_storage);
     Entry *root = rootNav->entry();
 
-    // printf("found define `%s' `%s' brief=`%s' doc=`%s'\n",
+    //printf("found define `%s' `%s' brief=`%s' doc=`%s'\n",
     //       root->name.data(),root->args.data(),root->brief.data(),root->doc.data());
 
-    if (rootNav->tagInfo() &&
-        !root->name.isEmpty()) // define read from a tag file
+    if (rootNav->tagInfo() && !root->name.isEmpty()) // define read from a tag file
     {
-      MemberDef *md = new MemberDef(
-          rootNav->tagInfo()->tagName, 1, 1, "#define", root->name, root->args,
-          0, Public, Normal, FALSE, Member, MemberType_Define, 0, 0);
+      MemberDef *md=new MemberDef(rootNav->tagInfo()->tagName,1,1,
+                    "#define",root->name,root->args,0,
+                    Public,Normal,FALSE,Member,MemberType_Define,0,0);
       md->setTagInfo(rootNav->tagInfo());
       md->setLanguage(root->lang);
-      // printf("Searching for `%s' fd=%p\n",filePathName.data(),fd);
+      //printf("Searching for `%s' fd=%p\n",filePathName.data(),fd);
       md->setFileDef(rootNav->parent()->fileDef());
-      // printf("Adding member=%s\n",md->name().data());
+      //printf("Adding member=%s\n",md->name().data());
       MemberName *mn;
-      if ((mn = Doxygen::functionNameSDict->find(root->name))) {
+      if ((mn=Doxygen::functionNameSDict->find(root->name)))
+      {
         mn->append(md);
-      } else {
+      }
+      else
+      {
         mn = new MemberName(root->name);
         mn->append(md);
-        Doxygen::functionNameSDict->append(root->name, mn);
+        Doxygen::functionNameSDict->append(root->name,mn);
       }
     }
-    MemberName *mn = Doxygen::functionNameSDict->find(root->name);
-    if (mn) {
+    MemberName *mn=Doxygen::functionNameSDict->find(root->name);
+    if (mn)
+    {
       MemberNameIterator mni(*mn);
       MemberDef *md;
-      int count = 0;
-      for (; (md = mni.current()); ++mni) {
-        if (md->memberType() == MemberType_Define)
-          count++;
-      }
-      if (count == 1) {
-        for (mni.toFirst(); (md = mni.current()); ++mni) {
-          if (md->memberType() == MemberType_Define) {
-            md->setDocumentation(root->doc, root->docFile, root->docLine);
+      int count=0;
+      for (;(md=mni.current());++mni)
+      {
+        if (md->memberType()==MemberType_Define) count++;
+      }
+      if (count==1)
+      {
+        for (mni.toFirst();(md=mni.current());++mni)
+        {
+          if (md->memberType()==MemberType_Define)
+          {
+            md->setDocumentation(root->doc,root->docFile,root->docLine);
             md->setDocsForDefinition(!root->proto);
-            md->setBriefDescription(root->brief, root->briefFile,
-                                    root->briefLine);
-            if (md->inbodyDocumentation().isEmpty()) {
-              md->setInbodyDocumentation(root->inbodyDocs, root->inbodyFile,
-                                         root->inbodyLine);
+            md->setBriefDescription(root->brief,root->briefFile,root->briefLine);
+            if (md->inbodyDocumentation().isEmpty())
+            {
+              md->setInbodyDocumentation(root->inbodyDocs,root->inbodyFile,root->inbodyLine);
             }
-            md->setBodySegment(root->bodyLine, root->endBodyLine);
+            md->setBodySegment(root->bodyLine,root->endBodyLine);
             md->setBodyDef(rootNav->fileDef());
             md->addSectionsToDefinition(root->anchors);
             md->setMaxInitLines(root->initLines);
             md->setRefItems(root->sli);
-            if (root->mGrpId != -1)
-              md->setMemberGroupId(root->mGrpId);
-            addMemberToGroups(root, md);
+            if (root->mGrpId!=-1) md->setMemberGroupId(root->mGrpId);
+            addMemberToGroups(root,md);
           }
         }
-      } else if (count > 1 && (!root->doc.isEmpty() || !root->brief.isEmpty() ||
-                               root->bodyLine != -1))
-      // multiple defines don't know where to add docs
-      // but maybe they are in different files together with their documentation
+      }
+      else if (count>1 &&
+               (!root->doc.isEmpty() ||
+                !root->brief.isEmpty() ||
+                root->bodyLine!=-1
+               )
+              )
+        // multiple defines don't know where to add docs
+        // but maybe they are in different files together with their documentation
       {
-        for (mni.toFirst(); (md = mni.current()); ++mni) {
-          if (md->memberType() == MemberType_Define) {
-            FileDef *fd = md->getFileDef();
-            if (fd && fd->absFilePath() == root->fileName)
-            // doc and define in the same file assume they belong together.
+        for (mni.toFirst();(md=mni.current());++mni)
+        {
+          if (md->memberType()==MemberType_Define)
+          {
+            FileDef *fd=md->getFileDef();
+            if (fd && fd->absFilePath()==root->fileName)
+              // doc and define in the same file assume they belong together.
             {
 #if 0
               if (md->documentation().isEmpty())
 #endif
               {
-                md->setDocumentation(root->doc, root->docFile, root->docLine);
+                md->setDocumentation(root->doc,root->docFile,root->docLine);
                 md->setDocsForDefinition(!root->proto);
               }
 #if 0
               if (md->briefDescription().isEmpty())
 #endif
               {
-                md->setBriefDescription(root->brief, root->briefFile,
-                                        root->briefLine);
+                md->setBriefDescription(root->brief,root->briefFile,root->briefLine);
               }
-              if (md->inbodyDocumentation().isEmpty()) {
-                md->setInbodyDocumentation(root->inbodyDocs, root->inbodyFile,
-                                           root->inbodyLine);
+              if (md->inbodyDocumentation().isEmpty())
+              {
+                md->setInbodyDocumentation(root->inbodyDocs,root->inbodyFile,root->inbodyLine);
               }
-              md->setBodySegment(root->bodyLine, root->endBodyLine);
+              md->setBodySegment(root->bodyLine,root->endBodyLine);
               md->setBodyDef(rootNav->fileDef());
               md->addSectionsToDefinition(root->anchors);
               md->setRefItems(root->sli);
               md->setLanguage(root->lang);
-              if (root->mGrpId != -1)
-                md->setMemberGroupId(root->mGrpId);
-              addMemberToGroups(root, md);
+              if (root->mGrpId!=-1) md->setMemberGroupId(root->mGrpId);
+              addMemberToGroups(root,md);
             }
           }
         }
-        // warn("define %s found in the following files:\n",root->name.data());
-        // warn("Cannot determine where to add the documentation found "
+        //warn("define %s found in the following files:\n",root->name.data());
+        //warn("Cannot determine where to add the documentation found "
         //     "at line %d of file %s. \n",
         //     root->startLine,root->fileName.data());
       }
-    } else if (!root->doc.isEmpty() ||
-               !root->brief.isEmpty()) // define not found
+    }
+    else if (!root->doc.isEmpty() || !root->brief.isEmpty()) // define not found
     {
       static bool preEnabled = Config_getBool(ENABLE_PREPROCESSING);
-      if (preEnabled) {
-        warn(root->fileName, root->startLine,
-             "documentation for unknown define %s found.\n", root->name.data());
-      } else {
-        warn(root->fileName, root->startLine,
+      if (preEnabled)
+      {
+        warn(root->fileName,root->startLine,
+             "documentation for unknown define %s found.\n",
+             root->name.data()
+            );
+      }
+      else
+      {
+        warn(root->fileName,root->startLine,
              "found documented #define but ignoring it because "
              "ENABLE_PREPROCESSING is NO.\n",
-             root->name.data());
+             root->name.data()
+            );
       }
     }
 
     rootNav->releaseEntry();
   }
-  RECURSE_ENTRYTREE(findDefineDocumentation, rootNav);
+  RECURSE_ENTRYTREE(findDefineDocumentation,rootNav);
 }
 
 //----------------------------------------------------------------------------
 
-static void findDirDocumentation(EntryNav *rootNav) {
-  if (rootNav->section() == Entry::DIRDOC_SEC) {
+static void findDirDocumentation(EntryNav *rootNav)
+{
+  if (rootNav->section() == Entry::DIRDOC_SEC)
+  {
     rootNav->loadEntry(g_storage);
     Entry *root = rootNav->entry();
 
     QCString normalizedName = root->name;
-    normalizedName = substitute(normalizedName, "\\", "/");
-    // printf("root->docFile=%s normalizedName=%s\n",
+    normalizedName = substitute(normalizedName,"\\","/");
+    //printf("root->docFile=%s normalizedName=%s\n",
     //    root->docFile.data(),normalizedName.data());
-    if (root->docFile == normalizedName) // current dir?
+    if (root->docFile==normalizedName) // current dir?
     {
-      int lastSlashPos = normalizedName.findRev('/');
-      if (lastSlashPos != -1) // strip file name
+      int lastSlashPos=normalizedName.findRev('/');
+      if (lastSlashPos!=-1) // strip file name
       {
-        normalizedName = normalizedName.left(lastSlashPos);
+        normalizedName=normalizedName.left(lastSlashPos);
       }
     }
-    if (normalizedName.at(normalizedName.length() - 1) != '/') {
-      normalizedName += '/';
+    if (normalizedName.at(normalizedName.length()-1)!='/')
+    {
+      normalizedName+='/';
     }
-    DirDef *dir, *matchingDir = 0;
+    DirDef *dir,*matchingDir=0;
     SDict<DirDef>::Iterator sdi(*Doxygen::directories);
-    for (sdi.toFirst(); (dir = sdi.current()); ++sdi) {
-      // printf("Dir: %s<->%s\n",dir->name().data(),normalizedName.data());
-      if (dir->name().right(normalizedName.length()) == normalizedName) {
-        if (matchingDir) {
-          warn(root->fileName, root->startLine,
-               "\\dir command matches multiple directories.\n"
-               "  Applying the command for directory %s\n"
-               "  Ignoring the command for directory %s\n",
-               matchingDir->name().data(), dir->name().data());
-        } else {
-          matchingDir = dir;
-        }
-      }
-    }
-    if (matchingDir) {
-      // printf("Match for with dir %s\n",matchingDir->name().data());
-      matchingDir->setBriefDescription(root->brief, root->briefFile,
-                                       root->briefLine);
-      matchingDir->setDocumentation(root->doc, root->docFile, root->docLine);
+    for (sdi.toFirst();(dir=sdi.current());++sdi)
+    {
+      //printf("Dir: %s<->%s\n",dir->name().data(),normalizedName.data());
+      if (dir->name().right(normalizedName.length())==normalizedName)
+      {
+        if (matchingDir)
+        {
+           warn(root->fileName,root->startLine,
+             "\\dir command matches multiple directories.\n"
+             "  Applying the command for directory %s\n"
+             "  Ignoring the command for directory %s\n",
+             matchingDir->name().data(),dir->name().data()
+           );
+        }
+        else
+        {
+          matchingDir=dir;
+        }
+      }
+    }
+    if (matchingDir)
+    {
+      //printf("Match for with dir %s\n",matchingDir->name().data());
+      matchingDir->setBriefDescription(root->brief,root->briefFile,root->briefLine);
+      matchingDir->setDocumentation(root->doc,root->docFile,root->docLine);
       matchingDir->setRefItems(root->sli);
-      addDirToGroups(root, matchingDir);
-    } else {
-      warn(root->fileName, root->startLine,
-           "No matching "
-           "directory found for command \\dir %s\n",
-           normalizedName.data());
+      addDirToGroups(root,matchingDir);
+    }
+    else
+    {
+      warn(root->fileName,root->startLine,"No matching "
+          "directory found for command \\dir %s\n",normalizedName.data());
     }
     rootNav->releaseEntry();
   }
-  RECURSE_ENTRYTREE(findDirDocumentation, rootNav);
+  RECURSE_ENTRYTREE(findDirDocumentation,rootNav);
 }
 
+
 //----------------------------------------------------------------------------
 // create a (sorted) list of separate documentation pages
 
-static void buildPageList(EntryNav *rootNav) {
-  if (rootNav->section() == Entry::PAGEDOC_SEC) {
+static void buildPageList(EntryNav *rootNav)
+{
+  if (rootNav->section() == Entry::PAGEDOC_SEC)
+  {
     rootNav->loadEntry(g_storage);
     Entry *root = rootNav->entry();
 
-    if (!root->name.isEmpty()) {
+    if (!root->name.isEmpty())
+    {
       addRelatedPage(rootNav);
     }
 
     rootNav->releaseEntry();
-  } else if (rootNav->section() == Entry::MAINPAGEDOC_SEC) {
+  }
+  else if (rootNav->section() == Entry::MAINPAGEDOC_SEC)
+  {
     rootNav->loadEntry(g_storage);
     Entry *root = rootNav->entry();
 
-    QCString title = root->args.stripWhiteSpace();
-    if (title.isEmpty())
-      title = theTranslator->trMainPage();
-    // QCString name = Config_getBool(GENERATE_TREEVIEW)?"main":"index";
+    QCString title=root->args.stripWhiteSpace();
+    if (title.isEmpty()) title=theTranslator->trMainPage();
+    //QCString name = Config_getBool(GENERATE_TREEVIEW)?"main":"index";
     QCString name = "index";
-    addRefItem(root->sli, name, "page", name, title, 0, 0);
+    addRefItem(root->sli,
+               name,
+               "page",
+               name,
+               title,
+               0,0
+               );
 
     rootNav->releaseEntry();
   }
-  RECURSE_ENTRYTREE(buildPageList, rootNav);
+  RECURSE_ENTRYTREE(buildPageList,rootNav);
 }
 
 // search for the main page defined in this project
-static void findMainPage(EntryNav *rootNav) {
-  if (rootNav->section() == Entry::MAINPAGEDOC_SEC) {
+static void findMainPage(EntryNav *rootNav)
+{
+  if (rootNav->section() == Entry::MAINPAGEDOC_SEC)
+  {
     rootNav->loadEntry(g_storage);
 
-    if (Doxygen::mainPage == 0 && rootNav->tagInfo() == 0) {
+    if (Doxygen::mainPage==0 && rootNav->tagInfo()==0)
+    {
       Entry *root = rootNav->entry();
-      // printf("Found main page! \n======\n%s\n=======\n",root->doc.data());
-      QCString title = root->args.stripWhiteSpace();
-      // QCString indexName=Config_getBool(GENERATE_TREEVIEW)?"main":"index";
-      QCString indexName = "index";
-      Doxygen::mainPage =
-          new PageDef(root->docFile, root->docLine, indexName,
-                      root->brief + root->doc + root->inbodyDocs, title);
-      // setFileNameForSections(root->anchors,"index",Doxygen::mainPage);
-      Doxygen::mainPage->setBriefDescription(root->brief, root->briefFile,
-                                             root->briefLine);
+      //printf("Found main page! \n======\n%s\n=======\n",root->doc.data());
+      QCString title=root->args.stripWhiteSpace();
+      //QCString indexName=Config_getBool(GENERATE_TREEVIEW)?"main":"index";
+      QCString indexName="index";
+      Doxygen::mainPage = new PageDef(root->docFile,root->docLine,
+                              indexName, root->brief+root->doc+root->inbodyDocs,title);
+      //setFileNameForSections(root->anchors,"index",Doxygen::mainPage);
+      Doxygen::mainPage->setBriefDescription(root->brief,root->briefFile,root->briefLine);
       Doxygen::mainPage->setFileName(indexName);
       Doxygen::mainPage->setShowToc(root->stat);
-      addPageToContext(Doxygen::mainPage, rootNav);
+      addPageToContext(Doxygen::mainPage,rootNav);
 
       SectionInfo *si = Doxygen::sectionDict->find(Doxygen::mainPage->name());
-      if (si) {
-        if (si->lineNr != -1) {
-          warn(root->fileName, root->startLine, "multiple use of section label "
-                                                "'%s' for main page, (first "
-                                                "occurrence: %s, line %d)",
-               Doxygen::mainPage->name().data(), si->fileName.data(),
-               si->lineNr);
-        } else {
-          warn(root->fileName, root->startLine, "multiple use of section label "
-                                                "'%s' for main page, (first "
-                                                "occurrence: %s)",
-               Doxygen::mainPage->name().data(), si->fileName.data());
-        }
-      } else {
+      if (si)
+      {
+        if (si->lineNr != -1)
+        {
+          warn(root->fileName,root->startLine,"multiple use of section label '%s' for main page, (first occurrence: %s, line %d)",Doxygen::mainPage->name().data(),si->fileName.data(),si->lineNr);
+        }
+        else
+        {
+          warn(root->fileName,root->startLine,"multiple use of section label '%s' for main page, (first occurrence: %s)",Doxygen::mainPage->name().data(),si->fileName.data());
+        }
+      }
+      else
+      {
         // a page name is a label as well! but should no be double either
-        si = new SectionInfo(indexName, root->startLine,
-                             Doxygen::mainPage->name(),
-                             Doxygen::mainPage->title(), SectionInfo::Page,
-                             0); // level 0
-        Doxygen::sectionDict->append(indexName, si);
+        si=new SectionInfo(
+          indexName, root->startLine,
+          Doxygen::mainPage->name(),
+          Doxygen::mainPage->title(),
+          SectionInfo::Page,
+          0); // level 0
+        Doxygen::sectionDict->append(indexName,si);
         Doxygen::mainPage->addSectionsToDefinition(root->anchors);
       }
-    } else if (rootNav->tagInfo() == 0) {
+    }
+    else if (rootNav->tagInfo()==0)
+    {
       Entry *root = rootNav->entry();
-      warn(root->fileName, root->startLine,
-           "found more than one \\mainpage comment block! (first occurrence: "
-           "%s, line %d), Skipping current block!",
-           Doxygen::mainPage->docFile().data(), Doxygen::mainPage->docLine());
+      warn(root->fileName,root->startLine,
+           "found more than one \\mainpage comment block! (first occurrence: %s, line %d), Skipping current block!",
+           Doxygen::mainPage->docFile().data(),Doxygen::mainPage->docLine());
     }
 
     rootNav->releaseEntry();
   }
-  RECURSE_ENTRYTREE(findMainPage, rootNav);
+  RECURSE_ENTRYTREE(findMainPage,rootNav);
 }
 
-// search for the main page imported via tag files and add only the section
-// labels
-static void findMainPageTagFiles(EntryNav *rootNav) {
-  if (rootNav->section() == Entry::MAINPAGEDOC_SEC) {
+// search for the main page imported via tag files and add only the section labels
+static void findMainPageTagFiles(EntryNav *rootNav)
+{
+  if (rootNav->section() == Entry::MAINPAGEDOC_SEC)
+  {
     rootNav->loadEntry(g_storage);
 
-    if (Doxygen::mainPage && rootNav->tagInfo()) {
+    if (Doxygen::mainPage && rootNav->tagInfo())
+    {
       Entry *root = rootNav->entry();
       Doxygen::mainPage->addSectionsToDefinition(root->anchors);
     }
   }
-  RECURSE_ENTRYTREE(findMainPageTagFiles, rootNav);
+  RECURSE_ENTRYTREE(findMainPageTagFiles,rootNav);
 }
 
-static void computePageRelations(EntryNav *rootNav) {
-  if ((rootNav->section() == Entry::PAGEDOC_SEC ||
-       rootNav->section() == Entry::MAINPAGEDOC_SEC) &&
-      !rootNav->name().isEmpty()) {
+static void computePageRelations(EntryNav *rootNav)
+{
+  if ((rootNav->section()==Entry::PAGEDOC_SEC ||
+       rootNav->section()==Entry::MAINPAGEDOC_SEC
+      )
+      && !rootNav->name().isEmpty()
+     )
+  {
     rootNav->loadEntry(g_storage);
     Entry *root = rootNav->entry();
 
-    PageDef *pd = root->section == Entry::PAGEDOC_SEC
-                      ? Doxygen::pageSDict->find(root->name)
-                      : Doxygen::mainPage;
-    if (pd) {
+    PageDef *pd = root->section==Entry::PAGEDOC_SEC ?
+                    Doxygen::pageSDict->find(root->name) :
+                    Doxygen::mainPage;
+    if (pd)
+    {
       QListIterator<BaseInfo> bii(*root->extends);
       BaseInfo *bi;
-      for (bii.toFirst(); (bi = bii.current()); ++bii) {
+      for (bii.toFirst();(bi=bii.current());++bii)
+      {
         PageDef *subPd = Doxygen::pageSDict->find(bi->name);
-        if (subPd) {
+        if (subPd)
+        {
           pd->addInnerCompound(subPd);
-          // printf("*** Added subpage relation: %s->%s\n",
+          //printf("*** Added subpage relation: %s->%s\n",
           //    pd->name().data(),subPd->name().data());
         }
       }
@@ -8066,36 +8801,42 @@ static void computePageRelations(EntryNav *rootNav) {
 
     rootNav->releaseEntry();
   }
-  RECURSE_ENTRYTREE(computePageRelations, rootNav);
+  RECURSE_ENTRYTREE(computePageRelations,rootNav);
 }
 
-static void checkPageRelations() {
+static void checkPageRelations()
+{
   PageSDict::Iterator pdi(*Doxygen::pageSDict);
-  PageDef *pd = 0;
-  for (pdi.toFirst(); (pd = pdi.current()); ++pdi) {
+  PageDef *pd=0;
+  for (pdi.toFirst();(pd=pdi.current());++pdi)
+  {
     Definition *ppd = pd->getOuterScope();
-    while (ppd) {
-      if (ppd == pd) {
+    while (ppd)
+    {
+      if (ppd==pd)
+      {
         err("page defined at line %d of file %s with label %s is a subpage "
             "of itself! Please remove this cyclic dependency.\n",
-            pd->docLine(), pd->docFile().data(), pd->name().data());
+            pd->docLine(),pd->docFile().data(),pd->name().data());
         exit(1);
       }
-      ppd = ppd->getOuterScope();
+      ppd=ppd->getOuterScope();
     }
   }
 }
 
 //----------------------------------------------------------------------------
 
-static void resolveUserReferences() {
+static void resolveUserReferences()
+{
   SDict<SectionInfo>::Iterator sdi(*Doxygen::sectionDict);
   SectionInfo *si;
-  for (; (si = sdi.current()); ++sdi) {
-    // printf("si->label=`%s' si->definition=%s si->fileName=`%s'\n",
+  for (;(si=sdi.current());++sdi)
+  {
+    //printf("si->label=`%s' si->definition=%s si->fileName=`%s'\n",
     //        si->label.data(),si->definition?si->definition->name().data():"<none>",
     //        si->fileName.data());
-    PageDef *pd = 0;
+    PageDef *pd=0;
 
     // hack: the items of a todo/test/bug/deprecated list are all fragments from
     // different files, so the resulting section's all have the wrong file
@@ -8104,62 +8845,74 @@ static void resolveUserReferences() {
     // generated section labels!
     QDictIterator<RefList> rli(*Doxygen::xrefLists);
     RefList *rl;
-    for (rli.toFirst(); (rl = rli.current()); ++rli) {
-      QCString label = "_" + rl->listName(); // "_todo", "_test", ...
-      if (si->label.left(label.length()) == label) {
-        si->fileName = rl->listName();
-        si->generated = TRUE;
+    for (rli.toFirst();(rl=rli.current());++rli)
+    {
+      QCString label="_"+rl->listName(); // "_todo", "_test", ...
+      if (si->label.left(label.length())==label)
+      {
+        si->fileName=rl->listName();
+        si->generated=TRUE;
         break;
       }
     }
 
-    // printf("start: si->label=%s
-    // si->fileName=%s\n",si->label.data(),si->fileName.data());
-    if (!si->generated) {
+    //printf("start: si->label=%s si->fileName=%s\n",si->label.data(),si->fileName.data());
+    if (!si->generated)
+    {
       // if this section is in a page and the page is in a group, then we
       // have to adjust the link file name to point to the group.
       if (!si->fileName.isEmpty() &&
-          (pd = Doxygen::pageSDict->find(si->fileName)) && pd->getGroupDef()) {
-        si->fileName = pd->getGroupDef()->getOutputFileBase().copy();
+          (pd=Doxygen::pageSDict->find(si->fileName)) &&
+          pd->getGroupDef())
+      {
+        si->fileName=pd->getGroupDef()->getOutputFileBase().copy();
       }
 
-      if (si->definition) {
+      if (si->definition)
+      {
         // TODO: there should be one function in Definition that returns
         // the file to link to, so we can avoid the following tests.
-        GroupDef *gd = 0;
-        if (si->definition->definitionType() == Definition::TypeMember) {
+        GroupDef *gd=0;
+        if (si->definition->definitionType()==Definition::TypeMember)
+        {
           gd = ((MemberDef *)si->definition)->getGroupDef();
         }
 
-        if (gd) {
-          si->fileName = gd->getOutputFileBase().copy();
-        } else {
-          // si->fileName=si->definition->getOutputFileBase().copy();
-          // printf("Setting si->fileName to %s\n",si->fileName.data());
+        if (gd)
+        {
+          si->fileName=gd->getOutputFileBase().copy();
+        }
+        else
+        {
+          //si->fileName=si->definition->getOutputFileBase().copy();
+          //printf("Setting si->fileName to %s\n",si->fileName.data());
         }
       }
     }
-    // printf("end: si->label=%s
-    // si->fileName=%s\n",si->label.data(),si->fileName.data());
+    //printf("end: si->label=%s si->fileName=%s\n",si->label.data(),si->fileName.data());
   }
 }
 
+
+
 //----------------------------------------------------------------------------
 // generate all separate documentation pages
 
-static void generatePageDocs() {
-  // printf("documentedPages=%d
-  // real=%d\n",documentedPages,Doxygen::pageSDict->count());
-  if (documentedPages == 0)
-    return;
+
+static void generatePageDocs()
+{
+  //printf("documentedPages=%d real=%d\n",documentedPages,Doxygen::pageSDict->count());
+  if (documentedPages==0) return;
   PageSDict::Iterator pdi(*Doxygen::pageSDict);
-  PageDef *pd = 0;
-  for (pdi.toFirst(); (pd = pdi.current()); ++pdi) {
-    if (!pd->getGroupDef() && !pd->isReference()) {
-      msg("Generating docs for page %s...\n", pd->name().data());
-      Doxygen::insideMainPage = TRUE;
+  PageDef *pd=0;
+  for (pdi.toFirst();(pd=pdi.current());++pdi)
+  {
+    if (!pd->getGroupDef() && !pd->isReference())
+    {
+      msg("Generating docs for page %s...\n",pd->name().data());
+      Doxygen::insideMainPage=TRUE;
       pd->writeDocumentation(*g_outputList);
-      Doxygen::insideMainPage = FALSE;
+      Doxygen::insideMainPage=FALSE;
     }
   }
 }
@@ -8167,77 +8920,87 @@ static void generatePageDocs() {
 //----------------------------------------------------------------------------
 // create a (sorted) list & dictionary of example pages
 
-static void buildExampleList(EntryNav *rootNav) {
-  if (rootNav->section() == Entry::EXAMPLE_SEC && !rootNav->name().isEmpty()) {
+static void buildExampleList(EntryNav *rootNav)
+{
+  if (rootNav->section()==Entry::EXAMPLE_SEC && !rootNav->name().isEmpty())
+  {
     rootNav->loadEntry(g_storage);
     Entry *root = rootNav->entry();
 
-    if (Doxygen::exampleSDict->find(root->name)) {
-      warn(root->fileName, root->startLine,
-           "Example %s was already documented. Ignoring "
-           "documentation found here.",
-           root->name.data());
-    } else {
-      PageDef *pd =
-          new PageDef(root->fileName, root->startLine, root->name,
-                      root->brief + root->doc + root->inbodyDocs, root->args);
-      pd->setBriefDescription(root->brief, root->briefFile, root->briefLine);
-      pd->setFileName(convertNameToFile(pd->name() + "-example", FALSE, TRUE));
+    if (Doxygen::exampleSDict->find(root->name))
+    {
+      warn(root->fileName,root->startLine,
+          "Example %s was already documented. Ignoring "
+          "documentation found here.",
+          root->name.data()
+          );
+    }
+    else
+    {
+      PageDef *pd=new PageDef(root->fileName,root->startLine,
+          root->name,root->brief+root->doc+root->inbodyDocs,root->args);
+      pd->setBriefDescription(root->brief,root->briefFile,root->briefLine);
+      pd->setFileName(convertNameToFile(pd->name()+"-example",FALSE,TRUE));
       pd->addSectionsToDefinition(root->anchors);
       pd->setLanguage(root->lang);
-      // pi->addSections(root->anchors);
+      //pi->addSections(root->anchors);
 
-      Doxygen::exampleSDict->inSort(root->name, pd);
-      // we don't add example to groups
-      // addExampleToGroups(root,pd);
+      Doxygen::exampleSDict->inSort(root->name,pd);
+      //we don't add example to groups
+      //addExampleToGroups(root,pd);
     }
 
     rootNav->releaseEntry();
   }
-  RECURSE_ENTRYTREE(buildExampleList, rootNav);
+  RECURSE_ENTRYTREE(buildExampleList,rootNav);
 }
 
 //----------------------------------------------------------------------------
 // prints the Entry tree (for debugging)
 
-void printNavTree(EntryNav *rootNav, int indent) {
+void printNavTree(EntryNav *rootNav,int indent)
+{
   QCString indentStr;
-  indentStr.fill(' ', indent);
-  msg("%s%s (sec=0x%x)\n", indentStr.isEmpty() ? "" : indentStr.data(),
-      rootNav->name().isEmpty() ? "<empty>" : rootNav->name().data(),
+  indentStr.fill(' ',indent);
+  msg("%s%s (sec=0x%x)\n",
+      indentStr.isEmpty()?"":indentStr.data(),
+      rootNav->name().isEmpty()?"<empty>":rootNav->name().data(),
       rootNav->section());
-  if (rootNav->children()) {
+  if (rootNav->children())
+  {
     EntryNavListIterator eli(*rootNav->children());
-    for (; eli.current(); ++eli)
-      printNavTree(eli.current(), indent + 2);
+    for (;eli.current();++eli) printNavTree(eli.current(),indent+2);
   }
 }
 
+
 //----------------------------------------------------------------------------
 // generate the example documentation
 
-static void generateExampleDocs() {
+static void generateExampleDocs()
+{
   g_outputList->disable(OutputGenerator::Man);
   PageSDict::Iterator pdi(*Doxygen::exampleSDict);
-  PageDef *pd = 0;
-  for (pdi.toFirst(); (pd = pdi.current()); ++pdi) {
-    msg("Generating docs for example %s...\n", pd->name().data());
+  PageDef *pd=0;
+  for (pdi.toFirst();(pd=pdi.current());++pdi)
+  {
+    msg("Generating docs for example %s...\n",pd->name().data());
     resetCCodeParserState();
-    QCString n = pd->getOutputFileBase();
-    startFile(*g_outputList, n, n, pd->name());
-    startTitle(*g_outputList, n);
+    QCString n=pd->getOutputFileBase();
+    startFile(*g_outputList,n,n,pd->name());
+    startTitle(*g_outputList,n);
     g_outputList->docify(pd->name());
-    endTitle(*g_outputList, n, 0);
+    endTitle(*g_outputList,n,0);
     g_outputList->startContents();
-    g_outputList->generateDoc(pd->docFile(), // file
-                              pd->docLine(), // startLine
-                              pd,            // context
-                              0,             // memberDef
-                              pd->documentation() + "\n\n\\include " +
-                                  pd->name(), // docs
-                              TRUE,           // index words
-                              TRUE,           // is example
-                              pd->name());
+    g_outputList->generateDoc(pd->docFile(),                            // file
+                         pd->docLine(),                            // startLine
+                         pd,                                       // context
+                         0,                                        // memberDef
+                         pd->documentation()+"\n\n\\include "+pd->name(),          // docs
+                         TRUE,                                     // index words
+                         TRUE,                                     // is example
+                         pd->name()
+                        );
     endFile(*g_outputList); // contains g_outputList->endContents()
   }
   g_outputList->enable(OutputGenerator::Man);
@@ -8246,11 +9009,14 @@ static void generateExampleDocs() {
 //----------------------------------------------------------------------------
 // generate module pages
 
-static void generateGroupDocs() {
+static void generateGroupDocs()
+{
   GroupSDict::Iterator gli(*Doxygen::groupSDict);
   GroupDef *gd;
-  for (gli.toFirst(); (gd = gli.current()); ++gli) {
-    if (!gd->isReference()) {
+  for (gli.toFirst();(gd=gli.current());++gli)
+  {
+    if (!gd->isReference())
+    {
       gd->writeDocumentation(*g_outputList);
     }
   }
@@ -8258,7 +9024,7 @@ static void generateGroupDocs() {
 
 //----------------------------------------------------------------------------
 
-// static void generatePackageDocs()
+//static void generatePackageDocs()
 //{
 //  writePackageIndex(*g_outputList);
 //
@@ -8276,29 +9042,35 @@ static void generateGroupDocs() {
 //----------------------------------------------------------------------------
 // generate module pages
 
-static void generateNamespaceDocs() {
-  // writeNamespaceIndex(*g_outputList);
+static void generateNamespaceDocs()
+{
+  //writeNamespaceIndex(*g_outputList);
 
   NamespaceSDict::Iterator nli(*Doxygen::namespaceSDict);
   NamespaceDef *nd;
   // for each namespace...
-  for (; (nd = nli.current()); ++nli) {
+  for (;(nd=nli.current());++nli)
+  {
 
-    if (nd->isLinkableInProject()) {
-      msg("Generating docs for namespace %s\n", nd->name().data());
+    if (nd->isLinkableInProject())
+    {
+      msg("Generating docs for namespace %s\n",nd->name().data());
       nd->writeDocumentation(*g_outputList);
     }
 
     // for each class in the namespace...
     ClassSDict::Iterator cli(*nd->getClassSDict());
     ClassDef *cd;
-    for (; (cd = cli.current()); ++cli) {
-      if ((cd->isLinkableInProject() &&
-           cd->templateMaster() ==
-               0) // skip external references, anonymous compounds and
-          // template instances and nested classes
-          && !cd->isHidden() && !cd->isEmbeddedInOuterScope()) {
-        msg("Generating docs for compound %s...\n", cd->name().data());
+    for ( ; (cd=cli.current()) ; ++cli )
+    {
+      if ( ( cd->isLinkableInProject() &&
+             cd->templateMaster()==0
+           ) // skip external references, anonymous compounds and
+             // template instances and nested classes
+           && !cd->isHidden() && !cd->isEmbeddedInOuterScope()
+         )
+      {
+        msg("Generating docs for compound %s...\n",cd->name().data());
 
         cd->writeDocumentation(*g_outputList);
         cd->writeMemberList(*g_outputList);
@@ -8309,52 +9081,64 @@ static void generateNamespaceDocs() {
 }
 
 #if defined(_WIN32)
-static QCString fixSlashes(QCString &s) {
+static QCString fixSlashes(QCString &s)
+{
   QCString result;
   uint i;
-  for (i = 0; i < s.length(); i++) {
-    switch (s.at(i)) {
-    case '/':
-    case '\\':
-      result += "\\\\";
-      break;
-    default:
-      result += s.at(i);
+  for (i=0;i<s.length();i++)
+  {
+    switch(s.at(i))
+    {
+      case '/':
+      case '\\':
+        result+="\\\\";
+        break;
+      default:
+        result+=s.at(i);
     }
   }
   return result;
 }
 #endif
 
+
 //----------------------------------------------------------------------------
 
 /*! Generate a template version of the configuration file.
  *  If the \a shortList parameter is TRUE a configuration file without
  *  comments will be generated.
  */
-static void generateConfigFile(const char *configFile, bool shortList,
-                               bool updateOnly = FALSE) {
+static void generateConfigFile(const char *configFile,bool shortList,
+                               bool updateOnly=FALSE)
+{
   QFile f;
-  bool fileOpened = openOutputFile(configFile, f);
-  bool writeToStdout = (configFile[0] == '-' && configFile[1] == '\0');
-  if (fileOpened) {
+  bool fileOpened=openOutputFile(configFile,f);
+  bool writeToStdout=(configFile[0]=='-' && configFile[1]=='\0');
+  if (fileOpened)
+  {
     FTextStream t(&f);
-    Config::writeTemplate(t, shortList, updateOnly);
-    if (!writeToStdout) {
-      if (!updateOnly) {
-        msg("\n\nConfiguration file `%s' created.\n\n", configFile);
+    Config::writeTemplate(t,shortList,updateOnly);
+    if (!writeToStdout)
+    {
+      if (!updateOnly)
+      {
+        msg("\n\nConfiguration file `%s' created.\n\n",configFile);
         msg("Now edit the configuration file and enter\n\n");
-        if (qstrcmp(configFile, "Doxyfile") || qstrcmp(configFile, "doxyfile"))
-          msg("  doxygen %s\n\n", configFile);
+        if (qstrcmp(configFile,"Doxyfile") || qstrcmp(configFile,"doxyfile"))
+          msg("  doxygen %s\n\n",configFile);
         else
           msg("  doxygen\n\n");
         msg("to generate the documentation for your project\n\n");
-      } else {
-        msg("\n\nConfiguration file `%s' updated.\n\n", configFile);
+      }
+      else
+      {
+        msg("\n\nConfiguration file `%s' updated.\n\n",configFile);
       }
     }
-  } else {
-    err("Cannot open file %s for writing\n", configFile);
+  }
+  else
+  {
+    err("Cannot open file %s for writing\n",configFile);
     exit(1);
   }
 }
@@ -8362,7 +9146,7 @@ static void generateConfigFile(const char *configFile, bool shortList,
 //----------------------------------------------------------------------------
 // read and parse a tag file
 
-// static bool readLineFromFile(QFile &f,QCString &s)
+//static bool readLineFromFile(QFile &f,QCString &s)
 //{
 //  char c=0;
 //  s.resize(0);
@@ -8372,55 +9156,60 @@ static void generateConfigFile(const char *configFile, bool shortList,
 
 //----------------------------------------------------------------------------
 
-static void readTagFile(Entry *root, const char *tl) {
+static void readTagFile(Entry *root,const char *tl)
+{
   QCString tagLine = tl;
   QCString fileName;
   QCString destName;
   int eqPos = tagLine.find('=');
-  if (eqPos != -1) // tag command contains a destination
+  if (eqPos!=-1) // tag command contains a destination
   {
     fileName = tagLine.left(eqPos).stripWhiteSpace();
-    destName = tagLine.right(tagLine.length() - eqPos - 1).stripWhiteSpace();
+    destName = tagLine.right(tagLine.length()-eqPos-1).stripWhiteSpace();
     QFileInfo fi(fileName);
-    Doxygen::tagDestinationDict.insert(fi.absFilePath().utf8(),
-                                       new QCString(destName));
-    // printf("insert tagDestination
-    // %s->%s\n",fi.fileName().data(),destName.data());
-  } else {
+    Doxygen::tagDestinationDict.insert(fi.absFilePath().utf8(),new QCString(destName));
+    //printf("insert tagDestination %s->%s\n",fi.fileName().data(),destName.data());
+  }
+  else
+  {
     fileName = tagLine;
   }
 
   QFileInfo fi(fileName);
-  if (!fi.exists() || !fi.isFile()) {
+  if (!fi.exists() || !fi.isFile())
+  {
     err("Tag file `%s' does not exist or is not a file. Skipping it...\n",
         fileName.data());
     return;
   }
 
   if (!destName.isEmpty())
-    msg("Reading tag file `%s', location `%s'...\n", fileName.data(),
-        destName.data());
+    msg("Reading tag file `%s', location `%s'...\n",fileName.data(),destName.data());
   else
-    msg("Reading tag file `%s'...\n", fileName.data());
+    msg("Reading tag file `%s'...\n",fileName.data());
 
-  parseTagFile(root, fi.absFilePath().utf8());
+  parseTagFile(root,fi.absFilePath().utf8());
 }
 
 //----------------------------------------------------------------------------
-static void copyLatexStyleSheet() {
+static void copyLatexStyleSheet()
+{
   QStrList latexExtraStyleSheet = Config_getList(LATEX_EXTRA_STYLESHEET);
-  for (uint i = 0; i < latexExtraStyleSheet.count(); ++i) {
+  for (uint i=0; i<latexExtraStyleSheet.count(); ++i)
+  {
     QCString fileName(latexExtraStyleSheet.at(i));
-    if (!fileName.isEmpty()) {
+    if (!fileName.isEmpty())
+    {
       QFileInfo fi(fileName);
-      if (!fi.exists()) {
-        err("Style sheet '%s' specified by LATEX_EXTRA_STYLESHEET does not "
-            "exist!\n",
-            fileName.data());
-      } else {
-        QCString destFileName =
-            Config_getString(LATEX_OUTPUT) + "/" + fi.fileName().data();
-        if (!checkExtension(fi.fileName().data(), latexStyleExtension)) {
+      if (!fi.exists())
+      {
+        err("Style sheet '%s' specified by LATEX_EXTRA_STYLESHEET does not exist!\n",fileName.data());
+      }
+      else
+      {
+        QCString destFileName = Config_getString(LATEX_OUTPUT)+"/"+fi.fileName().data();
+        if (!checkExtension(fi.fileName().data(), latexStyleExtension))
+        {
           destFileName += latexStyleExtension;
         }
         copyFile(fileName, destFileName);
@@ -8430,73 +9219,84 @@ static void copyLatexStyleSheet() {
 }
 
 //----------------------------------------------------------------------------
-static void copyStyleSheet() {
+static void copyStyleSheet()
+{
   QCString &htmlStyleSheet = Config_getString(HTML_STYLESHEET);
-  if (!htmlStyleSheet.isEmpty()) {
+  if (!htmlStyleSheet.isEmpty())
+  {
     QFileInfo fi(htmlStyleSheet);
-    if (!fi.exists()) {
-      err("Style sheet '%s' specified by HTML_STYLESHEET does not exist!\n",
-          htmlStyleSheet.data());
+    if (!fi.exists())
+    {
+      err("Style sheet '%s' specified by HTML_STYLESHEET does not exist!\n",htmlStyleSheet.data());
       htmlStyleSheet.resize(0); // revert to the default
-    } else {
-      QCString destFileName =
-          Config_getString(HTML_OUTPUT) + "/" + fi.fileName().data();
-      copyFile(htmlStyleSheet, destFileName);
+    }
+    else
+    {
+      QCString destFileName = Config_getString(HTML_OUTPUT)+"/"+fi.fileName().data();
+      copyFile(htmlStyleSheet,destFileName);
     }
   }
   QStrList htmlExtraStyleSheet = Config_getList(HTML_EXTRA_STYLESHEET);
-  for (uint i = 0; i < htmlExtraStyleSheet.count(); ++i) {
+  for (uint i=0; i<htmlExtraStyleSheet.count(); ++i)
+  {
     QCString fileName(htmlExtraStyleSheet.at(i));
-    if (!fileName.isEmpty()) {
+    if (!fileName.isEmpty())
+    {
       QFileInfo fi(fileName);
-      if (!fi.exists()) {
-        err("Style sheet '%s' specified by HTML_EXTRA_STYLESHEET does not "
-            "exist!\n",
-            fileName.data());
-      } else if (fi.fileName() == "doxygen.css" ||
-                 fi.fileName() == "tabs.css" ||
-                 fi.fileName() == "navtree.css") {
-        err("Style sheet %s specified by HTML_EXTRA_STYLESHEET is already a "
-            "built-in stylesheet. Please use a different name\n",
-            fi.fileName().data());
-      } else {
-        QCString destFileName =
-            Config_getString(HTML_OUTPUT) + "/" + fi.fileName().data();
+      if (!fi.exists())
+      {
+        err("Style sheet '%s' specified by HTML_EXTRA_STYLESHEET does not exist!\n",fileName.data());
+      }
+      else if (fi.fileName()=="doxygen.css" || fi.fileName()=="tabs.css" || fi.fileName()=="navtree.css")
+      {
+        err("Style sheet %s specified by HTML_EXTRA_STYLESHEET is already a built-in stylesheet. Please use a different name\n",fi.fileName().data());
+      }
+      else
+      {
+        QCString destFileName = Config_getString(HTML_OUTPUT)+"/"+fi.fileName().data();
         copyFile(fileName, destFileName);
       }
     }
   }
 }
 
-static void copyLogo(const QCString &outputOption) {
+static void copyLogo(const QCString &outputOption)
+{
   QCString &projectLogo = Config_getString(PROJECT_LOGO);
-  if (!projectLogo.isEmpty()) {
+  if (!projectLogo.isEmpty())
+  {
     QFileInfo fi(projectLogo);
-    if (!fi.exists()) {
-      err("Project logo '%s' specified by PROJECT_LOGO does not exist!\n",
-          projectLogo.data());
+    if (!fi.exists())
+    {
+      err("Project logo '%s' specified by PROJECT_LOGO does not exist!\n",projectLogo.data());
       projectLogo.resize(0); // revert to the default
-    } else {
-      QCString destFileName = outputOption + "/" + fi.fileName().data();
-      copyFile(projectLogo, destFileName);
+    }
+    else
+    {
+      QCString destFileName = outputOption+"/"+fi.fileName().data();
+      copyFile(projectLogo,destFileName);
       Doxygen::indexList->addImageFile(fi.fileName().data());
     }
   }
 }
 
-static void copyExtraFiles(QStrList files, const QString &filesOption,
-                           const QCString &outputOption) {
+static void copyExtraFiles(QStrList files,const QString &filesOption,const QCString &outputOption)
+{
   uint i;
-  for (i = 0; i < files.count(); ++i) {
+  for (i=0; i<files.count(); ++i)
+  {
     QCString fileName(files.at(i));
 
-    if (!fileName.isEmpty()) {
+    if (!fileName.isEmpty())
+    {
       QFileInfo fi(fileName);
-      if (!fi.exists()) {
-        err("Extra file '%s' specified in %s does not exist!\n",
-            fileName.data(), filesOption.data());
-      } else {
-        QCString destFileName = outputOption + "/" + fi.fileName().data();
+      if (!fi.exists())
+      {
+        err("Extra file '%s' specified in %s does not exist!\n", fileName.data(),filesOption.data());
+      }
+      else
+      {
+        QCString destFileName = outputOption+"/"+fi.fileName().data();
         Doxygen::indexList->addImageFile(fi.fileName().utf8());
         copyFile(fileName, destFileName);
       }
@@ -8506,213 +9306,241 @@ static void copyExtraFiles(QStrList files, const QString &filesOption,
 
 //----------------------------------------------------------------------------
 
-static ParserInterface *getParserForFile(const char *fn) {
-  QCString fileName = fn;
+static ParserInterface *getParserForFile(const char *fn)
+{
+  QCString fileName=fn;
   QCString extension;
   int sep = fileName.findRev('/');
   int ei = fileName.findRev('.');
-  if (ei != -1 &&
-      (sep == -1 || ei > sep)) // matches dir/file.ext but not dir.1/file
+  if (ei!=-1 && (sep==-1 || ei>sep)) // matches dir/file.ext but not dir.1/file
+  {
+    extension=fileName.right(fileName.length()-ei);
+  }
+  else
   {
-    extension = fileName.right(fileName.length() - ei);
-  } else {
     extension = ".no_extension";
   }
 
   return Doxygen::parserManager->getParser(extension);
 }
 
-static void parseFile(ParserInterface *parser, Entry *root, EntryNav *rootNav,
-                      FileDef *fd, const char *fn, bool sameTu,
-                      QStrList &filesInSameTu) {
+static void parseFile(ParserInterface *parser,
+                      Entry *root,EntryNav *rootNav,FileDef *fd,const char *fn,
+                      bool sameTu,QStrList &filesInSameTu)
+{
 #if USE_LIBCLANG
   static bool clangAssistedParsing = Config_getBool(CLANG_ASSISTED_PARSING);
 #else
   static bool clangAssistedParsing = FALSE;
 #endif
-  QCString fileName = fn;
+  QCString fileName=fn;
   QCString extension;
   int ei = fileName.findRev('.');
-  if (ei != -1) {
-    extension = fileName.right(fileName.length() - ei);
-  } else {
+  if (ei!=-1)
+  {
+    extension=fileName.right(fileName.length()-ei);
+  }
+  else
+  {
     extension = ".no_extension";
   }
 
   QFileInfo fi(fileName);
-  BufStr preBuf(fi.size() + 4096);
+  BufStr preBuf(fi.size()+4096);
 
   if (Config_getBool(ENABLE_PREPROCESSING) &&
-      parser->needsPreprocessing(extension)) {
-    BufStr inBuf(fi.size() + 4096);
-    msg("Preprocessing %s...\n", fn);
-    readInputFile(fileName, inBuf);
-    preprocessFile(fileName, inBuf, preBuf);
-  } else // no preprocessing
-  {
-    msg("Reading %s...\n", fn);
-    readInputFile(fileName, preBuf);
-  }
-  if (preBuf.data() && preBuf.curPos() > 0 &&
-      *(preBuf.data() + preBuf.curPos() - 1) != '\n') {
+      parser->needsPreprocessing(extension))
+  {
+    BufStr inBuf(fi.size()+4096);
+    msg("Preprocessing %s...\n",fn);
+    readInputFile(fileName,inBuf);
+    preprocessFile(fileName,inBuf,preBuf);
+  }
+  else // no preprocessing
+  {
+    msg("Reading %s...\n",fn);
+    readInputFile(fileName,preBuf);
+  }
+  if (preBuf.data() && preBuf.curPos()>0 && *(preBuf.data()+preBuf.curPos()-1)!='\n')
+  {
     preBuf.addChar('\n'); // add extra newline to help parser
   }
 
-  BufStr convBuf(preBuf.curPos() + 1024);
+  BufStr convBuf(preBuf.curPos()+1024);
 
   // convert multi-line C++ comments to C style comments
-  convertCppComments(&preBuf, &convBuf, fileName);
+  convertCppComments(&preBuf,&convBuf,fileName);
 
   convBuf.addChar('\0');
 
-  if (clangAssistedParsing && !sameTu) {
+  if (clangAssistedParsing && !sameTu)
+  {
     fd->getAllIncludeFilesRecursively(filesInSameTu);
   }
 
   // use language parse to parse the file
-  parser->parseInput(fileName, convBuf.data(), root, sameTu, filesInSameTu);
+  parser->parseInput(fileName,convBuf.data(),root,sameTu,filesInSameTu);
 
   // store the Entry tree in a file and create an index to
   // navigate/load entries
-  // printf("root->createNavigationIndex for %s\n",fd->name().data());
-  root->createNavigationIndex(rootNav, g_storage, fd);
+  //printf("root->createNavigationIndex for %s\n",fd->name().data());
+  root->createNavigationIndex(rootNav,g_storage,fd);
 }
 
 //! parse the list of input files
-static void parseFiles(Entry *root, EntryNav *rootNav) {
+static void parseFiles(Entry *root,EntryNav *rootNav)
+{
 #if USE_LIBCLANG
   static bool clangAssistedParsing = Config_getBool(CLANG_ASSISTED_PARSING);
-  if (clangAssistedParsing) {
+  if (clangAssistedParsing)
+  {
     QDict<void> g_processedFiles(10007);
 
     // create a dictionary with files to process
     QDict<void> g_filesToProcess(10007);
     StringListIterator it(g_inputFiles);
     QCString *s;
-    for (; (s = it.current()); ++it) {
-      g_filesToProcess.insert(*s, (void *)0x8);
+    for (;(s=it.current());++it)
+    {
+      g_filesToProcess.insert(*s,(void*)0x8);
     }
 
     // process source files (and their include dependencies)
-    for (it.toFirst(); (s = it.current()); ++it) {
+    for (it.toFirst();(s=it.current());++it)
+    {
       bool ambig;
-      FileDef *fd = findFileDef(Doxygen::inputNameDict, s->data(), ambig);
-      ASSERT(fd != 0);
+      FileDef *fd=findFileDef(Doxygen::inputNameDict,s->data(),ambig);
+      ASSERT(fd!=0);
       if (fd->isSource() && !fd->isReference()) // this is a source file
       {
         QStrList filesInSameTu;
-        ParserInterface *parser = getParserForFile(s->data());
+        ParserInterface * parser = getParserForFile(s->data());
         parser->startTranslationUnit(s->data());
-        parseFile(parser, root, rootNav, fd, s->data(), FALSE, filesInSameTu);
-        // printf("  got %d extra files in tu\n",filesInSameTu.count());
+        parseFile(parser,root,rootNav,fd,s->data(),FALSE,filesInSameTu);
+        //printf("  got %d extra files in tu\n",filesInSameTu.count());
 
         // Now process any include files in the same translation unit
         // first. When libclang is used this is much more efficient.
         char *incFile = filesInSameTu.first();
-        while (incFile && g_filesToProcess.find(incFile)) {
-          if (qstrcmp(incFile, s->data()) && !g_processedFiles.find(incFile)) {
-            FileDef *ifd = findFileDef(Doxygen::inputNameDict, incFile, ambig);
-            if (ifd && !ifd->isReference()) {
+        while (incFile && g_filesToProcess.find(incFile))
+        {
+          if (qstrcmp(incFile,s->data()) && !g_processedFiles.find(incFile))
+          {
+            FileDef *ifd=findFileDef(Doxygen::inputNameDict,incFile,ambig);
+            if (ifd && !ifd->isReference())
+            {
               QStrList moreFiles;
-              // printf("  Processing %s in same translation unit as
-              // %s\n",incFile,s->data());
-              parseFile(parser, root, rootNav, ifd, incFile, TRUE, moreFiles);
-              g_processedFiles.insert(incFile, (void *)0x8);
+              //printf("  Processing %s in same translation unit as %s\n",incFile,s->data());
+              parseFile(parser,root,rootNav,ifd,incFile,TRUE,moreFiles);
+              g_processedFiles.insert(incFile,(void*)0x8);
             }
           }
           incFile = filesInSameTu.next();
         }
         parser->finishTranslationUnit();
-        g_processedFiles.insert(*s, (void *)0x8);
+        g_processedFiles.insert(*s,(void*)0x8);
       }
     }
     // process remaining files
-    for (it.toFirst(); (s = it.current()); ++it) {
+    for (it.toFirst();(s=it.current());++it)
+    {
       if (!g_processedFiles.find(*s)) // not yet processed
       {
         bool ambig;
         QStrList filesInSameTu;
-        FileDef *fd = findFileDef(Doxygen::inputNameDict, s->data(), ambig);
-        ASSERT(fd != 0);
-        ParserInterface *parser = getParserForFile(s->data());
+        FileDef *fd=findFileDef(Doxygen::inputNameDict,s->data(),ambig);
+        ASSERT(fd!=0);
+        ParserInterface * parser = getParserForFile(s->data());
         parser->startTranslationUnit(s->data());
-        parseFile(parser, root, rootNav, fd, s->data(), FALSE, filesInSameTu);
+        parseFile(parser,root,rootNav,fd,s->data(),FALSE,filesInSameTu);
         parser->finishTranslationUnit();
-        g_processedFiles.insert(*s, (void *)0x8);
+        g_processedFiles.insert(*s,(void*)0x8);
       }
     }
-  } else // normal pocessing
+  }
+  else // normal pocessing
 #endif
   {
     StringListIterator it(g_inputFiles);
     QCString *s;
-    for (; (s = it.current()); ++it) {
+    for (;(s=it.current());++it)
+    {
       bool ambig;
       QStrList filesInSameTu;
-      FileDef *fd = findFileDef(Doxygen::inputNameDict, s->data(), ambig);
-      ASSERT(fd != 0);
-      ParserInterface *parser = getParserForFile(s->data());
+      FileDef *fd=findFileDef(Doxygen::inputNameDict,s->data(),ambig);
+      ASSERT(fd!=0);
+      ParserInterface * parser = getParserForFile(s->data());
       parser->startTranslationUnit(s->data());
-      parseFile(parser, root, rootNav, fd, s->data(), FALSE, filesInSameTu);
+      parseFile(parser,root,rootNav,fd,s->data(),FALSE,filesInSameTu);
     }
   }
 }
 
 // resolves a path that may include symlinks, if a recursive symlink is
 // found an empty string is returned.
-static QCString resolveSymlink(QCString path) {
-  int sepPos = 0;
-  int oldPos = 0;
+static QCString resolveSymlink(QCString path)
+{
+  int sepPos=0;
+  int oldPos=0;
   QFileInfo fi;
   QDict<void> nonSymlinks;
   QDict<void> known;
   QCString result = path;
   QCString oldPrefix = "/";
-  do {
+  do
+  {
 #ifdef WIN32
     // UNC path, skip server and share name
-    if (sepPos == 0 && (result.left(2) == "//" || result.left(2) == "\\\\"))
-      sepPos = result.find('/', 2);
-    if (sepPos != -1)
-      sepPos = result.find('/', sepPos + 1);
+    if (sepPos==0 && (result.left(2)=="//" || result.left(2)=="\\\\"))
+      sepPos = result.find('/',2);
+    if (sepPos!=-1)
+      sepPos = result.find('/',sepPos+1);
 #else
-    sepPos = result.find('/', sepPos + 1);
+    sepPos = result.find('/',sepPos+1);
 #endif
-    QCString prefix = sepPos == -1 ? result : result.left(sepPos);
-    if (nonSymlinks.find(prefix) == 0) {
+    QCString prefix = sepPos==-1 ? result : result.left(sepPos);
+    if (nonSymlinks.find(prefix)==0)
+    {
       fi.setFile(prefix);
-      if (fi.isSymLink()) {
+      if (fi.isSymLink())
+      {
         QString target = fi.readLink();
         bool isRelative = QFileInfo(target).isRelative();
-        if (isRelative) {
-          target = QDir::cleanDirPath(oldPrefix + "/" + target.data());
+        if (isRelative)
+        {
+          target = QDir::cleanDirPath(oldPrefix+"/"+target.data());
         }
-        if (sepPos != -1) {
-          if (fi.isDir() && target.length() > 0 &&
-              target.at(target.length() - 1) != '/') {
-            target += '/';
+        if (sepPos!=-1)
+        {
+          if (fi.isDir() && target.length()>0 && target.at(target.length()-1)!='/')
+          {
+            target+='/';
           }
-          target += result.mid(sepPos);
+          target+=result.mid(sepPos);
         }
         result = QDir::cleanDirPath(target).data();
         sepPos = 0;
-        if (known.find(result))
-          return QCString(); // recursive symlink!
-        known.insert(result, (void *)0x8);
-        if (isRelative) {
+        if (known.find(result)) return QCString(); // recursive symlink!
+        known.insert(result,(void*)0x8);
+        if (isRelative)
+        {
           sepPos = oldPos;
-        } else // link to absolute path
+        }
+        else // link to absolute path
         {
           sepPos = 0;
           oldPrefix = "/";
         }
-      } else {
-        nonSymlinks.insert(prefix, (void *)0x8);
+      }
+      else
+      {
+        nonSymlinks.insert(prefix,(void*)0x8);
         oldPrefix = prefix;
       }
       oldPos = sepPos;
     }
-  } while (sepPos != -1);
+  }
+  while (sepPos!=-1);
   return QDir::cleanDirPath(result).data();
 }
 
@@ -8724,86 +9552,101 @@ static QDict<void> g_pathsVisited(1009);
 // The directory is read iff the recusiveFlag is set.
 // The contents of all files is append to the input string
 
-int readDir(QFileInfo *fi, FileNameList *fnList, FileNameDict *fnDict,
-            StringDict *exclDict, QStrList *patList, QStrList *exclPatList,
-            StringList *resultList, StringDict *resultDict,
-            bool errorIfNotExist, bool recursive, QDict<void> *killDict,
-            QDict<void> *paths) {
+int readDir(QFileInfo *fi,
+            FileNameList *fnList,
+            FileNameDict *fnDict,
+            StringDict  *exclDict,
+            QStrList *patList,
+            QStrList *exclPatList,
+            StringList *resultList,
+            StringDict *resultDict,
+            bool errorIfNotExist,
+            bool recursive,
+            QDict<void> *killDict,
+            QDict<void> *paths
+           )
+{
   QCString dirName = fi->absFilePath().utf8();
-  if (paths && paths->find(dirName) == 0) {
-    paths->insert(dirName, (void *)0x8);
+  if (paths && paths->find(dirName)==0)
+  {
+    paths->insert(dirName,(void*)0x8);
   }
-  if (fi->isSymLink()) {
+  if (fi->isSymLink())
+  {
     dirName = resolveSymlink(dirName.data());
-    if (dirName.isEmpty())
-      return 0; // recusive symlink
-    if (g_pathsVisited.find(dirName))
-      return 0; // already visited path
-    g_pathsVisited.insert(dirName, (void *)0x8);
+    if (dirName.isEmpty()) return 0;            // recusive symlink
+    if (g_pathsVisited.find(dirName)) return 0; // already visited path
+    g_pathsVisited.insert(dirName,(void*)0x8);
   }
   QDir dir(dirName);
-  dir.setFilter(QDir::Files | QDir::Dirs | QDir::Hidden);
-  int totalSize = 0;
+  dir.setFilter( QDir::Files | QDir::Dirs | QDir::Hidden );
+  int totalSize=0;
   msg("Searching for files in directory %s\n", fi->absFilePath().data());
-  // printf("killDict=%p count=%d\n",killDict,killDict->count());
+  //printf("killDict=%p count=%d\n",killDict,killDict->count());
 
   const QFileInfoList *list = dir.entryInfoList();
-  if (list) {
-    QFileInfoListIterator it(*list);
+  if (list)
+  {
+    QFileInfoListIterator it( *list );
     QFileInfo *cfi;
 
-    while ((cfi = it.current())) {
-      if (exclDict == 0 ||
-          exclDict->find(cfi->absFilePath().utf8()) ==
-              0) { // file should not be excluded
-        // printf("killDict->find(%s)\n",cfi->absFilePath().data());
-        if (!cfi->exists() || !cfi->isReadable()) {
-          if (errorIfNotExist) {
-            warn_uncond(
-                "source %s is not a readable file or directory... skipping.\n",
-                cfi->absFilePath().data());
+    while ((cfi=it.current()))
+    {
+      if (exclDict==0 || exclDict->find(cfi->absFilePath().utf8())==0)
+      { // file should not be excluded
+        //printf("killDict->find(%s)\n",cfi->absFilePath().data());
+        if (!cfi->exists() || !cfi->isReadable())
+        {
+          if (errorIfNotExist)
+          {
+            warn_uncond("source %s is not a readable file or directory... skipping.\n",cfi->absFilePath().data());
           }
-        } else if (cfi->isFile() &&
-                   (!Config_getBool(EXCLUDE_SYMLINKS) || !cfi->isSymLink()) &&
-                   (patList == 0 || patternMatch(*cfi, patList)) &&
-                   !patternMatch(*cfi, exclPatList) &&
-                   (killDict == 0 ||
-                    killDict->find(cfi->absFilePath().utf8()) == 0)) {
-          totalSize += cfi->size() + cfi->absFilePath().length() + 4;
-          QCString name = cfi->fileName().utf8();
-          // printf("New file %s\n",name.data());
-          if (fnDict) {
-            FileDef *fd = new FileDef(cfi->dirPath().utf8() + "/", name);
-            FileName *fn = 0;
-            if (!name.isEmpty() && (fn = (*fnDict)[name])) {
+        }
+        else if (cfi->isFile() &&
+            (!Config_getBool(EXCLUDE_SYMLINKS) || !cfi->isSymLink()) &&
+            (patList==0 || patternMatch(*cfi,patList)) &&
+            !patternMatch(*cfi,exclPatList) &&
+            (killDict==0 || killDict->find(cfi->absFilePath().utf8())==0)
+            )
+        {
+          totalSize+=cfi->size()+cfi->absFilePath().length()+4;
+          QCString name=cfi->fileName().utf8();
+          //printf("New file %s\n",name.data());
+          if (fnDict)
+          {
+            FileDef  *fd=new FileDef(cfi->dirPath().utf8()+"/",name);
+            FileName *fn=0;
+            if (!name.isEmpty() && (fn=(*fnDict)[name]))
+            {
               fn->append(fd);
-            } else {
-              fn = new FileName(cfi->absFilePath().utf8(), name);
+            }
+            else
+            {
+              fn = new FileName(cfi->absFilePath().utf8(),name);
               fn->append(fd);
-              if (fnList)
-                fnList->inSort(fn);
-              fnDict->insert(name, fn);
+              if (fnList) fnList->inSort(fn);
+              fnDict->insert(name,fn);
             }
           }
-          QCString *rs = 0;
-          if (resultList || resultDict) {
-            rs = new QCString(cfi->absFilePath().utf8());
+          QCString *rs=0;
+          if (resultList || resultDict)
+          {
+            rs=new QCString(cfi->absFilePath().utf8());
           }
-          if (resultList)
-            resultList->append(rs);
-          if (resultDict)
-            resultDict->insert(cfi->absFilePath().utf8(), rs);
-          if (killDict)
-            killDict->insert(cfi->absFilePath().utf8(), (void *)0x8);
-        } else if (recursive &&
-                   (!Config_getBool(EXCLUDE_SYMLINKS) || !cfi->isSymLink()) &&
-                   cfi->isDir() && !patternMatch(*cfi, exclPatList) &&
-                   cfi->fileName().at(0) != '.') // skip "." ".." and ".dir"
+          if (resultList) resultList->append(rs);
+          if (resultDict) resultDict->insert(cfi->absFilePath().utf8(),rs);
+          if (killDict) killDict->insert(cfi->absFilePath().utf8(),(void *)0x8);
+        }
+        else if (recursive &&
+            (!Config_getBool(EXCLUDE_SYMLINKS) || !cfi->isSymLink()) &&
+            cfi->isDir() &&
+            !patternMatch(*cfi,exclPatList) &&
+            cfi->fileName().at(0)!='.') // skip "." ".." and ".dir"
         {
           cfi->setFile(cfi->absFilePath());
-          totalSize += readDir(cfi, fnList, fnDict, exclDict, patList,
-                               exclPatList, resultList, resultDict,
-                               errorIfNotExist, recursive, killDict, paths);
+          totalSize+=readDir(cfi,fnList,fnDict,exclDict,
+              patList,exclPatList,resultList,resultDict,errorIfNotExist,
+              recursive,killDict,paths);
         }
       }
       ++it;
@@ -8812,80 +9655,94 @@ int readDir(QFileInfo *fi, FileNameList *fnList, FileNameDict *fnDict,
   return totalSize;
 }
 
+
 //----------------------------------------------------------------------------
 // read a file or all files in a directory and append their contents to the
 // input string. The names of the files are appended to the `fiList' list.
 
-int readFileOrDirectory(const char *s, FileNameList *fnList,
-                        FileNameDict *fnDict, StringDict *exclDict,
-                        QStrList *patList, QStrList *exclPatList,
-                        StringList *resultList, StringDict *resultDict,
-                        bool recursive, bool errorIfNotExist,
-                        QDict<void> *killDict, QDict<void> *paths) {
-  // printf("killDict=%p count=%d\n",killDict,killDict->count());
+int readFileOrDirectory(const char *s,
+                        FileNameList *fnList,
+                        FileNameDict *fnDict,
+                        StringDict *exclDict,
+                        QStrList *patList,
+                        QStrList *exclPatList,
+                        StringList *resultList,
+                        StringDict *resultDict,
+                        bool recursive,
+                        bool errorIfNotExist,
+                        QDict<void> *killDict,
+                        QDict<void> *paths
+                       )
+{
+  //printf("killDict=%p count=%d\n",killDict,killDict->count());
   // strip trailing slashes
-  if (s == 0)
-    return 0;
+  if (s==0) return 0;
   QCString fs = s;
-  char lc = fs.at(fs.length() - 1);
-  if (lc == '/' || lc == '\\')
-    fs = fs.left(fs.length() - 1);
+  char lc = fs.at(fs.length()-1);
+  if (lc=='/' || lc=='\\') fs = fs.left(fs.length()-1);
 
   QFileInfo fi(fs);
-  // printf("readFileOrDirectory(%s)\n",s);
-  int totalSize = 0;
-  {
-    if (exclDict == 0 || exclDict->find(fi.absFilePath().utf8()) == 0) {
-      if (!fi.exists() || !fi.isReadable()) {
-        if (errorIfNotExist) {
-          warn_uncond(
-              "source %s is not a readable file or directory... skipping.\n",
-              s);
-        }
-      } else if (!Config_getBool(EXCLUDE_SYMLINKS) || !fi.isSymLink()) {
-        if (fi.isFile()) {
+  //printf("readFileOrDirectory(%s)\n",s);
+  int totalSize=0;
+  {
+    if (exclDict==0 || exclDict->find(fi.absFilePath().utf8())==0)
+    {
+      if (!fi.exists() || !fi.isReadable())
+      {
+        if (errorIfNotExist)
+        {
+          warn_uncond("source %s is not a readable file or directory... skipping.\n",s);
+        }
+      }
+      else if (!Config_getBool(EXCLUDE_SYMLINKS) || !fi.isSymLink())
+      {
+        if (fi.isFile())
+        {
           QCString dirPath = fi.dirPath(TRUE).utf8();
           QCString filePath = fi.absFilePath().utf8();
-          if (paths && paths->find(dirPath)) {
-            paths->insert(dirPath, (void *)0x8);
+          if (paths && paths->find(dirPath))
+          {
+            paths->insert(dirPath,(void*)0x8);
           }
-          // printf("killDict->find(%s)\n",fi.absFilePath().data());
-          if (killDict == 0 || killDict->find(filePath) == 0) {
-            totalSize += fi.size() + fi.absFilePath().length() +
-                         4; // readFile(&fi,fiList,input);
-            // fiList->inSort(new FileInfo(fi));
-            QCString name = fi.fileName().utf8();
-            // printf("New file %s\n",name.data());
-            if (fnDict) {
-              FileDef *fd = new FileDef(dirPath + "/", name);
-              FileName *fn = 0;
-              if (!name.isEmpty() && (fn = (*fnDict)[name])) {
+          //printf("killDict->find(%s)\n",fi.absFilePath().data());
+          if (killDict==0 || killDict->find(filePath)==0)
+          {
+            totalSize+=fi.size()+fi.absFilePath().length()+4; //readFile(&fi,fiList,input);
+            //fiList->inSort(new FileInfo(fi));
+            QCString name=fi.fileName().utf8();
+            //printf("New file %s\n",name.data());
+            if (fnDict)
+            {
+              FileDef  *fd=new FileDef(dirPath+"/",name);
+              FileName *fn=0;
+              if (!name.isEmpty() && (fn=(*fnDict)[name]))
+              {
                 fn->append(fd);
-              } else {
-                fn = new FileName(filePath, name);
+              }
+              else
+              {
+                fn = new FileName(filePath,name);
                 fn->append(fd);
-                if (fnList)
-                  fnList->inSort(fn);
-                fnDict->insert(name, fn);
+                if (fnList) fnList->inSort(fn);
+                fnDict->insert(name,fn);
               }
             }
-            QCString *rs = 0;
-            if (resultList || resultDict) {
-              rs = new QCString(filePath);
-              if (resultList)
-                resultList->append(rs);
-              if (resultDict)
-                resultDict->insert(filePath, rs);
+            QCString *rs=0;
+            if (resultList || resultDict)
+            {
+              rs=new QCString(filePath);
+              if (resultList) resultList->append(rs);
+              if (resultDict) resultDict->insert(filePath,rs);
             }
 
-            if (killDict)
-              killDict->insert(fi.absFilePath().utf8(), (void *)0x8);
+            if (killDict) killDict->insert(fi.absFilePath().utf8(),(void *)0x8);
           }
-        } else if (fi.isDir()) // readable dir
+        }
+        else if (fi.isDir()) // readable dir
         {
-          totalSize += readDir(&fi, fnList, fnDict, exclDict, patList,
-                               exclPatList, resultList, resultDict,
-                               errorIfNotExist, recursive, killDict, paths);
+          totalSize+=readDir(&fi,fnList,fnDict,exclDict,patList,
+              exclPatList,resultList,resultDict,errorIfNotExist,
+              recursive,killDict,paths);
         }
       }
     }
@@ -8895,27 +9752,32 @@ int readFileOrDirectory(const char *s, FileNameList *fnList,
 
 //----------------------------------------------------------------------------
 
-void readFormulaRepository() {
-  QFile f(Config_getString(HTML_OUTPUT) + "/formula.repository");
+void readFormulaRepository()
+{
+  QFile f(Config_getString(HTML_OUTPUT)+"/formula.repository");
   if (f.open(IO_ReadOnly)) // open repository
   {
     msg("Reading formula repository...\n");
     QTextStream t(&f);
     QCString line;
-    while (!t.eof()) {
-      line = t.readLine().utf8();
-      int se = line.find(':'); // find name and text separator.
-      if (se == -1) {
+    while (!t.eof())
+    {
+      line=t.readLine().utf8();
+      int se=line.find(':'); // find name and text separator.
+      if (se==-1)
+      {
         warn_uncond("formula.repository is corrupted!\n");
         break;
-      } else {
+      }
+      else
+      {
         QCString formName = line.left(se);
-        QCString formText = line.right(line.length() - se - 1);
-        Formula *f = new Formula(formText);
+        QCString formText = line.right(line.length()-se-1);
+        Formula *f=new Formula(formText);
         Doxygen::formulaList->setAutoDelete(TRUE);
         Doxygen::formulaList->append(f);
-        Doxygen::formulaDict->insert(formText, f);
-        Doxygen::formulaNameDict->insert(formName, f);
+        Doxygen::formulaDict->insert(formText,f);
+        Doxygen::formulaNameDict->insert(formName,f);
       }
     }
   }
@@ -8923,70 +9785,85 @@ void readFormulaRepository() {
 
 //----------------------------------------------------------------------------
 
-static void expandAliases() {
+static void expandAliases()
+{
   QDictIterator<QCString> adi(Doxygen::aliasDict);
   QCString *s;
-  for (adi.toFirst(); (s = adi.current()); ++adi) {
-    *s = expandAlias(adi.currentKey(), *s);
+  for (adi.toFirst();(s=adi.current());++adi)
+  {
+    *s = expandAlias(adi.currentKey(),*s);
   }
 }
 
 //----------------------------------------------------------------------------
 
-static void escapeAliases() {
+static void escapeAliases()
+{
   QDictIterator<QCString> adi(Doxygen::aliasDict);
   QCString *s;
-  for (adi.toFirst(); (s = adi.current()); ++adi) {
-    QCString value = *s, newValue;
-    int in, p = 0;
+  for (adi.toFirst();(s=adi.current());++adi)
+  {
+    QCString value=*s,newValue;
+    int in,p=0;
     // for each \n in the alias command value
-    while ((in = value.find("\\n", p)) != -1) {
-      newValue += value.mid(p, in - p);
+    while ((in=value.find("\\n",p))!=-1)
+    {
+      newValue+=value.mid(p,in-p);
       // expand \n's except if \n is part of a built-in command.
-      if (value.mid(in, 5) != "\\note" && value.mid(in, 5) != "\\name" &&
-          value.mid(in, 10) != "\\namespace" &&
-          value.mid(in, 14) != "\\nosubgrouping") {
-        newValue += "\\_linebr ";
-      } else {
-        newValue += "\\n";
+      if (value.mid(in,5)!="\\note" &&
+          value.mid(in,5)!="\\name" &&
+          value.mid(in,10)!="\\namespace" &&
+          value.mid(in,14)!="\\nosubgrouping"
+         )
+      {
+        newValue+="\\_linebr ";
+      }
+      else
+      {
+        newValue+="\\n";
       }
-      p = in + 2;
+      p=in+2;
     }
-    newValue += value.mid(p, value.length() - p);
-    *s = newValue;
-    // printf("Alias %s has value %s\n",adi.currentKey().data(),s->data());
+    newValue+=value.mid(p,value.length()-p);
+    *s=newValue;
+    //printf("Alias %s has value %s\n",adi.currentKey().data(),s->data());
   }
 }
 
 //----------------------------------------------------------------------------
 
-void readAliases() {
+void readAliases()
+{
   // add aliases to a dictionary
   Doxygen::aliasDict.setAutoDelete(TRUE);
   QStrList &aliasList = Config_getList(ALIASES);
-  const char *s = aliasList.first();
-  while (s) {
-    if (Doxygen::aliasDict[s] == 0) {
-      QCString alias = s;
-      int i = alias.find('=');
-      if (i > 0) {
-        QCString name = alias.left(i).stripWhiteSpace();
-        QCString value = alias.right(alias.length() - i - 1);
-        // printf("Alias: found name=`%s'
-        // value=`%s'\n",name.data(),value.data());
-        if (!name.isEmpty()) {
-          QCString *dn = Doxygen::aliasDict[name];
-          if (dn == 0) // insert new alias
+  const char *s=aliasList.first();
+  while (s)
+  {
+    if (Doxygen::aliasDict[s]==0)
+    {
+      QCString alias=s;
+      int i=alias.find('=');
+      if (i>0)
+      {
+        QCString name=alias.left(i).stripWhiteSpace();
+        QCString value=alias.right(alias.length()-i-1);
+        //printf("Alias: found name=`%s' value=`%s'\n",name.data(),value.data());
+        if (!name.isEmpty())
+        {
+          QCString *dn=Doxygen::aliasDict[name];
+          if (dn==0) // insert new alias
           {
-            Doxygen::aliasDict.insert(name, new QCString(value));
-          } else // overwrite previous alias
+            Doxygen::aliasDict.insert(name,new QCString(value));
+          }
+          else // overwrite previous alias
           {
-            *dn = value;
+            *dn=value;
           }
         }
       }
     }
-    s = aliasList.next();
+    s=aliasList.next();
   }
   expandAliases();
   escapeAliases();
@@ -8994,95 +9871,95 @@ void readAliases() {
 
 //----------------------------------------------------------------------------
 
-static void dumpSymbol(FTextStream &t, Definition *d) {
+static void dumpSymbol(FTextStream &t,Definition *d)
+{
   QCString anchor;
-  if (d->definitionType() == Definition::TypeMember) {
+  if (d->definitionType()==Definition::TypeMember)
+  {
     MemberDef *md = (MemberDef *)d;
-    anchor = ":" + md->anchor();
+    anchor=":"+md->anchor();
   }
   QCString scope;
-  if (d->getOuterScope() && d->getOuterScope() != Doxygen::globalScope) {
-    scope =
-        d->getOuterScope()->getOutputFileBase() + Doxygen::htmlFileExtension;
+  if (d->getOuterScope() && d->getOuterScope()!=Doxygen::globalScope)
+  {
+    scope = d->getOuterScope()->getOutputFileBase()+Doxygen::htmlFileExtension;
   }
   t << "REPLACE INTO symbols (symbol_id,scope_id,name,file,line) VALUES('"
-    << d->getOutputFileBase() + Doxygen::htmlFileExtension + anchor << "','"
-    << scope << "','" << d->name() << "','" << d->getDefFileName() << "','"
-    << d->getDefLine() << "');" << endl;
+    << d->getOutputFileBase()+Doxygen::htmlFileExtension+anchor << "','"
+    << scope << "','"
+    << d->name() << "','"
+    << d->getDefFileName() << "','"
+    << d->getDefLine()
+    << "');" << endl;
 }
 
-static void dumpSymbolMap() {
+static void dumpSymbolMap()
+{
   QFile f("symbols.sql");
-  if (f.open(IO_WriteOnly)) {
+  if (f.open(IO_WriteOnly))
+  {
     FTextStream t(&f);
     QDictIterator<DefinitionIntf> di(*Doxygen::symbolMap);
     DefinitionIntf *intf;
-    for (; (intf = di.current()); ++di) {
-      if (intf->definitionType() ==
-          DefinitionIntf::TypeSymbolList) // list of symbols
+    for (;(intf=di.current());++di)
+    {
+      if (intf->definitionType()==DefinitionIntf::TypeSymbolList) // list of symbols
       {
-        DefinitionListIterator dli(*(DefinitionList *)intf);
+        DefinitionListIterator dli(*(DefinitionList*)intf);
         Definition *d;
         // for each symbol
-        for (dli.toFirst(); (d = dli.current()); ++dli) {
-          dumpSymbol(t, d);
+        for (dli.toFirst();(d=dli.current());++dli)
+        {
+          dumpSymbol(t,d);
         }
-      } else // single symbol
+      }
+      else // single symbol
       {
         Definition *d = (Definition *)intf;
-        if (d != Doxygen::globalScope)
-          dumpSymbol(t, d);
+        if (d!=Doxygen::globalScope) dumpSymbol(t,d);
       }
     }
   }
 }
 
 // print developer options of doxygen
-static void devUsage() {
+static void devUsage()
+{
   msg("Developer parameters:\n");
   msg("  -m          dump symbol map\n");
   msg("  -b          output to wizard\n");
   msg("  -T          activates output generation via Django like template\n");
-  msg("  -d <level>  enable a debug level, such as (multiple invocations of -d "
-      "are possible):\n");
+  msg("  -d <level>  enable a debug level, such as (multiple invocations of -d are possible):\n");
   Debug::printFlags();
 }
 
+
 //----------------------------------------------------------------------------
 // print the usage of doxygen
 
-static void usage(const char *name) {
-  msg("Doxygen version %s\nCopyright Dimitri van Heesch 1997-2015\n\n",
-      versionString);
+static void usage(const char *name)
+{
+  msg("Doxygen version %s\nCopyright Dimitri van Heesch 1997-2015\n\n",versionString);
   msg("You can use doxygen in a number of ways:\n\n");
   msg("1) Use doxygen to generate a template configuration file:\n");
-  msg("    %s [-s] -g [configName]\n\n", name);
-  msg("    If - is used for configName doxygen will write to standard "
-      "output.\n\n");
+  msg("    %s [-s] -g [configName]\n\n",name);
+  msg("    If - is used for configName doxygen will write to standard output.\n\n");
   msg("2) Use doxygen to update an old configuration file:\n");
-  msg("    %s [-s] -u [configName]\n\n", name);
+  msg("    %s [-s] -u [configName]\n\n",name);
   msg("3) Use doxygen to generate documentation using an existing ");
   msg("configuration file:\n");
-  msg("    %s [configName]\n\n", name);
-  msg("    If - is used for configName doxygen will read from standard "
-      "input.\n\n");
-  msg("4) Use doxygen to generate a template file controlling the layout of "
-      "the\n");
+  msg("    %s [configName]\n\n",name);
+  msg("    If - is used for configName doxygen will read from standard input.\n\n");
+  msg("4) Use doxygen to generate a template file controlling the layout of the\n");
   msg("   generated documentation:\n");
-  msg("    %s -l [layoutFileName.xml]\n\n", name);
-  msg("5) Use doxygen to generate a template style sheet file for RTF, HTML or "
-      "Latex.\n");
-  msg("    RTF:        %s -w rtf styleSheetFile\n", name);
-  msg("    HTML:       %s -w html headerFile footerFile styleSheetFile "
-      "[configFile]\n",
-      name);
-  msg("    LaTeX:      %s -w latex headerFile footerFile styleSheetFile "
-      "[configFile]\n\n",
-      name);
+  msg("    %s -l [layoutFileName.xml]\n\n",name);
+  msg("5) Use doxygen to generate a template style sheet file for RTF, HTML or Latex.\n");
+  msg("    RTF:        %s -w rtf styleSheetFile\n",name);
+  msg("    HTML:       %s -w html headerFile footerFile styleSheetFile [configFile]\n",name);
+  msg("    LaTeX:      %s -w latex headerFile footerFile styleSheetFile [configFile]\n\n",name);
   msg("6) Use doxygen to generate a rtf extensions file\n");
-  msg("    RTF:   %s -e rtf extensionsFile\n\n", name);
-  msg("If -s is specified the comments of the configuration items in the "
-      "config file will be omitted.\n");
+  msg("    RTF:   %s -e rtf extensionsFile\n\n",name);
+  msg("If -s is specified the comments of the configuration items in the config file will be omitted.\n");
   msg("If configName is omitted `Doxyfile' will be used as a default.\n\n");
   msg("-v print version string\n");
 }
@@ -9091,25 +9968,26 @@ static void usage(const char *name) {
 // read the argument of option `c' from the comment argument list and
 // update the option index `optind'.
 
-static const char *getArg(int argc, char **argv, int &optind) {
-  char *s = 0;
-  if (qstrlen(&argv[optind][2]) > 0)
-    s = &argv[optind][2];
-  else if (optind + 1 < argc && argv[optind + 1][0] != '-')
-    s = argv[++optind];
+static const char *getArg(int argc,char **argv,int &optind)
+{
+  char *s=0;
+  if (qstrlen(&argv[optind][2])>0)
+    s=&argv[optind][2];
+  else if (optind+1<argc && argv[optind+1][0]!='-')
+    s=argv[++optind];
   return s;
 }
 
 //----------------------------------------------------------------------------
 
-void initDoxygen() {
+void initDoxygen()
+{
   initResources();
   const char *lang = portable_getenv("LC_ALL");
-  if (lang)
-    portable_setenv("LANG", lang);
-  setlocale(LC_ALL, "");
-  setlocale(LC_CTYPE, "C"); // to get isspace(0xA0)==0, needed for UTF-8
-  setlocale(LC_NUMERIC, "C");
+  if (lang) portable_setenv("LANG",lang);
+  setlocale(LC_ALL,"");
+  setlocale(LC_CTYPE,"C"); // to get isspace(0xA0)==0, needed for UTF-8
+  setlocale(LC_NUMERIC,"C");
 
   portable_correct_path();
 
@@ -9117,18 +9995,16 @@ void initDoxygen() {
   initPreprocessor();
 
   Doxygen::parserManager = new ParserManager;
-  Doxygen::parserManager->registerDefaultParser(new FileParser);
-  Doxygen::parserManager->registerParser("c", new CLanguageScanner);
-  Doxygen::parserManager->registerParser("python", new PythonLanguageScanner);
-  Doxygen::parserManager->registerParser("fortran", new FortranLanguageScanner);
-  Doxygen::parserManager->registerParser("fortranfree",
-                                         new FortranLanguageScannerFree);
-  Doxygen::parserManager->registerParser("fortranfixed",
-                                         new FortranLanguageScannerFixed);
-  Doxygen::parserManager->registerParser("vhdl", new VHDLLanguageScanner);
-  Doxygen::parserManager->registerParser("xml", new XMLScanner);
-  Doxygen::parserManager->registerParser("tcl", new TclLanguageScanner);
-  Doxygen::parserManager->registerParser("md", new MarkdownFileParser);
+  Doxygen::parserManager->registerDefaultParser(         new FileParser);
+  Doxygen::parserManager->registerParser("c",            new CLanguageScanner);
+  Doxygen::parserManager->registerParser("python",       new PythonLanguageScanner);
+  Doxygen::parserManager->registerParser("fortran",      new FortranLanguageScanner);
+  Doxygen::parserManager->registerParser("fortranfree",  new FortranLanguageScannerFree);
+  Doxygen::parserManager->registerParser("fortranfixed", new FortranLanguageScannerFixed);
+  Doxygen::parserManager->registerParser("vhdl",         new VHDLLanguageScanner);
+  Doxygen::parserManager->registerParser("xml",          new XMLScanner);
+  Doxygen::parserManager->registerParser("tcl",          new TclLanguageScanner);
+  Doxygen::parserManager->registerParser("md",           new MarkdownFileParser);
 
   // register any additional parsers here...
   Doxygen::parserManager->registerParser("prolog", new PrologLanguageScanner);
@@ -9138,9 +10014,9 @@ void initDoxygen() {
   initNamespaceMemberIndices();
   initFileMemberIndices();
 
-  Doxygen::symbolMap = new QDict<DefinitionIntf>(50177);
+  Doxygen::symbolMap     = new QDict<DefinitionIntf>(50177);
 #ifdef USE_LIBCLANG
-  Doxygen::clangUsrMap = new QDict<Definition>(50177);
+  Doxygen::clangUsrMap   = new QDict<Definition>(50177);
 #endif
   Doxygen::inputNameList = new FileNameList;
   Doxygen::inputNameList->setAutoDelete(TRUE);
@@ -9158,9 +10034,9 @@ void initDoxygen() {
   Doxygen::hiddenClasses->setAutoDelete(TRUE);
   Doxygen::directories = new DirSDict(17);
   Doxygen::directories->setAutoDelete(TRUE);
-  Doxygen::pageSDict = new PageSDict(1009); // all doc pages
+  Doxygen::pageSDict = new PageSDict(1009);          // all doc pages
   Doxygen::pageSDict->setAutoDelete(TRUE);
-  Doxygen::exampleSDict = new PageSDict(1009); // all examples
+  Doxygen::exampleSDict = new PageSDict(1009);       // all examples
   Doxygen::exampleSDict->setAutoDelete(TRUE);
   Doxygen::memGrpInfoDict.setAutoDelete(TRUE);
   Doxygen::tagDestinationDict.setAutoDelete(TRUE);
@@ -9176,11 +10052,11 @@ void initDoxygen() {
 
   // initialisation of these globals depends on
   // configuration switches so we need to postpone these
-  Doxygen::globalScope = 0;
-  Doxygen::inputNameDict = 0;
+  Doxygen::globalScope     = 0;
+  Doxygen::inputNameDict   = 0;
   Doxygen::includeNameDict = 0;
   Doxygen::exampleNameDict = 0;
-  Doxygen::imageNameDict = 0;
+  Doxygen::imageNameDict   = 0;
   Doxygen::dotFileNameDict = 0;
   Doxygen::mscFileNameDict = 0;
   Doxygen::diaFileNameDict = 0;
@@ -9189,16 +10065,17 @@ void initDoxygen() {
    *            Initialize some global constants
    **************************************************************************/
 
-  g_compoundKeywordDict.insert("template class", (void *)8);
-  g_compoundKeywordDict.insert("template struct", (void *)8);
-  g_compoundKeywordDict.insert("class", (void *)8);
-  g_compoundKeywordDict.insert("struct", (void *)8);
-  g_compoundKeywordDict.insert("union", (void *)8);
-  g_compoundKeywordDict.insert("interface", (void *)8);
-  g_compoundKeywordDict.insert("exception", (void *)8);
+  g_compoundKeywordDict.insert("template class",(void *)8);
+  g_compoundKeywordDict.insert("template struct",(void *)8);
+  g_compoundKeywordDict.insert("class",(void *)8);
+  g_compoundKeywordDict.insert("struct",(void *)8);
+  g_compoundKeywordDict.insert("union",(void *)8);
+  g_compoundKeywordDict.insert("interface",(void *)8);
+  g_compoundKeywordDict.insert("exception",(void *)8);
 }
 
-void cleanUpDoxygen() {
+void cleanUpDoxygen()
+{
   delete Doxygen::sectionDict;
   delete Doxygen::formulaNameDict;
   delete Doxygen::formulaDict;
@@ -9224,16 +10101,21 @@ void cleanUpDoxygen() {
   Mappers::freeMappers();
   codeFreeScanner();
 
-  if (Doxygen::symbolMap) {
+  if (Doxygen::symbolMap)
+  {
     // iterate through Doxygen::symbolMap and delete all
     // DefinitionList objects, since they have no owner
     QDictIterator<DefinitionIntf> dli(*Doxygen::symbolMap);
     DefinitionIntf *di;
-    for (dli.toFirst(); (di = dli.current());) {
-      if (di->definitionType() == DefinitionIntf::TypeSymbolList) {
+    for (dli.toFirst();(di=dli.current());)
+    {
+      if (di->definitionType()==DefinitionIntf::TypeSymbolList)
+      {
         DefinitionIntf *tmp = Doxygen::symbolMap->take(dli.currentKey());
         delete (DefinitionList *)tmp;
-      } else {
+      }
+      else
+      {
         ++dli;
       }
     }
@@ -9248,261 +10130,282 @@ void cleanUpDoxygen() {
   delete Doxygen::namespaceSDict;
   delete Doxygen::directories;
 
-  // delete Doxygen::symbolMap; <- we cannot do this unless all static lists
+  //delete Doxygen::symbolMap; <- we cannot do this unless all static lists
   //                              (such as Doxygen::namespaceSDict)
   //                              with objects based on Definition are made
   //                              dynamic first
 }
 
-static int computeIdealCacheParam(uint v) {
-  // printf("computeIdealCacheParam(v=%u)\n",v);
+static int computeIdealCacheParam(uint v)
+{
+  //printf("computeIdealCacheParam(v=%u)\n",v);
 
-  int r = 0;
-  while (v != 0)
-    v >>= 1, r++;
+  int r=0;
+  while (v!=0) v>>=1,r++;
   // r = log2(v)
 
   // convert to a valid cache size value
-  return QMAX(0, QMIN(r - 16, 9));
+  return QMAX(0,QMIN(r-16,9));
 }
 
-void readConfiguration(int argc, char **argv) {
+void readConfiguration(int argc, char **argv)
+{
   /**************************************************************************
    *             Handle arguments                                           *
    **************************************************************************/
 
-  int optind = 1;
-  const char *configName = 0;
-  const char *layoutName = 0;
+  int optind=1;
+  const char *configName=0;
+  const char *layoutName=0;
   const char *debugLabel;
   const char *formatName;
-  bool genConfig = FALSE;
-  bool shortList = FALSE;
-  bool updateConfig = FALSE;
-  bool genLayout = FALSE;
+  bool genConfig=FALSE;
+  bool shortList=FALSE;
+  bool updateConfig=FALSE;
+  bool genLayout=FALSE;
   int retVal;
-  while (optind < argc && argv[optind][0] == '-' &&
-         (isalpha(argv[optind][1]) || argv[optind][1] == '?' ||
-          argv[optind][1] == '-')) {
-    switch (argv[optind][1]) {
-    case 'g':
-      genConfig = TRUE;
-      configName = getArg(argc, argv, optind);
-      if (optind + 1 < argc && qstrcmp(argv[optind + 1], "-") == 0) {
-        configName = "-";
-        optind++;
-      }
-      if (!configName) {
-        configName = "Doxyfile";
-      }
-      break;
-    case 'l':
-      genLayout = TRUE;
-      layoutName = getArg(argc, argv, optind);
-      if (!layoutName) {
-        layoutName = "DoxygenLayout.xml";
-      }
-      break;
-    case 'd':
-      debugLabel = getArg(argc, argv, optind);
-      if (!debugLabel) {
-        err("option \"-d\" is missing debug specifier.\n");
-        devUsage();
-        cleanUpDoxygen();
-        exit(1);
-      }
-      retVal = Debug::setFlag(debugLabel);
-      if (!retVal) {
-        err("option \"-d\" has unknown debug specifier: \"%s\".\n", debugLabel);
-        cleanUpDoxygen();
-        exit(1);
-      }
-      break;
-    case 's':
-      shortList = TRUE;
-      break;
-    case 'u':
-      updateConfig = TRUE;
-      break;
-    case 'e':
-      formatName = getArg(argc, argv, optind);
-      if (!formatName) {
-        err("option \"-e\" is missing format specifier rtf.\n");
-        cleanUpDoxygen();
-        exit(1);
-      }
-      if (qstricmp(formatName, "rtf") == 0) {
-        if (optind + 1 >= argc) {
-          err("option \"-e rtf\" is missing an extensions file name\n");
+  while (optind<argc && argv[optind][0]=='-' &&
+               (isalpha(argv[optind][1]) || argv[optind][1]=='?' ||
+                argv[optind][1]=='-')
+        )
+  {
+    switch(argv[optind][1])
+    {
+      case 'g':
+        genConfig=TRUE;
+        configName=getArg(argc,argv,optind);
+        if (optind+1<argc && qstrcmp(argv[optind+1],"-")==0)
+        { configName="-"; optind++; }
+        if (!configName)
+        { configName="Doxyfile"; }
+        break;
+      case 'l':
+        genLayout=TRUE;
+        layoutName=getArg(argc,argv,optind);
+        if (!layoutName)
+        { layoutName="DoxygenLayout.xml"; }
+        break;
+      case 'd':
+        debugLabel=getArg(argc,argv,optind);
+        if (!debugLabel)
+        {
+          err("option \"-d\" is missing debug specifier.\n");
+          devUsage();
           cleanUpDoxygen();
           exit(1);
         }
-        QFile f;
-        if (openOutputFile(argv[optind + 1], f)) {
-          RTFGenerator::writeExtensionsFile(f);
+        retVal = Debug::setFlag(debugLabel);
+        if (!retVal)
+        {
+          err("option \"-d\" has unknown debug specifier: \"%s\".\n",debugLabel);
+          cleanUpDoxygen();
+          exit(1);
         }
-        cleanUpDoxygen();
-        exit(0);
-      }
-      err("option \"-e\" has invalid format specifier.\n");
-      cleanUpDoxygen();
-      exit(1);
-      break;
-    case 'w':
-      formatName = getArg(argc, argv, optind);
-      if (!formatName) {
-        err("option \"-w\" is missing format specifier rtf, html or latex\n");
-        cleanUpDoxygen();
-        exit(1);
-      }
-      if (qstricmp(formatName, "rtf") == 0) {
-        if (optind + 1 >= argc) {
-          err("option \"-w rtf\" is missing a style sheet file name\n");
+        break;
+      case 's':
+        shortList=TRUE;
+        break;
+      case 'u':
+        updateConfig=TRUE;
+        break;
+      case 'e':
+        formatName=getArg(argc,argv,optind);
+        if (!formatName)
+        {
+          err("option \"-e\" is missing format specifier rtf.\n");
           cleanUpDoxygen();
           exit(1);
         }
-        QFile f;
-        if (openOutputFile(argv[optind + 1], f)) {
-          RTFGenerator::writeStyleSheetFile(f);
+        if (qstricmp(formatName,"rtf")==0)
+        {
+          if (optind+1>=argc)
+          {
+            err("option \"-e rtf\" is missing an extensions file name\n");
+            cleanUpDoxygen();
+            exit(1);
+          }
+          QFile f;
+          if (openOutputFile(argv[optind+1],f))
+          {
+            RTFGenerator::writeExtensionsFile(f);
+          }
+          cleanUpDoxygen();
+          exit(0);
         }
+        err("option \"-e\" has invalid format specifier.\n");
         cleanUpDoxygen();
         exit(1);
-      } else if (qstricmp(formatName, "html") == 0) {
-        Config::init();
-        if (optind + 4 < argc || QFileInfo("Doxyfile").exists())
-        // explicit config file mentioned or default found on disk
-        {
-          QCString df =
-              optind + 4 < argc ? argv[optind + 4] : QCString("Doxyfile");
-          if (!Config::parse(df)) // parse the config file
+        break;
+      case 'w':
+        formatName=getArg(argc,argv,optind);
+        if (!formatName)
+        {
+          err("option \"-w\" is missing format specifier rtf, html or latex\n");
+          cleanUpDoxygen();
+          exit(1);
+        }
+        if (qstricmp(formatName,"rtf")==0)
+        {
+          if (optind+1>=argc)
           {
-            err("error opening or reading configuration file %s!\n",
-                argv[optind + 4]);
+            err("option \"-w rtf\" is missing a style sheet file name\n");
             cleanUpDoxygen();
             exit(1);
           }
-        }
-        if (optind + 3 >= argc) {
-          err("option \"-w html\" does not have enough arguments\n");
+          QFile f;
+          if (openOutputFile(argv[optind+1],f))
+          {
+            RTFGenerator::writeStyleSheetFile(f);
+          }
           cleanUpDoxygen();
           exit(1);
         }
-        Config::postProcess(TRUE);
-        Config::checkAndCorrect();
+        else if (qstricmp(formatName,"html")==0)
+        {
+          Config::init();
+          if (optind+4<argc || QFileInfo("Doxyfile").exists())
+             // explicit config file mentioned or default found on disk
+          {
+            QCString df = optind+4<argc ? argv[optind+4] : QCString("Doxyfile");
+            if (!Config::parse(df)) // parse the config file
+            {
+              err("error opening or reading configuration file %s!\n",argv[optind+4]);
+              cleanUpDoxygen();
+              exit(1);
+            }
+          }
+          if (optind+3>=argc)
+          {
+            err("option \"-w html\" does not have enough arguments\n");
+            cleanUpDoxygen();
+            exit(1);
+          }
+          Config::postProcess(TRUE);
+          Config::checkAndCorrect();
 
-        QCString outputLanguage = Config_getEnum(OUTPUT_LANGUAGE);
-        if (!setTranslator(outputLanguage)) {
-          warn_uncond(
-              "Output language %s not supported! Using English instead.\n",
-              outputLanguage.data());
-        }
+          QCString outputLanguage=Config_getEnum(OUTPUT_LANGUAGE);
+          if (!setTranslator(outputLanguage))
+          {
+            warn_uncond("Output language %s not supported! Using English instead.\n", outputLanguage.data());
+          }
 
-        QFile f;
-        if (openOutputFile(argv[optind + 1], f)) {
-          HtmlGenerator::writeHeaderFile(f, argv[optind + 3]);
-        }
-        f.close();
-        if (openOutputFile(argv[optind + 2], f)) {
-          HtmlGenerator::writeFooterFile(f);
-        }
-        f.close();
-        if (openOutputFile(argv[optind + 3], f)) {
-          HtmlGenerator::writeStyleSheetFile(f);
+          QFile f;
+          if (openOutputFile(argv[optind+1],f))
+          {
+            HtmlGenerator::writeHeaderFile(f, argv[optind+3]);
+          }
+          f.close();
+          if (openOutputFile(argv[optind+2],f))
+          {
+            HtmlGenerator::writeFooterFile(f);
+          }
+          f.close();
+          if (openOutputFile(argv[optind+3],f))
+          {
+            HtmlGenerator::writeStyleSheetFile(f);
+          }
+          cleanUpDoxygen();
+          exit(0);
         }
-        cleanUpDoxygen();
-        exit(0);
-      } else if (qstricmp(formatName, "latex") == 0) {
-        Config::init();
-        if (optind + 4 < argc || QFileInfo("Doxyfile").exists()) {
-          QCString df =
-              optind + 4 < argc ? argv[optind + 4] : QCString("Doxyfile");
-          if (!Config::parse(df)) {
-            err("error opening or reading configuration file %s!\n",
-                argv[optind + 4]);
+        else if (qstricmp(formatName,"latex")==0)
+        {
+          Config::init();
+          if (optind+4<argc || QFileInfo("Doxyfile").exists())
+          {
+            QCString df = optind+4<argc ? argv[optind+4] : QCString("Doxyfile");
+            if (!Config::parse(df))
+            {
+              err("error opening or reading configuration file %s!\n",argv[optind+4]);
+              cleanUpDoxygen();
+              exit(1);
+            }
+          }
+          if (optind+3>=argc)
+          {
+            err("option \"-w latex\" does not have enough arguments\n");
             cleanUpDoxygen();
             exit(1);
           }
+          Config::postProcess(TRUE);
+          Config::checkAndCorrect();
+
+          QCString outputLanguage=Config_getEnum(OUTPUT_LANGUAGE);
+          if (!setTranslator(outputLanguage))
+          {
+            warn_uncond("Output language %s not supported! Using English instead.\n", outputLanguage.data());
+          }
+
+          QFile f;
+          if (openOutputFile(argv[optind+1],f))
+          {
+            LatexGenerator::writeHeaderFile(f);
+          }
+          f.close();
+          if (openOutputFile(argv[optind+2],f))
+          {
+            LatexGenerator::writeFooterFile(f);
+          }
+          f.close();
+          if (openOutputFile(argv[optind+3],f))
+          {
+            LatexGenerator::writeStyleSheetFile(f);
+          }
+          cleanUpDoxygen();
+          exit(0);
         }
-        if (optind + 3 >= argc) {
-          err("option \"-w latex\" does not have enough arguments\n");
+        else
+        {
+          err("Illegal format specifier \"%s\": should be one of rtf, html or latex\n",formatName);
           cleanUpDoxygen();
           exit(1);
         }
-        Config::postProcess(TRUE);
-        Config::checkAndCorrect();
-
-        QCString outputLanguage = Config_getEnum(OUTPUT_LANGUAGE);
-        if (!setTranslator(outputLanguage)) {
-          warn_uncond(
-              "Output language %s not supported! Using English instead.\n",
-              outputLanguage.data());
-        }
-
-        QFile f;
-        if (openOutputFile(argv[optind + 1], f)) {
-          LatexGenerator::writeHeaderFile(f);
+        break;
+      case 'm':
+        g_dumpSymbolMap = TRUE;
+        break;
+      case 'v':
+        msg("%s\n",versionString);
+        cleanUpDoxygen();
+        exit(0);
+        break;
+      case '-':
+        if (qstrcmp(&argv[optind][2],"help")==0)
+        {
+          usage(argv[0]);
+          exit(0);
         }
-        f.close();
-        if (openOutputFile(argv[optind + 2], f)) {
-          LatexGenerator::writeFooterFile(f);
+        else if (qstrcmp(&argv[optind][2],"version")==0)
+        {
+          msg("%s\n",versionString);
+          cleanUpDoxygen();
+          exit(0);
         }
-        f.close();
-        if (openOutputFile(argv[optind + 3], f)) {
-          LatexGenerator::writeStyleSheetFile(f);
+        else
+        {
+          err("Unknown option \"-%s\"\n",&argv[optind][1]);
+          usage(argv[0]);
+          exit(1);
         }
-        cleanUpDoxygen();
-        exit(0);
-      } else {
-        err("Illegal format specifier \"%s\": should be one of rtf, html or "
-            "latex\n",
-            formatName);
-        cleanUpDoxygen();
-        exit(1);
-      }
-      break;
-    case 'm':
-      g_dumpSymbolMap = TRUE;
-      break;
-    case 'v':
-      msg("%s\n", versionString);
-      cleanUpDoxygen();
-      exit(0);
-      break;
-    case '-':
-      if (qstrcmp(&argv[optind][2], "help") == 0) {
+        break;
+      case 'b':
+        setvbuf(stdout,NULL,_IONBF,0);
+        Doxygen::outputToWizard=TRUE;
+        break;
+      case 'T':
+        msg("Warning: this option activates output generation via Django like template files. "
+            "This option is scheduled for doxygen 2.0, is currently incomplete and highly experimental! "
+            "Only use if you are a doxygen developer\n");
+        g_useOutputTemplate=TRUE;
+        break;
+      case 'h':
+      case '?':
         usage(argv[0]);
         exit(0);
-      } else if (qstrcmp(&argv[optind][2], "version") == 0) {
-        msg("%s\n", versionString);
-        cleanUpDoxygen();
-        exit(0);
-      } else {
-        err("Unknown option \"-%s\"\n", &argv[optind][1]);
+        break;
+      default:
+        err("Unknown option \"-%c\"\n",argv[optind][1]);
         usage(argv[0]);
         exit(1);
-      }
-      break;
-    case 'b':
-      setvbuf(stdout, NULL, _IONBF, 0);
-      Doxygen::outputToWizard = TRUE;
-      break;
-    case 'T':
-      msg("Warning: this option activates output generation via Django like "
-          "template files. "
-          "This option is scheduled for doxygen 2.0, is currently incomplete "
-          "and highly experimental! "
-          "Only use if you are a doxygen developer\n");
-      g_useOutputTemplate = TRUE;
-      break;
-    case 'h':
-    case '?':
-      usage(argv[0]);
-      exit(0);
-      break;
-    default:
-      err("Unknown option \"-%c\"\n", argv[optind][1]);
-      usage(argv[0]);
-      exit(1);
     }
     optind++;
   }
@@ -9513,53 +10416,70 @@ void readConfiguration(int argc, char **argv) {
 
   Config::init();
 
-  if (genConfig && g_useOutputTemplate) {
+  if (genConfig && g_useOutputTemplate)
+  {
     generateTemplateFiles("templates");
     cleanUpDoxygen();
     exit(0);
   }
 
-  if (genConfig) {
-    generateConfigFile(configName, shortList);
+  if (genConfig)
+  {
+    generateConfigFile(configName,shortList);
     cleanUpDoxygen();
     exit(0);
   }
-  if (genLayout) {
+  if (genLayout)
+  {
     writeDefaultLayoutFile(layoutName);
     cleanUpDoxygen();
     exit(0);
   }
 
-  QFileInfo configFileInfo1("Doxyfile"), configFileInfo2("doxyfile");
-  if (optind >= argc) {
-    if (configFileInfo1.exists()) {
-      configName = "Doxyfile";
-    } else if (configFileInfo2.exists()) {
-      configName = "doxyfile";
-    } else {
+  QFileInfo configFileInfo1("Doxyfile"),configFileInfo2("doxyfile");
+  if (optind>=argc)
+  {
+    if (configFileInfo1.exists())
+    {
+      configName="Doxyfile";
+    }
+    else if (configFileInfo2.exists())
+    {
+      configName="doxyfile";
+    }
+    else
+    {
       err("Doxyfile not found and no input file specified!\n");
       usage(argv[0]);
       exit(1);
     }
-  } else {
+  }
+  else
+  {
     QFileInfo fi(argv[optind]);
-    if (fi.exists() || qstrcmp(argv[optind], "-") == 0) {
-      configName = argv[optind];
-    } else {
-      err("configuration file %s not found!\n", argv[optind]);
+    if (fi.exists() || qstrcmp(argv[optind],"-")==0)
+    {
+      configName=argv[optind];
+    }
+    else
+    {
+      err("configuration file %s not found!\n",argv[optind]);
       usage(argv[0]);
       exit(1);
     }
   }
 
-  if (!Config::parse(configName, updateConfig)) {
-    err("could not open or read configuration file %s!\n", configName);
+
+  if (!Config::parse(configName,updateConfig))
+  {
+    err("could not open or read configuration file %s!\n",configName);
     cleanUpDoxygen();
     exit(1);
   }
 
-  if (updateConfig) {
-    generateConfigFile(configName, shortList, TRUE);
+  if (updateConfig)
+  {
+    generateConfigFile(configName,shortList,TRUE);
     cleanUpDoxygen();
     exit(0);
   }
@@ -9567,10 +10487,12 @@ void readConfiguration(int argc, char **argv) {
   /* Perlmod wants to know the path to the config file.*/
   QFileInfo configFileInfo(configName);
   setPerlModDoxyfile(configFileInfo.absFilePath().data());
+
 }
 
 /** check and resolve config options */
-void checkConfiguration() {
+void checkConfiguration()
+{
 
   Config::postProcess(FALSE);
   Config::checkAndCorrect();
@@ -9578,9 +10500,9 @@ void checkConfiguration() {
 }
 
 /** adjust globals that depend on configuration settings. */
-void adjustConfiguration() {
-  Doxygen::globalScope =
-      new NamespaceDef("<globalScope>", 1, 1, "<globalScope>");
+void adjustConfiguration()
+{
+  Doxygen::globalScope = new NamespaceDef("<globalScope>",1,1,"<globalScope>");
   Doxygen::inputNameDict = new FileNameDict(10007);
   Doxygen::includeNameDict = new FileNameDict(10007);
   Doxygen::exampleNameDict = new FileNameDict(1009);
@@ -9591,22 +10513,25 @@ void adjustConfiguration() {
   Doxygen::mscFileNameDict = new FileNameDict(257);
   Doxygen::diaFileNameDict = new FileNameDict(257);
 
-  QCString outputLanguage = Config_getEnum(OUTPUT_LANGUAGE);
-  if (!setTranslator(outputLanguage)) {
+  QCString outputLanguage=Config_getEnum(OUTPUT_LANGUAGE);
+  if (!setTranslator(outputLanguage))
+  {
     warn_uncond("Output language %s not supported! Using English instead.\n",
-                outputLanguage.data());
+       outputLanguage.data());
   }
   QStrList &includePath = Config_getList(INCLUDE_PATH);
-  char *s = includePath.first();
-  while (s) {
+  char *s=includePath.first();
+  while (s)
+  {
     QFileInfo fi(s);
     addSearchDir(fi.absFilePath().utf8());
-    s = includePath.next();
+    s=includePath.next();
   }
 
   /* Set the global html file extension. */
   Doxygen::htmlFileExtension = Config_getString(HTML_FILE_EXTENSION);
 
+
   Doxygen::xrefLists->setAutoDelete(TRUE);
 
   Doxygen::parseSourcesNeeded = Config_getBool(CALL_GRAPH) ||
@@ -9622,33 +10547,40 @@ void adjustConfiguration() {
 
   QStrList &extMaps = Config_getList(EXTENSION_MAPPING);
   char *mapping = extMaps.first();
-  while (mapping) {
+  while (mapping)
+  {
     QCString mapStr = mapping;
     int i;
-    if ((i = mapStr.find('=')) != -1) {
-      QCString ext = mapStr.left(i).stripWhiteSpace().lower();
-      QCString language = mapStr.mid(i + 1).stripWhiteSpace().lower();
-      if (!updateLanguageMapping(ext, language)) {
+    if ((i=mapStr.find('='))!=-1)
+    {
+      QCString ext=mapStr.left(i).stripWhiteSpace().lower();
+      QCString language=mapStr.mid(i+1).stripWhiteSpace().lower();
+      if (!updateLanguageMapping(ext,language))
+      {
         err("Failed to map file extension '%s' to unsupported language '%s'.\n"
             "Check the EXTENSION_MAPPING setting in the config file.\n",
-            ext.data(), language.data());
-      } else {
-        msg("Adding custom extension mapping: .%s will be treated as language "
-            "%s\n",
-            ext.data(), language.data());
+            ext.data(),language.data());
+      }
+      else
+      {
+        msg("Adding custom extension mapping: .%s will be treated as language %s\n",
+            ext.data(),language.data());
       }
     }
     mapping = extMaps.next();
   }
 
+
   // add predefined macro name to a dictionary
-  QStrList &expandAsDefinedList = Config_getList(EXPAND_AS_DEFINED);
-  s = expandAsDefinedList.first();
-  while (s) {
-    if (Doxygen::expandAsDefinedDict[s] == 0) {
-      Doxygen::expandAsDefinedDict.insert(s, (void *)666);
+  QStrList &expandAsDefinedList =Config_getList(EXPAND_AS_DEFINED);
+  s=expandAsDefinedList.first();
+  while (s)
+  {
+    if (Doxygen::expandAsDefinedDict[s]==0)
+    {
+      Doxygen::expandAsDefinedDict.insert(s,(void *)666);
     }
-    s = expandAsDefinedList.next();
+    s=expandAsDefinedList.next();
   }
 
   // read aliases and store them in a dictionary
@@ -9656,36 +10588,40 @@ void adjustConfiguration() {
 
   // store number of spaces in a tab into Doxygen::spaces
   int &tabSize = Config_getInt(TAB_SIZE);
-  Doxygen::spaces.resize(tabSize + 1);
-  int sp;
-  for (sp = 0; sp < tabSize; sp++)
-    Doxygen::spaces.at(sp) = ' ';
-  Doxygen::spaces.at(tabSize) = '\0';
+  Doxygen::spaces.resize(tabSize+1);
+  int sp;for (sp=0;sp<tabSize;sp++) Doxygen::spaces.at(sp)=' ';
+  Doxygen::spaces.at(tabSize)='\0';
 }
 
 #ifdef HAS_SIGNALS
-static void stopDoxygen(int) {
+static void stopDoxygen(int)
+{
   QDir thisDir;
   msg("Cleaning up...\n");
-  if (!Doxygen::entryDBFileName.isEmpty()) {
+  if (!Doxygen::entryDBFileName.isEmpty())
+  {
     thisDir.remove(Doxygen::entryDBFileName);
   }
-  if (!Doxygen::objDBFileName.isEmpty()) {
+  if (!Doxygen::objDBFileName.isEmpty())
+  {
     thisDir.remove(Doxygen::objDBFileName);
   }
-  killpg(0, SIGINT);
+  killpg(0,SIGINT);
   exit(1);
 }
 #endif
 
-static void writeTagFile() {
+static void writeTagFile()
+{
   QCString &generateTagFile = Config_getString(GENERATE_TAGFILE);
-  if (generateTagFile.isEmpty())
-    return;
+  if (generateTagFile.isEmpty()) return;
 
   QFile tag(generateTagFile);
-  if (!tag.open(IO_WriteOnly)) {
-    err("cannot open tag file %s for writing\n", generateTagFile.data());
+  if (!tag.open(IO_WriteOnly))
+  {
+    err("cannot open tag file %s for writing\n",
+        generateTagFile.data()
+       );
     return;
   }
   FTextStream tagFile(&tag);
@@ -9695,44 +10631,44 @@ static void writeTagFile() {
   // for each file
   FileNameListIterator fnli(*Doxygen::inputNameList);
   FileName *fn;
-  for (fnli.toFirst(); (fn = fnli.current()); ++fnli) {
+  for (fnli.toFirst();(fn=fnli.current());++fnli)
+  {
     FileNameIterator fni(*fn);
     FileDef *fd;
-    for (fni.toFirst(); (fd = fni.current()); ++fni) {
-      if (fd->isLinkableInProject())
-        fd->writeTagFile(tagFile);
+    for (fni.toFirst();(fd=fni.current());++fni)
+    {
+      if (fd->isLinkableInProject()) fd->writeTagFile(tagFile);
     }
   }
   // for each class
   ClassSDict::Iterator cli(*Doxygen::classSDict);
   ClassDef *cd;
-  for (; (cd = cli.current()); ++cli) {
-    if (cd->isLinkableInProject())
-      cd->writeTagFile(tagFile);
+  for ( ; (cd=cli.current()) ; ++cli )
+  {
+    if (cd->isLinkableInProject()) cd->writeTagFile(tagFile);
   }
   // for each namespace
   NamespaceSDict::Iterator nli(*Doxygen::namespaceSDict);
   NamespaceDef *nd;
-  for (; (nd = nli.current()); ++nli) {
-    if (nd->isLinkableInProject())
-      nd->writeTagFile(tagFile);
+  for ( ; (nd=nli.current()) ; ++nli )
+  {
+    if (nd->isLinkableInProject()) nd->writeTagFile(tagFile);
   }
   // for each group
   GroupSDict::Iterator gli(*Doxygen::groupSDict);
   GroupDef *gd;
-  for (gli.toFirst(); (gd = gli.current()); ++gli) {
-    if (gd->isLinkableInProject())
-      gd->writeTagFile(tagFile);
+  for (gli.toFirst();(gd=gli.current());++gli)
+  {
+    if (gd->isLinkableInProject()) gd->writeTagFile(tagFile);
   }
   // for each page
   PageSDict::Iterator pdi(*Doxygen::pageSDict);
-  PageDef *pd = 0;
-  for (pdi.toFirst(); (pd = pdi.current()); ++pdi) {
-    if (pd->isLinkableInProject())
-      pd->writeTagFile(tagFile);
+  PageDef *pd=0;
+  for (pdi.toFirst();(pd=pdi.current());++pdi)
+  {
+    if (pd->isLinkableInProject()) pd->writeTagFile(tagFile);
   }
-  if (Doxygen::mainPage)
-    Doxygen::mainPage->writeTagFile(tagFile);
+  if (Doxygen::mainPage) Doxygen::mainPage->writeTagFile(tagFile);
 
   /*
   if (Doxygen::mainPage && !Config_getString(GENERATE_TAGFILE).isEmpty())
@@ -9756,32 +10692,39 @@ static void writeTagFile() {
   tagFile << "</tagfile>" << endl;
 }
 
-static void exitDoxygen() {
-  if (!g_successfulRun) // premature exit
+static void exitDoxygen()
+{
+  if (!g_successfulRun)  // premature exit
   {
     QDir thisDir;
     msg("Exiting...\n");
-    if (!Doxygen::entryDBFileName.isEmpty()) {
+    if (!Doxygen::entryDBFileName.isEmpty())
+    {
       thisDir.remove(Doxygen::entryDBFileName);
     }
-    if (!Doxygen::objDBFileName.isEmpty()) {
+    if (!Doxygen::objDBFileName.isEmpty())
+    {
       thisDir.remove(Doxygen::objDBFileName);
     }
   }
 }
 
 static QCString createOutputDirectory(const QCString &baseDirName,
-                                      QCString &formatDirName,
-                                      const char *defaultDirName) {
+                                  QCString &formatDirName,
+                                  const char *defaultDirName)
+{
   // Note the & on the next line, we modify the formatDirOption!
-  if (formatDirName.isEmpty()) {
+  if (formatDirName.isEmpty())
+  {
     formatDirName = baseDirName + defaultDirName;
-  } else if (formatDirName[0] != '/' &&
-             (formatDirName.length() == 1 || formatDirName[1] != ':')) {
-    formatDirName.prepend(baseDirName + '/');
+  }
+  else if (formatDirName[0]!='/' && (formatDirName.length()==1 || formatDirName[1]!=':'))
+  {
+    formatDirName.prepend(baseDirName+'/');
   }
   QDir formatDir(formatDirName);
-  if (!formatDir.exists() && !formatDir.mkdir(formatDirName)) {
+  if (!formatDir.exists() && !formatDir.mkdir(formatDirName))
+  {
     err("Could not create output directory %s\n", formatDirName.data());
     cleanUpDoxygen();
     exit(1);
@@ -9789,22 +10732,25 @@ static QCString createOutputDirectory(const QCString &baseDirName,
   return formatDirName;
 }
 
-static QCString getQchFileName() {
-  QCString const &qchFile = Config_getString(QCH_FILE);
-  if (!qchFile.isEmpty()) {
+static QCString getQchFileName()
+{
+  QCString const & qchFile = Config_getString(QCH_FILE);
+  if (!qchFile.isEmpty())
+  {
     return qchFile;
   }
 
-  QCString const &projectName = Config_getString(PROJECT_NAME);
-  QCString const &versionText = Config_getString(PROJECT_NUMBER);
+  QCString const & projectName = Config_getString(PROJECT_NAME);
+  QCString const & versionText = Config_getString(PROJECT_NUMBER);
 
-  return QCString("../qch/") +
-         (projectName.isEmpty() ? QCString("index") : projectName) +
-         (versionText.isEmpty() ? QCString("") : QCString("-") + versionText) +
-         QCString(".qch");
+  return QCString("../qch/")
+      + (projectName.isEmpty() ? QCString("index") : projectName)
+      + (versionText.isEmpty() ? QCString("") : QCString("-") + versionText)
+      + QCString(".qch");
 }
 
-void searchInputFiles() {
+void searchInputFiles()
+{
   QStrList &exclPatterns = Config_getList(EXCLUDE_PATTERNS);
   bool alwaysRecursive = Config_getBool(RECURSIVE);
   StringDict excludeNameDict(1009);
@@ -9813,76 +10759,92 @@ void searchInputFiles() {
   // gather names of all files in the include path
   g_s.begin("Searching for include files...\n");
   QStrList &includePathList = Config_getList(INCLUDE_PATH);
-  char *s = includePathList.first();
-  while (s) {
+  char *s=includePathList.first();
+  while (s)
+  {
     QStrList &pl = Config_getList(INCLUDE_FILE_PATTERNS);
-    if (pl.count() == 0) {
+    if (pl.count()==0)
+    {
       pl = Config_getList(FILE_PATTERNS);
     }
-    readFileOrDirectory(s, 0, Doxygen::includeNameDict, 0, &pl, &exclPatterns,
-                        0, 0, alwaysRecursive);
-    s = includePathList.next();
+    readFileOrDirectory(s,0,Doxygen::includeNameDict,0,&pl,
+                        &exclPatterns,0,0,
+                        alwaysRecursive);
+    s=includePathList.next();
   }
   g_s.end();
 
   g_s.begin("Searching for example files...\n");
   QStrList &examplePathList = Config_getList(EXAMPLE_PATH);
-  s = examplePathList.first();
-  while (s) {
-    readFileOrDirectory(s, 0, Doxygen::exampleNameDict, 0,
-                        &Config_getList(EXAMPLE_PATTERNS), 0, 0, 0,
+  s=examplePathList.first();
+  while (s)
+  {
+    readFileOrDirectory(s,0,Doxygen::exampleNameDict,0,
+                        &Config_getList(EXAMPLE_PATTERNS),
+                        0,0,0,
                         (alwaysRecursive || Config_getBool(EXAMPLE_RECURSIVE)));
-    s = examplePathList.next();
+    s=examplePathList.next();
   }
   g_s.end();
 
   g_s.begin("Searching for images...\n");
-  QStrList &imagePathList = Config_getList(IMAGE_PATH);
-  s = imagePathList.first();
-  while (s) {
-    readFileOrDirectory(s, 0, Doxygen::imageNameDict, 0, 0, 0, 0, 0,
+  QStrList &imagePathList=Config_getList(IMAGE_PATH);
+  s=imagePathList.first();
+  while (s)
+  {
+    readFileOrDirectory(s,0,Doxygen::imageNameDict,0,0,
+                        0,0,0,
                         alwaysRecursive);
-    s = imagePathList.next();
+    s=imagePathList.next();
   }
   g_s.end();
 
   g_s.begin("Searching for dot files...\n");
-  QStrList &dotFileList = Config_getList(DOTFILE_DIRS);
-  s = dotFileList.first();
-  while (s) {
-    readFileOrDirectory(s, 0, Doxygen::dotFileNameDict, 0, 0, 0, 0, 0,
+  QStrList &dotFileList=Config_getList(DOTFILE_DIRS);
+  s=dotFileList.first();
+  while (s)
+  {
+    readFileOrDirectory(s,0,Doxygen::dotFileNameDict,0,0,
+                        0,0,0,
                         alwaysRecursive);
-    s = dotFileList.next();
+    s=dotFileList.next();
   }
   g_s.end();
 
   g_s.begin("Searching for msc files...\n");
-  QStrList &mscFileList = Config_getList(MSCFILE_DIRS);
-  s = mscFileList.first();
-  while (s) {
-    readFileOrDirectory(s, 0, Doxygen::mscFileNameDict, 0, 0, 0, 0, 0,
+  QStrList &mscFileList=Config_getList(MSCFILE_DIRS);
+  s=mscFileList.first();
+  while (s)
+  {
+    readFileOrDirectory(s,0,Doxygen::mscFileNameDict,0,0,
+                        0,0,0,
                         alwaysRecursive);
-    s = mscFileList.next();
+    s=mscFileList.next();
   }
   g_s.end();
 
   g_s.begin("Searching for dia files...\n");
-  QStrList &diaFileList = Config_getList(DIAFILE_DIRS);
-  s = diaFileList.first();
-  while (s) {
-    readFileOrDirectory(s, 0, Doxygen::diaFileNameDict, 0, 0, 0, 0, 0,
+  QStrList &diaFileList=Config_getList(DIAFILE_DIRS);
+  s=diaFileList.first();
+  while (s)
+  {
+    readFileOrDirectory(s,0,Doxygen::diaFileNameDict,0,0,
+                        0,0,0,
                         alwaysRecursive);
-    s = diaFileList.next();
+    s=diaFileList.next();
   }
   g_s.end();
 
   g_s.begin("Searching for files to exclude\n");
   QStrList &excludeList = Config_getList(EXCLUDE);
-  s = excludeList.first();
-  while (s) {
-    readFileOrDirectory(s, 0, 0, 0, &Config_getList(FILE_PATTERNS), 0, 0,
-                        &excludeNameDict, alwaysRecursive, FALSE);
-    s = excludeList.next();
+  s=excludeList.first();
+  while (s)
+  {
+    readFileOrDirectory(s,0,0,0,&Config_getList(FILE_PATTERNS),
+                        0,0,&excludeNameDict,
+                        alwaysRecursive,
+                        FALSE);
+    s=excludeList.next();
   }
   g_s.end();
 
@@ -9892,55 +10854,72 @@ void searchInputFiles() {
 
   g_s.begin("Searching INPUT for files to process...\n");
   QDict<void> *killDict = new QDict<void>(10007);
-  QStrList &inputList = Config_getList(INPUT);
+  QStrList &inputList=Config_getList(INPUT);
   g_inputFiles.setAutoDelete(TRUE);
-  s = inputList.first();
-  while (s) {
-    QCString path = s;
+  s=inputList.first();
+  while (s)
+  {
+    QCString path=s;
     uint l = path.length();
-    if (l > 0) {
+    if (l>0)
+    {
       // strip trailing slashes
-      if (path.at(l - 1) == '\\' || path.at(l - 1) == '/')
-        path = path.left(l - 1);
-
-      readFileOrDirectory(path, Doxygen::inputNameList, Doxygen::inputNameDict,
-                          &excludeNameDict, &Config_getList(FILE_PATTERNS),
-                          &exclPatterns, &g_inputFiles, 0, alwaysRecursive,
-                          TRUE, killDict, &Doxygen::inputPaths);
-    }
-    s = inputList.next();
+      if (path.at(l-1)=='\\' || path.at(l-1)=='/') path=path.left(l-1);
+
+      readFileOrDirectory(
+          path,
+          Doxygen::inputNameList,
+          Doxygen::inputNameDict,
+          &excludeNameDict,
+          &Config_getList(FILE_PATTERNS),
+          &exclPatterns,
+          &g_inputFiles,0,
+          alwaysRecursive,
+          TRUE,
+          killDict,
+          &Doxygen::inputPaths);
+    }
+    s=inputList.next();
   }
   delete killDict;
   g_s.end();
 }
 
-void parseInput() {
+
+void parseInput()
+{
   atexit(exitDoxygen);
 
+
   /**************************************************************************
    *            Make sure the output directory exists
    **************************************************************************/
   QCString &outputDirectory = Config_getString(OUTPUT_DIRECTORY);
-  if (outputDirectory.isEmpty()) {
-    outputDirectory = QDir::currentDirPath().utf8();
-  } else {
+  if (outputDirectory.isEmpty())
+  {
+    outputDirectory=QDir::currentDirPath().utf8();
+  }
+  else
+  {
     QDir dir(outputDirectory);
-    if (!dir.exists()) {
+    if (!dir.exists())
+    {
       dir.setPath(QDir::currentDirPath());
-      if (!dir.mkdir(outputDirectory)) {
+      if (!dir.mkdir(outputDirectory))
+      {
         err("tag OUTPUT_DIRECTORY: Output directory `%s' does not "
-            "exist and cannot be created\n",
-            outputDirectory.data());
+	    "exist and cannot be created\n",outputDirectory.data());
         cleanUpDoxygen();
         exit(1);
-      } else {
-        msg("Notice: Output directory `%s' does not exist. "
-            "I have created it for you.\n",
-            outputDirectory.data());
+      }
+      else
+      {
+	msg("Notice: Output directory `%s' does not exist. "
+	    "I have created it for you.\n", outputDirectory.data());
       }
       dir.cd(outputDirectory);
     }
-    outputDirectory = dir.absPath().utf8();
+    outputDirectory=dir.absPath().utf8();
   }
 
   /**************************************************************************
@@ -9951,12 +10930,10 @@ void parseInput() {
 
   // also scale lookup cache with SYMBOL_CACHE_SIZE
   int cacheSize = Config_getInt(LOOKUP_CACHE_SIZE);
-  if (cacheSize < 0)
-    cacheSize = 0;
-  if (cacheSize > 9)
-    cacheSize = 9;
+  if (cacheSize<0) cacheSize=0;
+  if (cacheSize>9) cacheSize=9;
   uint lookupSize = 65536 << cacheSize;
-  Doxygen::lookupCache = new QCache<LookupInfo>(lookupSize, lookupSize);
+  Doxygen::lookupCache = new QCache<LookupInfo>(lookupSize,lookupSize);
   Doxygen::lookupCache->setAutoDelete(TRUE);
 
 #ifdef HAS_SIGNALS
@@ -9964,16 +10941,19 @@ void parseInput() {
 #endif
 
   uint pid = portable_pid();
-  Doxygen::objDBFileName.sprintf("doxygen_objdb_%d.tmp", pid);
-  Doxygen::objDBFileName.prepend(outputDirectory + "/");
-  Doxygen::entryDBFileName.sprintf("doxygen_entrydb_%d.tmp", pid);
-  Doxygen::entryDBFileName.prepend(outputDirectory + "/");
+  Doxygen::objDBFileName.sprintf("doxygen_objdb_%d.tmp",pid);
+  Doxygen::objDBFileName.prepend(outputDirectory+"/");
+  Doxygen::entryDBFileName.sprintf("doxygen_entrydb_%d.tmp",pid);
+  Doxygen::entryDBFileName.prepend(outputDirectory+"/");
 
-  if (Doxygen::symbolStorage->open(Doxygen::objDBFileName) == -1) {
-    err("Failed to open temporary file %s\n", Doxygen::objDBFileName.data());
+  if (Doxygen::symbolStorage->open(Doxygen::objDBFileName)==-1)
+  {
+    err("Failed to open temporary file %s\n",Doxygen::objDBFileName.data());
     exit(1);
   }
 
+
+
   /**************************************************************************
    *            Check/create output directorties                            *
    **************************************************************************/
@@ -9981,60 +10961,60 @@ void parseInput() {
   QCString htmlOutput;
   bool &generateHtml = Config_getBool(GENERATE_HTML);
   if (generateHtml || g_useOutputTemplate /* TODO: temp hack */)
-    htmlOutput = createOutputDirectory(outputDirectory,
-                                       Config_getString(HTML_OUTPUT), "/html");
+    htmlOutput = createOutputDirectory(outputDirectory,Config_getString(HTML_OUTPUT),"/html");
 
   QCString docbookOutput;
   bool &generateDocbook = Config_getBool(GENERATE_DOCBOOK);
   if (generateDocbook)
-    docbookOutput = createOutputDirectory(
-        outputDirectory, Config_getString(DOCBOOK_OUTPUT), "/docbook");
+    docbookOutput = createOutputDirectory(outputDirectory,Config_getString(DOCBOOK_OUTPUT),"/docbook");
 
   QCString xmlOutput;
   bool &generateXml = Config_getBool(GENERATE_XML);
   if (generateXml)
-    xmlOutput = createOutputDirectory(outputDirectory,
-                                      Config_getString(XML_OUTPUT), "/xml");
+    xmlOutput = createOutputDirectory(outputDirectory,Config_getString(XML_OUTPUT),"/xml");
 
   QCString latexOutput;
   bool &generateLatex = Config_getBool(GENERATE_LATEX);
   if (generateLatex)
-    latexOutput = createOutputDirectory(
-        outputDirectory, Config_getString(LATEX_OUTPUT), "/latex");
+    latexOutput = createOutputDirectory(outputDirectory,Config_getString(LATEX_OUTPUT),"/latex");
 
   QCString rtfOutput;
   bool &generateRtf = Config_getBool(GENERATE_RTF);
   if (generateRtf)
-    rtfOutput = createOutputDirectory(outputDirectory,
-                                      Config_getString(RTF_OUTPUT), "/rtf");
+    rtfOutput = createOutputDirectory(outputDirectory,Config_getString(RTF_OUTPUT),"/rtf");
 
   QCString manOutput;
   bool &generateMan = Config_getBool(GENERATE_MAN);
   if (generateMan)
-    manOutput = createOutputDirectory(outputDirectory,
-                                      Config_getString(MAN_OUTPUT), "/man");
+    manOutput = createOutputDirectory(outputDirectory,Config_getString(MAN_OUTPUT),"/man");
 
-  // QCString sqlOutput;
-  // bool &generateSql = Config_getBool(GENERATE_SQLITE3);
-  // if (generateSql)
-  //  sqlOutput =
-  //  createOutputDirectory(outputDirectory,"SQLITE3_OUTPUT","/sqlite3");
+  //QCString sqlOutput;
+  //bool &generateSql = Config_getBool(GENERATE_SQLITE3);
+  //if (generateSql)
+  //  sqlOutput = createOutputDirectory(outputDirectory,"SQLITE3_OUTPUT","/sqlite3");
 
-  if (Config_getBool(HAVE_DOT)) {
+  if (Config_getBool(HAVE_DOT))
+  {
     QCString curFontPath = Config_getString(DOT_FONTPATH);
-    if (curFontPath.isEmpty()) {
+    if (curFontPath.isEmpty())
+    {
       portable_getenv("DOTFONTPATH");
       QCString newFontPath = ".";
-      if (!curFontPath.isEmpty()) {
-        newFontPath += portable_pathListSeparator();
-        newFontPath += curFontPath;
+      if (!curFontPath.isEmpty())
+      {
+        newFontPath+=portable_pathListSeparator();
+        newFontPath+=curFontPath;
       }
-      portable_setenv("DOTFONTPATH", newFontPath);
-    } else {
-      portable_setenv("DOTFONTPATH", curFontPath);
+      portable_setenv("DOTFONTPATH",newFontPath);
+    }
+    else
+    {
+      portable_setenv("DOTFONTPATH",curFontPath);
     }
   }
 
+
+
   /**************************************************************************
    *             Handle layout file                                         *
    **************************************************************************/
@@ -10042,20 +11022,23 @@ void parseInput() {
   LayoutDocManager::instance().init();
   QCString &layoutFileName = Config_getString(LAYOUT_FILE);
   bool defaultLayoutUsed = FALSE;
-  if (layoutFileName.isEmpty()) {
+  if (layoutFileName.isEmpty())
+  {
     layoutFileName = "DoxygenLayout.xml";
     defaultLayoutUsed = TRUE;
   }
 
   QFile layoutFile(layoutFileName);
-  if (layoutFile.open(IO_ReadOnly)) {
-    msg("Parsing layout file %s...\n", layoutFileName.data());
+  if (layoutFile.open(IO_ReadOnly))
+  {
+    msg("Parsing layout file %s...\n",layoutFileName.data());
     QTextStream t(&layoutFile);
     t.setEncoding(QTextStream::Latin1);
-    LayoutDocManager::instance().parse(t, layoutFileName);
-  } else if (!defaultLayoutUsed) {
-    warn_uncond("failed to open layout file '%s' for reading!\n",
-                layoutFileName.data());
+    LayoutDocManager::instance().parse(t,layoutFileName);
+  }
+  else if (!defaultLayoutUsed)
+  {
+    warn_uncond("failed to open layout file '%s' for reading!\n",layoutFileName.data());
   }
 
   /**************************************************************************
@@ -10064,24 +11047,19 @@ void parseInput() {
 
   // prevent search in the output directories
   QStrList &exclPatterns = Config_getList(EXCLUDE_PATTERNS);
-  if (generateHtml)
-    exclPatterns.append(htmlOutput);
-  if (generateDocbook)
-    exclPatterns.append(docbookOutput);
-  if (generateXml)
-    exclPatterns.append(xmlOutput);
-  if (generateLatex)
-    exclPatterns.append(latexOutput);
-  if (generateRtf)
-    exclPatterns.append(rtfOutput);
-  if (generateMan)
-    exclPatterns.append(manOutput);
+  if (generateHtml)    exclPatterns.append(htmlOutput);
+  if (generateDocbook) exclPatterns.append(docbookOutput);
+  if (generateXml)     exclPatterns.append(xmlOutput);
+  if (generateLatex)   exclPatterns.append(latexOutput);
+  if (generateRtf)     exclPatterns.append(rtfOutput);
+  if (generateMan)     exclPatterns.append(manOutput);
 
   searchInputFiles();
 
   // Notice: the order of the function calls below is very important!
 
-  if (Config_getBool(GENERATE_HTML)) {
+  if (Config_getBool(GENERATE_HTML))
+  {
     readFormulaRepository();
   }
 
@@ -10091,34 +11069,37 @@ void parseInput() {
 
   g_storage = new FileStorage;
   g_storage->setName(Doxygen::entryDBFileName);
-  if (!g_storage->open(IO_WriteOnly)) {
+  if (!g_storage->open(IO_WriteOnly))
+  {
     err("Failed to create temporary storage file %s\n",
         Doxygen::entryDBFileName.data());
     exit(1);
   }
-  Entry *root = new Entry;
-  EntryNav *rootNav = new EntryNav(0, root);
+  Entry *root=new Entry;
+  EntryNav *rootNav = new EntryNav(0,root);
   rootNav->setEntry(root);
   msg("Reading and parsing tag files\n");
 
   QStrList &tagFileList = Config_getList(TAGFILES);
-  char *s = tagFileList.first();
-  while (s) {
-    readTagFile(root, s);
-    root->createNavigationIndex(rootNav, g_storage, 0);
-    s = tagFileList.next();
+  char *s=tagFileList.first();
+  while (s)
+  {
+    readTagFile(root,s);
+    root->createNavigationIndex(rootNav,g_storage,0);
+    s=tagFileList.next();
   }
 
   /**************************************************************************
    *             Parse source files                                         *
    **************************************************************************/
 
-  if (Config_getBool(BUILTIN_STL_SUPPORT)) {
+  if (Config_getBool(BUILTIN_STL_SUPPORT))
+  {
     addSTLClasses(rootNav);
   }
 
   g_s.begin("Parsing files\n");
-  parseFiles(root, rootNav);
+  parseFiles(root,rootNav);
   g_storage->close();
   g_s.end();
 
@@ -10128,7 +11109,8 @@ void parseInput() {
   scanFreeScanner();
   pyscanFreeScanner();
 
-  if (!g_storage->open(IO_ReadOnly)) {
+  if (!g_storage->open(IO_ReadOnly))
+  {
     err("Failed to open temporary storage file %s for reading",
         Doxygen::entryDBFileName.data());
     exit(1);
@@ -10156,7 +11138,7 @@ void parseInput() {
   g_s.begin("Building file list...\n");
   buildFileList(rootNav);
   g_s.end();
-  // generateFileTree();
+  //generateFileTree();
 
   g_s.begin("Building class list...\n");
   buildClassList(rootNav);
@@ -10173,7 +11155,7 @@ void parseInput() {
   resolveClassNestingRelations();
   g_s.end();
   // 1.8.2-20121111: no longer add nested classes to the group as well
-  // distributeClassGroupRelations();
+  //distributeClassGroupRelations();
 
   // calling buildClassList may result in cached relations that
   // become invalid after resolveClassNestingRelations(), that's why
@@ -10237,7 +11219,8 @@ void parseInput() {
   findUsedTemplateInstances();
   g_s.end();
 
-  if (Config_getBool(INLINE_SIMPLE_STRUCTS)) {
+  if (Config_getBool(INLINE_SIMPLE_STRUCTS))
+  {
     g_s.begin("Searching for tag less structs...\n");
     findTagLessClasses();
     g_s.end();
@@ -10250,7 +11233,8 @@ void parseInput() {
   g_s.begin("Computing class relations...\n");
   computeTemplateClassRelations();
   flushUnresolvedRelations();
-  if (Config_getBool(OPTIMIZE_OUTPUT_VHDL)) {
+  if (Config_getBool(OPTIMIZE_OUTPUT_VHDL))
+  {
     VhdlDocGen::computeVhdlComponentRelations();
   }
   computeClassRelations();
@@ -10305,7 +11289,7 @@ void parseInput() {
   delete rootNav;
   g_storage->close();
   delete g_storage;
-  g_storage = 0;
+  g_storage=0;
 
   QDir thisDir;
   thisDir.remove(Doxygen::entryDBFileName);
@@ -10327,7 +11311,8 @@ void parseInput() {
   addMembersToMemberGroup();
   g_s.end();
 
-  if (Config_getBool(DISTRIBUTE_GROUP_DOC)) {
+  if (Config_getBool(DISTRIBUTE_GROUP_DOC))
+  {
     g_s.begin("Distributing member group documentation.\n");
     distributeMemberGroupDocumentation();
     g_s.end();
@@ -10337,7 +11322,8 @@ void parseInput() {
   computeMemberReferences();
   g_s.end();
 
-  if (Config_getBool(INHERIT_DOCS)) {
+  if (Config_getBool(INHERIT_DOCS))
+  {
     g_s.begin("Inheriting documentation...\n");
     inheritDocumentation();
     g_s.end();
@@ -10362,14 +11348,15 @@ void parseInput() {
   sortMemberLists();
   g_s.end();
 
-  if (Config_getBool(DIRECTORY_GRAPH)) {
+  if (Config_getBool(DIRECTORY_GRAPH))
+  {
     g_s.begin("Computing dependencies between directories...\n");
     computeDirDependencies();
     g_s.end();
   }
 
-  // g_s.begin("Resolving citations...\n");
-  // Doxygen::citeDict->resolve();
+  //g_s.begin("Resolving citations...\n");
+  //Doxygen::citeDict->resolve();
 
   g_s.begin("Generating citations page...\n");
   Doxygen::citeDict->generatePage();
@@ -10400,7 +11387,8 @@ void parseInput() {
   g_s.end();
 }
 
-void generateOutput() {
+void generateOutput()
+{
   /**************************************************************************
    *            Initialize output generators                                *
    **************************************************************************/
@@ -10409,97 +11397,98 @@ void generateOutput() {
   addCodeOnlyMappings();
 
   //// dump all symbols
-  if (g_dumpSymbolMap) {
+  if (g_dumpSymbolMap)
+  {
     dumpSymbolMap();
     exit(0);
   }
 
   initSearchIndexer();
 
-  bool generateHtml = Config_getBool(GENERATE_HTML);
+  bool generateHtml  = Config_getBool(GENERATE_HTML);
   bool generateLatex = Config_getBool(GENERATE_LATEX);
-  bool generateMan = Config_getBool(GENERATE_MAN);
-  bool generateRtf = Config_getBool(GENERATE_RTF);
+  bool generateMan   = Config_getBool(GENERATE_MAN);
+  bool generateRtf   = Config_getBool(GENERATE_RTF);
+
 
   g_outputList = new OutputList(TRUE);
-  if (generateHtml) {
+  if (generateHtml)
+  {
     g_outputList->add(new HtmlGenerator);
     HtmlGenerator::init();
 
     // add HTML indexers that are enabled
-    bool generateHtmlHelp = Config_getBool(GENERATE_HTMLHELP);
+    bool generateHtmlHelp    = Config_getBool(GENERATE_HTMLHELP);
     bool generateEclipseHelp = Config_getBool(GENERATE_ECLIPSEHELP);
-    bool generateQhp = Config_getBool(GENERATE_QHP);
-    bool generateTreeView = Config_getBool(GENERATE_TREEVIEW);
-    bool generateDocSet = Config_getBool(GENERATE_DOCSET);
-    if (generateEclipseHelp)
-      Doxygen::indexList->addIndex(new EclipseHelp);
-    if (generateHtmlHelp)
-      Doxygen::indexList->addIndex(new HtmlHelp);
-    if (generateQhp)
-      Doxygen::indexList->addIndex(new Qhp);
-    if (generateTreeView)
-      Doxygen::indexList->addIndex(new FTVHelp(TRUE));
-    if (generateDocSet)
-      Doxygen::indexList->addIndex(new DocSets);
+    bool generateQhp         = Config_getBool(GENERATE_QHP);
+    bool generateTreeView    = Config_getBool(GENERATE_TREEVIEW);
+    bool generateDocSet      = Config_getBool(GENERATE_DOCSET);
+    if (generateEclipseHelp) Doxygen::indexList->addIndex(new EclipseHelp);
+    if (generateHtmlHelp)    Doxygen::indexList->addIndex(new HtmlHelp);
+    if (generateQhp)         Doxygen::indexList->addIndex(new Qhp);
+    if (generateTreeView)    Doxygen::indexList->addIndex(new FTVHelp(TRUE));
+    if (generateDocSet)      Doxygen::indexList->addIndex(new DocSets);
     Doxygen::indexList->initialize();
     HtmlGenerator::writeTabData();
   }
-  if (generateLatex) {
+  if (generateLatex)
+  {
     g_outputList->add(new LatexGenerator);
     LatexGenerator::init();
   }
-  if (generateMan) {
+  if (generateMan)
+  {
     g_outputList->add(new ManGenerator);
     ManGenerator::init();
   }
-  if (generateRtf) {
+  if (generateRtf)
+  {
     g_outputList->add(new RTFGenerator);
     RTFGenerator::init();
   }
-  if (Config_getBool(USE_HTAGS)) {
+  if (Config_getBool(USE_HTAGS))
+  {
     Htags::useHtags = TRUE;
     QCString htmldir = Config_getString(HTML_OUTPUT);
     if (!Htags::execute(htmldir))
-      err("USE_HTAGS is YES but htags(1) failed. \n");
+       err("USE_HTAGS is YES but htags(1) failed. \n");
     if (!Htags::loadFilemap(htmldir))
-      err("htags(1) ended normally but failed to load the filemap. \n");
+       err("htags(1) ended normally but failed to load the filemap. \n");
   }
 
   /**************************************************************************
    *                        Generate documentation                          *
    **************************************************************************/
 
-  if (generateHtml)
-    writeDoxFont(Config_getString(HTML_OUTPUT));
-  if (generateLatex)
-    writeDoxFont(Config_getString(LATEX_OUTPUT));
-  if (generateRtf)
-    writeDoxFont(Config_getString(RTF_OUTPUT));
+  if (generateHtml)  writeDoxFont(Config_getString(HTML_OUTPUT));
+  if (generateLatex) writeDoxFont(Config_getString(LATEX_OUTPUT));
+  if (generateRtf)   writeDoxFont(Config_getString(RTF_OUTPUT));
 
   g_s.begin("Generating style sheet...\n");
-  // printf("writing style info\n");
+  //printf("writing style info\n");
   g_outputList->writeStyleInfo(0); // write first part
   g_s.end();
 
-  static bool searchEngine = Config_getBool(SEARCHENGINE);
+  static bool searchEngine      = Config_getBool(SEARCHENGINE);
   static bool serverBasedSearch = Config_getBool(SERVER_BASED_SEARCH);
 
   g_s.begin("Generating search indices...\n");
-  if (searchEngine && !serverBasedSearch &&
-      (generateHtml || g_useOutputTemplate)) {
+  if (searchEngine && !serverBasedSearch && (generateHtml || g_useOutputTemplate))
+  {
     createJavascriptSearchIndex();
   }
 
   // generate search indices (need to do this before writing other HTML
   // pages as these contain a drop down menu with options depending on
   // what categories we find in this function.
-  if (generateHtml && searchEngine) {
-    QCString searchDirName = Config_getString(HTML_OUTPUT) + "/search";
+  if (generateHtml && searchEngine)
+  {
+    QCString searchDirName = Config_getString(HTML_OUTPUT)+"/search";
     QDir searchDir(searchDirName);
-    if (!searchDir.exists() && !searchDir.mkdir(searchDirName)) {
+    if (!searchDir.exists() && !searchDir.mkdir(searchDirName))
+    {
       err("Could not create search results directory '%s' $PWD='%s'\n",
-          searchDirName.data(), QDir::currentDirPath().data());
+          searchDirName.data(),QDir::currentDirPath().data());
       exit(1);
     }
     HtmlGenerator::writeSearchData(searchDirName);
@@ -10514,7 +11503,8 @@ void generateOutput() {
   generateExampleDocs();
   g_s.end();
 
-  if (!Htags::useHtags) {
+  if (!Htags::useHtags)
+  {
     g_s.begin("Generating file sources...\n");
     generateFileSources();
     g_s.end();
@@ -10540,7 +11530,8 @@ void generateOutput() {
   generateNamespaceDocs();
   g_s.end();
 
-  if (Config_getBool(GENERATE_LEGEND)) {
+  if (Config_getBool(GENERATE_LEGEND))
+  {
     g_s.begin("Generating graph info page...\n");
     writeGraphInfo(*g_outputList);
     g_s.end();
@@ -10550,23 +11541,27 @@ void generateOutput() {
   generateDirDocs(*g_outputList);
   g_s.end();
 
-  if (Doxygen::formulaList->count() > 0 && generateHtml &&
-      !Config_getBool(USE_MATHJAX)) {
+  if (Doxygen::formulaList->count()>0 && generateHtml
+      && !Config_getBool(USE_MATHJAX))
+  {
     g_s.begin("Generating bitmaps for formulas in HTML...\n");
     Doxygen::formulaList->generateBitmaps(Config_getString(HTML_OUTPUT));
     g_s.end();
   }
 
-  if (Config_getBool(SORT_GROUP_NAMES)) {
+  if (Config_getBool(SORT_GROUP_NAMES))
+  {
     Doxygen::groupSDict->sort();
     GroupSDict::Iterator gli(*Doxygen::groupSDict);
     GroupDef *gd;
-    for (gli.toFirst(); (gd = gli.current()); ++gli) {
+    for (gli.toFirst();(gd=gli.current());++gli)
+    {
       gd->sortSubGroups();
     }
   }
 
-  if (g_outputList->count() > 0) {
+  if (g_outputList->count()>0)
+  {
     writeIndexHierarchy(*g_outputList);
   }
 
@@ -10578,7 +11573,8 @@ void generateOutput() {
   writeTagFile();
   g_s.end();
 
-  if (Config_getBool(DOT_CLEANUP)) {
+  if (Config_getBool(DOT_CLEANUP))
+  {
     if (generateHtml)
       removeDoxFont(Config_getString(HTML_OUTPUT));
     if (generateRtf)
@@ -10587,120 +11583,133 @@ void generateOutput() {
       removeDoxFont(Config_getString(LATEX_OUTPUT));
   }
 
-  if (Config_getBool(GENERATE_XML)) {
+  if (Config_getBool(GENERATE_XML))
+  {
     g_s.begin("Generating XML output...\n");
-    Doxygen::generatingXmlOutput = TRUE;
+    Doxygen::generatingXmlOutput=TRUE;
     generateXML();
-    Doxygen::generatingXmlOutput = FALSE;
+    Doxygen::generatingXmlOutput=FALSE;
     g_s.end();
   }
-  if (USE_SQLITE3) {
+  if (USE_SQLITE3)
+  {
     g_s.begin("Generating SQLITE3 output...\n");
     generateSqlite3();
     g_s.end();
   }
 
-  if (Config_getBool(GENERATE_DOCBOOK)) {
+  if (Config_getBool(GENERATE_DOCBOOK))
+  {
     g_s.begin("Generating Docbook output...\n");
     generateDocbook();
     g_s.end();
   }
 
-  if (Config_getBool(GENERATE_AUTOGEN_DEF)) {
+  if (Config_getBool(GENERATE_AUTOGEN_DEF))
+  {
     g_s.begin("Generating AutoGen DEF output...\n");
     generateDEF();
     g_s.end();
   }
-  if (Config_getBool(GENERATE_PERLMOD)) {
+  if (Config_getBool(GENERATE_PERLMOD))
+  {
     g_s.begin("Generating Perl module output...\n");
     generatePerlMod();
     g_s.end();
   }
-  if (generateHtml && searchEngine && serverBasedSearch) {
+  if (generateHtml && searchEngine && serverBasedSearch)
+  {
     g_s.begin("Generating search index\n");
-    if (Doxygen::searchIndex->kind() ==
-        SearchIndexIntf::Internal) // write own search index
+    if (Doxygen::searchIndex->kind()==SearchIndexIntf::Internal) // write own search index
     {
       HtmlGenerator::writeSearchPage();
-      Doxygen::searchIndex->write(Config_getString(HTML_OUTPUT) +
-                                  "/search/search.idx");
-    } else // write data for external search index
+      Doxygen::searchIndex->write(Config_getString(HTML_OUTPUT)+"/search/search.idx");
+    }
+    else // write data for external search index
     {
       HtmlGenerator::writeExternalSearchPage();
       QCString searchDataFile = Config_getString(SEARCHDATA_FILE);
-      if (searchDataFile.isEmpty()) {
-        searchDataFile = "searchdata.xml";
+      if (searchDataFile.isEmpty())
+      {
+        searchDataFile="searchdata.xml";
       }
-      if (!portable_isAbsolutePath(searchDataFile)) {
-        searchDataFile.prepend(Config_getString(OUTPUT_DIRECTORY) + "/");
+      if (!portable_isAbsolutePath(searchDataFile))
+      {
+        searchDataFile.prepend(Config_getString(OUTPUT_DIRECTORY)+"/");
       }
       Doxygen::searchIndex->write(searchDataFile);
     }
     g_s.end();
   }
 
-  if (g_useOutputTemplate)
-    generateOutputViaTemplate();
+  if (g_useOutputTemplate) generateOutputViaTemplate();
 
-  if (generateRtf) {
+  if (generateRtf)
+  {
     g_s.begin("Combining RTF output...\n");
-    if (!RTFGenerator::preProcessFileInplace(Config_getString(RTF_OUTPUT),
-                                             "refman.rtf")) {
+    if (!RTFGenerator::preProcessFileInplace(Config_getString(RTF_OUTPUT),"refman.rtf"))
+    {
       err("An error occurred during post-processing the RTF files!\n");
     }
     g_s.end();
   }
 
-  if (Config_getBool(HAVE_DOT)) {
+  if (Config_getBool(HAVE_DOT))
+  {
     g_s.begin("Running dot...\n");
     DotManager::instance()->run();
     g_s.end();
   }
 
   // copy static stuff
-  if (generateHtml) {
+  if (generateHtml)
+  {
     FTVHelp::generateTreeViewImages();
     copyStyleSheet();
     copyLogo(Config_getString(HTML_OUTPUT));
-    copyExtraFiles(Config_getList(HTML_EXTRA_FILES), "HTML_EXTRA_FILES",
-                   Config_getString(HTML_OUTPUT));
+    copyExtraFiles(Config_getList(HTML_EXTRA_FILES),"HTML_EXTRA_FILES",Config_getString(HTML_OUTPUT));
   }
-  if (generateLatex) {
+  if (generateLatex)
+  {
     copyLatexStyleSheet();
     copyLogo(Config_getString(LATEX_OUTPUT));
-    copyExtraFiles(Config_getList(LATEX_EXTRA_FILES), "LATEX_EXTRA_FILES",
-                   Config_getString(LATEX_OUTPUT));
+    copyExtraFiles(Config_getList(LATEX_EXTRA_FILES),"LATEX_EXTRA_FILES",Config_getString(LATEX_OUTPUT));
   }
-  if (generateRtf) {
+  if (generateRtf)
+  {
     copyLogo(Config_getString(RTF_OUTPUT));
   }
 
-  if (generateHtml && Config_getBool(GENERATE_HTMLHELP) &&
-      !Config_getString(HHC_LOCATION).isEmpty()) {
+  if (generateHtml &&
+      Config_getBool(GENERATE_HTMLHELP) &&
+      !Config_getString(HHC_LOCATION).isEmpty())
+  {
     g_s.begin("Running html help compiler...\n");
     QString oldDir = QDir::currentDirPath();
     QDir::setCurrent(Config_getString(HTML_OUTPUT));
     portable_sysTimerStart();
-    if (portable_system(Config_getString(HHC_LOCATION), "index.hhp",
-                        Debug::isFlagSet(Debug::ExtCmd)) != 1) {
+    if (portable_system(Config_getString(HHC_LOCATION), "index.hhp", Debug::isFlagSet(Debug::ExtCmd))!=1)
+    {
       err("failed to run html help compiler on index.hhp\n");
     }
     portable_sysTimerStop();
     QDir::setCurrent(oldDir);
     g_s.end();
   }
-  if (generateHtml && Config_getBool(GENERATE_QHP) &&
-      !Config_getString(QHG_LOCATION).isEmpty()) {
+  if ( generateHtml &&
+       Config_getBool(GENERATE_QHP) &&
+      !Config_getString(QHG_LOCATION).isEmpty())
+  {
     g_s.begin("Running qhelpgenerator...\n");
     QCString const qhpFileName = Qhp::getQhpFileName();
     QCString const qchFileName = getQchFileName();
 
-    QCString const args = QCString().sprintf("%s -o \"%s\"", qhpFileName.data(),
-                                             qchFileName.data());
+    QCString const args = QCString().sprintf("%s -o \"%s\"", qhpFileName.data(), qchFileName.data());
     QString const oldDir = QDir::currentDirPath();
     QDir::setCurrent(Config_getString(HTML_OUTPUT));
     portable_sysTimerStart();
-    if (portable_system(Config_getString(QHG_LOCATION), args.data(), FALSE)) {
+    if (portable_system(Config_getString(QHG_LOCATION), args.data(), FALSE))
+    {
       err("failed to run qhelpgenerator on index.qhp\n");
     }
     portable_sysTimerStop();
@@ -10710,27 +11719,30 @@ void generateOutput() {
 
   int cacheParam;
   msg("lookup cache used %d/%d hits=%d misses=%d\n",
-      Doxygen::lookupCache->count(), Doxygen::lookupCache->size(),
-      Doxygen::lookupCache->hits(), Doxygen::lookupCache->misses());
-  cacheParam = computeIdealCacheParam(
-      Doxygen::lookupCache->misses() * 2 /
-      3); // part of the cache is flushed, hence the 2/3 correction factor
-  if (cacheParam > Config_getInt(LOOKUP_CACHE_SIZE)) {
-    msg("Note: based on cache misses the ideal setting for LOOKUP_CACHE_SIZE "
-        "is %d at the cost of higher memory usage.\n",
-        cacheParam);
-  }
-
-  if (Debug::isFlagSet(Debug::Time)) {
-    msg("Total elapsed time: %.3f seconds\n(of which %.3f seconds waiting for "
-        "external tools to finish)\n",
-        ((double)Doxygen::runningTime.elapsed()) / 1000.0,
-        portable_getSysElapsedTime());
+      Doxygen::lookupCache->count(),
+      Doxygen::lookupCache->size(),
+      Doxygen::lookupCache->hits(),
+      Doxygen::lookupCache->misses());
+  cacheParam = computeIdealCacheParam(Doxygen::lookupCache->misses()*2/3); // part of the cache is flushed, hence the 2/3 correction factor
+  if (cacheParam>Config_getInt(LOOKUP_CACHE_SIZE))
+  {
+    msg("Note: based on cache misses the ideal setting for LOOKUP_CACHE_SIZE is %d at the cost of higher memory usage.\n",cacheParam);
+  }
+
+  if (Debug::isFlagSet(Debug::Time))
+  {
+    msg("Total elapsed time: %.3f seconds\n(of which %.3f seconds waiting for external tools to finish)\n",
+         ((double)Doxygen::runningTime.elapsed())/1000.0,
+         portable_getSysElapsedTime()
+        );
     g_s.print();
-  } else {
+  }
+  else
+  {
     msg("finished...\n");
   }
 
+
   /**************************************************************************
    *                        Start cleaning up                               *
    **************************************************************************/
@@ -10746,5 +11758,6 @@ void generateOutput() {
   delete Doxygen::symbolMap;
   delete Doxygen::clangUsrMap;
   delete Doxygen::symbolStorage;
-  g_successfulRun = TRUE;
+  g_successfulRun=TRUE;
 }
+
diff --git a/src/markdown.cpp b/src/markdown.cpp
index ccd8c16a..67ceba2e 100644
--- a/src/markdown.cpp
+++ b/src/markdown.cpp
@@ -3,8 +3,8 @@
  * Copyright (C) 1997-2015 by Dimitri van Heesch.
  *
  * Permission to use, copy, modify, and distribute this software and its
- * documentation under the terms of the GNU General Public License is hereby
- * granted. No representations are made about the suitability of this software
+ * documentation under the terms of the GNU General Public License is hereby 
+ * granted. No representations are made about the suitability of this software 
  * for any purpose. It is provided "as is" without express or implied warranty.
  * See the GNU General Public License for more details.
  *
@@ -13,7 +13,7 @@
  *
  */
 
-/* Note: part of the code below is inspired by libupskirt written by
+/* Note: part of the code below is inspired by libupskirt written by 
  * Natacha Porté. Original copyright message follows:
  *
  * Copyright (c) 2008, Natacha Porté
@@ -31,8 +31,7 @@
  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  */
 
-#include <qdict.h>
-#include <qfileinfo.h>
+#include <stdio.h>
 #include <qglobal.h>
 #include <qregexp.h>
 #include <qfileinfo.h>
@@ -40,26 +39,27 @@
 #include <qvector.h>
 #define USE_ORIGINAL_TABLES
 
-#include "bufstr.h"
-#include "commentcnv.h"
-#include "commentscan.h"
-#include "config.h"
+#include "markdown.h"
+#include "growbuf.h"
 #include "debug.h"
+#include "util.h"
 #include "doxygen.h"
+#include "commentscan.h"
 #include "entry.h"
-#include "growbuf.h"
-#include "markdown.h"
-#include "message.h"
-#include "prologscanner.h"
+#include "bufstr.h"
+#include "commentcnv.h"
+#include "config.h"
 #include "section.h"
-#include "util.h"
+#include "message.h"
+
 //-----------
 
 // is character at position i in data part of an identifier?
-#define isIdChar(i)                                                            \
-  ((data[i] >= 'a' && data[i] <= 'z') || (data[i] >= 'A' && data[i] <= 'Z') || \
-   (data[i] >= '0' && data[i] <= '9') ||                                       \
-   (((unsigned char)data[i]) >= 0x80)) // unicode characters
+#define isIdChar(i) \
+  ((data[i]>='a' && data[i]<='z') || \
+   (data[i]>='A' && data[i]<='Z') || \
+   (data[i]>='0' && data[i]<='9') || \
+   (((unsigned char)data[i])>=0x80)) // unicode characters
 
 #define extraChar(i) \
   (data[i]=='-' || data[i]=='+' || data[i]=='!' || \
@@ -67,27 +67,28 @@
    data[i]=='&' || data[i]=='*' || data[i]=='%')
 
 // is character at position i in data allowed before an emphasis section
-#define isOpenEmphChar(i)                                                      \
-  (data[i] == '\n' || data[i] == ' ' || data[i] == '\'' || data[i] == '<' ||   \
-   data[i] == '{' || data[i] == '(' || data[i] == '[' || data[i] == ',' ||     \
-   data[i] == ':' || data[i] == ';')
+#define isOpenEmphChar(i) \
+  (data[i]=='\n' || data[i]==' ' || data[i]=='\'' || data[i]=='<' || \
+   data[i]=='{'  || data[i]=='(' || data[i]=='['  || data[i]==',' || \
+   data[i]==':'  || data[i]==';')
 
-// is character at position i in data an escape that prevents ending an emphasis
-// section
+// is character at position i in data an escape that prevents ending an emphasis section
 // so for example *bla (*.txt) is cool*
-#define ignoreCloseEmphChar(i)                                                 \
-  (data[i] == '(' || data[i] == '{' || data[i] == '[' || data[i] == '<' ||     \
-   data[i] == '=' || data[i] == '+' || data[i] == '-' || data[i] == '\\' ||    \
-   data[i] == '@')
+#define ignoreCloseEmphChar(i) \
+  (data[i]=='('  || data[i]=='{' || data[i]=='[' || data[i]=='<' || \
+   data[i]=='='  || data[i]=='+' || data[i]=='-' || data[i]=='\\' || \
+   data[i]=='@')
 
 //----------
 
-struct LinkRef {
-  LinkRef(const QCString &l, const QCString &t) : link(l), title(t) {}
+struct LinkRef
+{
+  LinkRef(const QCString &l,const QCString &t) : link(l), title(t) {}
   QCString link;
   QCString title;
 };
-truct TableCell
+
+struct TableCell
 {
   TableCell() : colSpan(false) {}
   QCString cellText;
@@ -98,101 +99,86 @@ typedef int (*action_t)(GrowBuf &out,const char *data,int offset,int size);
 
 enum Alignment { AlignNone, AlignLeft, AlignCenter, AlignRight };
 
+
 //----------
 
 static QDict<LinkRef> g_linkRefs(257);
-static action_t g_actions[256];
-static Entry *g_current;
-static QCString g_fileName;
-static int g_lineNr;
+static action_t       g_actions[256];
+static Entry         *g_current;
+static QCString       g_fileName;
+static int            g_lineNr;
 
 // In case a markdown page starts with a level1 header, that header is used
 // as a title of the page, in effect making it a level0 header, so the
 // level of all other sections needs to be corrected as well.
 // This flag is TRUE if corrections are needed.
-// static bool           g_correctSectionLevel;
+//static bool           g_correctSectionLevel;
+
 
 //----------
 
 const int codeBlockIndent = 4;
 
-static void processInline(GrowBuf &out, const char *data, int size);
+static void processInline(GrowBuf &out,const char *data,int size);
 
 // escape characters that have a special meaning later on.
-static QCString escapeSpecialChars(const QCString &s) {
-  if (s.isEmpty())
-    return "";
-  bool insideQuote = FALSE;
+static QCString escapeSpecialChars(const QCString &s)
+{
+  if (s.isEmpty()) return "";
+  bool insideQuote=FALSE;
   GrowBuf growBuf;
-  const char *p = s;
-  char c, pc = '\0';
-  while ((c = *p++)) {
-    switch (c) {
-    case '"':
-      if (pc != '\\') {
-        insideQuote = !insideQuote;
-      }
-      growBuf.addChar(c);
-      break;
-    case '<':
-      if (!insideQuote) {
-        growBuf.addChar('\\');
-      }
-      growBuf.addChar('<');
-      break;
-    case '>':
-      if (!insideQuote) {
-        growBuf.addChar('\\');
-      }
-      growBuf.addChar('>');
-      break;
-    case '\\':
-      if (!insideQuote) {
-        growBuf.addChar('\\');
-      }
-      growBuf.addChar('\\');
-      break;
-    case '@':
-      if (!insideQuote) {
-        growBuf.addChar('\\');
-      }
-      growBuf.addChar('@');
-      break;
-    default:
-      growBuf.addChar(c);
-      break;
+  const char *p=s;
+  char c,pc='\0';
+  while ((c=*p++))
+  {
+    switch (c)
+    {
+      case '"':  if (pc!='\\')  { insideQuote=!insideQuote; } growBuf.addChar(c);   break;
+      case '<':  if (!insideQuote) { growBuf.addChar('\\'); } growBuf.addChar('<'); break;
+      case '>':  if (!insideQuote) { growBuf.addChar('\\'); } growBuf.addChar('>'); break;
+      case '\\': if (!insideQuote) { growBuf.addChar('\\'); } growBuf.addChar('\\'); break;
+      case '@':  if (!insideQuote) { growBuf.addChar('\\'); } growBuf.addChar('@'); break;
+      default:   growBuf.addChar(c); break;
     }
-    pc = c;
+    pc=c;
   }
   growBuf.addChar(0);
   return growBuf.get();
 }
 
-static void convertStringFragment(QCString &result, const char *data,
-                                  int size) {
-  if (size < 0)
-    size = 0;
-  result.resize(size + 1);
-  memcpy(result.rawData(), data, size);
-  result.at(size) = '\0';
+static void convertStringFragment(QCString &result,const char *data,int size)
+{
+  if (size<0) size=0;
+  result.resize(size+1);
+  memcpy(result.rawData(),data,size);
+  result.at(size)='\0';
 }
 
 /** helper function to convert presence of left and/or right alignment markers
  *  to a alignment value
  */
-static Alignment markersToAlignment(bool leftMarker, bool rightMarker) {
-  // printf("markerToAlignment(%d,%d)\n",leftMarker,rightMarker);
-  if (leftMarker && rightMarker) {
+static Alignment markersToAlignment(bool leftMarker,bool rightMarker)
+{
+  //printf("markerToAlignment(%d,%d)\n",leftMarker,rightMarker);
+  if (leftMarker && rightMarker)
+  {
     return AlignCenter;
-  } else if (leftMarker) {
+  }
+  else if (leftMarker)
+  {
     return AlignLeft;
-  } else if (rightMarker) {
+  }
+  else if (rightMarker)
+  {
     return AlignRight;
-  } else {
+  }
+  else
+  {
     return AlignNone;
   }
 }
 
+
 // Check if data contains a block command. If so returned the command
 // that ends the block. If not an empty string is returned.
 // Note When offset>0 character position -1 will be inspected.
@@ -211,35 +197,51 @@ static Alignment markersToAlignment(bool leftMarker, bool rightMarker) {
 // \xmlonly..\endxmlonly
 // \rtfonly..\endrtfonly
 // \manonly..\endmanonly
-static QCString isBlockCommand(const char *data, int offset, int size) {
-  bool openBracket = offset > 0 && data[-1] == '{';
-  bool isEscaped = offset > 0 && (data[-1] == '\\' || data[-1] == '@');
-  if (isEscaped)
-    return QCString();
-
-  int end = 1;
-  while (end < size && (data[end] >= 'a' && data[end] <= 'z'))
-    end++;
-  if (end == 1)
-    return QCString();
+static QCString isBlockCommand(const char *data,int offset,int size)
+{
+  bool openBracket = offset>0 && data[-1]=='{';
+  bool isEscaped = offset>0 && (data[-1]=='\\' || data[-1]=='@');
+  if (isEscaped) return QCString();
+
+  int end=1;
+  while (end<size && (data[end]>='a' && data[end]<='z')) end++;
+  if (end==1) return QCString();
   QCString blockName;
-  convertStringFragment(blockName, data + 1, end - 1);
-  if (blockName == "code" && openBracket) {
+  convertStringFragment(blockName,data+1,end-1);
+  if (blockName=="code" && openBracket)
+  {
     return "}";
-  } else if (blockName == "dot" || blockName == "code" || blockName == "msc" ||
-             blockName == "verbatim" || blockName == "latexonly" ||
-             blockName == "htmlonly" || blockName == "xmlonly" ||
-             blockName == "rtfonly" || blockName == "manonly" ||
-             blockName == "docbookonly") {
-    return "end" + blockName;
-  } else if (blockName == "startuml") {
+  }
+  else if (blockName=="dot"         || 
+           blockName=="code"        || 
+           blockName=="msc"         ||
+           blockName=="verbatim"    || 
+           blockName=="latexonly"   || 
+           blockName=="htmlonly"    ||
+           blockName=="xmlonly"     ||
+           blockName=="rtfonly"     ||
+           blockName=="manonly"     ||
+           blockName=="docbookonly"
+     )
+  {
+    return "end"+blockName;
+  }
+  else if (blockName=="startuml")
+  {
     return "enduml";
-  } else if (blockName == "f" && end < size) {
-    if (data[end] == '$') {
+  }
+  else if (blockName=="f" && end<size)
+  {
+    if (data[end]=='$')
+    {
       return "f$";
-    } else if (data[end] == '[') {
+    }
+    else if (data[end]=='[')
+    {
       return "f]";
-    } else if (data[end] == '}') {
+    }
+    else if (data[end]=='}')
+    {
       return "f}";
     }
   }
@@ -249,34 +251,38 @@ static QCString isBlockCommand(const char *data, int offset, int size) {
 /** looks for the next emph char, skipping other constructs, and
  *  stopping when either it is found, or we are at the end of a paragraph.
  */
-static int findEmphasisChar(const char *data, int size, char c, int c_size) {
+static int findEmphasisChar(const char *data, int size, char c, int c_size)
+{
   int i = 1;
 
-  while (i < size) {
-    while (i < size && data[i] != c && data[i] != '`' && data[i] != '\\' &&
-           data[i] != '@' && data[i] != '\n')
-      i++;
-    // printf("findEmphasisChar: data=[%s] i=%d c=%c\n",data,i,data[i]);
+  while (i<size)
+  {
+    while (i<size && data[i]!=c    && data[i]!='`' && 
+                     data[i]!='\\' && data[i]!='@' &&
+                     data[i]!='\n') i++;
+    //printf("findEmphasisChar: data=[%s] i=%d c=%c\n",data,i,data[i]);
 
-    // not counting escaped chars or characters that are unlikely
+    // not counting escaped chars or characters that are unlikely 
     // to appear as the end of the emphasis char
-    if (i > 0 && ignoreCloseEmphChar(i - 1)) {
+    if (i>0 && ignoreCloseEmphChar(i-1))
+    {
       i++;
       continue;
-    } else {
+    }
+    else
+    {
       // get length of emphasis token
       int len = 0;
-      while (i + len < size && data[i + len] == c) {
+      while (i+len<size && data[i+len]==c)
+      {
         len++;
       }
 
-      if (len > 0) {
-        if (len != c_size ||
-            (i < size - len &&
-             isIdChar(i +
-                      len))) // to prevent touching some_underscore_identifier
+      if (len>0)
+      {
+        if (len!=c_size || (i<size-len && isIdChar(i+len))) // to prevent touching some_underscore_identifier
         {
-          i = i + len;
+          i=i+len;
           continue;
         }
         return i; // found it
@@ -284,104 +290,114 @@ static int findEmphasisChar(const char *data, int size, char c, int c_size) {
     }
 
     // skipping a code span
-    if (data[i] == '`') {
-      int snb = 0;
-      while (i < size && data[i] == '`')
-        snb++, i++;
+    if (data[i]=='`')
+    {
+      int snb=0;
+      while (i<size && data[i]=='`') snb++,i++;
 
       // find same pattern to end the span
-      int enb = 0;
-      while (i < size && enb < snb) {
-        if (data[i] == '`')
-          enb++;
-        if (snb == 1 && data[i] == '\'')
-          break; // ` ended by '
+      int enb=0;
+      while (i<size && enb<snb)
+      {
+        if (data[i]=='`') enb++;
+        if (snb==1 && data[i]=='\'') break; // ` ended by '
         i++;
       }
-    } else if (data[i] == '@' ||
-               data[i] ==
-                   '\\') { // skip over blocks that should not be processed
-      QCString endBlockName = isBlockCommand(data + i, i, size - i);
-      if (!endBlockName.isEmpty()) {
+    }
+    else if (data[i]=='@' || data[i]=='\\')
+    { // skip over blocks that should not be processed
+      QCString endBlockName = isBlockCommand(data+i,i,size-i);
+      if (!endBlockName.isEmpty())
+      {
         i++;
         int l = endBlockName.length();
-        while (i < size - l) {
-          if ((data[i] == '\\' || data[i] == '@') &&     // command
-              data[i - 1] != '\\' && data[i - 1] != '@') // not escaped
+        while (i<size-l)
+        {
+          if ((data[i]=='\\' || data[i]=='@') && // command
+              data[i-1]!='\\' && data[i-1]!='@') // not escaped
           {
-            if (qstrncmp(&data[i + 1], endBlockName, l) == 0) {
+            if (qstrncmp(&data[i+1],endBlockName,l)==0)
+            {
               break;
             }
           }
           i++;
         }
-      } else if (i < size - 1 &&
-                 isIdChar(i + 1)) // @cmd, stop processing, see bug 690385
+      }
+      else if (i<size-1 && isIdChar(i+1)) // @cmd, stop processing, see bug 690385
       {
         return 0;
-      } else {
+      }
+      else
+      {
         i++;
       }
-    } else if (data[i] == '\n') // end * or _ at paragraph boundary
+    }
+    else if (data[i]=='\n') // end * or _ at paragraph boundary
     {
       i++;
-      while (i < size && data[i] == ' ')
-        i++;
-      if (i >= size || data[i] == '\n')
-        return 0; // empty line -> paragraph
-    } else        // should not get here!
+      while (i<size && data[i]==' ') i++;
+      if (i>=size || data[i]=='\n') return 0; // empty line -> paragraph
+    }
+    else // should not get here!
     {
       i++;
     }
+
   }
   return 0;
 }
 
 /** process single emphasis */
-static int processEmphasis1(GrowBuf &out, const char *data, int size, char c) {
+static int processEmphasis1(GrowBuf &out, const char *data, int size, char c)
+{
   int i = 0, len;
 
   /* skipping one symbol if coming from emph3 */
-  if (size > 1 && data[0] == c && data[1] == c) {
-    i = 1;
-  }
+  if (size>1 && data[0]==c && data[1]==c) { i=1; }
 
-  while (i < size) {
-    len = findEmphasisChar(data + i, size - i, c, 1);
-    if (len == 0)
-      return 0;
-    i += len;
-    if (i >= size)
-      return 0;
+  while (i<size)
+  {
+    len = findEmphasisChar(data+i, size-i, c, 1);
+    if (len==0) return 0; 
+    i+=len;
+    if (i>=size) return 0; 
 
-    if (i + 1 < size && data[i + 1] == c) {
+    if (i+1<size && data[i+1]==c)
+    {
       i++;
       continue;
     }
-    if (data[i] == c && data[i - 1] != ' ' && data[i - 1] != '\n') {
+    if (data[i]==c && data[i-1]!=' ' && data[i-1]!='\n')
+    {
       out.addStr("<em>");
-      processInline(out, data, i);
+      processInline(out,data,i);
       out.addStr("</em>");
-      return i + 1;
+      return i+1;
     }
   }
   return 0;
 }
 
 /** process double emphasis */
-static int processEmphasis2(GrowBuf &out, const char *data, int size, char c) {
+static int processEmphasis2(GrowBuf &out, const char *data, int size, char c)
+{
   int i = 0, len;
 
-  while (i < size) {
-    len = findEmphasisChar(data + i, size - i, c, 2);
-    if (len == 0) {
+  while (i<size)
+  {
+    len = findEmphasisChar(data+i, size-i, c, 2);
+    if (len==0)
+    {
       return 0;
     }
     i += len;
-    if (i + 1 < size && data[i] == c && data[i + 1] == c && i &&
-        data[i - 1] != ' ' && data[i - 1] != '\n') {
+    if (i+1<size && data[i]==c && data[i+1]==c && i && data[i-1]!=' ' && 
+        data[i-1]!='\n'
+       )
+    {
       out.addStr("<strong>");
-      processInline(out, data, i);
+      processInline(out,data,i);
       out.addStr("</strong>");
       return i + 2;
     }
@@ -391,42 +407,57 @@ static int processEmphasis2(GrowBuf &out, const char *data, int size, char c) {
 }
 
 /** Parsing tripple emphasis.
- *  Finds the first closing tag, and delegates to the other emph
+ *  Finds the first closing tag, and delegates to the other emph 
  */
-static int processEmphasis3(GrowBuf &out, const char *data, int size, char c) {
+static int processEmphasis3(GrowBuf &out, const char *data, int size, char c)
+{
   int i = 0, len;
 
-  while (i < size) {
-    len = findEmphasisChar(data + i, size - i, c, 3);
-    if (len == 0) {
+  while (i<size)
+  {
+    len = findEmphasisChar(data+i, size-i, c, 3);
+    if (len==0)
+    {
       return 0;
     }
-    i += len;
+    i+=len;
 
     /* skip whitespace preceded symbols */
-    if (data[i] != c || data[i - 1] == ' ' || data[i - 1] == '\n') {
+    if (data[i]!=c || data[i-1]==' ' || data[i-1]=='\n')
+    {
       continue;
     }
 
-    if (i + 2 < size && data[i + 1] == c && data[i + 2] == c) {
+    if (i+2<size && data[i+1]==c && data[i+2]==c)
+    {
       out.addStr("<em><strong>");
-      processInline(out, data, i);
+      processInline(out,data,i);
       out.addStr("</strong></em>");
-      return i + 3;
-    } else if (i + 1 < size && data[i + 1] == c) {
+      return i+3;
+    }
+    else if (i+1<size && data[i+1]==c)
+    {
       // double symbol found, handing over to emph1
-      len = processEmphasis1(out, data - 2, size + 2, c);
-      if (len == 0) {
+      len = processEmphasis1(out, data-2, size+2, c);
+      if (len==0)
+      {
         return 0;
-      } else {
+      }
+      else
+      {
         return len - 2;
       }
-    } else {
+    }
+    else
+    {
       // single symbol found, handing over to emph2
-      len = processEmphasis2(out, data - 1, size + 1, c);
-      if (len == 0) {
+      len = processEmphasis2(out, data-1, size+1, c);
+      if (len==0)
+      {
         return 0;
-      } else {
+      }
+      else
+      {
         return len - 1;
       }
     }
@@ -435,28 +466,29 @@ static int processEmphasis3(GrowBuf &out, const char *data, int size, char c) {
 }
 
 /** Process ndash and mdashes */
-static int processNmdash(GrowBuf &out, const char *data, int off, int size) {
+static int processNmdash(GrowBuf &out,const char *data,int off,int size)
+{
   // precondition: data[0]=='-'
-  int i = 1;
-  int count = 1;
-  if (i < size && data[i] == '-') // found --
+  int i=1;
+  int count=1;
+  if (i<size && data[i]=='-') // found --
   {
-    count++, i++;
+    count++,i++;
   }
-  if (i < size && data[i] == '-') // found ---
+  if (i<size && data[i]=='-') // found ---
   {
-    count++, i++;
+    count++,i++;
   }
-  if (i < size && data[i] == '-') // found ----
+  if (i<size && data[i]=='-') // found ----
   {
     count++;
   }
-  if (count == 2 &&
-      (off < 8 || qstrncmp(data - 8, "operator", 8) != 0)) // -- => ndash
+  if (count==2 && (off<8 || qstrncmp(data-8,"operator",8)!=0)) // -- => ndash
   {
     out.addStr("&ndash;");
     return 2;
-  } else if (count == 3) // --- => ndash
+  }
+  else if (count==3) // --- => ndash
   {
     out.addStr("&mdash;");
     return 3;
@@ -466,17 +498,19 @@ static int processNmdash(GrowBuf &out, const char *data, int off, int size) {
 }
 
 /** Process quoted section "...", can contain one embedded newline */
-static int processQuoted(GrowBuf &out, const char *data, int, int size) {
-  int i = 1;
-  int nl = 0;
-  while (i < size && data[i] != '"' && nl < 2) {
-    if (data[i] == '\n')
-      nl++;
+static int processQuoted(GrowBuf &out,const char *data,int,int size)
+{
+  int i=1;
+  int nl=0;
+  while (i<size && data[i]!='"' && nl<2) 
+  {
+    if (data[i]=='\n') nl++;
     i++;
   }
-  if (i < size && data[i] == '"' && nl < 2) {
-    out.addStr(data, i + 1);
-    return i + 1;
+  if (i<size && data[i]=='"' && nl<2)
+  {
+    out.addStr(data,i+1);
+    return i+1;
   }
   // not a quoted section
   return 0;
@@ -485,80 +519,90 @@ static int processQuoted(GrowBuf &out, const char *data, int, int size) {
 /** Process a HTML tag. Note that <pre>..</pre> are treated specially, in
  *  the sense that all code inside is written unprocessed
  */
-static int processHtmlTag(GrowBuf &out, const char *data, int offset,
-                          int size) {
-  if (offset > 0 && data[-1] == '\\')
-    return 0; // escaped <
+static int processHtmlTag(GrowBuf &out,const char *data,int offset,int size)
+{
+  if (offset>0 && data[-1]=='\\') return 0; // escaped <
 
   // find the end of the html tag
-  int i = 1;
-  int l = 0;
+  int i=1;
+  int l=0;
   // compute length of the tag name
-  while (i < size && isIdChar(i))
-    i++, l++;
+  while (i<size && isIdChar(i)) i++,l++;
   QCString tagName;
-  convertStringFragment(tagName, data + 1, i - 1);
-  if (tagName.lower() == "pre") // found <pre> tag
+  convertStringFragment(tagName,data+1,i-1);
+  if (tagName.lower()=="pre") // found <pre> tag
   {
-    bool insideStr = FALSE;
-    while (i < size - 6) {
-      char c = data[i];
-      if (!insideStr && c == '<') // potential start of html tag
-      {
-        if (data[i + 1] == '/' && tolower(data[i + 2]) == 'p' &&
-            tolower(data[i + 3]) == 'r' && tolower(data[i + 4]) == 'e' &&
-            tolower(data[i + 5]) ==
-                '>') { // found </pre> tag, copy from start to end of tag
-          out.addStr(data, i + 6);
-          // printf("found <pre>..</pre> [%d..%d]\n",0,i+6);
-          return i + 6;
+    bool insideStr=FALSE;
+    while (i<size-6)
+    {
+      char c=data[i];
+      if (!insideStr && c=='<') // potential start of html tag
+      {
+        if (data[i+1]=='/' &&
+            tolower(data[i+2])=='p' && tolower(data[i+3])=='r' &&
+            tolower(data[i+4])=='e' && tolower(data[i+5])=='>')
+        { // found </pre> tag, copy from start to end of tag
+          out.addStr(data,i+6);
+          //printf("found <pre>..</pre> [%d..%d]\n",0,i+6);
+          return i+6;
         }
-      } else if (insideStr && c == '"') {
-        if (data[i - 1] != '\\')
-          insideStr = FALSE;
-      } else if (c == '"') {
-        insideStr = TRUE;
+      }
+      else if (insideStr && c=='"')
+      {
+        if (data[i-1]!='\\') insideStr=FALSE;
+      }
+      else if (c=='"')
+      {
+        insideStr=TRUE;
       }
       i++;
     }
-  } else // some other html tag
+  }
+  else // some other html tag
   {
-    if (l > 0 && i < size) {
-      if (data[i] == '/' && i < size - 1 && data[i + 1] == '>') // <bla/>
+    if (l>0 && i<size)
+    {
+      if (data[i]=='/' && i<size-1 && data[i+1]=='>') // <bla/>
       {
-        // printf("Found htmlTag={%s}\n",QCString(data).left(i+2).data());
-        out.addStr(data, i + 2);
-        return i + 2;
-      } else if (data[i] == '>') // <bla>
+        //printf("Found htmlTag={%s}\n",QCString(data).left(i+2).data());
+        out.addStr(data,i+2);
+        return i+2;
+      }
+      else if (data[i]=='>') // <bla>
       {
-        // printf("Found htmlTag={%s}\n",QCString(data).left(i+1).data());
-        out.addStr(data, i + 1);
-        return i + 1;
-      } else if (data[i] == ' ') // <bla attr=...
+        //printf("Found htmlTag={%s}\n",QCString(data).left(i+1).data());
+        out.addStr(data,i+1);
+        return i+1;
+      }
+      else if (data[i]==' ') // <bla attr=...
       {
         i++;
-        bool insideAttr = FALSE;
-        while (i < size) {
-          if (!insideAttr && data[i] == '"') {
-            insideAttr = TRUE;
-          } else if (data[i] == '"' && data[i - 1] != '\\') {
-            insideAttr = FALSE;
-          } else if (!insideAttr && data[i] == '>') // found end of tag
+        bool insideAttr=FALSE;
+        while (i<size)
+        {
+          if (!insideAttr && data[i]=='"')
           {
-            // printf("Found htmlTag={%s}\n",QCString(data).left(i+1).data());
-            out.addStr(data, i + 1);
-            return i + 1;
+            insideAttr=TRUE;
+          }
+          else if (data[i]=='"' && data[i-1]!='\\')
+          {
+            insideAttr=FALSE;
+          }
+          else if (!insideAttr && data[i]=='>') // found end of tag
+          {
+            //printf("Found htmlTag={%s}\n",QCString(data).left(i+1).data());
+            out.addStr(data,i+1);
+            return i+1;
           }
           i++;
         }
       }
     }
   }
-  // printf("Not a valid html tag\n");
+  //printf("Not a valid html tag\n");
   return 0;
 }
 
-=
 static int processEmphasis(GrowBuf &out,const char *data,int offset,int size)
 {
   if ((offset>0 && !isOpenEmphChar(-1)) || // invalid char before * or _
@@ -570,300 +614,317 @@ static int processEmphasis(GrowBuf &out,const char *data,int offset,int size)
 
   char c = data[0];
   int ret;
-  if (size > 2 && data[1] != c) // _bla or *bla
+  if (size>2 && data[1]!=c) // _bla or *bla
   {
     // whitespace cannot follow an opening emphasis
-    if (data[1] == ' ' || data[1] == '\n' ||
-        (ret = processEmphasis1(out, data + 1, size - 1, c)) == 0) {
+    if (data[1]==' ' || data[1]=='\n' || 
+        (ret = processEmphasis1(out, data+1, size-1, c)) == 0)
+    {
       return 0;
     }
-    return ret + 1;
+    return ret+1;
   }
-  if (size > 3 && data[1] == c && data[2] != c) // __bla or **bla
+  if (size>3 && data[1]==c && data[2]!=c) // __bla or **bla
   {
-    if (data[2] == ' ' || data[2] == '\n' ||
-        (ret = processEmphasis2(out, data + 2, size - 2, c)) == 0) {
+    if (data[2]==' ' || data[2]=='\n' || 
+        (ret = processEmphasis2(out, data+2, size-2, c)) == 0)
+    {
       return 0;
     }
-    return ret + 2;
+    return ret+2;
   }
-  if (size > 4 && data[1] == c && data[2] == c &&
-      data[3] != c) // ___bla or ***bla
+  if (size>4 && data[1]==c && data[2]==c && data[3]!=c) // ___bla or ***bla
   {
-    if (data[3] == ' ' || data[3] == '\n' ||
-        (ret = processEmphasis3(out, data + 3, size - 3, c)) == 0) {
+    if (data[3]==' ' || data[3]=='\n' || 
+        (ret = processEmphasis3(out, data+3, size-3, c)) == 0)
+    {
       return 0;
     }
-    return ret + 3;
+    return ret+3;
   }
   return 0;
 }
 
-static int processLink(GrowBuf &out, const char *data, int, int size) {
+static int processLink(GrowBuf &out,const char *data,int,int size)
+{
   QCString content;
   QCString link;
   QCString title;
-  int contentStart, contentEnd, linkStart, titleStart, titleEnd;
+  int contentStart,contentEnd,linkStart,titleStart,titleEnd;
   bool isImageLink = FALSE;
   bool isToc = FALSE;
-  int i = 1;
-  if (data[0] == '!') {
+  int i=1;
+  if (data[0]=='!')
+  {
     isImageLink = TRUE;
-    if (size < 2 || data[1] != '[') {
+    if (size<2 || data[1]!='[')
+    {
       return 0;
     }
     i++;
   }
-  contentStart = i;
-  int level = 1;
-  int nl = 0;
+  contentStart=i;
+  int level=1;
+  int nl=0;
   // find the matching ]
-  while (i < size) {
-    if (data[i - 1] == '\\') // skip escaped characters
+  while (i<size)
+  {
+    if (data[i-1]=='\\') // skip escaped characters
+    {
+    }
+    else if (data[i]=='[')
     {
-    } else if (data[i] == '[') {
       level++;
-    } else if (data[i] == ']') {
+    }
+    else if (data[i]==']')
+    {
       level--;
-      if (level <= 0)
-        break;
-    } else if (data[i] == '\n') {
+      if (level<=0) break;
+    }
+    else if (data[i]=='\n')
+    {
       nl++;
-      if (nl > 1)
-        return 0; // only allow one newline in the content
+      if (nl>1) return 0; // only allow one newline in the content
     }
     i++;
   }
-  if (i >= size)
-    return 0; // premature end of comment -> no link
-  contentEnd = i;
-  convertStringFragment(content, data + contentStart,
-                        contentEnd - contentStart);
-  // printf("processLink: content={%s}\n",content.data());
-  if (!isImageLink && content.isEmpty())
-    return 0; // no link text
-  i++;        // skip over ]
+  if (i>=size) return 0; // premature end of comment -> no link
+  contentEnd=i;
+  convertStringFragment(content,data+contentStart,contentEnd-contentStart);
+  //printf("processLink: content={%s}\n",content.data());
+  if (!isImageLink && content.isEmpty()) return 0; // no link text
+  i++; // skip over ]
 
   // skip whitespace
-  while (i < size && data[i] == ' ')
-    i++;
-  if (i < size && data[i] == '\n') // one newline allowed here
+  while (i<size && data[i]==' ') i++;
+  if (i<size && data[i]=='\n') // one newline allowed here
   {
     i++;
     // skip more whitespace
-    while (i < size && data[i] == ' ')
-      i++;
+    while (i<size && data[i]==' ') i++;
   }
 
-  bool explicitTitle = FALSE;
-  if (i < size && data[i] == '(') // inline link
+  bool explicitTitle=FALSE;
+  if (i<size && data[i]=='(') // inline link
   {
     i++;
-    while (i < size && data[i] == ' ')
-      i++;
-    if (i < size && data[i] == '<')
-      i++;
-    linkStart = i;
-    nl = 0;
-    int braceCount = 1;
-    while (i < size && data[i] != '\'' && data[i] != '"' && braceCount > 0) {
-      if (data[i] == '\n') // unexpected EOL
+    while (i<size && data[i]==' ') i++;
+    if (i<size && data[i]=='<') i++;
+    linkStart=i;
+    nl=0;
+    int braceCount=1;
+    while (i<size && data[i]!='\'' && data[i]!='"' && braceCount>0)
+    {
+      if (data[i]=='\n') // unexpected EOL
       {
         nl++;
-        if (nl > 1)
-          return 0;
-      } else if (data[i] == '(') {
+        if (nl>1) return 0;
+      }
+      else if (data[i]=='(')
+      {
         braceCount++;
-      } else if (data[i] == ')') {
+      }
+      else if (data[i]==')')
+      {
         braceCount--;
       }
-      if (braceCount > 0) {
+      if (braceCount>0)
+      {
         i++;
       }
     }
-    if (i >= size || data[i] == '\n')
-      return 0;
-    convertStringFragment(link, data + linkStart, i - linkStart);
+    if (i>=size || data[i]=='\n') return 0;
+    convertStringFragment(link,data+linkStart,i-linkStart);
     link = link.stripWhiteSpace();
-    // printf("processLink: link={%s}\n",link.data());
-    if (link.isEmpty())
-      return 0;
-    if (link.at(link.length() - 1) == '>')
-      link = link.left(link.length() - 1);
+    //printf("processLink: link={%s}\n",link.data());
+    if (link.isEmpty()) return 0;
+    if (link.at(link.length()-1)=='>') link=link.left(link.length()-1);
 
     // optional title
-    if (data[i] == '\'' || data[i] == '"') {
+    if (data[i]=='\'' || data[i]=='"')
+    {
       char c = data[i];
       i++;
-      titleStart = i;
-      nl = 0;
-      while (i < size && data[i] != ')') {
-        if (data[i] == '\n') {
-          if (nl > 1)
-            return 0;
+      titleStart=i;
+      nl=0;
+      while (i<size && data[i]!=')')
+      {
+        if (data[i]=='\n')
+        {
+          if (nl>1) return 0;
           nl++;
         }
         i++;
       }
-      if (i >= size) {
+      if (i>=size)
+      {
         return 0;
       }
-      titleEnd = i - 1;
+      titleEnd = i-1;
       // search back for closing marker
-      while (titleEnd > titleStart && data[titleEnd] == ' ')
-        titleEnd--;
-      if (data[titleEnd] == c) // found it
+      while (titleEnd>titleStart && data[titleEnd]==' ') titleEnd--;
+      if (data[titleEnd]==c) // found it
+      {
+        convertStringFragment(title,data+titleStart,titleEnd-titleStart);
+        //printf("processLink: title={%s}\n",title.data());
+      }
+      else
       {
-        convertStringFragment(title, data + titleStart, titleEnd - titleStart);
-        // printf("processLink: title={%s}\n",title.data());
-      } else {
         return 0;
       }
     }
     i++;
-  } else if (i < size && data[i] == '[') // reference link
+  }
+  else if (i<size && data[i]=='[') // reference link
   {
     i++;
-    linkStart = i;
-    nl = 0;
+    linkStart=i;
+    nl=0;
     // find matching ]
-    while (i < size && data[i] != ']') {
-      if (data[i] == '\n') {
+    while (i<size && data[i]!=']')
+    {
+      if (data[i]=='\n')
+      {
         nl++;
-        if (nl > 1)
-          return 0;
+        if (nl>1) return 0;
       }
       i++;
     }
-    if (i >= size)
-      return 0;
+    if (i>=size) return 0;
     // extract link
-    convertStringFragment(link, data + linkStart, i - linkStart);
-    // printf("processLink: link={%s}\n",link.data());
+    convertStringFragment(link,data+linkStart,i-linkStart);
+    //printf("processLink: link={%s}\n",link.data());
     link = link.stripWhiteSpace();
     if (link.isEmpty()) // shortcut link
     {
-      link = content;
+      link=content;
     }
     // lookup reference
     LinkRef *lr = g_linkRefs.find(link.lower());
     if (lr) // found it
     {
-      link = lr->link;
+      link  = lr->link;
       title = lr->title;
-      // printf("processLink: ref: link={%s}
-      // title={%s}\n",link.data(),title.data());
-    } else // reference not found!
+      //printf("processLink: ref: link={%s} title={%s}\n",link.data(),title.data());
+    }
+    else // reference not found! 
     {
-      // printf("processLink: ref {%s} do not exist\n",link.lower().data());
+      //printf("processLink: ref {%s} do not exist\n",link.lower().data());
       return 0;
     }
     i++;
-  } else if (i < size && data[i] != ':' &&
-             !content.isEmpty()) // minimal link ref notation [some id]
+  }
+  else if (i<size && data[i]!=':' && !content.isEmpty()) // minimal link ref notation [some id]
   {
     LinkRef *lr = g_linkRefs.find(content.lower());
-    // printf("processLink: minimal link {%s} lr=%p",content.data(),lr);
+    //printf("processLink: minimal link {%s} lr=%p",content.data(),lr);
     if (lr) // found it
     {
-      link = lr->link;
+      link  = lr->link;
       title = lr->title;
-      explicitTitle = TRUE;
-      i = contentEnd;
-    } else if (content == "TOC") {
-      isToc = TRUE;
-      i = contentEnd;
-    } else {
+      explicitTitle=TRUE;
+      i=contentEnd;
+    }
+    else if (content=="TOC")
+    {
+      isToc=TRUE;
+      i=contentEnd;
+    }
+    else
+    {
       return 0;
     }
     i++;
-  } else {
+  }
+  else
+  {
     return 0;
   }
   if (isToc) // special case for [TOC]
   {
-    if (g_current)
-      g_current->stat = TRUE;
-  } else if (isImageLink) {
+    if (g_current) g_current->stat=TRUE;
+  }
+  else if (isImageLink) 
+  {
     bool ambig;
-    FileDef *fd = 0;
-    if (link.find("@ref ") != -1 || link.find("\\ref ") != -1 ||
-        (fd = findFileDef(Doxygen::imageNameDict, link, ambig)))
-    // assume doxygen symbol link or local image link
+    FileDef *fd=0;
+    if (link.find("@ref ")!=-1 || link.find("\\ref ")!=-1 ||
+        (fd=findFileDef(Doxygen::imageNameDict,link,ambig))) 
+        // assume doxygen symbol link or local image link
     {
       out.addStr("@image html ");
       out.addStr(link.mid(fd ? 0 : 5));
-      if (!explicitTitle && !content.isEmpty()) {
+      if (!explicitTitle && !content.isEmpty())
+      {
         out.addStr(" \"");
         out.addStr(content);
         out.addStr("\"");
-      } else if ((content.isEmpty() || explicitTitle) && !title.isEmpty()) {
+      }
+      else if ((content.isEmpty() || explicitTitle) && !title.isEmpty())
+      {
         out.addStr(" \"");
         out.addStr(title);
         out.addStr("\"");
       }
-    } else {
+    }
+    else
+    {
       out.addStr("<img src=\"");
       out.addStr(link);
       out.addStr("\" alt=\"");
       out.addStr(content);
       out.addStr("\"");
-      if (!title.isEmpty()) {
+      if (!title.isEmpty())
+      {
         out.addStr(" title=\"");
-        out.addStr(substitute(title.simplifyWhiteSpace(), "\"", "&quot;"));
+        out.addStr(substitute(title.simplifyWhiteSpace(),"\"","&quot;"));
         out.addStr("\"");
       }
       out.addStr("/>");
     }
-  } else {
+  }
+  else
+  {
     SrcLangExt lang = getLanguageFromFileName(link);
-    int lp = -1;
-    if ((lp = link.find("@ref ")) != -1 || (lp = link.find("\\ref ")) != -1 ||
-        lang == SrcLangExt_Markdown)
-    // assume doxygen symbol link
+    int lp=-1;
+    if ((lp=link.find("@ref "))!=-1 || (lp=link.find("\\ref "))!=-1 || lang==SrcLangExt_Markdown) 
+        // assume doxygen symbol link
     {
-      if (lp == -1) // link to markdown page
+      if (lp==-1) // link to markdown page
       {
         out.addStr("@ref ");
       }
       out.addStr(link);
       out.addStr(" \"");
-      if (explicitTitle && !title.isEmpty()) {
+      if (explicitTitle && !title.isEmpty())
+      {
         out.addStr(title);
-      } else {
+      }
+      else
+      {
         out.addStr(content);
       }
       out.addStr("\"");
-    } else if (link.find('/') != -1 || link.find('.') != -1 ||
-               link.find('#') != -1) { // file/url link
-      uint len = link.length();
-      if (link[len - 2] == '/' && link[len - 1] >= '0' &&
-          link[len - 1] <= '9') {
-        out.addStr("@ref ");
-        out.addStr(link);
-        out.addStr(" \"");
-        out.addStr(content);
-        out.addStr("\"");
-      } else {
-        out.addStr("<a href=\"");
-        out.addStr(link);
+    }
+    else if (link.find('/')!=-1 || link.find('.')!=-1 || link.find('#')!=-1) 
+    { // file/url link
+      out.addStr("<a href=\"");
+      out.addStr(link);
+      out.addStr("\"");
+      if (!title.isEmpty())
+      {
+        out.addStr(" title=\"");
+        out.addStr(substitute(title.simplifyWhiteSpace(),"\"","&quot;"));
         out.addStr("\"");
-        if (!title.isEmpty()) {
-          out.addStr(" title=\"");
-          out.addStr(substitute(title.simplifyWhiteSpace(), "\"", "&quot;"));
-          out.addStr("\"");
-        }
-        out.addStr(">");
-        out.addStr(content.simplifyWhiteSpace());
-        out.addStr("</a>");
       }
       out.addStr(">");
       content = content.simplifyWhiteSpace();
-      processInline(out, content, content.length());
+      processInline(out,content,content.length());
       out.addStr("</a>");
-    } else // avoid link to e.g. F[x](y)
+    }
+    else // avoid link to e.g. F[x](y)
     {
-      // printf("no link for '%s'\n",link.data());
+      //printf("no link for '%s'\n",link.data());
       return 0;
     }
   }
@@ -871,534 +932,499 @@ static int processLink(GrowBuf &out, const char *data, int, int size) {
 }
 
 /** '`' parsing a code span (assuming codespan != 0) */
-static int processCodeSpan(GrowBuf &out, const char *data, int /*offset*/,
-                           int size) {
+static int processCodeSpan(GrowBuf &out, const char *data, int /*offset*/, int size)
+{
   int end, nb = 0, i, f_begin, f_end;
 
   /* counting the number of backticks in the delimiter */
-  while (nb < size && data[nb] == '`') {
+  while (nb<size && data[nb]=='`')
+  {
     nb++;
   }
 
   /* finding the next delimiter */
   i = 0;
-  int nl = 0;
-  for (end = nb; end < size && i < nb && nl < 2; end++) {
-    if (data[end] == '`') {
-      i++;
-    } else if (data[end] == '\n') {
-      i = 0;
+  int nl=0;
+  for (end=nb; end<size && i<nb && nl<2; end++)
+  {
+    if (data[end]=='`') 
+    {
+      i++; 
+    }
+    else if (data[end]=='\n')
+    {
+      i=0;
       nl++;
-    } else {
-      i = 0;
+    }
+    else
+    {
+      i=0; 
     }
   }
-  if (i < nb && end >= size) {
-    return 0; // no matching delimiter
+  if (i < nb && end >= size)
+  {
+    return 0;  // no matching delimiter
   }
-  if (nl == 2) // too many newlines inside the span
+  if (nl==2) // too many newlines inside the span
   {
     return 0;
   }
 
   // trimming outside whitespaces
   f_begin = nb;
-  while (f_begin < end && data[f_begin] == ' ') {
+  while (f_begin < end && data[f_begin]==' ')
+  {
     f_begin++;
   }
   f_end = end - nb;
-  while (f_end > nb && data[f_end - 1] == ' ') {
+  while (f_end > nb && data[f_end-1]==' ')
+  {
     f_end--;
   }
 
-  if (nb == 1) // check for closing ' followed by space within f_begin..f_end
+  if (nb==1) // check for closing ' followed by space within f_begin..f_end
   {
-    i = f_begin;
-    while (i < f_end - 1) {
-      if (data[i] == '\'' &&
-          !isIdChar(i + 1)) // reject `some word' and not `it's cool`
+    i=f_begin;
+    while (i<f_end-1)
+    {
+      if (data[i]=='\'' && !isIdChar(i+1)) // reject `some word' and not `it's cool`
       {
         return 0;
       }
       i++;
     }
   }
-  // printf("found code span
-  // '%s'\n",QCString(data+f_begin).left(f_end-f_begin).data());
+  //printf("found code span '%s'\n",QCString(data+f_begin).left(f_end-f_begin).data());
 
   /* real code span */
-  if (f_begin < f_end) {
+  if (f_begin < f_end)
+  {
     QCString codeFragment;
-    convertStringFragment(codeFragment, data + f_begin, f_end - f_begin);
+    convertStringFragment(codeFragment,data+f_begin,f_end-f_begin);
     out.addStr("<tt>");
-    // out.addStr(convertToHtml(codeFragment,TRUE));
+    //out.addStr(convertToHtml(codeFragment,TRUE));
     out.addStr(escapeSpecialChars(codeFragment));
     out.addStr("</tt>");
   }
   return end;
 }
 
-static int processSpecialCommand(GrowBuf &out, const char *data, int offset,
-                                 int size) {
-  int i = 1;
-  QCString endBlockName = isBlockCommand(data, offset, size);
-  if (!endBlockName.isEmpty()) {
+
+static int processSpecialCommand(GrowBuf &out, const char *data, int offset, int size)
+{
+  int i=1;
+  QCString endBlockName = isBlockCommand(data,offset,size);
+  if (!endBlockName.isEmpty())
+  {
     int l = endBlockName.length();
-    while (i < size - l) {
-      if ((data[i] == '\\' || data[i] == '@') &&     // command
-          data[i - 1] != '\\' && data[i - 1] != '@') // not escaped
-      {
-        if (qstrncmp(&data[i + 1], endBlockName, l) == 0) {
-          // printf("found end at %d\n",i);
-          out.addStr(data, i + 1 + l);
-          return i + 1 + l;
+    while (i<size-l)
+    {
+      if ((data[i]=='\\' || data[i]=='@') && // command
+          data[i-1]!='\\' && data[i-1]!='@') // not escaped
+      {
+        if (qstrncmp(&data[i+1],endBlockName,l)==0)
+        {
+          //printf("found end at %d\n",i);
+          out.addStr(data,i+1+l);
+          return i+1+l;
         }
       }
       i++;
     }
   }
-  if (size > 1 && data[0] == '\\') {
-    char c = data[1];
-    if (c == '[' || c == ']' || c == '*' || c == '+' || c == '-' || c == '!' ||
-        c == '(' || c == ')' || c == '.' || c == '`' || c == '_') {
-      if (c == '-' && size > 3 && data[2] == '-' && data[3] == '-') // \---
-      {
-        out.addStr(&data[1], 3);
-        return 4;
-      } else if (c == '-' && size > 2 && data[2] == '-') // \--
-      {
-        out.addStr(&data[1], 2);
-        return 3;
-      }
-      out.addStr(&data[1], 1);
+  if (size>1 && data[0]=='\\')
+  {
+    char c=data[1];
+    if (c=='[' || c==']' || c=='*' || c=='!' || c=='(' || c==')' || c=='`' || c=='_')
+    {
+      out.addChar(data[1]);
       return 2;
-    } else if (c == '-' && size > 3 && data[2] == '-' && data[3] == '-') // \---
+    }
+    else if (c=='-' && size>3 && data[2]=='-' && data[3]=='-') // \---
     {
-      out.addStr(&data[1], 3);
+      out.addStr(&data[1],3);
       return 4;
-    } else if (c == '-' && size > 2 && data[2] == '-') // \--
+    }
+    else if (c=='-' && size>2 && data[2]=='-') // \--
     {
-      out.addStr(&data[1], 2);
+      out.addStr(&data[1],2);
       return 3;
     }
   }
   return 0;
 }
 
-static void processInline(GrowBuf &out, const char *data, int size) {
-  int i = 0, end = 0;
+static void processInline(GrowBuf &out,const char *data,int size)
+{
+  int i=0, end=0;
   action_t action = 0;
-  while (i < size) {
-    while (end < size && ((action = g_actions[(uchar)data[end]]) == 0))
-      end++;
-    out.addStr(data + i, end - i);
-    if (end >= size)
-      break;
-    i = end;
-    end = action(out, data + i, i, size - i);
-    if (!end) {
-      end = i + 1;
-    } else {
-      i += end;
-      end = i;
+  while (i<size)
+  {
+    while (end<size && ((action=g_actions[(uchar)data[end]])==0)) end++;
+    out.addStr(data+i,end-i);
+    if (end>=size) break;
+    i=end;
+    end = action(out,data+i,i,size-i);
+    if (!end)
+    {
+      end=i+1;
+    }
+    else
+    {
+      i+=end;
+      end=i;
     }
   }
 }
 
 /** returns whether the line is a setext-style hdr underline */
-static int isHeaderline(const char *data, int size) {
-  int i = 0, c = 0;
-  while (i < size && data[i] == ' ')
-    i++;
+static int isHeaderline(const char *data, int size)
+{
+  int i=0, c=0;
+  while (i<size && data[i]==' ') i++;
 
   // test of level 1 header
-  if (data[i] == '=') {
-    while (i < size && data[i] == '=')
-      i++, c++;
-    while (i < size && data[i] == ' ')
-      i++;
-    return (c > 1 && (i >= size || data[i] == '\n')) ? 1 : 0;
+  if (data[i]=='=')
+  {
+    while (i<size && data[i]=='=') i++,c++;
+    while (i<size && data[i]==' ') i++;
+    return (c>1 && (i>=size || data[i]=='\n')) ? 1 : 0;
   }
   // test of level 2 header
-  if (data[i] == '-') {
-    while (i < size && data[i] == '-')
-      i++, c++;
-    while (i < size && data[i] == ' ')
-      i++;
-    return (c > 1 && (i >= size || data[i] == '\n')) ? 2 : 0;
+  if (data[i]=='-')
+  {
+    while (i<size && data[i]=='-') i++,c++;
+    while (i<size && data[i]==' ') i++;
+    return (c>1 && (i>=size || data[i]=='\n')) ? 2 : 0;
   }
   return 0;
 }
 
 /** returns TRUE if this line starts a block quote */
-static bool isBlockQuote(const char *data, int size, int indent) {
+static bool isBlockQuote(const char *data,int size,int indent)
+{
   int i = 0;
-  while (i < size && data[i] == ' ')
-    i++;
-  if (i < indent + codeBlockIndent) // could be a quotation
+  while (i<size && data[i]==' ') i++;
+  if (i<indent+codeBlockIndent) // could be a quotation
   {
     // count >'s and skip spaces
-    int level = 0;
-    while (i < size && (data[i] == '>' || data[i] == ' ')) {
-      if (data[i] == '>')
-        level++;
+    int level=0;
+    while (i<size && (data[i]=='>' || data[i]==' ')) 
+    {
+      if (data[i]=='>') level++;
       i++;
     }
-    // last characters should be a space or newline,
+    // last characters should be a space or newline, 
     // so a line starting with >= does not match
-    return level > 0 && i < size && ((data[i - 1] == ' ') || data[i] == '\n');
-  } else // too much indentation -> code block
+    return level>0 && i<size && ((data[i-1]==' ') || data[i]=='\n'); 
+  }
+  else // too much indentation -> code block
   {
     return FALSE;
   }
-  // return i<size && data[i]=='>' && i<indent+codeBlockIndent;
-}
-
-static bool isIndicator(QCString data) {
-  if (data.isEmpty())
-    return false;
-  int size = data.size(), n;
-  if (n == data.findRev('/') > 0 && data[n] >= '0' && data[n] <= '9' &&
-      size == n + 1)
-    return true;
-  return false;
+  //return i<size && data[i]=='>' && i<indent+codeBlockIndent;
 }
 
 /** returns end of the link ref if this is indeed a link reference. */
-static int isLinkRef(const char *data, int size, QCString &refid,
-                     QCString &link, QCString &title) {
-  int i = 0;
-  // printf("isLinkRef data={%s}\n",data);
+static int isLinkRef(const char *data,int size,
+            QCString &refid,QCString &link,QCString &title)
+{
+  //printf("isLinkRef data={%s}\n",data);
   // format: start with [some text]:
-  while (i < size && data[i] == ' ')
-    i++;
-  if (i >= size || data[i] != '[') {
-    int refIdStart = i, j;
-
-    convertStringFragment(refid, data + refIdStart, i - refIdStart);
-
-    if (isIndicator(refid)) {
-      extern QDict<char> g_foreignCache;
-
-      // printf("?* %s\n", refid.data() );
-      QCString o;
-      uint arity;
-      normalizeIndicator(refid, o);
-      const char *result = o.data();
-      if (result) {
-        const char *out = g_foreignCache[result];
-        if (out) {
-          refid = result;
-          link = out;
-          link += "()";
-        } else {
-          refid = result;
-          // printf("<* %s\n", refid.data() );
-          link = refid;
-        }
-        title.resize(0);
-        return i;
-      }
-      return 0;
-    }
-  }
-  int refIdStart = i;
-  while (i < size && data[i] != '\n' && data[i] != ']')
-    i++;
-  if (i >= size || data[i] != ']')
-    return 0;
-  convertStringFragment(refid, data + refIdStart, i - refIdStart);
-  if (refid.isEmpty())
-    return 0;
-  // printf("  isLinkRef: found refid='%s'\n",refid.data());
+  int i = 0;
+  while (i<size && data[i]==' ') i++;
+  if (i>=size || data[i]!='[') return 0;
   i++;
-  if (i >= size || data[i] != ':')
-    return 0;
+  int refIdStart=i;
+  while (i<size && data[i]!='\n' && data[i]!=']') i++;
+  if (i>=size || data[i]!=']') return 0;
+  convertStringFragment(refid,data+refIdStart,i-refIdStart);
+  if (refid.isEmpty()) return 0;
+  //printf("  isLinkRef: found refid='%s'\n",refid.data());
+  i++;
+  if (i>=size || data[i]!=':') return 0;
   i++;
 
-  if (i < size && data[i] == '\n') {
-    i++;
-    while (i < size && data[i] == ' ')
-      i++;
-  }
-  if (i >= size)
-    return 0;
-
-  if (i < size && data[i] == '<')
-    i++;
-  int linkStart = i;
-  while (i < size && data[i] != ' ' && data[i] != '\n')
-    i++;
-  int linkEnd = i;
-  if (i < size && data[i] == '>')
+  // format: whitespace* \n? whitespace* (<url> | url)
+  while (i<size && data[i]==' ') i++;
+  if (i<size && data[i]=='\n')
+  {
     i++;
-  if (linkStart == linkEnd)
-    return 0; // empty link
-  convertStringFragment(link, data + linkStart, linkEnd - linkStart);
-  // printf("  isLinkRef: found link='%s'\n",link.data());
-  if (link == "@ref" || link == "\\ref") {
-    int argStart = i;
-    while (i < size && data[i] != '\n' && data[i] != '"')
-      i++;
+    while (i<size && data[i]==' ') i++;
+  }
+  if (i>=size) return 0;
+
+  if (i<size && data[i]=='<') i++;
+  int linkStart=i;
+  while (i<size && data[i]!=' ' && data[i]!='\n') i++;
+  int linkEnd=i;
+  if (i<size && data[i]=='>') i++;
+  if (linkStart==linkEnd) return 0; // empty link
+  convertStringFragment(link,data+linkStart,linkEnd-linkStart);
+  //printf("  isLinkRef: found link='%s'\n",link.data());
+  if (link=="@ref" || link=="\\ref")
+  {
+    int argStart=i;
+    while (i<size && data[i]!='\n' && data[i]!='"') i++;
     QCString refArg;
-    convertStringFragment(refArg, data + argStart, i - argStart);
-    link += refArg;
+    convertStringFragment(refArg,data+argStart,i-argStart);
+    link+=refArg;
   }
 
   title.resize(0);
 
   // format: (whitespace* \n? whitespace* ( 'title' | "title" | (title) ))?
-  int eol = 0;
-  while (i < size && data[i] == ' ')
-    i++;
-  if (i < size && data[i] == '\n') {
-    eol = i;
+  int eol=0;
+  while (i<size && data[i]==' ') i++;
+  if (i<size && data[i]=='\n')
+  {
+    eol=i;
     i++;
-    while (i < size && data[i] == ' ')
-      i++;
+    while (i<size && data[i]==' ') i++;
   }
-  if (i >= size) {
-    // printf("end of isLinkRef while looking for title! i=%d\n",i);
+  if (i>=size) 
+  {
+    //printf("end of isLinkRef while looking for title! i=%d\n",i);
     return i; // end of buffer while looking for the optional title
   }
 
   char c = data[i];
-  if (c == '\'' || c == '"' || c == '(') // optional title present?
+  if (c=='\'' || c=='"' || c=='(') // optional title present?
   {
-    // printf("  start of title found! char='%c'\n",c);
+    //printf("  start of title found! char='%c'\n",c);
     i++;
-    if (c == '(')
-      c = ')'; // replace c by end character
-    int titleStart = i;
+    if (c=='(') c=')'; // replace c by end character
+    int titleStart=i;
     // search for end of the line
-    while (i < size && data[i] != '\n')
-      i++;
+    while (i<size && data[i]!='\n') i++;
     eol = i;
 
     // search back to matching character
-    int end = i - 1;
-    while (end > titleStart && data[end] != c)
-      end--;
-    if (end > titleStart) {
-      convertStringFragment(title, data + titleStart, end - titleStart);
+    int end=i-1;
+    while (end>titleStart && data[end]!=c) end--;
+    if (end>titleStart)
+    {
+      convertStringFragment(title,data+titleStart,end-titleStart);
     }
-    // printf("  title found: '%s'\n",title.data());
+    //printf("  title found: '%s'\n",title.data());
   }
-  while (i < size && data[i] == ' ')
-    i++;
-  // printf("end of isLinkRef: i=%d size=%d data[i]='%c' eol=%d\n",
+  while (i<size && data[i]==' ') i++;
+  //printf("end of isLinkRef: i=%d size=%d data[i]='%c' eol=%d\n",
   //    i,size,data[i],eol);
-  if (i >= size)
-    return i; // end of buffer while ref id was found
-  else if (eol)
-    return eol; // end of line while ref id was found
-  return 0;     // invalid link ref
-}
-
-static int isHRuler(const char *data, int size) {
-  int i = 0;
-  if (size > 0 && data[size - 1] == '\n')
-    size--; // ignore newline character
-  while (i < size && data[i] == ' ')
-    i++;
-  if (i >= size)
-    return 0; // empty line
-  char c = data[i];
-  if (c != '*' && c != '-' && c != '_') {
+  if      (i>=size)       return i;    // end of buffer while ref id was found
+  else if (eol)           return eol;  // end of line while ref id was found
+  return 0;                            // invalid link ref
+}
+
+static int isHRuler(const char *data,int size)
+{
+  int i=0;
+  if (size>0 && data[size-1]=='\n') size--; // ignore newline character
+  while (i<size && data[i]==' ') i++;
+  if (i>=size) return 0; // empty line
+  char c=data[i];
+  if (c!='*' && c!='-' && c!='_') 
+  {
     return 0; // not a hrule character
   }
-  int n = 0;
-  while (i < size) {
-    if (data[i] == c) {
+  int n=0;
+  while (i<size)
+  {
+    if (data[i]==c)
+    {
       n++; // count rule character
-    } else if (data[i] != ' ') {
+    }
+    else if (data[i]!=' ')
+    {
       return 0; // line contains non hruler characters
     }
     i++;
   }
-  return n >= 3; // at least 3 characters needed for a hruler
+  return n>=3; // at least 3 characters needed for a hruler
 }
 
-static QCString extractTitleId(QCString &title, int level) {
-  // static QRegExp r1("^[a-z_A-Z][a-z_A-Z0-9\\-]*:");
+static QCString extractTitleId(QCString &title, int level)
+{
+  //static QRegExp r1("^[a-z_A-Z][a-z_A-Z0-9\\-]*:");
   static QRegExp r2("\\{#[a-z_A-Z][a-z_A-Z0-9\\-]*\\}");
-  int l = 0;
-  int i = r2.match(title, 0, &l);
-  if (i != -1 &&
-      title.mid(i + l).stripWhiteSpace().isEmpty()) // found {#id} style id
+  int l=0;
+  int i = r2.match(title,0,&l);
+  if (i!=-1 && title.mid(i+l).stripWhiteSpace().isEmpty()) // found {#id} style id
   {
-    QCString id = title.mid(i + 2, l - 3);
+    QCString id = title.mid(i+2,l-3);
     title = title.left(i);
-    // printf("found id='%s' title='%s'\n",id.data(),title.data());
+    //printf("found id='%s' title='%s'\n",id.data(),title.data());
     return id;
   }
-  if ((level > 0) && (level <= Config_getInt(TOC_INCLUDE_HEADINGS))) {
+  if ((level > 0) && (level <= Config_getInt(TOC_INCLUDE_HEADINGS)))
+  {
     static int autoId = 0;
     QCString id;
-    id.sprintf("autotoc_md%d", autoId++);
-    // printf("auto-generated id='%s' title='%s'\n",id.data(),title.data());
+    id.sprintf("autotoc_md%d",autoId++);
+    //printf("auto-generated id='%s' title='%s'\n",id.data(),title.data());
     return id;
   }
-  // printf("no id found in title '%s'\n",title.data());
+  //printf("no id found in title '%s'\n",title.data());
   return "";
 }
 
-static int isAtxHeader(const char *data, int size, QCString &header,
-                       QCString &id) {
+
+static int isAtxHeader(const char *data,int size,
+                       QCString &header,QCString &id)
+{
   int i = 0, end;
-  int level = 0, blanks = 0;
+  int level = 0, blanks=0;
 
   // find start of header text and determine heading level
-  while (i < size && data[i] == ' ')
-    i++;
-  if (i >= size || data[i] != '#') {
+  while (i<size && data[i]==' ') i++;
+  if (i>=size || data[i]!='#') 
+  {
     return 0;
   }
-  while (i < size && level < 6 && data[i] == '#')
-    i++, level++;
-  while (i < size && data[i] == ' ')
-    i++, blanks++;
-  if (level == 1 && blanks == 0) {
-    return 0; // special case to prevent #someid seen as a header (see bug
-              // 671395)
+  while (i<size && level<6 && data[i]=='#') i++,level++;
+  while (i<size && data[i]==' ') i++,blanks++;
+  if (level==1 && blanks==0) 
+  {
+    return 0; // special case to prevent #someid seen as a header (see bug 671395)
   }
 
   // find end of header text
-  end = i;
-  while (end < size && data[end] != '\n')
-    end++;
-  while (end > i && (data[end - 1] == '#' || data[end - 1] == ' '))
-    end--;
+  end=i;
+  while (end<size && data[end]!='\n') end++;
+  while (end>i && (data[end-1]=='#' || data[end-1]==' ')) end--;
 
   // store result
-  convertStringFragment(header, data + i, end - i);
+  convertStringFragment(header,data+i,end-i);
   id = extractTitleId(header, level);
   if (!id.isEmpty()) // strip #'s between title and id
   {
-    i = header.length() - 1;
-    while (i >= 0 && (header.at(i) == '#' || header.at(i) == ' '))
-      i--;
-    header = header.left(i + 1);
+    i=header.length()-1;
+    while (i>=0 && (header.at(i)=='#' || header.at(i)==' ')) i--;
+    header=header.left(i+1);
   }
 
   return level;
 }
 
-static int isEmptyLine(const char *data, int size) {
-  int i = 0;
-  while (i < size) {
-    if (data[i] == '\n')
-      return TRUE;
-    if (data[i] != ' ')
-      return FALSE;
+static int isEmptyLine(const char *data,int size)
+{
+  int i=0;
+  while (i<size)
+  {
+    if (data[i]=='\n') return TRUE;
+    if (data[i]!=' ') return FALSE;
     i++;
   }
   return TRUE;
 }
 
-#define isLiTag(i)                                                             \
-  (data[(i)] == '<' && (data[(i) + 1] == 'l' || data[(i) + 1] == 'L') &&       \
-   (data[(i) + 2] == 'i' || data[(i) + 2] == 'I') && (data[(i) + 3] == '>'))
+#define isLiTag(i) \
+   (data[(i)]=='<' && \
+   (data[(i)+1]=='l' || data[(i)+1]=='L') && \
+   (data[(i)+2]=='i' || data[(i)+2]=='I') && \
+   (data[(i)+3]=='>'))
 
 // compute the indent from the start of the input, excluding list markers
 // such as -, -#, *, +, 1., and <li>
-static int computeIndentExcludingListMarkers(const char *data, int size) {
-  int i = 0;
-  int indent = 0;
-  bool isDigit = FALSE;
-  bool isLi = FALSE;
-  bool listMarkerSkipped = FALSE;
-  while (i < size &&
-         (data[i] == ' ' ||      // space
-          (!listMarkerSkipped && // first list marker
-           (data[i] == '+' || data[i] == '-' ||
-            data[i] == '*' || // unordered list char
-            (data[i] == '#' && i > 0 && data[i - 1] == '-') || // -# item
-            (isDigit =
-                 (data[i] >= '1' && data[i] <= '9')) || // ordered list marker?
-            (isLi = (i < size - 3 && isLiTag(i)))       // <li> tag
-            )))) {
+static int computeIndentExcludingListMarkers(const char *data,int size)
+{
+  int i=0;
+  int indent=0;
+  bool isDigit=FALSE;
+  bool isLi=FALSE;
+  bool listMarkerSkipped=FALSE;
+  while (i<size && 
+         (data[i]==' ' ||                                    // space
+          (!listMarkerSkipped &&                             // first list marker
+           (data[i]=='+' || data[i]=='-' || data[i]=='*' ||  // unordered list char
+            (data[i]=='#' && i>0 && data[i-1]=='-') ||       // -# item
+            (isDigit=(data[i]>='1' && data[i]<='9')) ||      // ordered list marker?
+            (isLi=(i<size-3 && isLiTag(i)))                  // <li> tag
+           )
+          )
+         )
+        ) 
+  {
     if (isDigit) // skip over ordered list marker '10. '
     {
-      int j = i + 1;
-      while (j < size &&
-             ((data[j] >= '0' && data[j] <= '9') || data[j] == '.')) {
-        if (data[j] == '.') // should be end of the list marker
+      int j=i+1;
+      while (j<size && ((data[j]>='0' && data[j]<='9') || data[j]=='.'))
+      {
+        if (data[j]=='.') // should be end of the list marker
         {
-          if (j < size - 1 && data[j + 1] == ' ') // valid list marker
+          if (j<size-1 && data[j+1]==' ') // valid list marker
           {
-            listMarkerSkipped = TRUE;
-            indent += j + 1 - i;
-            i = j + 1;
+            listMarkerSkipped=TRUE;
+            indent+=j+1-i;
+            i=j+1;
             break;
-          } else // not a list marker
+          }
+          else // not a list marker
           {
             break;
           }
         }
         j++;
       }
-    } else if (isLi) {
-      i += 3; // skip over <li>
-      indent += 3;
-      listMarkerSkipped = TRUE;
-    } else if (data[i] == '-' && i < size - 2 && data[i + 1] == '#' &&
-               data[i + 2] == ' ') { // case "-# "
-      listMarkerSkipped = TRUE;      // only a single list marker is accepted
-      i++;                           // skip over #
+    }
+    else if (isLi)
+    {
+      i+=3; // skip over <li>
+      indent+=3;
+      listMarkerSkipped=TRUE;
+    }
+    else if (data[i]=='-' && i<size-2 && data[i+1]=='#' && data[i+2]==' ')
+    { // case "-# "
+      listMarkerSkipped=TRUE; // only a single list marker is accepted
+      i++; // skip over #
       indent++;
-    } else if (data[i] != ' ' && i < size - 1 &&
-               data[i + 1] == ' ') { // case "- " or "+ " or "* "
-      listMarkerSkipped = TRUE;      // only a single list marker is accepted
     }
-    if (data[i] != ' ' && !listMarkerSkipped) { // end of indent
+    else if (data[i]!=' ' && i<size-1 && data[i+1]==' ')
+    { // case "- " or "+ " or "* "
+      listMarkerSkipped=TRUE; // only a single list marker is accepted
+    }
+    if (data[i]!=' ' && !listMarkerSkipped)
+    { // end of indent
       break;
     }
-    indent++, i++;
+    indent++,i++;
   }
-  // printf("{%s}->%d\n",QCString(data).left(size).data(),indent);
+  //printf("{%s}->%d\n",QCString(data).left(size).data(),indent);
   return indent;
 }
 
-static bool isFencedCodeBlock(const char *data, int size, int refIndent,
-                              QCString &lang, int &start, int &end,
-                              int &offset) {
+static bool isFencedCodeBlock(const char *data,int size,int refIndent,
+                             QCString &lang,int &start,int &end,int &offset)
+{
   // rules: at least 3 ~~~, end of the block same amount of ~~~'s, otherwise
   // return FALSE
-  int i = 0;
-  int indent = 0;
-  int startTildes = 0;
-  while (i < size && data[i] == ' ')
-    indent++, i++;
-  if (indent >= refIndent + 4)
-    return FALSE; // part of code block
-  char tildaChar = '~';
-  if (i < size && data[i] == '`')
-    tildaChar = '`';
-  while (i < size && data[i] == tildaChar)
-    startTildes++, i++;
-  if (startTildes < 3)
-    return FALSE; // not enough tildes
-  if (i < size && data[i] == '{')
-    i++; // skip over optional {
-  int startLang = i;
-  while (i < size && (data[i] != '\n' && data[i] != '}' && data[i] != ' '))
-    i++;
-  convertStringFragment(lang, data + startLang, i - startLang);
-  while (i < size && data[i] != '\n')
-    i++; // proceed to the end of the line
-  start = i;
-  while (i < size) {
-    if (data[i] == tildaChar) {
-      end = i - 1;
-      int endTildes = 0;
-      while (i < size && data[i] == tildaChar)
-        endTildes++, i++;
-      while (i < size && data[i] == ' ')
-        i++;
-      if (i == size || data[i] == '\n') {
-        offset = i;
-        return endTildes == startTildes;
+  int i=0;
+  int indent=0;
+  int startTildes=0;
+  while (i<size && data[i]==' ') indent++,i++;
+  if (indent>=refIndent+4) return FALSE; // part of code block
+  char tildaChar='~';
+  if (i<size && data[i]=='`') tildaChar='`';
+  while (i<size && data[i]==tildaChar) startTildes++,i++;
+  if (startTildes<3) return FALSE; // not enough tildes
+  if (i<size && data[i]=='{') i++; // skip over optional {
+  int startLang=i;
+  while (i<size && (data[i]!='\n' && data[i]!='}' && data[i]!=' ')) i++;
+  convertStringFragment(lang,data+startLang,i-startLang);
+  while (i<size && data[i]!='\n') i++; // proceed to the end of the line
+  start=i;
+  while (i<size)
+  {
+    if (data[i]==tildaChar)
+    {
+      end=i-1;
+      int endTildes=0;
+      while (i<size && data[i]==tildaChar) endTildes++,i++;
+      while (i<size && data[i]==' ') i++;
+      if (i==size || data[i]=='\n') 
+      {
+        offset=i;
+        return endTildes==startTildes;
       }
     }
     i++;
@@ -1406,69 +1432,70 @@ static bool isFencedCodeBlock(const char *data, int size, int refIndent,
   return FALSE;
 }
 
-static bool isCodeBlock(const char *data, int offset, int size, int &indent) {
-  // printf("<isCodeBlock(offset=%d,size=%d,indent=%d)\n",offset,size,indent);
+static bool isCodeBlock(const char *data,int offset,int size,int &indent)
+{
+  //printf("<isCodeBlock(offset=%d,size=%d,indent=%d)\n",offset,size,indent);
   // determine the indent of this line
-  int i = 0;
-  int indent0 = 0;
-  while (i < size && data[i] == ' ')
-    indent0++, i++;
+  int i=0;
+  int indent0=0;
+  while (i<size && data[i]==' ') indent0++,i++;
 
-  if (indent0 < codeBlockIndent) {
-    // printf(">isCodeBlock: line is not indented enough %d<4\n",indent0);
+  if (indent0<codeBlockIndent)
+  {
+    //printf(">isCodeBlock: line is not indented enough %d<4\n",indent0);
     return FALSE;
   }
-  if (indent0 >= size ||
-      data[indent0] == '\n') // empty line does not start a code block
+  if (indent0>=size || data[indent0]=='\n') // empty line does not start a code block
   {
-    // printf("only spaces at the end of a comment block\n");
+    //printf("only spaces at the end of a comment block\n");
     return FALSE;
   }
-
-  i = offset;
-  int nl = 0;
+    
+  i=offset;
+  int nl=0;
   int nl_pos[3];
   // search back 3 lines and remember the start of lines -1 and -2
-  while (i > 0 && nl < 3) {
-    if (data[i - offset - 1] == '\n')
-      nl_pos[nl++] = i - offset;
+  while (i>0 && nl<3)
+  {
+    if (data[i-offset-1]=='\n') nl_pos[nl++]=i-offset;
     i--;
   }
 
   // if there are only 2 preceding lines, then line -2 starts at -offset
-  if (i == 0 && nl == 2)
-    nl_pos[nl++] = -offset;
-  // printf("  nl=%d\n",nl);
+  if (i==0 && nl==2) nl_pos[nl++]=-offset;
+  //printf("  nl=%d\n",nl);
 
-  if (nl == 3) // we have at least 2 preceding lines
+  if (nl==3) // we have at least 2 preceding lines
   {
-    // printf("  positions: nl_pos=[%d,%d,%d] line[-2]='%s' line[-1]='%s'\n",
+    //printf("  positions: nl_pos=[%d,%d,%d] line[-2]='%s' line[-1]='%s'\n",
     //    nl_pos[0],nl_pos[1],nl_pos[2],
     //    QCString(data+nl_pos[1]).left(nl_pos[0]-nl_pos[1]-1).data(),
     //    QCString(data+nl_pos[2]).left(nl_pos[1]-nl_pos[2]-1).data());
 
     // check that line -1 is empty
-    if (!isEmptyLine(data + nl_pos[1], nl_pos[0] - nl_pos[1] - 1)) {
+    if (!isEmptyLine(data+nl_pos[1],nl_pos[0]-nl_pos[1]-1))
+    {
       return FALSE;
     }
 
     // determine the indent of line -2
-    indent = computeIndentExcludingListMarkers(data + nl_pos[2],
-                                               nl_pos[1] - nl_pos[2]);
-
-    // printf(">isCodeBlock local_indent %d>=%d+4=%d\n",
+    indent=computeIndentExcludingListMarkers(data+nl_pos[2],nl_pos[1]-nl_pos[2]);
+    
+    //printf(">isCodeBlock local_indent %d>=%d+4=%d\n",
     //    indent0,indent2,indent0>=indent2+4);
     // if the difference is >4 spaces -> code block
-    return indent0 >= indent + codeBlockIndent;
-  } else // not enough lines to determine the relative indent, use global indent
+    return indent0>=indent+codeBlockIndent;
+  }
+  else // not enough lines to determine the relative indent, use global indent
   {
     // check that line -1 is empty
-    if (nl == 1 && !isEmptyLine(data - offset, offset - 1)) {
+    if (nl==1 && !isEmptyLine(data-offset,offset-1))
+    {
       return FALSE;
     }
-    // printf(">isCodeBlock global indent %d>=%d+4=%d nl=%d\n",
+    //printf(">isCodeBlock global indent %d>=%d+4=%d nl=%d\n",
     //    indent0,indent,indent0>=indent+4,nl);
-    return indent0 >= indent + codeBlockIndent;
+    return indent0>=indent+codeBlockIndent;
   }
 }
 
@@ -1481,93 +1508,92 @@ static bool isCodeBlock(const char *data, int offset, int size, int &indent) {
  *  @param[out] columns number of table columns found
  *  @returns The offset until the next line in the buffer.
  */
-int findTableColumns(const char *data, int size, int &start, int &end,
-                     int &columns) {
-  int i = 0, n = 0;
+int findTableColumns(const char *data,int size,int &start,int &end,int &columns)
+{
+  int i=0,n=0;
   int eol;
   // find start character of the table line
-  while (i < size && data[i] == ' ')
-    i++;
-  if (i < size && data[i] == '|' && data[i] != '\n')
-    i++, n++; // leading | does not count
+  while (i<size && data[i]==' ') i++;
+  if (i<size && data[i]=='|' && data[i]!='\n') i++,n++; // leading | does not count
   start = i;
 
   // find end character of the table line
-  while (i < size && data[i] != '\n')
-    i++;
-  eol = i + 1;
+  while (i<size && data[i]!='\n') i++;
+  eol=i+1;
   i--;
-  while (i > 0 && data[i] == ' ')
-    i--;
-  if (i > 0 && data[i - 1] != '\\' && data[i] == '|')
-    i--, n++; // trailing or escaped | does not count
+  while (i>0 && data[i]==' ') i--;
+  if (i>0 && data[i-1]!='\\' && data[i]=='|') i--,n++; // trailing or escaped | does not count
   end = i;
 
   // count columns between start and end
-  columns = 0;
-  if (end > start) {
-    i = start;
-    while (i <= end) // look for more column markers
-    {
-      if (data[i] == '|' && (i == 0 || data[i - 1] != '\\'))
-        columns++;
-      if (columns == 1)
-        columns++; // first | make a non-table into a two column table
+  columns=0;
+  if (end>start)
+  {
+    i=start;
+    while (i<=end) // look for more column markers
+    {
+      if (data[i]=='|' && (i==0 || data[i-1]!='\\')) columns++;
+      if (columns==1) columns++; // first | make a non-table into a two column table
       i++;
     }
   }
-  if (n == 2 && columns == 0) // table row has | ... |
+  if (n==2 && columns==0) // table row has | ... |
   {
     columns++;
   }
-  // printf("findTableColumns(start=%d,end=%d,columns=%d) eol=%d\n",
+  //printf("findTableColumns(start=%d,end=%d,columns=%d) eol=%d\n",
   //    start,end,columns,eol);
   return eol;
 }
 
 /** Returns TRUE iff data points to the start of a table block */
-static bool isTableBlock(const char *data, int size) {
-  int cc0, start, end;
+static bool isTableBlock(const char *data,int size)
+{
+  int cc0,start,end;
 
   // the first line should have at least two columns separated by '|'
-  int i = findTableColumns(data, size, start, end, cc0);
-  if (i >= size || cc0 < 1) {
-    // printf("isTableBlock: no |'s in the header\n");
+  int i = findTableColumns(data,size,start,end,cc0);
+  if (i>=size || cc0<1) 
+  {
+    //printf("isTableBlock: no |'s in the header\n");
     return FALSE;
   }
 
   int cc1;
-  int ret = findTableColumns(data + i, size - i, start, end, cc1);
-  int j = i + start;
+  int ret = findTableColumns(data+i,size-i,start,end,cc1);
+  int j=i+start;
   // separator line should consist of |, - and : and spaces only
-  while (j <= end + i) {
-    if (data[j] != ':' && data[j] != '-' && data[j] != '|' && data[j] != ' ') {
-      // printf("isTableBlock: invalid character '%c'\n",data[j]);
+  while (j<=end+i)
+  {
+    if (data[j]!=':' && data[j]!='-' && data[j]!='|' && data[j]!=' ')
+    {
+      //printf("isTableBlock: invalid character '%c'\n",data[j]);
       return FALSE; // invalid characters in table separator
     }
     j++;
   }
-  if (cc1 != cc0) // number of columns should be same as previous line
+  if (cc1!=cc0) // number of columns should be same as previous line
   {
     return FALSE;
   }
 
-  i += ret; // goto next line
+  i+=ret; // goto next line
   int cc2;
-  findTableColumns(data + i, size - i, start, end, cc2);
+  findTableColumns(data+i,size-i,start,end,cc2);
 
-  // printf("isTableBlock: %d\n",cc1==cc2);
-  return cc1 == cc2;
+  //printf("isTableBlock: %d\n",cc1==cc2);
+  return cc1==cc2;
 }
 
-static int writeTableBlock(GrowBuf &out, const char *data, int size) {
-  int i = 0, j, k;
-  int columns, start, end, cc;
+static int writeTableBlock(GrowBuf &out,const char *data,int size)
+{
+  int i=0,j,k;
+  int columns,start,end,cc;
 
-  i = findTableColumns(data, size, start, end, columns);
- 
+  i = findTableColumns(data,size,start,end,columns);
+  
 #ifdef USE_ORIGINAL_TABLES
- out.addStr("<table>");
+  out.addStr("<table>");
 
   // write table header, in range [start..end]
   out.addStr("<tr>");
@@ -1577,73 +1603,61 @@ static int writeTableBlock(GrowBuf &out, const char *data, int size) {
 #endif
     
   // read cell alignments
-  int ret = findTableColumns(data + i, size - i, start, end, cc);
-  k = 0;
+  int ret = findTableColumns(data+i,size-i,start,end,cc);
+  k=0;
   Alignment *columnAlignment = new Alignment[columns];
 
-  bool leftMarker = FALSE, rightMarker = FALSE;
-  bool startFound = FALSE;
-  j = start + i;
-  while (j <= end + i) {
-    if (!startFound) {
-      if (data[j] == ':') {
-        leftMarker = TRUE;
-        startFound = TRUE;
-      }
-      if (data[j] == '-')
-        startFound = TRUE;
-      // printf("  data[%d]=%c startFound=%d\n",j,data[j],startFound);
-    }
-    if (data[j] == '-')
-      rightMarker = FALSE;
-    else if (data[j] == ':')
-      rightMarker = TRUE;
-    if (j <= end + i && (data[j] == '|' && (j == 0 || data[j - 1] != '\\'))) {
-      if (k < columns) {
-        columnAlignment[k] = markersToAlignment(leftMarker, rightMarker);
-        // printf("column[%d] alignment=%d\n",k,columnAlignment[k]);
-        leftMarker = FALSE;
-        rightMarker = FALSE;
-        startFound = FALSE;
+  bool leftMarker=FALSE,rightMarker=FALSE;
+  bool startFound=FALSE;
+  j=start+i;
+  while (j<=end+i)
+  {
+    if (!startFound)
+    {
+      if (data[j]==':') { leftMarker=TRUE; startFound=TRUE; }
+      if (data[j]=='-') startFound=TRUE; 
+      //printf("  data[%d]=%c startFound=%d\n",j,data[j],startFound);
+    }
+    if      (data[j]=='-') rightMarker=FALSE;
+    else if (data[j]==':') rightMarker=TRUE;
+    if (j<=end+i && (data[j]=='|' && (j==0 || data[j-1]!='\\'))) 
+    {
+      if (k<columns)
+      {
+        columnAlignment[k] = markersToAlignment(leftMarker,rightMarker);
+        //printf("column[%d] alignment=%d\n",k,columnAlignment[k]);
+        leftMarker=FALSE;
+        rightMarker=FALSE;
+        startFound=FALSE;
       }
       k++;
     }
     j++;
   }
-  if (k < columns) {
-    columnAlignment[k] = markersToAlignment(leftMarker, rightMarker);
-    // printf("column[%d] alignment=%d\n",k,columnAlignment[k]);
+  if (k<columns)
+  {
+    columnAlignment[k] = markersToAlignment(leftMarker,rightMarker);
+    //printf("column[%d] alignment=%d\n",k,columnAlignment[k]);
   }
   // proceed to next line
-  i += ret;
+  i+=ret;
 
-<<<<<<< HEAD
-  int m = headerStart;
-  for (k = 0; k < columns; k++) {
-=======
 #ifdef USE_ORIGINAL_TABLES
 
   int m=headerStart;
   for (k=0;k<columns;k++)
   {
->>>>>>> 5f01f783e2387a5d44ad70fbff5365aa0e5df938
     out.addStr("<th");
-    switch (columnAlignment[k]) {
-    case AlignLeft:
-      out.addStr(" align=\"left\"");
-      break;
-    case AlignRight:
-      out.addStr(" align=\"right\"");
-      break;
-    case AlignCenter:
-      out.addStr(" align=\"center\"");
-      break;
-    case AlignNone:
-      break;
+    switch (columnAlignment[k])
+    {
+      case AlignLeft:   out.addStr(" align=\"left\""); break;
+      case AlignRight:  out.addStr(" align=\"right\""); break;
+      case AlignCenter: out.addStr(" align=\"center\""); break;
+      case AlignNone:   break;
     }
     out.addStr(">");
-    while (m <= headerEnd &&
-           (data[m] != '|' || (m > 0 && data[m - 1] == '\\'))) {
+    while (m<=headerEnd && (data[m]!='|' || (m>0 && data[m-1]=='\\')))
+    {
       out.addChar(data[m++]);
     }
     m++;
@@ -1651,38 +1665,37 @@ static int writeTableBlock(GrowBuf &out, const char *data, int size) {
   out.addStr("\n</th>\n");
 
   // write table cells
-  while (i < size) {
-    int ret = findTableColumns(data + i, size - i, start, end, cc);
-    // printf("findTableColumns cc=%d\n",cc);
-    if (cc != columns)
-      break; // end of table
+  while (i<size)
+  {
+    int ret = findTableColumns(data+i,size-i,start,end,cc);
+    //printf("findTableColumns cc=%d\n",cc);
+    if (cc!=columns) break; // end of table
 
     out.addStr("<tr>");
-    j = start + i;
-    int columnStart = j;
-    k = 0;
-    while (j <= end + i) {
-      if (j == columnStart) {
+    j=start+i;
+    int columnStart=j;
+    k=0;
+    while (j<=end+i)
+    {
+      if (j==columnStart)
+      {
         out.addStr("<td");
-        switch (columnAlignment[k]) {
-        case AlignLeft:
-          out.addStr(" align=\"left\"");
-          break;
-        case AlignRight:
-          out.addStr(" align=\"right\"");
-          break;
-        case AlignCenter:
-          out.addStr(" align=\"center\"");
-          break;
-        case AlignNone:
-          break;
+        switch (columnAlignment[k])
+        {
+          case AlignLeft:   out.addStr(" align=\"left\""); break;
+          case AlignRight:  out.addStr(" align=\"right\""); break;
+          case AlignCenter: out.addStr(" align=\"center\""); break;
+          case AlignNone:   break;
         }
         out.addStr(">");
       }
-      if (j <= end + i && (data[j] == '|' && (j == 0 || data[j - 1] != '\\'))) {
-        columnStart = j + 1;
+      if (j<=end+i && (data[j]=='|' && (j==0 || data[j-1]!='\\'))) 
+      {
+        columnStart=j+1;
         k++;
-      } else {
+      }
+      else
+      {
         out.addChar(data[j]);
       }
       j++;
@@ -1690,7 +1703,7 @@ static int writeTableBlock(GrowBuf &out, const char *data, int size) {
     out.addChar('\n');
 
     // proceed to next line
-    i += ret;
+    i+=ret;
   }
 
   out.addStr("</table> ");
@@ -1854,341 +1867,368 @@ static int writeTableBlock(GrowBuf &out, const char *data, int size) {
   return i;
 }
 
-void writeOneLineHeaderOrRuler(GrowBuf &out, const char *data, int size) {
+
+void writeOneLineHeaderOrRuler(GrowBuf &out,const char *data,int size)
+{
   int level;
   QCString header;
   QCString id;
-  if (isHRuler(data, size)) {
+  if (isHRuler(data,size))
+  {
     out.addStr("<hr>\n");
-  } else if ((level = isAtxHeader(data, size, header, id))) {
-    // if (level==1) g_correctSectionLevel=FALSE;
-    // if (g_correctSectionLevel) level--;
+  }
+  else if ((level=isAtxHeader(data,size,header,id)))
+  {
+    //if (level==1) g_correctSectionLevel=FALSE;
+    //if (g_correctSectionLevel) level--;
     QCString hTag;
-    if (level < 5 && !id.isEmpty()) {
+    if (level<5 && !id.isEmpty())
+    {
       SectionInfo::SectionType type = SectionInfo::Anchor;
-      switch (level) {
-      case 1:
-        out.addStr("@section ");
-        type = SectionInfo::Section;
-        break;
-      case 2:
-        out.addStr("@subsection ");
-        type = SectionInfo::Subsection;
-        break;
-      case 3:
-        out.addStr("@subsubsection ");
-        type = SectionInfo::Subsubsection;
-        break;
-      default:
-        out.addStr("@paragraph ");
-        type = SectionInfo::Paragraph;
-        break;
+      switch(level)
+      {
+        case 1:  out.addStr("@section ");       
+                 type=SectionInfo::Section; 
+                 break;
+        case 2:  out.addStr("@subsection ");    
+                 type=SectionInfo::Subsection; 
+                 break;
+        case 3:  out.addStr("@subsubsection "); 
+                 type=SectionInfo::Subsubsection;
+                 break;
+        default: out.addStr("@paragraph "); 
+                 type=SectionInfo::Paragraph;
+                 break;
       }
       out.addStr(id);
       out.addStr(" ");
       out.addStr(header);
       out.addStr("\n");
       SectionInfo *si = Doxygen::sectionDict->find(id);
-      if (si) {
-        if (si->lineNr != -1) {
-          warn(g_fileName, g_lineNr, "multiple use of section label '%s', "
-                                     "(first occurrence: %s, line %d)",
-               header.data(), si->fileName.data(), si->lineNr);
-        } else {
-          warn(g_fileName, g_lineNr,
-               "multiple use of section label '%s', (first occurrence: %s)",
-               header.data(), si->fileName.data());
+      if (si)
+      {
+        if (si->lineNr != -1)
+        {
+          warn(g_fileName,g_lineNr,"multiple use of section label '%s', (first occurrence: %s, line %d)",header.data(),si->fileName.data(),si->lineNr);
+        }
+        else
+        {
+          warn(g_fileName,g_lineNr,"multiple use of section label '%s', (first occurrence: %s)",header.data(),si->fileName.data());
         }
-      } else {
-        si = new SectionInfo(g_fileName, g_lineNr, id, header, type, level);
-        if (g_current) {
+      }
+      else
+      {
+        si = new SectionInfo(g_fileName,g_lineNr,id,header,type,level);
+        if (g_current)
+        {
           g_current->anchors->append(si);
         }
-        Doxygen::sectionDict->append(id, si);
+        Doxygen::sectionDict->append(id,si);
       }
-    } else {
-      if (!id.isEmpty()) {
-        out.addStr("\\anchor " + id + "\n");
+    }
+    else
+    {
+      if (!id.isEmpty())
+      {
+        out.addStr("\\anchor "+id+"\n");
       }
-      hTag.sprintf("h%d", level);
-      out.addStr("<" + hTag + ">");
-      out.addStr(header);
-      out.addStr("</" + hTag + ">\n");
+      hTag.sprintf("h%d",level);
+      out.addStr("<"+hTag+">");
+      out.addStr(header); 
+      out.addStr("</"+hTag+">\n");
     }
-  } else // nothing interesting -> just output the line
+  }
+  else // nothing interesting -> just output the line
   {
-    out.addStr(data, size);
+    out.addStr(data,size);
   }
 }
 
-static int writeBlockQuote(GrowBuf &out, const char *data, int size) {
+static int writeBlockQuote(GrowBuf &out,const char *data,int size)
+{
   int l;
-  int i = 0;
-  int curLevel = 0;
-  int end = 0;
-  while (i < size) {
+  int i=0;
+  int curLevel=0;
+  int end=0;
+  while (i<size)
+  {
     // find end of this line
-    end = i + 1;
-    while (end <= size && data[end - 1] != '\n')
-      end++;
-    int j = i;
-    int level = 0;
-    int indent = i;
+    end=i+1;
+    while (end<=size && data[end-1]!='\n') end++;
+    int j=i;
+    int level=0;
+    int indent=i;
     // compute the quoting level
-    while (j < end && (data[j] == ' ' || data[j] == '>')) {
-      if (data[j] == '>') {
-        level++;
-        indent = j + 1;
-      } else if (j > 0 && data[j - 1] == '>')
-        indent = j + 1;
+    while (j<end && (data[j]==' ' || data[j]=='>'))
+    {
+      if (data[j]=='>') { level++; indent=j+1; }
+      else if (j>0 && data[j-1]=='>') indent=j+1;
       j++;
     }
-    if (j > 0 && data[j - 1] == '>' &&
-        !(j == size ||
-          data[j] == '\n')) // disqualify last > if not followed by space
+    if (j>0 && data[j-1]=='>' && 
+        !(j==size || data[j]=='\n')) // disqualify last > if not followed by space
     {
       indent--;
       j--;
     }
-    if (level > curLevel) // quote level increased => add start markers
+    if (level>curLevel) // quote level increased => add start markers
     {
-      for (l = curLevel; l < level; l++) {
+      for (l=curLevel;l<level;l++)
+      {
         out.addStr("<blockquote>\n");
       }
-    } else if (level < curLevel) // quote level descreased => add end markers
+    }
+    else if (level<curLevel) // quote level descreased => add end markers
     {
-      for (l = level; l < curLevel; l++) {
+      for (l=level;l<curLevel;l++)
+      {
         out.addStr("</blockquote>\n");
       }
     }
-    curLevel = level;
-    if (level == 0)
-      break; // end of quote block
+    curLevel=level;
+    if (level==0) break; // end of quote block
     // copy line without quotation marks
-    out.addStr(data + indent, end - indent);
+    out.addStr(data+indent,end-indent);
     // proceed with next line
-    i = end;
+    i=end;
   }
   // end of comment within blockquote => add end markers
-  for (l = 0; l < curLevel; l++) {
+  for (l=0;l<curLevel;l++)
+  {
     out.addStr("</blockquote>\n");
   }
   return i;
 }
 
-static int writeCodeBlock(GrowBuf &out, const char *data, int size,
-                          int refIndent) {
-  int i = 0, end;
-  // printf("writeCodeBlock: data={%s}\n",QCString(data).left(size).data());
+static int writeCodeBlock(GrowBuf &out,const char *data,int size,int refIndent)
+{
+  int i=0,end;
+  //printf("writeCodeBlock: data={%s}\n",QCString(data).left(size).data());
   out.addStr("@verbatim\n");
-  int emptyLines = 0;
-  while (i < size) {
+  int emptyLines=0;
+  while (i<size)
+  {
     // find end of this line
-    end = i + 1;
-    while (end <= size && data[end - 1] != '\n')
-      end++;
-    int j = i;
-    int indent = 0;
-    while (j < end && data[j] == ' ')
-      j++, indent++;
-    // printf("j=%d end=%d indent=%d refIndent=%d tabSize=%d data={%s}\n",
+    end=i+1;
+    while (end<=size && data[end-1]!='\n') end++;
+    int j=i;
+    int indent=0;
+    while (j<end && data[j]==' ') j++,indent++;
+    //printf("j=%d end=%d indent=%d refIndent=%d tabSize=%d data={%s}\n",
     //    j,end,indent,refIndent,Config_getInt(TAB_SIZE),QCString(data+i).left(end-i-1).data());
-    if (j == end - 1) // empty line
+    if (j==end-1) // empty line 
     {
       emptyLines++;
-      i = end;
-    } else if (indent >=
-               refIndent +
-                   codeBlockIndent) // enough indent to contine the code block
+      i=end;
+    }
+    else if (indent>=refIndent+codeBlockIndent) // enough indent to contine the code block
     {
-      while (emptyLines > 0) // write skipped empty lines
+      while (emptyLines>0) // write skipped empty lines
       {
         // add empty line
         out.addStr("\n");
         emptyLines--;
       }
       // add code line minus the indent
-      out.addStr(data + i + refIndent + codeBlockIndent,
-                 end - i - refIndent - codeBlockIndent);
-      i = end;
-    } else // end of code block
+      out.addStr(data+i+refIndent+codeBlockIndent,end-i-refIndent-codeBlockIndent);
+      i=end;
+    }
+    else // end of code block
     {
       break;
     }
   }
-  out.addStr("@endverbatim\n");
-  while (emptyLines > 0) // write skipped empty lines
+  out.addStr("@endverbatim\n"); 
+  while (emptyLines>0) // write skipped empty lines
   {
     // add empty line
     out.addStr("\n");
     emptyLines--;
   }
-  // printf("i=%d\n",i);
+  //printf("i=%d\n",i);
   return i;
 }
 
 // start searching for the end of the line start at offset \a i
 // keeping track of possible blocks that need to to skipped.
-static void findEndOfLine(GrowBuf &out, const char *data, int size, int &pi,
-                          int &i, int &end) {
+static void findEndOfLine(GrowBuf &out,const char *data,int size,
+                          int &pi,int&i,int &end)
+{
   // find end of the line
-  int nb = 0;
-  end = i + 1;
-  while (end <= size && data[end - 1] != '\n') {
+  int nb=0;
+  end=i+1;
+  while (end<=size && data[end-1]!='\n')
+  {
     // while looking for the end of the line we might encounter a block
     // that needs to be passed unprocessed.
-    if ((data[end - 1] == '\\' || data[end - 1] == '@') && // command
-        (end <= 1 ||
-         (data[end - 2] != '\\' && data[end - 2] != '@')) // not escaped
-        ) {
-      QCString endBlockName =
-          isBlockCommand(data + end - 1, end - 1, size - (end - 1));
+    if ((data[end-1]=='\\' || data[end-1]=='@') &&          // command
+        (end<=1 || (data[end-2]!='\\' && data[end-2]!='@')) // not escaped
+       )
+    {
+      QCString endBlockName = isBlockCommand(data+end-1,end-1,size-(end-1));
       end++;
-      if (!endBlockName.isEmpty()) {
+      if (!endBlockName.isEmpty())
+      {
         int l = endBlockName.length();
-        for (; end < size - l - 1; end++) // search for end of block marker
+        for (;end<size-l-1;end++) // search for end of block marker
         {
-          if ((data[end] == '\\' || data[end] == '@') &&
-              data[end - 1] != '\\' && data[end - 1] != '@') {
-            if (qstrncmp(&data[end + 1], endBlockName, l) == 0) {
-              if (pi != -1) // output previous line if available
+          if ((data[end]=='\\' || data[end]=='@') &&
+              data[end-1]!='\\' && data[end-1]!='@'
+             )
+          {
+            if (qstrncmp(&data[end+1],endBlockName,l)==0)
+            {
+              if (pi!=-1) // output previous line if available
               {
-                // printf("feol
-                // out={%s}\n",QCString(data+pi).left(i-pi).data());
-                out.addStr(data + pi, i - pi);
+                //printf("feol out={%s}\n",QCString(data+pi).left(i-pi).data());
+                out.addStr(data+pi,i-pi);
               }
               // found end marker, skip over this block
-              // printf("feol.block
-              // out={%s}\n",QCString(data+i).left(end+l+1-i).data());
-              out.addStr(data + i, end + l + 1 - i);
-              pi = -1;
-              i = end + l + 1; // continue after block
-              end = i + 1;
+              //printf("feol.block out={%s}\n",QCString(data+i).left(end+l+1-i).data());
+              out.addStr(data+i,end+l+1-i);
+              pi=-1;
+              i=end+l+1; // continue after block
+              end=i+1;
               break;
             }
           }
         }
       }
-    } else if (nb == 0 && data[end - 1] == '<' && end < size - 6 &&
-               (end <= 1 || (data[end - 2] != '\\' && data[end - 2] != '@'))) {
-      if (tolower(data[end]) == 'p' && tolower(data[end + 1]) == 'r' &&
-          tolower(data[end + 2]) == 'e' && data[end + 3] == '>') // <pre> tag
+    }
+    else if (nb==0 && data[end-1]=='<' && end<size-6 &&
+             (end<=1 || (data[end-2]!='\\' && data[end-2]!='@'))
+            )
+    {
+      if (tolower(data[end])=='p' && tolower(data[end+1])=='r' &&
+          tolower(data[end+2])=='e' && data[end+3]=='>') // <pre> tag
       {
-        if (pi != -1) // output previous line if available
+        if (pi!=-1) // output previous line if available
         {
-          out.addStr(data + pi, i - pi);
+          out.addStr(data+pi,i-pi);
         }
         // output part until <pre>
-        out.addStr(data + i, end - 1 - i);
+        out.addStr(data+i,end-1-i); 
         // output part until </pre>
-        i = end - 1 +
-            processHtmlTag(out, data + end - 1, end - 1, size - end + 1);
-        pi = -1;
-        end = i + 1;
+        i = end-1 + processHtmlTag(out,data+end-1,end-1,size-end+1);
+        pi=-1;
+        end = i+1;
         break;
-      } else {
+      }
+      else
+      {
         end++;
       }
-    } else if (nb == 0 && data[end - 1] == '`') {
-      while (end <= size && data[end - 1] == '`')
-        end++, nb++;
-    } else if (nb > 0 && data[end - 1] == '`') {
-      int enb = 0;
-      while (end <= size && data[end - 1] == '`')
-        end++, enb++;
-      if (enb == nb)
-        nb = 0;
-    } else {
+    }
+    else if (nb==0 && data[end-1]=='`') 
+    {
+      while (end<=size && data[end-1]=='`') end++,nb++;
+    }
+    else if (nb>0 && data[end-1]=='`')
+    {
+      int enb=0;
+      while (end<=size && data[end-1]=='`') end++,enb++;
+      if (enb==nb) nb=0;
+    }
+    else
+    {
       end++;
     }
   }
-  // printf("findEndOfLine pi=%d i=%d end=%d
-  // {%s}\n",pi,i,end,QCString(data+i).left(end-i).data());
+  //printf("findEndOfLine pi=%d i=%d end=%d {%s}\n",pi,i,end,QCString(data+i).left(end-i).data());
 }
 
-static void writeFencedCodeBlock(GrowBuf &out, const char *data,
-                                 const char *lng, int blockStart,
-                                 int blockEnd) {
+static void writeFencedCodeBlock(GrowBuf &out,const char *data,const char *lng,
+                int blockStart,int blockEnd)
+{
   QCString lang = lng;
-  if (!lang.isEmpty() && lang.at(0) == '.')
-    lang = lang.mid(1);
+  if (!lang.isEmpty() && lang.at(0)=='.') lang=lang.mid(1);
   out.addStr("@code");
-  if (!lang.isEmpty()) {
-    out.addStr("{" + lang + "}");
+  if (!lang.isEmpty())
+  {
+    out.addStr("{"+lang+"}");
   }
-  out.addStr(data + blockStart, blockEnd - blockStart);
+  out.addStr(data+blockStart,blockEnd-blockStart);
   out.addStr("\n");
   out.addStr("@endcode");
 }
 
-static QCString processQuotations(const QCString &s, int refIndent) {
+static QCString processQuotations(const QCString &s,int refIndent)
+{
   GrowBuf out;
   const char *data = s.data();
   int size = s.length();
-  int i = 0, end = 0, pi = -1;
-  int blockStart, blockEnd, blockOffset;
+  int i=0,end=0,pi=-1;
+  int blockStart,blockEnd,blockOffset;
   QCString lang;
-  while (i < size) {
-    findEndOfLine(out, data, size, pi, i, end);
+  while (i<size)
+  {
+    findEndOfLine(out,data,size,pi,i,end);
     // line is now found at [i..end)
 
-    if (pi != -1) {
-      if (isFencedCodeBlock(data + pi, size - pi, refIndent, lang, blockStart,
-                            blockEnd, blockOffset)) {
-        writeFencedCodeBlock(out, data + pi, lang, blockStart, blockEnd);
-        i = pi + blockOffset;
-        pi = -1;
-        end = i + 1;
+    if (pi!=-1)
+    {
+      if (isFencedCodeBlock(data+pi,size-pi,refIndent,lang,blockStart,blockEnd,blockOffset))
+      {
+        writeFencedCodeBlock(out,data+pi,lang,blockStart,blockEnd);
+        i=pi+blockOffset;
+        pi=-1;
+        end=i+1;
         continue;
-      } else if (isBlockQuote(data + pi, i - pi, refIndent)) {
-        i = pi + writeBlockQuote(out, data + pi, size - pi);
-        pi = -1;
-        end = i + 1;
+      }
+      else if (isBlockQuote(data+pi,i-pi,refIndent))
+      {
+        i = pi+writeBlockQuote(out,data+pi,size-pi);
+        pi=-1;
+        end=i+1;
         continue;
-      } else {
-        // printf("quote out={%s}\n",QCString(data+pi).left(i-pi).data());
-        out.addStr(data + pi, i - pi);
+      }
+      else
+      {
+        //printf("quote out={%s}\n",QCString(data+pi).left(i-pi).data());
+        out.addStr(data+pi,i-pi);
       }
     }
-    pi = i;
-    i = end;
+    pi=i;
+    i=end;
   }
-  if (pi != -1 && pi < size) // deal with the last line
+  if (pi!=-1 && pi<size) // deal with the last line
   {
-    if (isBlockQuote(data + pi, size - pi, refIndent)) {
-      writeBlockQuote(out, data + pi, size - pi);
-    } else {
-      out.addStr(data + pi, size - pi);
+    if (isBlockQuote(data+pi,size-pi,refIndent))
+    {
+      writeBlockQuote(out,data+pi,size-pi);
+    }
+    else
+    {
+      out.addStr(data+pi,size-pi);
     }
   }
   out.addChar(0);
 
-  // printf("Process quotations\n---- input ----\n%s\n---- output
-  // ----\n%s\n------------\n",
+  //printf("Process quotations\n---- input ----\n%s\n---- output ----\n%s\n------------\n",
   //    s.data(),out.get());
 
   return out.get();
 }
 
-static QCString processBlocks(const QCString &s, int indent) {
+static QCString processBlocks(const QCString &s,int indent)
+{
   GrowBuf out;
   const char *data = s.data();
   int size = s.length();
-  int i = 0, end = 0, pi = -1, ref, level;
-  QCString id, link, title;
+  int i=0,end=0,pi=-1,ref,level;
+  QCString id,link,title;
   int blockIndent = indent;
 
   // get indent for the first line
-  end = i + 1;
-  int sp = 0;
-  while (end <= size && data[end - 1] != '\n') {
-    if (data[end - 1] == ' ')
-      sp++;
+  end = i+1;
+  int sp=0;
+  while (end<=size && data[end-1]!='\n') 
+  {
+    if (data[end-1]==' ') sp++;
     end++;
   }
 
-#if 0 // commented out, since starting with a comment block is probably a usage
-      // error
+#if 0 // commented out, since starting with a comment block is probably a usage error
       // see also http://stackoverflow.com/q/20478611/784672
 
   // special case when the documentation starts with a code block
@@ -2202,111 +2242,131 @@ static QCString processBlocks(const QCString &s, int indent) {
 #endif
 
   // process each line
-  while (i < size) {
-    findEndOfLine(out, data, size, pi, i, end);
+  while (i<size)
+  {
+    findEndOfLine(out,data,size,pi,i,end);
     // line is now found at [i..end)
 
-    // printf("findEndOfLine: pi=%d i=%d end=%d\n",pi,i,end);
+    //printf("findEndOfLine: pi=%d i=%d end=%d\n",pi,i,end);
 
-    if (pi != -1) {
-      int blockStart, blockEnd, blockOffset;
+    if (pi!=-1)
+    {
+      int blockStart,blockEnd,blockOffset;
       QCString lang;
       blockIndent = indent;
-      // printf("isHeaderLine(%s)=%d\n",QCString(data+i).left(size-i).data(),level);
-      if ((level = isHeaderline(data + i, size - i)) > 0) {
-        // if (level==1) g_correctSectionLevel=FALSE;
-        // if (g_correctSectionLevel) level--;
-        // printf("Found header at %d-%d\n",i,end);
-        while (pi < size && data[pi] == ' ')
-          pi++;
-        QCString header, id;
-        convertStringFragment(header, data + pi, i - pi - 1);
+      //printf("isHeaderLine(%s)=%d\n",QCString(data+i).left(size-i).data(),level);
+      if ((level=isHeaderline(data+i,size-i))>0)
+      {
+        //if (level==1) g_correctSectionLevel=FALSE;
+        //if (g_correctSectionLevel) level--;
+        //printf("Found header at %d-%d\n",i,end);
+        while (pi<size && data[pi]==' ') pi++;
+        QCString header,id;
+        convertStringFragment(header,data+pi,i-pi-1);
         id = extractTitleId(header, level);
-        // printf("header='%s' is='%s'\n",header.data(),id.data());
-        if (!header.isEmpty()) {
-          if (!id.isEmpty()) {
-            out.addStr(level == 1 ? "@section " : "@subsection ");
+        //printf("header='%s' is='%s'\n",header.data(),id.data());
+        if (!header.isEmpty())
+        {
+          if (!id.isEmpty())
+          {
+            out.addStr(level==1?"@section ":"@subsection ");
             out.addStr(id);
             out.addStr(" ");
             out.addStr(header);
             out.addStr("\n\n");
             SectionInfo *si = Doxygen::sectionDict->find(id);
-            if (si) {
-              if (si->lineNr != -1) {
-                warn(g_fileName, g_lineNr, "multiple use of section label "
-                                           "'%s', (first occurrence: %s, line "
-                                           "%d)",
-                     header.data(), si->fileName.data(), si->lineNr);
-              } else {
-                warn(g_fileName, g_lineNr, "multiple use of section label "
-                                           "'%s', (first occurrence: %s)",
-                     header.data(), si->fileName.data());
+            if (si)
+            {
+              if (si->lineNr != -1)
+              {
+                warn(g_fileName,g_lineNr,"multiple use of section label '%s', (first occurrence: %s, line %d)",header.data(),si->fileName.data(),si->lineNr);
+              }
+              else
+              {
+                warn(g_fileName,g_lineNr,"multiple use of section label '%s', (first occurrence: %s)",header.data(),si->fileName.data());
               }
-            } else {
-              si = new SectionInfo(g_fileName, g_lineNr, id, header,
-                                   level == 1 ? SectionInfo::Section
-                                              : SectionInfo::Subsection,
-                                   level);
-              if (g_current) {
+            }
+            else
+            {
+              si = new SectionInfo(g_fileName,g_lineNr,id,header,
+                      level==1 ? SectionInfo::Section : SectionInfo::Subsection,level);
+              if (g_current)
+              {
                 g_current->anchors->append(si);
               }
-              Doxygen::sectionDict->append(id, si);
+              Doxygen::sectionDict->append(id,si);
             }
-          } else {
-            out.addStr(level == 1 ? "<h1>" : "<h2>");
+          }
+          else
+          {
+            out.addStr(level==1?"<h1>":"<h2>");
             out.addStr(header);
-            out.addStr(level == 1 ? "\n</h1>\n" : "\n</h2>\n");
+            out.addStr(level==1?"\n</h1>\n":"\n</h2>\n");
           }
-        } else {
+        }
+        else
+        {
           out.addStr("<hr>\n");
         }
-        pi = -1;
-        i = end;
-        end = i + 1;
+        pi=-1;
+        i=end;
+        end=i+1;
         continue;
-      } else if ((ref = isLinkRef(data + pi, size - pi, id, link, title))) {
-        // printf("found link ref: id='%s' link='%s' title='%s'\n",
+      }
+      else if ((ref=isLinkRef(data+pi,size-pi,id,link,title)))
+      {
+        //printf("found link ref: id='%s' link='%s' title='%s'\n",
         //       id.data(),link.data(),title.data());
-        g_linkRefs.insert(id.lower(), new LinkRef(link, title));
-        i = ref + pi;
-        pi = -1;
-        end = i + 1;
-      } else if (isFencedCodeBlock(data + pi, size - pi, indent, lang,
-                                   blockStart, blockEnd, blockOffset)) {
-        // printf("Found FencedCodeBlock lang='%s' start=%d end=%d code={%s}\n",
+        g_linkRefs.insert(id.lower(),new LinkRef(link,title));
+        i=ref+pi;
+        pi=-1;
+        end=i+1;
+      }
+      else if (isFencedCodeBlock(data+pi,size-pi,indent,lang,blockStart,blockEnd,blockOffset))
+      {
+        //printf("Found FencedCodeBlock lang='%s' start=%d end=%d code={%s}\n",
         //       lang.data(),blockStart,blockEnd,QCString(data+pi+blockStart).left(blockEnd-blockStart).data());
-        writeFencedCodeBlock(out, data + pi, lang, blockStart, blockEnd);
-        i = pi + blockOffset;
-        pi = -1;
-        end = i + 1;
+        writeFencedCodeBlock(out,data+pi,lang,blockStart,blockEnd);
+        i=pi+blockOffset;
+        pi=-1;
+        end=i+1;
         continue;
-      } else if (isCodeBlock(data + i, i, end - i, blockIndent)) {
+      }
+      else if (isCodeBlock(data+i,i,end-i,blockIndent))
+      {
         // skip previous line (it is empty anyway)
-        i += writeCodeBlock(out, data + i, size - i, blockIndent);
-        pi = -1;
-        end = i + 1;
+        i+=writeCodeBlock(out,data+i,size-i,blockIndent);
+        pi=-1;
+        end=i+1;
         continue;
-      } else if (isTableBlock(data + pi, size - pi)) {
-        i = pi + writeTableBlock(out, data + pi, size - pi);
-        pi = -1;
-        end = i + 1;
+      }
+      else if (isTableBlock(data+pi,size-pi))
+      {
+        i=pi+writeTableBlock(out,data+pi,size-pi);
+        pi=-1;
+        end=i+1;
         continue;
-      } else {
-        writeOneLineHeaderOrRuler(out, data + pi, i - pi);
+      }
+      else
+      {
+        writeOneLineHeaderOrRuler(out,data+pi,i-pi);
       }
     }
-    pi = i;
-    i = end;
+    pi=i;
+    i=end;
   }
-  // printf("last line %d size=%d\n",i,size);
-  if (pi != -1 && pi < size) // deal with the last line
+  //printf("last line %d size=%d\n",i,size);
+  if (pi!=-1 && pi<size) // deal with the last line
   {
-    if (isLinkRef(data + pi, size - pi, id, link, title)) {
-      printf("found link ref: id='%s' link='%s' title='%s'\n", id.data(),
-             link.data(), title.data());
-      g_linkRefs.insert(id.lower(), new LinkRef(link, title));
-    } else {
-      writeOneLineHeaderOrRuler(out, data + pi, size - pi);
+    if (isLinkRef(data+pi,size-pi,id,link,title))
+    {
+      //printf("found link ref: id='%s' link='%s' title='%s'\n",
+      //    id.data(),link.data(),title.data());
+      g_linkRefs.insert(id.lower(),new LinkRef(link,title));
+    }
+    else
+    {
+      writeOneLineHeaderOrRuler(out,data+pi,size-pi);
     }
   }
 
@@ -2314,238 +2374,248 @@ static QCString processBlocks(const QCString &s, int indent) {
   return out.get();
 }
 
-/** returns TRUE if input string docs starts with \@page or \@mainpage command
- */
-static bool isExplicitPage(const QCString &docs) {
-  int i = 0;
+/** returns TRUE if input string docs starts with \@page or \@mainpage command */
+static bool isExplicitPage(const QCString &docs)
+{
+  int i=0;
   const char *data = docs.data();
-  if (data) {
-    int size = docs.size();
-    while (i < size && (data[i] == ' ' || data[i] == '\n')) {
+  if (data)
+  {
+    int size=docs.size();
+    while (i<size && (data[i]==' ' || data[i]=='\n'))
+    {
       i++;
     }
-    if (i < size + 1 && (data[i] == '\\' || data[i] == '@') &&
-        (qstrncmp(&data[i + 1], "page ", 5) == 0 ||
-         qstrncmp(&data[i + 1], "mainpage", 8) == 0)) {
+    if (i<size+1 &&
+        (data[i]=='\\' || data[i]=='@') &&
+        (qstrncmp(&data[i+1],"page ",5)==0 || qstrncmp(&data[i+1],"mainpage",8)==0)
+       )
+    {
       return TRUE;
     }
   }
   return FALSE;
 }
 
-static QCString extractPageTitle(QCString &docs, QCString &id) {
-  int ln = 0;
+static QCString extractPageTitle(QCString &docs,QCString &id)
+{
+  int ln=0;
   // first first non-empty line
   QCString title;
   const char *data = docs.data();
-  int i = 0;
-  int size = docs.size();
-  while (i < size && (data[i] == ' ' || data[i] == '\n')) {
-    if (data[i] == '\n')
-      ln++;
+  int i=0;
+  int size=docs.size();
+  while (i<size && (data[i]==' ' || data[i]=='\n')) 
+  {
+    if (data[i]=='\n') ln++;
     i++;
   }
-  if (i >= size)
-    return "";
-  int end1 = i + 1;
-  while (end1 < size && data[end1 - 1] != '\n')
-    end1++;
-  // printf("i=%d end1=%d size=%d
-  // line='%s'\n",i,end1,size,docs.mid(i,end1-i).data());
+  if (i>=size) return "";
+  int end1=i+1;
+  while (end1<size && data[end1-1]!='\n') end1++;
+  //printf("i=%d end1=%d size=%d line='%s'\n",i,end1,size,docs.mid(i,end1-i).data());
   // first line from i..end1
-  if (end1 < size) {
+  if (end1<size)
+  {
     ln++;
     // second line form end1..end2
-    int end2 = end1 + 1;
-    while (end2 < size && data[end2 - 1] != '\n')
-      end2++;
-    if (isHeaderline(data + end1, size - end1)) {
-      convertStringFragment(title, data + i, end1 - i - 1);
+    int end2=end1+1;
+    while (end2<size && data[end2-1]!='\n') end2++;
+    if (isHeaderline(data+end1,size-end1))
+    {
+      convertStringFragment(title,data+i,end1-i-1);
       QCString lns;
-      lns.fill('\n', ln);
-      docs = lns + docs.mid(end2);
+      lns.fill('\n',ln);
+      docs=lns+docs.mid(end2);
       id = extractTitleId(title, 0);
-      // printf("extractPageTitle(title='%s' docs='%s'
-      // id='%s')\n",title.data(),docs.data(),id.data());
+      //printf("extractPageTitle(title='%s' docs='%s' id='%s')\n",title.data(),docs.data(),id.data());
       return title;
     }
   }
-  if (i < end1 && isAtxHeader(data + i, end1 - i, title, id) > 0) {
-    docs = docs.mid(end1);
+  if (i<end1 && isAtxHeader(data+i,end1-i,title,id)>0)
+  {
+    docs=docs.mid(end1);
   }
-  // printf("extractPageTitle(title='%s' docs='%s'
-  // id='%s')\n",title.data(),docs.data(),id.data());
+  //printf("extractPageTitle(title='%s' docs='%s' id='%s')\n",title.data(),docs.data(),id.data());
   return title;
 }
 
-static QCString detab(const QCString &s, int &refIndent) {
+static QCString detab(const QCString &s,int &refIndent)
+{
   static int tabSize = Config_getInt(TAB_SIZE);
   GrowBuf out;
   int size = s.length();
   const char *data = s.data();
-  int i = 0;
-  int col = 0;
-  const int maxIndent = 1000000; // value representing infinity
-  int minIndent = maxIndent;
-  while (i < size) {
+  int i=0;
+  int col=0;
+  const int maxIndent=1000000; // value representing infinity
+  int minIndent=maxIndent;
+  while (i<size)
+  {
     char c = data[i++];
-    switch (c) {
-    case '\t': // expand tab
-    {
-      int stop = tabSize - (col % tabSize);
-      // printf("expand at %d stop=%d\n",col,stop);
-      col += stop;
-      while (stop--)
-        out.addChar(' ');
-    } break;
-    case '\n': // reset colomn counter
-      out.addChar(c);
-      col = 0;
-      break;
-    case ' ': // increment column counter
-      out.addChar(c);
-      col++;
-      break;
-    default: // non-whitespace => update minIndent
-      out.addChar(c);
-      if (c < 0 && i < size) // multibyte sequence
-      {
-        out.addChar(data[i++]); // >= 2 bytes
-        if (((uchar)c & 0xE0) == 0xE0 && i < size) {
-          out.addChar(data[i++]); // 3 bytes
+    switch(c)
+    {
+      case '\t': // expand tab
+        {
+          int stop = tabSize - (col%tabSize);
+          //printf("expand at %d stop=%d\n",col,stop);
+          col+=stop;
+          while (stop--) out.addChar(' '); 
         }
-        if (((uchar)c & 0xF0) == 0xF0 && i < size) {
-          out.addChar(data[i++]); // 4 byres
+        break;
+      case '\n': // reset colomn counter
+        out.addChar(c);
+        col=0;
+        break;
+      case ' ': // increment column counter
+        out.addChar(c);
+        col++;
+        break;
+      default: // non-whitespace => update minIndent
+        out.addChar(c);
+        if (c<0 && i<size) // multibyte sequence
+        {
+          out.addChar(data[i++]); // >= 2 bytes
+          if (((uchar)c&0xE0)==0xE0 && i<size)
+          {
+            out.addChar(data[i++]); // 3 bytes
+          }
+          if (((uchar)c&0xF0)==0xF0 && i<size)
+          {
+            out.addChar(data[i++]); // 4 byres
+          }
         }
-      }
-      if (col < minIndent)
-        minIndent = col;
-      col++;
+        if (col<minIndent) minIndent=col;
+        col++;
     }
   }
-  if (minIndent != maxIndent)
-    refIndent = minIndent;
-  else
-    refIndent = 0;
+  if (minIndent!=maxIndent) refIndent=minIndent; else refIndent=0;
   out.addChar(0);
-  // printf("detab refIndent=%d\n",refIndent);
+  //printf("detab refIndent=%d\n",refIndent);
   return out.get();
 }
 
 //---------------------------------------------------------------------------
 
-QCString processMarkdown(const QCString &fileName, const int lineNr, Entry *e,
-                         const QCString &input) {
-  static bool init = FALSE;
-  if (!init) {
+QCString processMarkdown(const QCString &fileName,const int lineNr,Entry *e,const QCString &input)
+{
+  static bool init=FALSE;
+  if (!init)
+  {
     // setup callback table for special characters
-    g_actions[(unsigned int)'_'] = processEmphasis;
-    g_actions[(unsigned int)'*'] = processEmphasis;
-    g_actions[(unsigned int)'`'] = processCodeSpan;
-    g_actions[(unsigned int)'\\'] = processSpecialCommand;
-    g_actions[(unsigned int)'@'] = processSpecialCommand;
-    g_actions[(unsigned int)'['] = processLink;
-    g_actions[(unsigned int)'!'] = processLink;
-    g_actions[(unsigned int)'<'] = processHtmlTag;
-    g_actions[(unsigned int)'-'] = processNmdash;
-    g_actions[(unsigned int)'"'] = processQuoted;
-    init = TRUE;
+    g_actions[(unsigned int)'_']=processEmphasis;
+    g_actions[(unsigned int)'*']=processEmphasis;
+    g_actions[(unsigned int)'`']=processCodeSpan;
+    g_actions[(unsigned int)'\\']=processSpecialCommand;
+    g_actions[(unsigned int)'@']=processSpecialCommand;
+    g_actions[(unsigned int)'[']=processLink;
+    g_actions[(unsigned int)'!']=processLink;
+    g_actions[(unsigned int)'<']=processHtmlTag;
+    g_actions[(unsigned int)'-']=processNmdash;
+    g_actions[(unsigned int)'"']=processQuoted;
+    init=TRUE;
   }
 
   g_linkRefs.setAutoDelete(TRUE);
   g_linkRefs.clear();
   g_current = e;
   g_fileName = fileName;
-  g_lineNr = lineNr;
+  g_lineNr   = lineNr;
   static GrowBuf out;
-  if (input.isEmpty())
-    return input;
+  if (input.isEmpty()) return input;
   out.clear();
   int refIndent;
   // for replace tabs by spaces
-  QCString s = detab(input, refIndent);
-  // printf("======== DeTab =========\n---- output
-  // -----\n%s\n---------\n",s.data());
+  QCString s = detab(input,refIndent);
+  //printf("======== DeTab =========\n---- output -----\n%s\n---------\n",s.data());
   // then process quotation blocks (as these may contain other blocks)
-  s = processQuotations(s, refIndent);
-  // printf("======== Quotations =========\n---- output
-  // -----\n%s\n---------\n",s.data());
+  s = processQuotations(s,refIndent);
+  //printf("======== Quotations =========\n---- output -----\n%s\n---------\n",s.data());
   // then process block items (headers, rules, and code blocks, references)
-  s = processBlocks(s, refIndent);
-  // printf("======== Blocks =========\n---- output
-  // -----\n%s\n---------\n",s.data());
+  s = processBlocks(s,refIndent);
+  //printf("======== Blocks =========\n---- output -----\n%s\n---------\n",s.data());
   // finally process the inline markup (links, emphasis and code spans)
-  processInline(out, s, s.length());
+  processInline(out,s,s.length());
   out.addChar(0);
-  Debug::print(Debug::Markdown, 0, "======== Markdown =========\n---- input "
-                                   "------- \n%s\n---- output "
-                                   "-----\n%s\n---------\n",
-               qPrint(input), qPrint(out.get()));
+  Debug::print(Debug::Markdown,0,"======== Markdown =========\n---- input ------- \n%s\n---- output -----\n%s\n---------\n",qPrint(input),qPrint(out.get()));
   return out.get();
 }
 
 //---------------------------------------------------------------------------
 
-QCString markdownFileNameToId(const QCString &fileName) {
-  QCString baseFn = stripFromPath(QFileInfo(fileName).absFilePath().utf8());
+QCString markdownFileNameToId(const QCString &fileName)
+{
+  QCString baseFn  = stripFromPath(QFileInfo(fileName).absFilePath().utf8());
   int i = baseFn.findRev('.');
-  if (i != -1)
-    baseFn = baseFn.left(i);
-  QCString baseName = substitute(substitute(baseFn, " ", "_"), "/", "_");
-  return "md_" + baseName;
+  if (i!=-1) baseFn = baseFn.left(i);
+  QCString baseName = substitute(substitute(baseFn," ","_"),"/","_");
+  return "md_"+baseName;
 }
 
-void MarkdownFileParser::parseInput(const char *fileName, const char *fileBuf,
-                                    Entry *root, bool /*sameTranslationUnit*/,
-                                    QStrList & /*filesInSameTranslationUnit*/) {
+void MarkdownFileParser::parseInput(const char *fileName, 
+                const char *fileBuf, 
+                Entry *root,
+                bool /*sameTranslationUnit*/,
+                QStrList & /*filesInSameTranslationUnit*/)
+{
   Entry *current = new Entry;
   current->lang = SrcLangExt_Markdown;
   current->fileName = fileName;
-  current->docFile = fileName;
-  current->docLine = 1;
+  current->docFile  = fileName;
+  current->docLine  = 1;
   QCString docs = fileBuf;
   QCString id;
-  QCString title = extractPageTitle(docs, id).stripWhiteSpace();
+  QCString title=extractPageTitle(docs,id).stripWhiteSpace();
   QCString titleFn = QFileInfo(fileName).baseName().utf8();
-  QCString fn = QFileInfo(fileName).fileName().utf8();
+  QCString fn      = QFileInfo(fileName).fileName().utf8();
   static QCString mdfileAsMainPage = Config_getString(USE_MDFILE_AS_MAINPAGE);
-  if (id.isEmpty())
-    id = markdownFileNameToId(fileName);
-  if (!isExplicitPage(docs)) {
+  if (id.isEmpty()) id = markdownFileNameToId(fileName);
+  if (!isExplicitPage(docs))
+  {
     if (!mdfileAsMainPage.isEmpty() &&
-        (fn == mdfileAsMainPage || // name reference
-         QFileInfo(fileName).absFilePath() ==
-             QFileInfo(mdfileAsMainPage)
-                 .absFilePath()) // file reference with path
-        ) {
-      docs.prepend("@mainpage " + title + "\n");
-    } else if (id == "mainpage" || id == "index") {
-      if (title.isEmpty())
-        title = titleFn;
-      docs.prepend("@mainpage " + title + "\n");
-    } else {
-      if (title.isEmpty())
-        title = titleFn;
-      docs.prepend("@page " + id + " " + title + "\n");
-    }
-  }
-  int lineNr = 1;
-  int position = 0;
-
-  // even without markdown support enabled, we still  // parse markdown files as
-  // such
+        (fn==mdfileAsMainPage || // name reference
+         QFileInfo(fileName).absFilePath()==
+         QFileInfo(mdfileAsMainPage).absFilePath()) // file reference with path
+       )
+    {
+      docs.prepend("@mainpage "+title+"\n");
+    }
+    else if (id=="mainpage" || id=="index")
+    {
+      if (title.isEmpty()) title = titleFn;
+      docs.prepend("@mainpage "+title+"\n");
+    }
+    else
+    {
+      if (title.isEmpty()) title = titleFn;
+      docs.prepend("@page "+id+" "+title+"\n");
+    }
+  }
+  int lineNr=1;
+  int position=0;
+
+  // even without markdown support enabled, we still 
+  // parse markdown files as such
   bool markdownEnabled = Doxygen::markdownSupport;
   Doxygen::markdownSupport = TRUE;
 
   bool needsEntry = FALSE;
-  Protection prot = Public;
-  while (parseCommentBlock(this, current, docs, fileName, lineNr,
-                           FALSE, // isBrief
-                           FALSE, // javadoc autobrief
-                           FALSE, // inBodyDocs
-                           prot,  // protection
-                           position, needsEntry)) {
-    if (needsEntry) {
+  Protection prot=Public;
+  while (parseCommentBlock(
+        this,
+        current,
+        docs,
+        fileName,
+        lineNr,
+        FALSE,     // isBrief
+        FALSE,     // javadoc autobrief
+        FALSE,     // inBodyDocs
+        prot,      // protection
+        position,
+        needsEntry))
+  {
+    if (needsEntry)
+    {
       QCString docFile = current->docFile;
       root->addSubEntry(current);
       current = new Entry;
@@ -2554,43 +2624,57 @@ void MarkdownFileParser::parseInput(const char *fileName, const char *fileBuf,
       current->docLine = lineNr;
     }
   }
-  if (needsEntry) {
+  if (needsEntry)
+  {
     root->addSubEntry(current);
   }
 
   // restore setting
   Doxygen::markdownSupport = markdownEnabled;
-  // g_correctSectionLevel = FALSE;
-  void showScannerTree(uint off, Entry * current);
-  showScannerTree(0, root);
+  //g_correctSectionLevel = FALSE;
 }
 
 void MarkdownFileParser::parseCode(CodeOutputInterface &codeOutIntf,
-                                   const char *scopeName, const QCString &input,
-                                   SrcLangExt lang, bool isExampleBlock,
-                                   const char *exampleName, FileDef *fileDef,
-                                   int startLine, int endLine,
-                                   bool inlineFragment, MemberDef *memberDef,
-                                   bool showLineNumbers, Definition *searchCtx,
-                                   bool collectXRefs) {
+               const char *scopeName,
+               const QCString &input,
+               SrcLangExt lang,
+               bool isExampleBlock,
+               const char *exampleName,
+               FileDef *fileDef,
+               int startLine,
+               int endLine,
+               bool inlineFragment,
+               MemberDef *memberDef,
+               bool showLineNumbers,
+               Definition *searchCtx,
+               bool collectXRefs
+              )
+{
   ParserInterface *pIntf = Doxygen::parserManager->getParser("*.cpp");
-  if (pIntf != this) {
-    pIntf->parseCode(codeOutIntf, scopeName, input, lang, isExampleBlock,
-                     exampleName, fileDef, startLine, endLine, inlineFragment,
-                     memberDef, showLineNumbers, searchCtx, collectXRefs);
+  if (pIntf!=this)
+  {
+    pIntf->parseCode(
+       codeOutIntf,scopeName,input,lang,isExampleBlock,exampleName,
+       fileDef,startLine,endLine,inlineFragment,memberDef,showLineNumbers,
+       searchCtx,collectXRefs);
   }
 }
 
-void MarkdownFileParser::resetCodeParserState() {
+void MarkdownFileParser::resetCodeParserState()
+{
   ParserInterface *pIntf = Doxygen::parserManager->getParser("*.cpp");
-  if (pIntf != this) {
+  if (pIntf!=this)
+  {
     pIntf->resetCodeParserState();
   }
 }
 
-void MarkdownFileParser::parsePrototype(const char *text) {
+void MarkdownFileParser::parsePrototype(const char *text)
+{
   ParserInterface *pIntf = Doxygen::parserManager->getParser("*.cpp");
-  if (pIntf != this) {
+  if (pIntf!=this)
+  {
     pIntf->parsePrototype(text);
   }
 }
+
diff --git a/src/namespacedef.cpp b/src/namespacedef.cpp
index 4af1fd9c..a741da69 100644
--- a/src/namespacedef.cpp
+++ b/src/namespacedef.cpp
@@ -46,9 +46,9 @@ NamespaceDef::NamespaceDef(const char *df, int dl, int dc, const char *name,
   } else {
     setFileName(name);
   }
-  classSDict = new ClassSDict(17);
-  namespaceSDict = new NamespaceSDict(17);
-  m_innerCompounds = new SDict<Definition>(17);
+  classSDict = new ClassSDict(109);
+  namespaceSDict = new NamespaceSDict(109);
+  m_innerCompounds = new SDict<Definition>(109);
   usingDirList = 0;
   usingDeclList = 0;
   m_allMembersDict = 0;
@@ -699,7 +699,7 @@ NamespaceSDict *NamespaceDef::getUsedNamespaces() const {
 
 void NamespaceDef::addUsingDeclaration(Definition *d) {
   if (usingDeclList == 0) {
-    usingDeclList = new SDict<Definition>(17);
+    usingDeclList = new SDict<Definition>(109);
   }
   if (usingDeclList->find(d->qualifiedName()) == 0) {
     usingDeclList->append(d->qualifiedName(), d);
@@ -1003,7 +1003,8 @@ QCString NamespaceDef::title() const {
   QCString pageTitle;
   if (lang == SrcLangExt_Java) {
     pageTitle = theTranslator->trPackage(displayName());
-  } else if (lang == SrcLangExt_Fortran) {
+  } else if (lang == SrcLangExt_Fortran ||
+             lang == SrcLangExt_Prolog) {
     pageTitle = theTranslator->trModuleReference(displayName());
   } else if (lang == SrcLangExt_IDL) {
     pageTitle = isConstantGroup()
@@ -1021,7 +1022,8 @@ QCString NamespaceDef::compoundTypeString() const {
     return "package";
   } else if (lang == SrcLangExt_CSharp) {
     return "namespace";
-  } else if (lang == SrcLangExt_Fortran) {
+  } else if (lang == SrcLangExt_Fortran ||
+             lang == SrcLangExt_Prolog) {
     return "module";
   } else if (lang == SrcLangExt_IDL) {
     if (isModule()) {
diff --git a/src/prologscanner.l b/src/prologscanner.l
index 19f4ddc4..f384ec26 100644
--- a/src/prologscanner.l
+++ b/src/prologscanner.l
@@ -17,7 +17,7 @@
 /*  This code is based on the doxygen python module, based on the work by the MoxyPyDoxy team
  *  (Linda Leong, Mike Rivera, Kim Truong, and Gabriel Estrada)
  *  in Spring 2005 as part of CS 179E: Compiler Design Project
- *  at the University of California, Riverside; the course was
+ *  at the Un/iversity of California, Riverside; the course was
  *  taught by Peter H. Froehlich <phf@acm.org>.
  *
  *  The code was extensively rewritten
@@ -36,7 +36,7 @@
 #include <assert.h>
 #include <ctype.h>
 
-#include <qarray.h>
+/* #include <array.h> */
 #include <qstack.h>
 #include <qregexp.h>
 #include <unistd.h>
@@ -59,6 +59,7 @@
 #include "prologcode.h"
 #include "arguments.h"
 
+
 // Toggle for some debugging info
 //#define DBG_CTX(x) fprintf x
 #define DBG_CTX(x)                                                             \
@@ -78,7 +79,6 @@
   static int inputPosition;
   int g_ignore;
   static QFile inputFile;
-
   static Protection protection;
 
   static Entry *current_root = 0;
@@ -99,79 +99,83 @@
   static bool g_system_module;
   static bool g_new_module;
 
-  static int savedDocBlockOuter;
-  static int savedDocBlockInner;
-  static QCString docBlock;
-  static QCString docBlockName;
-  static bool docBlockInBody;
-  static bool docBlockJavaStyle;
-  static bool docBrief;
 
-  static QCString docComment;
 
+    static int savedDocBlockOuter;
+    static int savedDocBlockInner;
+    static QCString docBlock;
+    static QCString docBlockName;
+    static bool docBlockInBody;
+    static bool docBlockJavaStyle;
+    static bool docBrief;
 
-  static bool g_specialBlock;
-  static bool g_grammar;
+    static QCString docComment;
 
-  static uint g_arity;
+    static bool g_specialBlock;
+    static bool g_grammar;
 
-  static QDict<char> g_prologFileCache(257);
-  static QDict<char> g_systemPredTable(257);
-  static QDict<Entry> g_predNameCache(257);
-  static QDict<Entry> g_moduleEntryCache(257);
-  static QDict<Entry> g_varNameCache(257);
-  static QDict<char> g_exportNameCache(257);
- static QDict<char> g_groupEntryCache(257);
+    static uint g_arity;
 
-  QDict<char> g_foreignCache(257);
+    static QDict<char> g_prologFileCache(257);
+    static QDict<char> g_systemPredTable(257);
+    static QDict<Entry> g_predNameCache(257);
+    static QDict<Entry> g_moduleEntryCache(257);
+    static QDict<Entry> g_varNameCache(257);
+    static QDict<char> g_exportNameCache(257);
+   static QDict<char> g_groupEntryCache(257);
 
-  static QCString g_packageScope;
-  static QCString g_pName;
+    QDict<char> g_foreignCache(257);
 
-  // static bool             g_insideConstructor;
+    static QCString g_packageScope;
+    static QCString g_pName;
 
-  static QCString g_moduleScope;
-  static QCString g_packageName;
+    // static bool             g_insideConstructor;
 
-  // static bool             g_hideClassDocs;
+    static QCString g_moduleScope;
+    static QCString g_packageName;
 
-  static QCString g_defVal;
+    // static bool             g_hideClassDocs;
 
-  static bool g_lexInit = FALSE;
-  static bool g_packageCommentAllowed;
-  static bool g_slashStarComment;
-  static bool g_SWIStyle;
+    static QCString g_defVal;
+
+    static bool g_lexInit = FALSE;
+    static bool g_packageCommentAllowed;
+    static bool g_slashStarComment;
+    static bool g_SWIStyle;
 
-  /* algorithmm is:
-     - empty space: call = 0 && arg = 0;
-     - a(: = arg++;
-     - ( && arg == call: arg++, call++;
-     - ( && arg > call: arg++
-     - { && no { before && grammar: arg++, call++
-     - {, [ otherwise: arg++
-     - }, ) && arg == call: arg--, call--
-     - arg--
-  */
-  static unsigned int g_callLevel = 0;
-  static unsigned int g_argLevel = 0;
 
-  static Entry *g_call = 0;
-  static Entry *g_callStore = 0;
+      /* algorithmm is:
+         - empty space: call = 0 && arg = 0;
+         - a(: = arg++;
+         - ( && arg == call: arg++, call++;
+         - ( && arg > call: arg++
+         - { && no { before && grammar: arg++, call++
+         - {, [ otherwise: arg++
+         - }, ) && arg == call: arg--, call--
+         - arg--
+      */
+      static unsigned int g_callLevel = 0;
+      static unsigned int g_argLevel = 0;
 
-  static QCString newModule(const char *modname);
-  static Entry *buildPredEntry(QCString pname);
+      static Entry *g_call = 0;
+      static Entry *g_callStore = 0;
 
-  static bool g_headDone, g_atCall;
-  static bool g_firstCall = true;
+      static QCString newModule(const char *modname);
+      static Entry *buildPredEntry(QCString pname);
 
-  static void parseMain(const char *fileName, const char *fileBuf, Entry *rt);
+      static bool g_headDone, g_atCall;
+      static bool g_firstCall = true;
 
-  static void fillArgs();
+      static void parseMain(const char *fileName, const char *fileBuf, Entry *rt);
 
-  static QRegExp ra("/[0-9]+$");
+      static void fillArgs();
+
+      static QRegExp ra("/[0-9]+$");
   static QRegExp rm("^[a-z][a-zA-Z_0-9]*:");
   static QRegExp rmq("^'[^']+':");
 
+
+//#define DEBUG_ALL 1
 #define DEBUG_ALL 0
 
 static Entry * createModuleEntry( QCString mname );
@@ -290,10 +294,10 @@ static Entry * createModuleEntry( QCString mname );
   }
 
   static void newEntry() {
-    //        if (current && current->parent())
-    //     printf("||%p %s -< %p %s||\n", current->parent(),
-    //     current->parent()->name.data() , current, current->name.data() /*,
-    //     current->program.data() */);
+        if (current && current->parent())
+         printf("||%p %s -< %p %s||\n", current->parent(),
+         current->parent()->name.data() , current, current->name.data() /*,
+            current->program.data() */);
 
     //  else   if (current->section!=Entry::CLASSDOC_SEC)
       assert(current->name);
@@ -1632,7 +1636,7 @@ if (g_headDone) {
     current->name =removeRedundantWhiteSpace(sliceArgument(item.data(), ',' ));
       newModule( current->name );
     current->section=Entry::USINGDECL_SEC;
-    newEntry();
+        newEntry();
     BEGIN(ImportList);
 
   }
@@ -2136,8 +2140,8 @@ showScannerTree(uint off, Entry *current) {
 void PrologLanguageScanner::parseInput(const char *fileName,
                                        const char *fileBuf,
                                        Entry *root,
-                                       bool /*sameTranslationUnit*/,
-                                       QStrList & /*filesInSameTranslationUnit*/)
+                                       bool sameTranslationUnit,
+                                       QStrList & filesInSameTranslationUnit)
 {
   g_thisParser = this;
   g_predNameCache.clear();
@@ -2154,10 +2158,10 @@ void PrologLanguageScanner::parseInput(const char *fileName,
 
  }
 
-bool PrologLanguageScanner::needsPreprocessing(const QCString &)
+bool PrologLanguageScanner::needsPreprocessing(const QCString &s)
 {
-  return FALSE;
-}
+ return FALSE;
+ }
 
 void PrologLanguageScanner::parseCode(CodeOutputInterface &codeOutIntf,
 				      const char *scopeName,
diff --git a/src/util.cpp b/src/util.cpp
index bf0879ab..d81e05af 100644
--- a/src/util.cpp
+++ b/src/util.cpp
@@ -1,11 +1,11 @@
 /*****************************************************************************
- *
+ * 
  *
  * Copyright (C) 1997-2015 by Dimitri van Heesch.
  *
  * Permission to use, copy, modify, and distribute this software and its
- * documentation under the terms of the GNU General Public License is hereby
- * granted. No representations are made about the suitability of this software
+ * documentation under the terms of the GNU General Public License is hereby 
+ * granted. No representations are made about the suitability of this software 
  * for any purpose. It is provided "as is" without express or implied warranty.
  * See the GNU General Public License for more details.
  *
@@ -14,56 +14,54 @@
  *
  */
 
+#include <stdlib.h>
 #include <ctype.h>
 #include <errno.h>
-#include <stdlib.h>
-
-#include <limits.h>
 #include <math.h>
+#include <limits.h>
 
 #include "md5.h"
 
-#include <qcache.h>
-#include <qdatetime.h>
-#include <qdir.h>
-#include <qfileinfo.h>
 #include <qregexp.h>
+#include <qfileinfo.h>
+#include <qdir.h>
+#include <qdatetime.h>
+#include <qcache.h>
 
-#include "arguments.h"
-#include "bufstr.h"
+#include "util.h"
+#include "message.h"
 #include "classdef.h"
-#include "classlist.h"
-#include "config.h"
-#include "debug.h"
-#include "defargs.h"
-#include "dirdef.h"
-#include "doxygen.h"
+#include "filedef.h"
 #include "doxygen.h"
-#include "entry.h"
+#include "outputlist.h"
+#include "defargs.h"
+#include "language.h"
+#include "config.h"
+#include "htmlhelp.h"
 #include "example.h"
-#include "filedef.h"
-#include "filename.h"
+#include "version.h"
 #include "groupdef.h"
-#include "growbuf.h"
-#include "htmlentity.h"
-#include "htmlhelp.h"
-#include "image.h"
-#include "language.h"
-#include "membergroup.h"
-#include "memberlist.h"
-#include "membername.h"
-#include "message.h"
-#include "namespacedef.h"
-#include "outputlist.h"
-#include "pagedef.h"
-#include "parserintf.h"
-#include "portable.h"
-#include "prologscanner.h"
 #include "reflist.h"
+#include "pagedef.h"
+#include "debug.h"
 #include "searchindex.h"
+#include "doxygen.h"
 #include "textdocvisitor.h"
-#include "util.h"
-#include "version.h"
+#include "portable.h"
+#include "parserintf.h"
+#include "bufstr.h"
+#include "image.h"
+#include "growbuf.h"
+#include "entry.h"
+#include "arguments.h"
+#include "memberlist.h"
+#include "classlist.h"
+#include "namespacedef.h"
+#include "membername.h"
+#include "filename.h"
+#include "membergroup.h"
+#include "dirdef.h"
+#include "htmlentity.h"
 
 #define ENABLE_TRACINGSUPPORT 0
 
@@ -76,6 +74,7 @@
 #include <unistd.h>
 #endif
 
+
 //------------------------------------------------------------------------
 
 // selects one of the name to sub-dir mapping algorithms that is used
@@ -83,8 +82,8 @@
 
 #define ALGO_COUNT 1
 #define ALGO_CRC16 2
-#define ALGO_MD5 3
-
+#define ALGO_MD5   3
+    
 //#define MAP_ALGO ALGO_COUNT
 //#define MAP_ALGO ALGO_CRC16
 #define MAP_ALGO ALGO_MD5
@@ -95,52 +94,60 @@
 // TextGeneratorOLImpl implementation
 //------------------------------------------------------------------------
 
-TextGeneratorOLImpl::TextGeneratorOLImpl(OutputDocInterface &od) : m_od(od) {}
+TextGeneratorOLImpl::TextGeneratorOLImpl(OutputDocInterface &od) : m_od(od) 
+{
+}
 
-void TextGeneratorOLImpl::writeString(const char *s, bool keepSpaces) const {
-  if (s == 0)
-    return;
-  // printf("TextGeneratorOlImpl::writeString('%s',%d)\n",s,keepSpaces);
-  if (keepSpaces) {
-    const char *p = s;
-    if (p) {
+void TextGeneratorOLImpl::writeString(const char *s,bool keepSpaces) const
+{ 
+  if (s==0) return;
+  //printf("TextGeneratorOlImpl::writeString('%s',%d)\n",s,keepSpaces);
+  if (keepSpaces)
+  {
+    const char *p=s;
+    if (p)
+    {
       char cs[2];
       char c;
-      cs[1] = '\0';
-      while ((c = *p++)) {
-        if (c == ' ')
-          m_od.writeNonBreakableSpace(1);
-        else
-          cs[0] = c, m_od.docify(cs);
+      cs[1]='\0';
+      while ((c=*p++))
+      {
+        if (c==' ') m_od.writeNonBreakableSpace(1); 
+        else cs[0]=c,m_od.docify(cs);
       }
     }
-  } else {
-    m_od.docify(s);
+  }
+  else
+  {
+    m_od.docify(s); 
   }
 }
 
-void TextGeneratorOLImpl::writeBreak(int indent) const {
+void TextGeneratorOLImpl::writeBreak(int indent) const
+{ 
   m_od.lineBreak("typebreak");
   int i;
-  for (i = 0; i < indent; i++) {
+  for (i=0;i<indent;i++)
+  {
     m_od.writeNonBreakableSpace(3);
   }
 }
 
-void TextGeneratorOLImpl::writeLink(const char *extRef, const char *file,
-                                    const char *anchor,
-                                    const char *text) const {
-  // printf("TextGeneratorOlImpl::writeLink('%s')\n",text);
-  m_od.writeObjectLink(extRef, file, anchor, text);
+void TextGeneratorOLImpl::writeLink(const char *extRef,const char *file,
+                                    const char *anchor,const char *text
+                                   ) const
+{
+  //printf("TextGeneratorOlImpl::writeLink('%s')\n",text);
+  m_od.writeObjectLink(extRef,file,anchor,text);
 }
 
 //------------------------------------------------------------------------
 //------------------------------------------------------------------------
 
 // an inheritance tree of depth of 100000 should be enough for everyone :-)
-const int maxInheritanceDepth = 100000;
+const int maxInheritanceDepth = 100000; 
 
-/*!
+/*! 
   Removes all anonymous scopes from string s
   Possible examples:
 \verbatim
@@ -154,94 +161,100 @@ const int maxInheritanceDepth = 100000;
    "bla @1"              => "bla"
 \endverbatim
  */
-QCString removeAnonymousScopes(const QCString &s) {
+QCString removeAnonymousScopes(const QCString &s)
+{
   QCString result;
-  if (s.isEmpty())
-    return result;
+  if (s.isEmpty()) return result;
   static QRegExp re("[ :]*@[0-9]+[: ]*");
-  int i, l, sl = s.length();
-  int p = 0;
-  while ((i = re.match(s, p, &l)) != -1) {
-    result += s.mid(p, i - p);
-    int c = i;
-    bool b1 = FALSE, b2 = FALSE;
-    while (c < i + l && s.at(c) != '@')
-      if (s.at(c++) == ':')
-        b1 = TRUE;
-    c = i + l - 1;
-    while (c >= i && s.at(c) != '@')
-      if (s.at(c--) == ':')
-        b2 = TRUE;
-    if (b1 && b2) {
-      result += "::";
-    }
-    p = i + l;
-  }
-  result += s.right(sl - p);
-  // printf("removeAnonymousScopes(`%s')=`%s'\n",s.data(),result.data());
+  int i,l,sl=s.length();
+  int p=0;
+  while ((i=re.match(s,p,&l))!=-1)
+  {
+    result+=s.mid(p,i-p);
+    int c=i;
+    bool b1=FALSE,b2=FALSE;
+    while (c<i+l && s.at(c)!='@') if (s.at(c++)==':') b1=TRUE;
+    c=i+l-1;
+    while (c>=i && s.at(c)!='@') if (s.at(c--)==':') b2=TRUE;
+    if (b1 && b2) 
+    { 
+      result+="::"; 
+    }
+    p=i+l;
+  }
+  result+=s.right(sl-p);
+  //printf("removeAnonymousScopes(`%s')=`%s'\n",s.data(),result.data());
   return result;
 }
 
 // replace anonymous scopes with __anonymous__ or replacement if provided
-QCString replaceAnonymousScopes(const QCString &s, const char *replacement) {
+QCString replaceAnonymousScopes(const QCString &s,const char *replacement)
+{
   QCString result;
-  if (s.isEmpty())
-    return result;
+  if (s.isEmpty()) return result;
   static QRegExp re("@[0-9]+");
-  int i, l, sl = s.length();
-  int p = 0;
-  while ((i = re.match(s, p, &l)) != -1) {
-    result += s.mid(p, i - p);
-    if (replacement) {
-      result += replacement;
-    } else {
-      result += "__anonymous__";
-    }
-    p = i + l;
-  }
-  result += s.right(sl - p);
-  // printf("replaceAnonymousScopes(`%s')=`%s'\n",s.data(),result.data());
+  int i,l,sl=s.length();
+  int p=0;
+  while ((i=re.match(s,p,&l))!=-1)
+  {
+    result+=s.mid(p,i-p);
+    if (replacement)
+    {
+      result+=replacement;
+    }
+    else
+    {
+      result+="__anonymous__";
+    }
+    p=i+l;
+  }
+  result+=s.right(sl-p);
+  //printf("replaceAnonymousScopes(`%s')=`%s'\n",s.data(),result.data());
   return result;
 }
 
+
 // strip anonymous left hand side part of the scope
-QCString stripAnonymousNamespaceScope(const QCString &s) {
-  int i, p = 0, l;
+QCString stripAnonymousNamespaceScope(const QCString &s)
+{
+  int i,p=0,l;
   QCString newScope;
   int sl = s.length();
-  while ((i = getScopeFragment(s, p, &l)) != -1) {
-    // printf("Scope fragment %s\n",s.mid(i,l).data());
-    if (Doxygen::namespaceSDict->find(s.left(i + l)) != 0) {
-      if (s.at(i) != '@') {
-        if (!newScope.isEmpty())
-          newScope += "::";
-        newScope += s.mid(i, l);
-      }
-    } else if (i < sl) {
-      if (!newScope.isEmpty())
-        newScope += "::";
-      newScope += s.right(sl - i);
+  while ((i=getScopeFragment(s,p,&l))!=-1)
+  {
+    //printf("Scope fragment %s\n",s.mid(i,l).data());
+    if (Doxygen::namespaceSDict->find(s.left(i+l))!=0)
+    {
+      if (s.at(i)!='@')
+      {
+        if (!newScope.isEmpty()) newScope+="::";
+        newScope+=s.mid(i,l);
+      }
+    }
+    else if (i<sl)
+    {
+      if (!newScope.isEmpty()) newScope+="::";
+      newScope+=s.right(sl-i);
       goto done;
     }
-    p = i + l;
+    p=i+l;
   }
 done:
-  // printf("stripAnonymousNamespaceScope(`%s')=`%s'\n",s.data(),newScope.data());
+  //printf("stripAnonymousNamespaceScope(`%s')=`%s'\n",s.data(),newScope.data());
   return newScope;
 }
 
-void writePageRef(OutputDocInterface &od, const char *cn, const char *mn) {
+void writePageRef(OutputDocInterface &od,const char *cn,const char *mn)
+{
   od.pushGeneratorState();
-
+  
   od.disable(OutputGenerator::Html);
   od.disable(OutputGenerator::Man);
-  if (Config_getBool(PDF_HYPERLINKS))
-    od.disable(OutputGenerator::Latex);
-  if (Config_getBool(RTF_HYPERLINKS))
-    od.disable(OutputGenerator::RTF);
+  if (Config_getBool(PDF_HYPERLINKS)) od.disable(OutputGenerator::Latex);
+  if (Config_getBool(RTF_HYPERLINKS)) od.disable(OutputGenerator::RTF);
   od.startPageRef();
   od.docify(theTranslator->trPageAbbreviation());
-  od.endPageRef(cn, mn);
+  od.endPageRef(cn,mn);
 
   od.popGeneratorState();
 }
@@ -250,146 +263,171 @@ void writePageRef(OutputDocInterface &od, const char *cn, const char *mn) {
  *  translators to be able to specify different elements orders
  *  depending on whether text flows from left to right or visa versa.
  */
-QCString generateMarker(int id) {
+QCString generateMarker(int id)
+{
   const int maxMarkerStrLen = 20;
   char result[maxMarkerStrLen];
-  qsnprintf(result, maxMarkerStrLen, "@%d", id);
+  qsnprintf(result,maxMarkerStrLen,"@%d",id);
   return result;
 }
 
-static QCString stripFromPath(const QCString &path, QStrList &l) {
-  // look at all the strings in the list and strip the longest match
-  const char *s = l.first();
+static QCString stripFromPath(const QCString &path,QStrList &l)
+{
+  // look at all the strings in the list and strip the longest match  
+  const char *s=l.first();
   QCString potential;
   unsigned int length = 0;
-  while (s) {
+  while (s)
+  {
     QCString prefix = s;
     if (prefix.length() > length &&
-        qstricmp(path.left(prefix.length()), prefix) ==
-            0) // case insensitive compare
+        qstricmp(path.left(prefix.length()),prefix)==0) // case insensitive compare
     {
       length = prefix.length();
-      potential = path.right(path.length() - prefix.length());
+      potential = path.right(path.length()-prefix.length());
     }
     s = l.next();
   }
-  if (length)
-    return potential;
+  if (length) return potential;
   return path;
 }
 
 /*! strip part of \a path if it matches
  *  one of the paths in the Config_getList(STRIP_FROM_PATH) list
  */
-QCString stripFromPath(const QCString &path) {
-  return stripFromPath(path, Config_getList(STRIP_FROM_PATH));
+QCString stripFromPath(const QCString &path)
+{
+  return stripFromPath(path,Config_getList(STRIP_FROM_PATH));
 }
 
 /*! strip part of \a path if it matches
  *  one of the paths in the Config_getList(INCLUDE_PATH) list
  */
-QCString stripFromIncludePath(const QCString &path) {
-  return stripFromPath(path, Config_getList(STRIP_FROM_INC_PATH));
+QCString stripFromIncludePath(const QCString &path)
+{
+  return stripFromPath(path,Config_getList(STRIP_FROM_INC_PATH));
 }
 
 /*! try to determine if \a name is a source or a header file name by looking
- * at the extension. A number of variations is allowed in both upper and
+ * at the extension. A number of variations is allowed in both upper and 
  * lower case) If anyone knows or uses another extension please let me know :-)
  */
-int guessSection(const char *name) {
-  QCString n = ((QCString)name).lower();
-  if (n.right(2) == ".c" || // source
-      n.right(3) == ".cc" || n.right(4) == ".cxx" || n.right(4) == ".cpp" ||
-      n.right(4) == ".c++" || n.right(5) == ".java" || n.right(2) == ".m" ||
-      n.right(2) == ".M" || n.right(3) == ".mm" ||
-      n.right(3) == ".ii" || // inline
-      n.right(4) == ".ixx" || n.right(4) == ".ipp" || n.right(4) == ".i++" ||
-      n.right(4) == ".inl" || n.right(4) == ".xml")
-    return Entry::SOURCE_SEC;
-  if (n.right(2) == ".h" || // header
-      n.right(3) == ".hh" || n.right(4) == ".hxx" || n.right(4) == ".hpp" ||
-      n.right(4) == ".h++" || n.right(4) == ".idl" || n.right(4) == ".ddl" ||
-      n.right(5) == ".pidl")
-    return Entry::HEADER_SEC;
+int guessSection(const char *name)
+{
+  QCString n=((QCString)name).lower();
+  if (n.right(2)==".c"    || // source
+      n.right(3)==".cc"   ||
+      n.right(4)==".cxx"  ||
+      n.right(4)==".cpp"  ||
+      n.right(4)==".c++"  ||
+      n.right(5)==".java" ||
+      n.right(2)==".m"    ||
+      n.right(2)==".M"    ||
+      n.right(3)==".mm"   ||
+      n.right(3)==".ii"   || // inline
+      n.right(4)==".ixx"  ||
+      n.right(4)==".ipp"  ||
+      n.right(4)==".i++"  ||
+      n.right(4)==".inl"  ||
+      n.right(4)==".xml" 
+     ) return Entry::SOURCE_SEC;
+  if (n.right(2)==".h"   || // header
+      n.right(3)==".hh"  ||
+      n.right(4)==".hxx" ||
+      n.right(4)==".hpp" ||
+      n.right(4)==".h++" ||
+      n.right(4)==".idl" ||
+      n.right(4)==".ddl" ||
+      n.right(5)==".pidl"
+     ) return Entry::HEADER_SEC;
   return 0;
 }
 
-QCString resolveTypeDef(Definition *context, const QCString &qualifiedName,
-                        Definition **typedefContext) {
-  // printf("<<resolveTypeDef(%s,%s)\n",
+QCString resolveTypeDef(Definition *context,const QCString &qualifiedName,
+                        Definition **typedefContext)
+{
+  //printf("<<resolveTypeDef(%s,%s)\n",
   //          context ? context->name().data() : "<none>",qualifiedName.data());
   QCString result;
-  if (qualifiedName.isEmpty()) {
-    // printf("  qualified name empty!\n");
+  if (qualifiedName.isEmpty()) 
+  {
+    //printf("  qualified name empty!\n");
     return result;
   }
 
-  Definition *mContext = context;
-  if (typedefContext)
-    *typedefContext = context;
+  Definition *mContext=context;
+  if (typedefContext) *typedefContext=context;
 
   // see if the qualified name has a scope part
   int scopeIndex = qualifiedName.findRev("::");
-  QCString resName = qualifiedName;
-  if (scopeIndex != -1) // strip scope part for the name
+  QCString resName=qualifiedName;
+  if (scopeIndex!=-1) // strip scope part for the name
   {
-    resName = qualifiedName.right(qualifiedName.length() - scopeIndex - 2);
-    if (resName.isEmpty()) {
+    resName=qualifiedName.right(qualifiedName.length()-scopeIndex-2);
+    if (resName.isEmpty())
+    {
       // qualifiedName was of form A:: !
-      // printf("  qualified name of form A::!\n");
+      //printf("  qualified name of form A::!\n");
       return result;
     }
   }
-  MemberDef *md = 0;
-  while (mContext && md == 0) {
+  MemberDef *md=0;
+  while (mContext && md==0)
+  {
     // step 1: get the right scope
-    Definition *resScope = mContext;
-    if (scopeIndex != -1) {
+    Definition *resScope=mContext;
+    if (scopeIndex!=-1) 
+    {
       // split-off scope part
       QCString resScopeName = qualifiedName.left(scopeIndex);
-      // printf("resScopeName=`%s'\n",resScopeName.data());
+      //printf("resScopeName=`%s'\n",resScopeName.data());
 
       // look-up scope in context
-      int is, ps = 0;
+      int is,ps=0;
       int l;
-      while ((is = getScopeFragment(resScopeName, ps, &l)) != -1) {
-        QCString qualScopePart = resScopeName.mid(is, l);
-        QCString tmp = resolveTypeDef(mContext, qualScopePart);
-        if (!tmp.isEmpty())
-          qualScopePart = tmp;
+      while ((is=getScopeFragment(resScopeName,ps,&l))!=-1)
+      {
+        QCString qualScopePart = resScopeName.mid(is,l);
+        QCString tmp = resolveTypeDef(mContext,qualScopePart);
+        if (!tmp.isEmpty()) qualScopePart=tmp;
         resScope = resScope->findInnerCompound(qualScopePart);
-        // printf("qualScopePart=`%s'
-        // resScope=%p\n",qualScopePart.data(),resScope);
-        if (resScope == 0)
-          break;
-        ps = is + l;
+        //printf("qualScopePart=`%s' resScope=%p\n",qualScopePart.data(),resScope);
+        if (resScope==0) break;
+        ps=is+l;
       }
     }
-    // printf("resScope=%s\n",resScope?resScope->name().data():"<none>");
-
+    //printf("resScope=%s\n",resScope?resScope->name().data():"<none>");
+    
     // step 2: get the member
-    if (resScope) // no scope or scope found in the current context
+    if (resScope) // no scope or scope found in the current context 
     {
-      // printf("scope found: %s, look for typedef %s\n",
+      //printf("scope found: %s, look for typedef %s\n",
       //     resScope->qualifiedName().data(),resName.data());
-      MemberNameSDict *mnd = 0;
-      if (resScope->definitionType() == Definition::TypeClass) {
-        mnd = Doxygen::memberNameSDict;
-      } else {
-        mnd = Doxygen::functionNameSDict;
-      }
-      MemberName *mn = mnd->find(resName);
-      if (mn) {
+      MemberNameSDict *mnd=0;
+      if (resScope->definitionType()==Definition::TypeClass)
+      {
+        mnd=Doxygen::memberNameSDict;
+      }
+      else
+      {
+        mnd=Doxygen::functionNameSDict;
+      }
+      MemberName *mn=mnd->find(resName);
+      if (mn)
+      {
         MemberNameIterator mni(*mn);
-        MemberDef *tmd = 0;
-        int minDist = -1;
-        for (; (tmd = mni.current()); ++mni) {
-          // printf("Found member %s resScope=%s outerScope=%s mContext=%p\n",
-          //    tmd->name().data(), resScope->name().data(),
+        MemberDef *tmd=0;
+        int minDist=-1;
+        for (;(tmd=mni.current());++mni)
+        {
+          //printf("Found member %s resScope=%s outerScope=%s mContext=%p\n",
+          //    tmd->name().data(), resScope->name().data(), 
           //    tmd->getOuterScope()->name().data(), mContext);
-          if (tmd->isTypedef() /*&& tmd->getOuterScope()==resScope*/) {
-            int dist = isAccessibleFrom(resScope, 0, tmd);
-            if (dist != -1 && (md == 0 || dist < minDist)) {
+          if (tmd->isTypedef() /*&& tmd->getOuterScope()==resScope*/)
+          {
+            int dist=isAccessibleFrom(resScope,0,tmd);
+            if (dist!=-1 && (md==0 || dist<minDist))
+            {
               md = tmd;
               minDist = dist;
             }
@@ -397,42 +435,46 @@ QCString resolveTypeDef(Definition *context, const QCString &qualifiedName,
         }
       }
     }
-    mContext = mContext->getOuterScope();
+    mContext=mContext->getOuterScope();
   }
 
   // step 3: get the member's type
-  if (md) {
-    // printf(">>resolveTypeDef: Found typedef name `%s' in scope `%s'
-    // value=`%s' args='%s'\n",
+  if (md)
+  {
+    //printf(">>resolveTypeDef: Found typedef name `%s' in scope `%s' value=`%s' args='%s'\n",
     //    qualifiedName.data(),context->name().data(),md->typeString(),md->argsString()
     //    );
-    result = md->typeString();
+    result=md->typeString();
     QCString args = md->argsString();
-    if (args.find(")(") != -1) // typedef of a function/member pointer
+    if (args.find(")(")!=-1) // typedef of a function/member pointer
     {
-      result += args;
-    } else if (args.find('[') != -1) // typedef of an array
+      result+=args;
+    }
+    else if (args.find('[')!=-1) // typedef of an array
     {
-      result += args;
+      result+=args;
     }
-    if (typedefContext)
-      *typedefContext = md->getOuterScope();
-  } else {
-    // printf(">>resolveTypeDef: Typedef `%s' not found in scope `%s'!\n",
+    if (typedefContext) *typedefContext=md->getOuterScope();
+  }
+  else
+  {
+    //printf(">>resolveTypeDef: Typedef `%s' not found in scope `%s'!\n",
     //    qualifiedName.data(),context ? context->name().data() : "<global>");
   }
   return result;
+  
 }
 
-/*! Get a class definition given its name.
+
+/*! Get a class definition given its name. 
  *  Returns 0 if the class is not found.
  */
-ClassDef *getClass(const char *n) {
-  if (n == 0 || n[0] == '\0')
-    return 0;
-  QCString name = n;
+ClassDef *getClass(const char *n)
+{
+  if (n==0 || n[0]=='\0') return 0;
+  QCString name=n;
   ClassDef *result = Doxygen::classSDict->find(name);
-  // if (result==0 && !exact) // also try generic and protocol versions
+  //if (result==0 && !exact) // also try generic and protocol versions
   //{
   //  result = Doxygen::classSDict->find(name+"-g");
   //  if (result==0)
@@ -440,27 +482,31 @@ ClassDef *getClass(const char *n) {
   //    result = Doxygen::classSDict->find(name+"-p");
   //  }
   //}
-  // printf("getClass(%s)=%s\n",n,result?result->name().data():"<none>");
+  //printf("getClass(%s)=%s\n",n,result?result->name().data():"<none>");
   return result;
 }
 
-NamespaceDef *getResolvedNamespace(const char *name) {
-  if (name == 0 || name[0] == '\0')
-    return 0;
+NamespaceDef *getResolvedNamespace(const char *name)
+{
+  if (name==0 || name[0]=='\0') return 0;
   QCString *subst = Doxygen::namespaceAliasDict[name];
-  if (subst) {
-    int count = 0; // recursion detection guard
+  if (subst)
+  {
+    int count=0; // recursion detection guard
     QCString *newSubst;
-    while ((newSubst = Doxygen::namespaceAliasDict[*subst]) && count < 10) {
-      subst = newSubst;
+    while ((newSubst=Doxygen::namespaceAliasDict[*subst]) && count<10)
+    {
+      subst=newSubst;
       count++;
     }
-    if (count == 10) {
-      warn_uncond("possible recursive namespace alias detected for %s!\n",
-                  name);
+    if (count==10)
+    {
+      warn_uncond("possible recursive namespace alias detected for %s!\n",name);
     }
     return Doxygen::namespaceSDict->find(subst->data());
-  } else {
+  }
+  else
+  {
     return Doxygen::namespaceSDict->find(name);
   }
 }
@@ -469,219 +515,228 @@ static QDict<MemberDef> g_resolvedTypedefs;
 static QDict<Definition> g_visitedNamespaces;
 
 // forward declaration
-static ClassDef *getResolvedClassRec(Definition *scope, FileDef *fileScope,
-                                     const char *n, MemberDef **pTypeDef,
-                                     QCString *pTemplSpec,
-                                     QCString *pResolvedType);
-int isAccessibleFromWithExpScope(Definition *scope, FileDef *fileScope,
-                                 Definition *item,
-                                 const QCString &explicitScopePart);
+static ClassDef *getResolvedClassRec(Definition *scope,
+                              FileDef *fileScope,
+                              const char *n,
+                              MemberDef **pTypeDef,
+                              QCString *pTemplSpec,
+                              QCString *pResolvedType
+                             );
+int isAccessibleFromWithExpScope(Definition *scope,FileDef *fileScope,Definition *item,
+                     const QCString &explicitScopePart);
 
 /*! Returns the class representing the value of the typedef represented by \a md
  *  within file \a fileScope.
  *
  *  Example: typedef A T; will return the class representing A if it is a class.
- *
+ * 
  *  Example: typedef int T; will return 0, since "int" is not a class.
  */
-ClassDef *newResolveTypedef(FileDef *fileScope, MemberDef *md,
-                            MemberDef **pMemType, QCString *pTemplSpec,
+ClassDef *newResolveTypedef(FileDef *fileScope,MemberDef *md,
+                            MemberDef **pMemType,QCString *pTemplSpec,
                             QCString *pResolvedType,
-                            ArgumentList *actTemplParams) {
-  // printf("newResolveTypedef(md=%p,cachedVal=%p)\n",md,md->getCachedTypedefVal());
+                            ArgumentList *actTemplParams)
+{
+  //printf("newResolveTypedef(md=%p,cachedVal=%p)\n",md,md->getCachedTypedefVal());
   bool isCached = md->isTypedefValCached(); // value already cached
-  if (isCached) {
-    // printf("Already cached %s->%s [%s]\n",
+  if (isCached)
+  {
+    //printf("Already cached %s->%s [%s]\n",
     //    md->name().data(),
     //    md->getCachedTypedefVal()?md->getCachedTypedefVal()->name().data():"<none>",
     //    md->getCachedResolvedTypedef()?md->getCachedResolvedTypedef().data():"<none>");
 
-    if (pTemplSpec)
-      *pTemplSpec = md->getCachedTypedefTemplSpec();
-    if (pResolvedType)
-      *pResolvedType = md->getCachedResolvedTypedef();
+    if (pTemplSpec)    *pTemplSpec    = md->getCachedTypedefTemplSpec();
+    if (pResolvedType) *pResolvedType = md->getCachedResolvedTypedef();
     return md->getCachedTypedefVal();
   }
-  // printf("new typedef\n");
+  //printf("new typedef\n");
   QCString qname = md->qualifiedName();
-  if (g_resolvedTypedefs.find(qname))
-    return 0; // typedef already done
-
-  g_resolvedTypedefs.insert(qname, md); // put on the trace list
+  if (g_resolvedTypedefs.find(qname)) return 0; // typedef already done
 
+  g_resolvedTypedefs.insert(qname,md); // put on the trace list
+  
   ClassDef *typeClass = md->getClassDef();
   QCString type = md->typeString(); // get the "value" of the typedef
-  if (typeClass && typeClass->isTemplate() && actTemplParams &&
-      actTemplParams->count() > 0) {
-    type = substituteTemplateArgumentsInString(
-        type, typeClass->templateArguments(), actTemplParams);
+  if (typeClass && typeClass->isTemplate() && 
+      actTemplParams && actTemplParams->count()>0)
+  {
+    type = substituteTemplateArgumentsInString(type,
+            typeClass->templateArguments(),actTemplParams);
   }
   QCString typedefValue = type;
-  int tl = type.length();
-  int ip = tl - 1; // remove * and & at the end
-  while (ip >= 0 &&
-         (type.at(ip) == '*' || type.at(ip) == '&' || type.at(ip) == ' ')) {
+  int tl=type.length();
+  int ip=tl-1; // remove * and & at the end
+  while (ip>=0 && (type.at(ip)=='*' || type.at(ip)=='&' || type.at(ip)==' ')) 
+  {
     ip--;
   }
-  type = type.left(ip + 1);
+  type=type.left(ip+1);
   type.stripPrefix("const ");  // strip leading "const"
   type.stripPrefix("struct "); // strip leading "struct"
   type.stripPrefix("union ");  // strip leading "union"
-  int sp = 0;
-  tl = type.length(); // length may have been changed
-  while (sp < tl && type.at(sp) == ' ')
-    sp++;
+  int sp=0;
+  tl=type.length(); // length may have been changed
+  while (sp<tl && type.at(sp)==' ') sp++;
   MemberDef *memTypeDef = 0;
-  ClassDef *result = getResolvedClassRec(md->getOuterScope(), fileScope, type,
-                                         &memTypeDef, 0, pResolvedType);
+  ClassDef  *result = getResolvedClassRec(md->getOuterScope(),
+                                  fileScope,type,&memTypeDef,0,pResolvedType);
   // if type is a typedef then return what it resolves to.
-  if (memTypeDef && memTypeDef->isTypedef()) {
-    result = newResolveTypedef(fileScope, memTypeDef, pMemType, pTemplSpec);
+  if (memTypeDef && memTypeDef->isTypedef()) 
+  {
+    result=newResolveTypedef(fileScope,memTypeDef,pMemType,pTemplSpec);
     goto done;
-  } else if (memTypeDef && memTypeDef->isEnumerate() && pMemType) {
+  }
+  else if (memTypeDef && memTypeDef->isEnumerate() && pMemType)
+  {
     *pMemType = memTypeDef;
   }
 
-  // printf("type=%s result=%p\n",type.data(),result);
-  if (result == 0) {
+  //printf("type=%s result=%p\n",type.data(),result);
+  if (result==0)
+  {
     // try unspecialized version if type is template
-    int si = type.findRev("::");
-    int i = type.find('<');
-    if (si == -1 &&
-        i != -1) // typedef of a template => try the unspecialized version
-    {
-      if (pTemplSpec)
-        *pTemplSpec = type.mid(i);
-      result = getResolvedClassRec(md->getOuterScope(), fileScope, type.left(i),
-                                   0, 0, pResolvedType);
-      // printf("result=%p pRresolvedType=%s sp=%d ip=%d tl=%d\n",
+    int si=type.findRev("::");
+    int i=type.find('<');
+    if (si==-1 && i!=-1) // typedef of a template => try the unspecialized version
+    {
+      if (pTemplSpec) *pTemplSpec = type.mid(i);
+      result = getResolvedClassRec(md->getOuterScope(),fileScope,
+                                   type.left(i),0,0,pResolvedType);
+      //printf("result=%p pRresolvedType=%s sp=%d ip=%d tl=%d\n",
       //    result,pResolvedType?pResolvedType->data():"<none>",sp,ip,tl);
-    } else if (si != -1) // A::B
+    }
+    else if (si!=-1) // A::B
     {
-      i = type.find('<', si);
-      if (i == -1) // Something like A<T>::B => lookup A::B
+      i=type.find('<',si);
+      if (i==-1) // Something like A<T>::B => lookup A::B
       {
-        i = type.length();
-      } else // Something like A<T>::B<S> => lookup A::B, spec=<S>
+        i=type.length();
+      }
+      else // Something like A<T>::B<S> => lookup A::B, spec=<S>
       {
-        if (pTemplSpec)
-          *pTemplSpec = type.mid(i);
+        if (pTemplSpec) *pTemplSpec = type.mid(i);
       }
-      result = getResolvedClassRec(
-          md->getOuterScope(), fileScope,
-          stripTemplateSpecifiersFromScope(type.left(i), FALSE), 0, 0,
-          pResolvedType);
+      result = getResolvedClassRec(md->getOuterScope(),fileScope,
+           stripTemplateSpecifiersFromScope(type.left(i),FALSE),0,0,
+           pResolvedType);
     }
 
-    // if (result) ip=si+sp+1;
+    //if (result) ip=si+sp+1;
   }
 
 done:
-  if (pResolvedType) {
-    if (result) {
-      *pResolvedType = result->qualifiedName();
-      // printf("*pResolvedType=%s\n",pResolvedType->data());
-      if (sp > 0)
-        pResolvedType->prepend(typedefValue.left(sp));
-      if (ip < tl - 1)
-        pResolvedType->append(typedefValue.right(tl - ip - 1));
-    } else {
-      *pResolvedType = typedefValue;
+  if (pResolvedType)
+  {
+    if (result)
+    {
+      *pResolvedType=result->qualifiedName();
+      //printf("*pResolvedType=%s\n",pResolvedType->data());
+      if (sp>0)    pResolvedType->prepend(typedefValue.left(sp));
+      if (ip<tl-1) pResolvedType->append(typedefValue.right(tl-ip-1));
+    }
+    else
+    {
+      *pResolvedType=typedefValue;
     }
   }
 
   // remember computed value for next time
-  if (result && result->getDefFileName() != "<code>")
-  // this check is needed to prevent that temporary classes that are
-  // introduced while parsing code fragments are being cached here.
+  if (result && result->getDefFileName()!="<code>") 
+    // this check is needed to prevent that temporary classes that are 
+    // introduced while parsing code fragments are being cached here.
   {
-    // printf("setting cached typedef %p in result %p\n",md,result);
-    // printf("==> %s
-    // (%s,%d)\n",result->name().data(),result->getDefFileName().data(),result->getDefLine());
-    // printf("*pResolvedType=%s\n",pResolvedType?pResolvedType->data():"<none>");
-    md->cacheTypedefVal(result, pTemplSpec ? *pTemplSpec : QCString(),
-                        pResolvedType ? *pResolvedType : QCString());
+    //printf("setting cached typedef %p in result %p\n",md,result);
+    //printf("==> %s (%s,%d)\n",result->name().data(),result->getDefFileName().data(),result->getDefLine());
+    //printf("*pResolvedType=%s\n",pResolvedType?pResolvedType->data():"<none>");
+    md->cacheTypedefVal(result,
+        pTemplSpec ? *pTemplSpec : QCString(),
+        pResolvedType ? *pResolvedType : QCString()
+       );
   }
-
+  
   g_resolvedTypedefs.remove(qname); // remove from the trace list
-
+  
   return result;
 }
 
 /*! Substitutes a simple unqualified \a name within \a scope. Returns the
  *  value of the typedef or \a name if no typedef was found.
  */
-static QCString substTypedef(Definition *scope, FileDef *fileScope,
-                             const QCString &name, MemberDef **pTypeDef = 0) {
-  QCString result = name;
-  if (name.isEmpty())
-    return result;
+static QCString substTypedef(Definition *scope,FileDef *fileScope,const QCString &name,
+            MemberDef **pTypeDef=0)
+{
+  QCString result=name;
+  if (name.isEmpty()) return result;
 
   // lookup scope fragment in the symbol map
   DefinitionIntf *di = Doxygen::symbolMap->find(name);
-  if (di == 0)
-    return result; // no matches
+  if (di==0) return result; // no matches
 
-  MemberDef *bestMatch = 0;
-  if (di->definitionType() == DefinitionIntf::TypeSymbolList) // multi symbols
+  MemberDef *bestMatch=0;
+  if (di->definitionType()==DefinitionIntf::TypeSymbolList) // multi symbols
   {
     // search for the best match
-    DefinitionListIterator dli(*(DefinitionList *)di);
+    DefinitionListIterator dli(*(DefinitionList*)di);
     Definition *d;
-    int minDistance = 10000;                        // init at "infinite"
-    for (dli.toFirst(); (d = dli.current()); ++dli) // foreach definition
+    int minDistance=10000; // init at "infinite"
+    for (dli.toFirst();(d=dli.current());++dli) // foreach definition
     {
       // only look at members
-      if (d->definitionType() == Definition::TypeMember) {
+      if (d->definitionType()==Definition::TypeMember)
+      {
         // that are also typedefs
         MemberDef *md = (MemberDef *)d;
         if (md->isTypedef()) // d is a typedef
         {
           // test accessibility of typedef within scope.
-          int distance = isAccessibleFromWithExpScope(scope, fileScope, d, "");
-          if (distance != -1 && distance < minDistance)
-          // definition is accessible and a better match
+          int distance = isAccessibleFromWithExpScope(scope,fileScope,d,"");
+          if (distance!=-1 && distance<minDistance) 
+            // definition is accessible and a better match
           {
-            minDistance = distance;
-            bestMatch = md;
+            minDistance=distance;
+            bestMatch = md; 
           }
         }
       }
     }
-  } else if (di->definitionType() ==
-             DefinitionIntf::TypeMember) // single symbol
+  }
+  else if (di->definitionType()==DefinitionIntf::TypeMember) // single symbol
   {
-    Definition *d = (Definition *)di;
+    Definition *d = (Definition*)di;
     // that are also typedefs
     MemberDef *md = (MemberDef *)di;
     if (md->isTypedef()) // d is a typedef
     {
       // test accessibility of typedef within scope.
-      int distance = isAccessibleFromWithExpScope(scope, fileScope, d, "");
-      if (distance != -1) // definition is accessible
+      int distance = isAccessibleFromWithExpScope(scope,fileScope,d,"");
+      if (distance!=-1) // definition is accessible 
       {
-        bestMatch = md;
+        bestMatch = md; 
       }
     }
   }
-  if (bestMatch) {
+  if (bestMatch) 
+  {
     result = bestMatch->typeString();
-    if (pTypeDef)
-      *pTypeDef = bestMatch;
+    if (pTypeDef) *pTypeDef=bestMatch;
   }
-
-  // printf("substTypedef(%s,%s)=%s\n",scope?scope->name().data():"<global>",
+  
+  //printf("substTypedef(%s,%s)=%s\n",scope?scope->name().data():"<global>",
   //                                  name.data(),result.data());
   return result;
 }
 
-static Definition *endOfPathIsUsedClass(SDict<Definition> *cl,
-                                        const QCString &localName) {
-  if (cl) {
+static Definition *endOfPathIsUsedClass(SDict<Definition> *cl,const QCString &localName)
+{
+  if (cl)
+  {
     SDict<Definition>::Iterator cli(*cl);
     Definition *cd;
-    for (cli.toFirst(); (cd = cli.current()); ++cli) {
-      if (cd->localName() == localName) {
+    for (cli.toFirst();(cd=cli.current());++cli)
+    {
+      if (cd->localName()==localName)
+      {
         return cd;
       }
     }
@@ -690,117 +745,124 @@ static Definition *endOfPathIsUsedClass(SDict<Definition> *cl,
 }
 
 /*! Starting with scope \a start, the string \a path is interpreted as
- *  a part of a qualified scope name (e.g. A::B::C), and the scope is
- *  searched. If found the scope definition is returned, otherwise 0
+ *  a part of a qualified scope name (e.g. A::B::C), and the scope is 
+ *  searched. If found the scope definition is returned, otherwise 0 
  *  is returned.
  */
-static Definition *followPath(Definition *start, FileDef *fileScope,
-                              const QCString &path) {
-  int is, ps;
+static Definition *followPath(Definition *start,FileDef *fileScope,const QCString &path)
+{
+  int is,ps;
   int l;
-  Definition *current = start;
-  ps = 0;
-  // printf("followPath: start='%s'
-  // path='%s'\n",start?start->name().data():"<none>",path.data());
+  Definition *current=start;
+  ps=0;
+  //printf("followPath: start='%s' path='%s'\n",start?start->name().data():"<none>",path.data());
   // for each part of the explicit scope
-  while ((is = getScopeFragment(path, ps, &l)) != -1) {
+  while ((is=getScopeFragment(path,ps,&l))!=-1)
+  {
     // try to resolve the part if it is a typedef
-    MemberDef *typeDef = 0;
-    QCString qualScopePart =
-        substTypedef(current, fileScope, path.mid(is, l), &typeDef);
-    // printf("      qualScopePart=%s\n",qualScopePart.data());
-    if (typeDef) {
-      ClassDef *type = newResolveTypedef(fileScope, typeDef);
-      if (type) {
-        // printf("Found type %s\n",type->name().data());
+    MemberDef *typeDef=0;
+    QCString qualScopePart = substTypedef(current,fileScope,path.mid(is,l),&typeDef);
+    //printf("      qualScopePart=%s\n",qualScopePart.data());
+    if (typeDef)
+    {
+      ClassDef *type = newResolveTypedef(fileScope,typeDef);
+      if (type)
+      {
+        //printf("Found type %s\n",type->name().data());
         return type;
       }
     }
     Definition *next = current->findInnerCompound(qualScopePart);
-    // printf("++ Looking for %s inside %s result %s\n",
+    //printf("++ Looking for %s inside %s result %s\n",
     //     qualScopePart.data(),
     //     current->name().data(),
     //     next?next->name().data():"<null>");
-    if (next == 0) // failed to follow the path
+    if (next==0) // failed to follow the path 
     {
-      // printf("==> next==0!\n");
-      if (current->definitionType() == Definition::TypeNamespace) {
-        next = endOfPathIsUsedClass(((NamespaceDef *)current)->getUsedClasses(),
-                                    qualScopePart);
-      } else if (current->definitionType() == Definition::TypeFile) {
-        next = endOfPathIsUsedClass(((FileDef *)current)->getUsedClasses(),
-                                    qualScopePart);
+      //printf("==> next==0!\n");
+      if (current->definitionType()==Definition::TypeNamespace)
+      {
+        next = endOfPathIsUsedClass(
+            ((NamespaceDef *)current)->getUsedClasses(),qualScopePart);
+      }
+      else if (current->definitionType()==Definition::TypeFile)
+      {
+        next = endOfPathIsUsedClass(
+            ((FileDef *)current)->getUsedClasses(),qualScopePart);
       }
       current = next;
-      if (current == 0)
-        break;
-    } else // continue to follow scope
+      if (current==0) break;
+    }
+    else // continue to follow scope
     {
       current = next;
-      // printf("==> current = %p\n",current);
+      //printf("==> current = %p\n",current);
     }
-    ps = is + l;
+    ps=is+l;
   }
-  // printf("followPath(start=%s,path=%s) result=%s\n",
+  //printf("followPath(start=%s,path=%s) result=%s\n",
   //    start->name().data(),path.data(),current?current->name().data():"<null>");
   return current; // path could be followed
 }
 
-bool accessibleViaUsingClass(const SDict<Definition> *cl, FileDef *fileScope,
+bool accessibleViaUsingClass(const SDict<Definition> *cl,
+                             FileDef *fileScope,
                              Definition *item,
-                             const QCString &explicitScopePart = "") {
-  // printf("accessibleViaUsingClass(%p)\n",cl);
-  if (cl) // see if the class was imported via a using statement
+                             const QCString &explicitScopePart=""
+                            )
+{
+  //printf("accessibleViaUsingClass(%p)\n",cl);
+  if (cl) // see if the class was imported via a using statement 
   {
     SDict<Definition>::Iterator cli(*cl);
     Definition *ucd;
     bool explicitScopePartEmpty = explicitScopePart.isEmpty();
-    for (cli.toFirst(); (ucd = cli.current()); ++cli) {
-      // printf("Trying via used class %s\n",ucd->name().data());
-      Definition *sc = explicitScopePartEmpty
-                           ? ucd
-                           : followPath(ucd, fileScope, explicitScopePart);
-      if (sc && sc == item)
-        return TRUE;
-      // printf("Try via used class done\n");
+    for (cli.toFirst();(ucd=cli.current());++cli)
+    {
+      //printf("Trying via used class %s\n",ucd->name().data());
+      Definition *sc = explicitScopePartEmpty ? ucd : followPath(ucd,fileScope,explicitScopePart);
+      if (sc && sc==item) return TRUE; 
+      //printf("Try via used class done\n");
     }
   }
   return FALSE;
 }
 
-bool accessibleViaUsingNamespace(const NamespaceSDict *nl, FileDef *fileScope,
+bool accessibleViaUsingNamespace(const NamespaceSDict *nl,
+                                 FileDef *fileScope,
                                  Definition *item,
-                                 const QCString &explicitScopePart = "") {
+                                 const QCString &explicitScopePart="")
+{
   static QDict<void> visitedDict;
   if (nl) // check used namespaces for the class
   {
     NamespaceSDict::Iterator nli(*nl);
     NamespaceDef *und;
-    int count = 0;
-    for (nli.toFirst(); (und = nli.current()); ++nli, count++) {
-      // printf("[Trying via used namespace %s:
-      // count=%d/%d\n",und->name().data(),
+    int count=0;
+    for (nli.toFirst();(und=nli.current());++nli,count++)
+    {
+      //printf("[Trying via used namespace %s: count=%d/%d\n",und->name().data(),
       //    count,nl->count());
-      Definition *sc = explicitScopePart.isEmpty()
-                           ? und
-                           : followPath(und, fileScope, explicitScopePart);
-      if (sc && item->getOuterScope() == sc) {
-        // printf("] found it\n");
-        return TRUE;
+      Definition *sc = explicitScopePart.isEmpty() ? und : followPath(und,fileScope,explicitScopePart);
+      if (sc && item->getOuterScope()==sc) 
+      {
+        //printf("] found it\n");
+        return TRUE; 
       }
-      QCString key = und->name();
-      if (und->getUsedNamespaces() && visitedDict.find(key) == 0) {
-        visitedDict.insert(key, (void *)0x08);
+      QCString key=und->name();
+      if (und->getUsedNamespaces() && visitedDict.find(key)==0)
+      {
+        visitedDict.insert(key,(void *)0x08);
 
-        if (accessibleViaUsingNamespace(und->getUsedNamespaces(), fileScope,
-                                        item, explicitScopePart)) {
-          // printf("] found it via recursion\n");
+        if (accessibleViaUsingNamespace(und->getUsedNamespaces(),fileScope,item,explicitScopePart))
+        {
+          //printf("] found it via recursion\n");
           return TRUE;
         }
 
         visitedDict.remove(key);
       }
-      // printf("] Try via used namespace done\n");
+      //printf("] Try via used namespace done\n");
     }
   }
   return FALSE;
@@ -811,248 +873,274 @@ const int MAX_STACK_SIZE = 1000;
 /** Helper class representing the stack of items considered while resolving
  *  the scope.
  */
-class AccessStack {
-public:
-  AccessStack() : m_index(0) {}
-  void push(Definition *scope, FileDef *fileScope, Definition *item) {
-    if (m_index < MAX_STACK_SIZE) {
-      m_elements[m_index].scope = scope;
-      m_elements[m_index].fileScope = fileScope;
-      m_elements[m_index].item = item;
-      m_index++;
-    }
-  }
-  void push(Definition *scope, FileDef *fileScope, Definition *item,
-            const QCString &expScope) {
-    if (m_index < MAX_STACK_SIZE) {
-      m_elements[m_index].scope = scope;
-      m_elements[m_index].fileScope = fileScope;
-      m_elements[m_index].item = item;
-      m_elements[m_index].expScope = expScope;
-      m_index++;
-    }
-  }
-  void pop() {
-    if (m_index > 0)
-      m_index--;
-  }
-  bool find(Definition *scope, FileDef *fileScope, Definition *item) {
-    int i = 0;
-    for (i = 0; i < m_index; i++) {
-      AccessElem *e = &m_elements[i];
-      if (e->scope == scope && e->fileScope == fileScope && e->item == item) {
-        return TRUE;
+class AccessStack
+{
+  public:
+    AccessStack() : m_index(0) {}
+    void push(Definition *scope,FileDef *fileScope,Definition *item)
+    {
+      if (m_index<MAX_STACK_SIZE)
+      {
+        m_elements[m_index].scope     = scope;
+        m_elements[m_index].fileScope = fileScope;
+        m_elements[m_index].item      = item;
+        m_index++;
       }
     }
-    return FALSE;
-  }
-  bool find(Definition *scope, FileDef *fileScope, Definition *item,
-            const QCString &expScope) {
-    int i = 0;
-    for (i = 0; i < m_index; i++) {
-      AccessElem *e = &m_elements[i];
-      if (e->scope == scope && e->fileScope == fileScope && e->item == item &&
-          e->expScope == expScope) {
-        return TRUE;
+    void push(Definition *scope,FileDef *fileScope,Definition *item,const QCString &expScope)
+    {
+      if (m_index<MAX_STACK_SIZE)
+      {
+        m_elements[m_index].scope     = scope;
+        m_elements[m_index].fileScope = fileScope;
+        m_elements[m_index].item      = item;
+        m_elements[m_index].expScope  = expScope;
+        m_index++;
       }
     }
-    return FALSE;
-  }
+    void pop()
+    {
+      if (m_index>0) m_index--;
+    }
+    bool find(Definition *scope,FileDef *fileScope, Definition *item)
+    {
+      int i=0;
+      for (i=0;i<m_index;i++)
+      {
+        AccessElem *e = &m_elements[i];
+        if (e->scope==scope && e->fileScope==fileScope && e->item==item) 
+        {
+          return TRUE;
+        }
+      }
+      return FALSE;
+    }
+    bool find(Definition *scope,FileDef *fileScope, Definition *item,const QCString &expScope)
+    {
+      int i=0;
+      for (i=0;i<m_index;i++)
+      {
+        AccessElem *e = &m_elements[i];
+        if (e->scope==scope && e->fileScope==fileScope && e->item==item && e->expScope==expScope) 
+        {
+          return TRUE;
+        }
+      }
+      return FALSE;
+    }
 
-private:
-  /** Element in the stack. */
-  struct AccessElem {
-    Definition *scope;
-    FileDef *fileScope;
-    Definition *item;
-    QCString expScope;
-  };
-  int m_index;
-  AccessElem m_elements[MAX_STACK_SIZE];
+  private:
+    /** Element in the stack. */
+    struct AccessElem
+    {
+      Definition *scope;
+      FileDef *fileScope;
+      Definition *item;
+      QCString expScope;
+    };
+    int m_index;
+    AccessElem m_elements[MAX_STACK_SIZE];
 };
 
 /* Returns the "distance" (=number of levels up) from item to scope, or -1
- * if item in not inside scope.
+ * if item in not inside scope. 
  */
-int isAccessibleFrom(Definition *scope, FileDef *fileScope, Definition *item) {
-  // printf("<isAccesibleFrom(scope=%s,item=%s itemScope=%s)\n",
+int isAccessibleFrom(Definition *scope,FileDef *fileScope,Definition *item)
+{
+  //printf("<isAccesibleFrom(scope=%s,item=%s itemScope=%s)\n",
   //    scope->name().data(),item->name().data(),item->getOuterScope()->name().data());
 
   static AccessStack accessStack;
-  if (accessStack.find(scope, fileScope, item)) {
+  if (accessStack.find(scope,fileScope,item))
+  {
     return -1;
   }
-  accessStack.push(scope, fileScope, item);
+  accessStack.push(scope,fileScope,item);
 
-  int result = 0; // assume we found it
+  int result=0; // assume we found it
   int i;
 
-  Definition *itemScope = item->getOuterScope();
-  bool memberAccessibleFromScope =
-      (item->definitionType() == Definition::TypeMember && // a member
-       itemScope &&
-       itemScope->definitionType() == Definition::TypeClass &&    // of a class
-       scope->definitionType() == Definition::TypeClass &&        // accessible
-       ((ClassDef *)scope)->isAccessibleMember((MemberDef *)item) // from scope
-       );
-  bool nestedClassInsideBaseClass =
-      (item->definitionType() == Definition::TypeClass && // a nested class
-       itemScope &&
-       itemScope->definitionType() == Definition::TypeClass && // inside a base
-       scope->definitionType() == Definition::TypeClass &&     // class of scope
-       ((ClassDef *)scope)->isBaseClass((ClassDef *)itemScope, TRUE));
-
-  if (itemScope == scope || memberAccessibleFromScope ||
-      nestedClassInsideBaseClass) {
-    // printf("> found it\n");
-    if (nestedClassInsideBaseClass)
-      result++; // penalty for base class to prevent
-                // this is preferred over nested class in this class
-                // see bug 686956
-  } else if (scope == Doxygen::globalScope) {
-    if (fileScope) {
+  Definition *itemScope=item->getOuterScope();
+  bool memberAccessibleFromScope = 
+      (item->definitionType()==Definition::TypeMember &&                   // a member
+       itemScope && itemScope->definitionType()==Definition::TypeClass  && // of a class
+       scope->definitionType()==Definition::TypeClass &&                   // accessible
+       ((ClassDef*)scope)->isAccessibleMember((MemberDef *)item)           // from scope
+      );
+  bool nestedClassInsideBaseClass = 
+      (item->definitionType()==Definition::TypeClass &&                    // a nested class
+       itemScope && itemScope->definitionType()==Definition::TypeClass &&  // inside a base 
+       scope->definitionType()==Definition::TypeClass &&                   // class of scope
+       ((ClassDef*)scope)->isBaseClass((ClassDef*)itemScope,TRUE)          
+      );
+
+  if (itemScope==scope || memberAccessibleFromScope || nestedClassInsideBaseClass) 
+  {
+    //printf("> found it\n");
+    if (nestedClassInsideBaseClass) result++; // penalty for base class to prevent
+                                              // this is preferred over nested class in this class
+                                              // see bug 686956
+  }
+  else if (scope==Doxygen::globalScope)
+  {
+    if (fileScope)
+    {
       SDict<Definition> *cl = fileScope->getUsedClasses();
-      if (accessibleViaUsingClass(cl, fileScope, item)) {
-        // printf("> found via used class\n");
+      if (accessibleViaUsingClass(cl,fileScope,item)) 
+      {
+        //printf("> found via used class\n");
         goto done;
       }
       NamespaceSDict *nl = fileScope->getUsedNamespaces();
-      if (accessibleViaUsingNamespace(nl, fileScope, item)) {
-        // printf("> found via used namespace\n");
+      if (accessibleViaUsingNamespace(nl,fileScope,item)) 
+      {
+        //printf("> found via used namespace\n");
         goto done;
       }
     }
-    // printf("> reached global scope\n");
-    result = -1; // not found in path to globalScope
-  } else         // keep searching
+    //printf("> reached global scope\n");
+    result=-1; // not found in path to globalScope
+  }
+  else // keep searching
   {
-    // check if scope is a namespace, which is using other classes and
-    // namespaces
-    if (scope->definitionType() == Definition::TypeNamespace) {
-      NamespaceDef *nscope = (NamespaceDef *)scope;
-      // printf("  %s is namespace with %d used
-      // classes\n",nscope->name().data(),nscope->getUsedClasses());
+    // check if scope is a namespace, which is using other classes and namespaces
+    if (scope->definitionType()==Definition::TypeNamespace)
+    {
+      NamespaceDef *nscope = (NamespaceDef*)scope;
+      //printf("  %s is namespace with %d used classes\n",nscope->name().data(),nscope->getUsedClasses());
       SDict<Definition> *cl = nscope->getUsedClasses();
-      if (accessibleViaUsingClass(cl, fileScope, item)) {
-        // printf("> found via used class\n");
+      if (accessibleViaUsingClass(cl,fileScope,item)) 
+      {
+        //printf("> found via used class\n");
         goto done;
       }
       NamespaceSDict *nl = nscope->getUsedNamespaces();
-      if (accessibleViaUsingNamespace(nl, fileScope, item)) {
-        // printf("> found via used namespace\n");
+      if (accessibleViaUsingNamespace(nl,fileScope,item)) 
+      {
+        //printf("> found via used namespace\n");
         goto done;
       }
     }
     // repeat for the parent scope
-    i = isAccessibleFrom(scope->getOuterScope(), fileScope, item);
-    // printf("> result=%d\n",i);
-    result = (i == -1) ? -1 : i + 2;
+    i=isAccessibleFrom(scope->getOuterScope(),fileScope,item);
+    //printf("> result=%d\n",i);
+    result= (i==-1) ? -1 : i+2;
   }
 done:
   accessStack.pop();
-  // Doxygen::lookupCache.insert(key,new int(result));
+  //Doxygen::lookupCache.insert(key,new int(result));
   return result;
 }
 
+
 /* Returns the "distance" (=number of levels up) from item to scope, or -1
  * if item in not in this scope. The explicitScopePart limits the search
- * to scopes that match \a scope (or its parent scope(s)) plus the explicit
- * part.
+ * to scopes that match \a scope (or its parent scope(s)) plus the explicit part.
  * Example:
  *
  * class A { public: class I {}; };
  * class B { public: class J {}; };
  *
  * - Looking for item=='J' inside scope=='B' will return 0.
- * - Looking for item=='I' inside scope=='B' will return -1
+ * - Looking for item=='I' inside scope=='B' will return -1 
  *   (as it is not found in B nor in the global scope).
- * - Looking for item=='A::I' inside scope=='B', first the match B::A::I is
- * tried but
- *   not found and then A::I is searched in the global scope, which matches and
+ * - Looking for item=='A::I' inside scope=='B', first the match B::A::I is tried but 
+ *   not found and then A::I is searched in the global scope, which matches and 
  *   thus the result is 1.
  */
-int isAccessibleFromWithExpScope(Definition *scope, FileDef *fileScope,
-                                 Definition *item,
-                                 const QCString &explicitScopePart) {
-  if (explicitScopePart.isEmpty()) {
+int isAccessibleFromWithExpScope(Definition *scope,FileDef *fileScope,
+                     Definition *item,const QCString &explicitScopePart)
+{
+  if (explicitScopePart.isEmpty())
+  {
     // handle degenerate case where there is no explicit scope.
-    return isAccessibleFrom(scope, fileScope, item);
+    return isAccessibleFrom(scope,fileScope,item);
   }
 
   static AccessStack accessStack;
-  if (accessStack.find(scope, fileScope, item, explicitScopePart)) {
+  if (accessStack.find(scope,fileScope,item,explicitScopePart))
+  {
     return -1;
   }
-  accessStack.push(scope, fileScope, item, explicitScopePart);
+  accessStack.push(scope,fileScope,item,explicitScopePart);
+
 
-  // printf("
-  // <isAccessibleFromWithExpScope(%s,%s,%s)\n",scope?scope->name().data():"<global>",
+  //printf("  <isAccessibleFromWithExpScope(%s,%s,%s)\n",scope?scope->name().data():"<global>",
   //                                      item?item->name().data():"<none>",
   //                                      explicitScopePart.data());
-  int result = 0; // assume we found it
-  Definition *newScope = followPath(scope, fileScope, explicitScopePart);
-  if (newScope) // explicitScope is inside scope => newScope is the result
+  int result=0; // assume we found it
+  Definition *newScope = followPath(scope,fileScope,explicitScopePart);
+  if (newScope)  // explicitScope is inside scope => newScope is the result
   {
     Definition *itemScope = item->getOuterScope();
-    // printf("    scope traversal successful
-    // %s<->%s!\n",itemScope->name().data(),newScope->name().data());
-    // if (newScope && newScope->definitionType()==Definition::TypeClass)
+    //printf("    scope traversal successful %s<->%s!\n",itemScope->name().data(),newScope->name().data());
+    //if (newScope && newScope->definitionType()==Definition::TypeClass)
     //{
     //  ClassDef *cd = (ClassDef *)newScope;
     //  printf("---> Class %s: bases=%p\n",cd->name().data(),cd->baseClasses());
     //}
-    if (itemScope == newScope) // exact match of scopes => distance==0
-    {
-      // printf("> found it\n");
-    } else if (itemScope && newScope &&
-               itemScope->definitionType() == Definition::TypeClass &&
-               newScope->definitionType() == Definition::TypeClass &&
-               ((ClassDef *)newScope)
-                   ->isBaseClass((ClassDef *)itemScope, TRUE, 0)) {
-      // inheritance is also ok. Example: looking for B::I, where
+    if (itemScope==newScope)  // exact match of scopes => distance==0
+    {
+      //printf("> found it\n");
+    }
+    else if (itemScope && newScope &&
+             itemScope->definitionType()==Definition::TypeClass &&
+             newScope->definitionType()==Definition::TypeClass &&
+             ((ClassDef*)newScope)->isBaseClass((ClassDef*)itemScope,TRUE,0)
+            )
+    {
+      // inheritance is also ok. Example: looking for B::I, where 
       // class A { public: class I {} };
       // class B : public A {}
       // but looking for B::I, where
       // class A { public: class I {} };
       // class B { public: class I {} };
-      // will find A::I, so we still prefer a direct match and give this one a
-      // distance of 1
-      result = 1;
+      // will find A::I, so we still prefer a direct match and give this one a distance of 1
+      result=1;
 
-      // printf("scope(%s) is base class of newScope(%s)\n",
+      //printf("scope(%s) is base class of newScope(%s)\n",
       //    scope->name().data(),newScope->name().data());
-    } else {
-      int i = -1;
-      if (newScope->definitionType() == Definition::TypeNamespace) {
-        g_visitedNamespaces.insert(newScope->name(), newScope);
+    }
+    else
+    {
+      int i=-1;
+      if (newScope->definitionType()==Definition::TypeNamespace)
+      {
+        g_visitedNamespaces.insert(newScope->name(),newScope);
         // this part deals with the case where item is a class
         // A::B::C but is explicit referenced as A::C, where B is imported
         // in A via a using directive.
-        // printf("newScope is a namespace: %s!\n",newScope->name().data());
-        NamespaceDef *nscope = (NamespaceDef *)newScope;
+        //printf("newScope is a namespace: %s!\n",newScope->name().data());
+        NamespaceDef *nscope = (NamespaceDef*)newScope;
         SDict<Definition> *cl = nscope->getUsedClasses();
-        if (cl) {
+        if (cl)
+        {
           SDict<Definition>::Iterator cli(*cl);
           Definition *cd;
-          for (cli.toFirst(); (cd = cli.current()); ++cli) {
-            // printf("Trying for class %s\n",cd->name().data());
-            if (cd == item) {
-              // printf("> class is used in this scope\n");
+          for (cli.toFirst();(cd=cli.current());++cli)
+          {
+            //printf("Trying for class %s\n",cd->name().data());
+            if (cd==item)
+            {
+              //printf("> class is used in this scope\n");
               goto done;
             }
           }
         }
         NamespaceSDict *nl = nscope->getUsedNamespaces();
-        if (nl) {
+        if (nl)
+        {
           NamespaceSDict::Iterator nli(*nl);
           NamespaceDef *nd;
-          for (nli.toFirst(); (nd = nli.current()); ++nli) {
-            if (g_visitedNamespaces.find(nd->name()) == 0) {
-              // printf("Trying for namespace %s\n",nd->name().data());
-              i = isAccessibleFromWithExpScope(scope, fileScope, item,
-                                               nd->name());
-              if (i != -1) {
-                // printf("> found via explicit scope of used namespace\n");
+          for (nli.toFirst();(nd=nli.current());++nli)
+          {
+            if (g_visitedNamespaces.find(nd->name())==0)
+            {
+              //printf("Trying for namespace %s\n",nd->name().data());
+              i = isAccessibleFromWithExpScope(scope,fileScope,item,nd->name());
+              if (i!=-1)
+              {
+                //printf("> found via explicit scope of used namespace\n");
                 goto done;
               }
             }
@@ -1060,100 +1148,118 @@ int isAccessibleFromWithExpScope(Definition *scope, FileDef *fileScope,
         }
       }
       // repeat for the parent scope
-      if (scope != Doxygen::globalScope) {
-        i = isAccessibleFromWithExpScope(scope->getOuterScope(), fileScope,
-                                         item, explicitScopePart);
+      if (scope!=Doxygen::globalScope)
+      {
+        i = isAccessibleFromWithExpScope(scope->getOuterScope(),fileScope,
+            item,explicitScopePart);
       }
-      // printf("  | result=%d\n",i);
-      result = (i == -1) ? -1 : i + 2;
+      //printf("  | result=%d\n",i);
+      result = (i==-1) ? -1 : i+2;
     }
-  } else // failed to resolve explicitScope
+  }
+  else // failed to resolve explicitScope
   {
-    // printf("    failed to resolve: scope=%s\n",scope->name().data());
-    if (scope->definitionType() == Definition::TypeNamespace) {
-      NamespaceDef *nscope = (NamespaceDef *)scope;
+    //printf("    failed to resolve: scope=%s\n",scope->name().data());
+    if (scope->definitionType()==Definition::TypeNamespace)
+    {
+      NamespaceDef *nscope = (NamespaceDef*)scope;
       NamespaceSDict *nl = nscope->getUsedNamespaces();
-      if (accessibleViaUsingNamespace(nl, fileScope, item, explicitScopePart)) {
-        // printf("> found in used namespace\n");
+      if (accessibleViaUsingNamespace(nl,fileScope,item,explicitScopePart)) 
+      {
+        //printf("> found in used namespace\n");
         goto done;
       }
     }
-    if (scope == Doxygen::globalScope) {
-      if (fileScope) {
+    if (scope==Doxygen::globalScope)
+    {
+      if (fileScope)
+      {
         NamespaceSDict *nl = fileScope->getUsedNamespaces();
-        if (accessibleViaUsingNamespace(nl, fileScope, item,
-                                        explicitScopePart)) {
-          // printf("> found in used namespace\n");
+        if (accessibleViaUsingNamespace(nl,fileScope,item,explicitScopePart)) 
+        {
+          //printf("> found in used namespace\n");
           goto done;
         }
       }
-      // printf("> not found\n");
-      result = -1;
-    } else // continue by looking into the parent scope
+      //printf("> not found\n");
+      result=-1;
+    }
+    else // continue by looking into the parent scope
     {
-      int i = isAccessibleFromWithExpScope(scope->getOuterScope(), fileScope,
-                                           item, explicitScopePart);
-      // printf("> result=%d\n",i);
-      result = (i == -1) ? -1 : i + 2;
+      int i=isAccessibleFromWithExpScope(scope->getOuterScope(),fileScope,
+          item,explicitScopePart);
+      //printf("> result=%d\n",i);
+      result= (i==-1) ? -1 : i+2;
     }
   }
 
 done:
-  // printf("  > result=%d\n",result);
+  //printf("  > result=%d\n",result);
   accessStack.pop();
-  // Doxygen::lookupCache.insert(key,new int(result));
+  //Doxygen::lookupCache.insert(key,new int(result));
   return result;
 }
 
-int computeQualifiedIndex(const QCString &name) {
+int computeQualifiedIndex(const QCString &name)
+{
   int i = name.find('<');
-  return name.findRev("::", i == -1 ? name.length() : i);
-}
-
-static void getResolvedSymbol(Definition *scope, FileDef *fileScope,
-                              Definition *d, const QCString &explicitScopePart,
-                              ArgumentList *actTemplParams, int &minDistance,
-                              ClassDef *&bestMatch, MemberDef *&bestTypedef,
-                              QCString &bestTemplSpec,
-                              QCString &bestResolvedType) {
-  // printf("  => found type %x name=%s d=%p\n",
+  return name.findRev("::",i==-1 ? name.length() : i);
+}
+
+static void getResolvedSymbol(Definition *scope,
+                       FileDef *fileScope,
+                       Definition *d, 
+                       const QCString &explicitScopePart,
+                       ArgumentList *actTemplParams,
+                       int &minDistance,
+                       ClassDef *&bestMatch,
+                       MemberDef *&bestTypedef,
+                       QCString &bestTemplSpec,
+                       QCString &bestResolvedType
+                      )
+{
+  //printf("  => found type %x name=%s d=%p\n",
   //       d->definitionType(),d->name().data(),d);
 
   // only look at classes and members that are enums or typedefs
-  if (d->definitionType() == Definition::TypeClass ||
-      (d->definitionType() == Definition::TypeMember &&
-       (((MemberDef *)d)->isTypedef() || ((MemberDef *)d)->isEnumerate()))) {
+  if (d->definitionType()==Definition::TypeClass ||
+      (d->definitionType()==Definition::TypeMember && 
+       (((MemberDef*)d)->isTypedef() || ((MemberDef*)d)->isEnumerate()) 
+      )
+     )
+  {
     g_visitedNamespaces.clear();
     // test accessibility of definition within scope.
-    int distance =
-        isAccessibleFromWithExpScope(scope, fileScope, d, explicitScopePart);
-    // printf("  %s; distance %s (%p) is
-    // %d\n",scope->name().data(),d->name().data(),d,distance);
-    if (distance != -1) // definition is accessible
+    int distance = isAccessibleFromWithExpScope(scope,fileScope,d,explicitScopePart);
+    //printf("  %s; distance %s (%p) is %d\n",scope->name().data(),d->name().data(),d,distance);
+    if (distance!=-1) // definition is accessible
     {
       // see if we are dealing with a class or a typedef
-      if (d->definitionType() == Definition::TypeClass) // d is a class
+      if (d->definitionType()==Definition::TypeClass) // d is a class
       {
         ClassDef *cd = (ClassDef *)d;
-        // printf("cd=%s\n",cd->name().data());
+        //printf("cd=%s\n",cd->name().data());
         if (!cd->isTemplateArgument()) // skip classes that
-        // are only there to
-        // represent a template
-        // argument
+          // are only there to 
+          // represent a template 
+          // argument
         {
-          // printf("is not a templ arg\n");
-          if (distance < minDistance) // found a definition that is "closer"
+          //printf("is not a templ arg\n");
+          if (distance<minDistance) // found a definition that is "closer"
           {
-            minDistance = distance;
-            bestMatch = cd;
+            minDistance=distance;
+            bestMatch = cd; 
             bestTypedef = 0;
             bestTemplSpec.resize(0);
             bestResolvedType = cd->qualifiedName();
-          } else if (distance == minDistance && fileScope && bestMatch &&
-                     fileScope->getUsedNamespaces() &&
-                     d->getOuterScope()->definitionType() ==
-                         Definition::TypeNamespace &&
-                     bestMatch->getOuterScope() == Doxygen::globalScope) {
+          }
+          else if (distance==minDistance &&
+              fileScope && bestMatch &&
+              fileScope->getUsedNamespaces() && 
+              d->getOuterScope()->definitionType()==Definition::TypeNamespace && 
+              bestMatch->getOuterScope()==Doxygen::globalScope
+              )
+          {
             // in case the distance is equal it could be that a class X
             // is defined in a namespace and in the global scope. When searched
             // in the global scope the distance is 0 in both cases. We have
@@ -1162,74 +1268,87 @@ static void getResolvedSymbol(Definition *scope, FileDef *fileScope,
             // found was in a namespace while the best match so far isn't.
             // Just a non-perfect heuristic but it could help in some situations
             // (kdecore code is an example).
-            minDistance = distance;
-            bestMatch = cd;
+            minDistance=distance;
+            bestMatch = cd; 
             bestTypedef = 0;
             bestTemplSpec.resize(0);
             bestResolvedType = cd->qualifiedName();
           }
-        } else {
-          // printf("  is a template argument!\n");
         }
-      } else if (d->definitionType() == Definition::TypeMember) {
+        else
+        {
+          //printf("  is a template argument!\n");
+        }
+      }
+      else if (d->definitionType()==Definition::TypeMember)
+      {
         MemberDef *md = (MemberDef *)d;
-        // printf("  member isTypedef()=%d\n",md->isTypedef());
+        //printf("  member isTypedef()=%d\n",md->isTypedef());
         if (md->isTypedef()) // d is a typedef
         {
-          QCString args = md->argsString();
+          QCString args=md->argsString();
           if (args.isEmpty()) // do not expand "typedef t a[4];"
           {
-            // printf("    found typedef!\n");
+            //printf("    found typedef!\n");
 
             // we found a symbol at this distance, but if it didn't
             // resolve to a class, we still have to make sure that
             // something at a greater distance does not match, since
             // that symbol is hidden by this one.
-            if (distance < minDistance) {
+            if (distance<minDistance)
+            {
               QCString spec;
               QCString type;
-              minDistance = distance;
+              minDistance=distance;
               MemberDef *enumType = 0;
-              ClassDef *cd = newResolveTypedef(fileScope, md, &enumType, &spec,
-                                               &type, actTemplParams);
-              if (cd) // type resolves to a class
+              ClassDef *cd = newResolveTypedef(fileScope,md,&enumType,&spec,&type,actTemplParams);
+              if (cd)  // type resolves to a class
               {
-                // printf("      bestTypeDef=%p spec=%s
-                // type=%s\n",md,spec.data(),type.data());
+                //printf("      bestTypeDef=%p spec=%s type=%s\n",md,spec.data(),type.data());
                 bestMatch = cd;
                 bestTypedef = md;
                 bestTemplSpec = spec;
                 bestResolvedType = type;
-              } else if (enumType) // type resolves to a enum
+              }
+              else if (enumType) // type resolves to a enum
               {
-                // printf("      is enum\n");
+                //printf("      is enum\n");
                 bestMatch = 0;
                 bestTypedef = enumType;
                 bestTemplSpec = "";
                 bestResolvedType = enumType->qualifiedName();
-              } else if (md->isReference()) // external reference
+              }
+              else if (md->isReference()) // external reference
               {
                 bestMatch = 0;
                 bestTypedef = md;
                 bestTemplSpec = spec;
                 bestResolvedType = type;
-              } else {
+              }
+              else
+              {
                 bestMatch = 0;
                 bestTypedef = md;
                 bestTemplSpec.resize(0);
                 bestResolvedType.resize(0);
-                // printf("      no match\n");
+                //printf("      no match\n");
               }
-            } else {
-              // printf("      not the best match %d
-              // min=%d\n",distance,minDistance);
             }
-          } else {
-            // printf("     not a simple typedef\n")
+            else
+            {
+              //printf("      not the best match %d min=%d\n",distance,minDistance);
+            }
+          }
+          else
+          {
+            //printf("     not a simple typedef\n")
           }
-        } else if (md->isEnumerate()) {
-          if (distance < minDistance) {
-            minDistance = distance;
+        }
+        else if (md->isEnumerate())
+        {
+          if (distance<minDistance)
+          {
+            minDistance=distance;
             bestMatch = 0;
             bestTypedef = md;
             bestTemplSpec = "";
@@ -1238,191 +1357,200 @@ static void getResolvedSymbol(Definition *scope, FileDef *fileScope,
         }
       }
     } // if definition accessible
-    else {
-      // printf("  Not accessible!\n");
+    else
+    {
+      //printf("  Not accessible!\n");
     }
   } // if definition is a class or member
-  // printf("  bestMatch=%p
-  // bestResolvedType=%s\n",bestMatch,bestResolvedType.data());
+  //printf("  bestMatch=%p bestResolvedType=%s\n",bestMatch,bestResolvedType.data());
 }
 
 /* Find the fully qualified class name referred to by the input class
  * or typedef name against the input scope.
  * Loops through scope and each of its parent scopes looking for a
- * match against the input name. Can recursively call itself when
+ * match against the input name. Can recursively call itself when 
  * resolving typedefs.
  */
-static ClassDef *getResolvedClassRec(Definition *scope, FileDef *fileScope,
-                                     const char *n, MemberDef **pTypeDef,
-                                     QCString *pTemplSpec,
-                                     QCString *pResolvedType) {
-  // printf("[getResolvedClassRec(%s,%s)\n",scope?scope->name().data():"<global>",n);
+static ClassDef *getResolvedClassRec(Definition *scope,
+    FileDef *fileScope,
+    const char *n,
+    MemberDef **pTypeDef,
+    QCString *pTemplSpec,
+    QCString *pResolvedType
+    )
+{
+  //printf("[getResolvedClassRec(%s,%s)\n",scope?scope->name().data():"<global>",n);
   QCString name;
   QCString explicitScopePart;
   QCString strippedTemplateParams;
-  name = stripTemplateSpecifiersFromScope(removeRedundantWhiteSpace(n), TRUE,
-                                          &strippedTemplateParams);
+  name=stripTemplateSpecifiersFromScope
+                     (removeRedundantWhiteSpace(n),TRUE,
+                      &strippedTemplateParams);
   ArgumentList actTemplParams;
   if (!strippedTemplateParams.isEmpty()) // template part that was stripped
   {
-    stringToArgumentList(strippedTemplateParams, &actTemplParams);
+    stringToArgumentList(strippedTemplateParams,&actTemplParams);
   }
 
   int qualifierIndex = computeQualifiedIndex(name);
-  // printf("name=%s qualifierIndex=%d\n",name.data(),qualifierIndex);
-  if (qualifierIndex != -1) // qualified name
+  //printf("name=%s qualifierIndex=%d\n",name.data(),qualifierIndex);
+  if (qualifierIndex!=-1) // qualified name
   {
     // split off the explicit scope part
-    explicitScopePart = name.left(qualifierIndex);
+    explicitScopePart=name.left(qualifierIndex);
     // todo: improve namespace alias substitution
-    replaceNamespaceAliases(explicitScopePart, explicitScopePart.length());
-    name = name.mid(qualifierIndex + 2);
+    replaceNamespaceAliases(explicitScopePart,explicitScopePart.length());
+    name=name.mid(qualifierIndex+2);
   }
 
-  if (name.isEmpty()) {
-    // printf("] empty name\n");
+  if (name.isEmpty()) 
+  {
+    //printf("] empty name\n");
     return 0; // empty name
   }
 
-  // printf("Looking for symbol %s\n",name.data());
+  //printf("Looking for symbol %s\n",name.data());
   DefinitionIntf *di = Doxygen::symbolMap->find(name);
-  // the -g (for C# generics) and -p (for ObjC protocols) are now already
+  // the -g (for C# generics) and -p (for ObjC protocols) are now already 
   // stripped from the key used in the symbolMap, so that is not needed here.
-  if (di == 0) {
-    // di = Doxygen::symbolMap->find(name+"-g");
-    // if (di==0)
+  if (di==0) 
+  {
+    //di = Doxygen::symbolMap->find(name+"-g");
+    //if (di==0)
     //{
-    di = Doxygen::symbolMap->find(name + "-p");
-    if (di == 0) {
-      // printf("no such symbol!\n");
-      return 0;
-    }
+      di = Doxygen::symbolMap->find(name+"-p");
+      if (di==0)
+      {
+        //printf("no such symbol!\n");
+        return 0;
+      }
     //}
   }
-  // printf("found symbol!\n");
+  //printf("found symbol!\n");
 
-  bool hasUsingStatements =
-      (fileScope && ((fileScope->getUsedNamespaces() &&
-                      fileScope->getUsedNamespaces()->count() > 0) ||
-                     (fileScope->getUsedClasses() &&
-                      fileScope->getUsedClasses()->count() > 0)));
-  // printf("hasUsingStatements=%d\n",hasUsingStatements);
+  bool hasUsingStatements = 
+    (fileScope && ((fileScope->getUsedNamespaces() && 
+                    fileScope->getUsedNamespaces()->count()>0) ||
+                   (fileScope->getUsedClasses() && 
+                    fileScope->getUsedClasses()->count()>0)) 
+    );
+  //printf("hasUsingStatements=%d\n",hasUsingStatements);
   // Since it is often the case that the same name is searched in the same
   // scope over an over again (especially for the linked source code generation)
   // we use a cache to collect previous results. This is possible since the
   // result of a lookup is deterministic. As the key we use the concatenated
   // scope, the name to search for and the explicit scope prefix. The speedup
   // achieved by this simple cache can be enormous.
-  int scopeNameLen = scope->name().length() + 1;
-  int nameLen = name.length() + 1;
+  int scopeNameLen = scope->name().length()+1;
+  int nameLen = name.length()+1;
   int explicitPartLen = explicitScopePart.length();
-  int fileScopeLen =
-      hasUsingStatements ? 1 + fileScope->absFilePath().length() : 0;
+  int fileScopeLen = hasUsingStatements ? 1+fileScope->absFilePath().length() : 0;
 
   // below is a more efficient coding of
   // QCString key=scope->name()+"+"+name+"+"+explicitScopePart;
-  QCString key(scopeNameLen + nameLen + explicitPartLen + fileScopeLen + 1);
-  char *p = key.rawData();
-  qstrcpy(p, scope->name());
-  *(p + scopeNameLen - 1) = '+';
-  p += scopeNameLen;
-  qstrcpy(p, name);
-  *(p + nameLen - 1) = '+';
-  p += nameLen;
-  qstrcpy(p, explicitScopePart);
-  p += explicitPartLen;
+  QCString key(scopeNameLen+nameLen+explicitPartLen+fileScopeLen+1);
+  char *p=key.rawData();
+  qstrcpy(p,scope->name()); *(p+scopeNameLen-1)='+';
+  p+=scopeNameLen;
+  qstrcpy(p,name); *(p+nameLen-1)='+';
+  p+=nameLen;
+  qstrcpy(p,explicitScopePart);
+  p+=explicitPartLen;
 
   // if a file scope is given and it contains using statements we should
   // also use the file part in the key (as a class name can be in
-  // two different namespaces and a using statement in a file can select
+  // two different namespaces and a using statement in a file can select 
   // one of them).
-  if (hasUsingStatements) {
+  if (hasUsingStatements)
+  {
     // below is a more efficient coding of
     // key+="+"+fileScope->name();
-    *p++ = '+';
-    qstrcpy(p, fileScope->absFilePath());
-    p += fileScopeLen - 1;
-  }
-  *p = '\0';
-
-  LookupInfo *pval = Doxygen::lookupCache->find(key);
-  // printf("Searching for %s result=%p\n",key.data(),pval);
-  if (pval) {
-    // printf("LookupInfo %p %p '%s' %p\n",
-    //    pval->classDef, pval->typeDef, pval->templSpec.data(),
-    //    pval->resolvedType.data());
-    if (pTemplSpec)
-      *pTemplSpec = pval->templSpec;
-    if (pTypeDef)
-      *pTypeDef = pval->typeDef;
-    if (pResolvedType)
-      *pResolvedType = pval->resolvedType;
-    // printf("] cachedMatch=%s\n",
+    *p++='+';
+    qstrcpy(p,fileScope->absFilePath());
+    p+=fileScopeLen-1;
+  }
+  *p='\0';
+
+  LookupInfo *pval=Doxygen::lookupCache->find(key);
+  //printf("Searching for %s result=%p\n",key.data(),pval);
+  if (pval)
+  {
+    //printf("LookupInfo %p %p '%s' %p\n", 
+    //    pval->classDef, pval->typeDef, pval->templSpec.data(), 
+    //    pval->resolvedType.data()); 
+    if (pTemplSpec)    *pTemplSpec=pval->templSpec;
+    if (pTypeDef)      *pTypeDef=pval->typeDef;
+    if (pResolvedType) *pResolvedType=pval->resolvedType;
+    //printf("] cachedMatch=%s\n",
     //    pval->classDef?pval->classDef->name().data():"<none>");
-    // if (pTemplSpec)
+    //if (pTemplSpec) 
     //  printf("templSpec=%s\n",pTemplSpec->data());
-    return pval->classDef;
-  } else // not found yet; we already add a 0 to avoid the possibility of
-  // endless recursion.
+    return pval->classDef; 
+  }
+  else // not found yet; we already add a 0 to avoid the possibility of 
+    // endless recursion.
   {
-    Doxygen::lookupCache->insert(key, new LookupInfo);
+    Doxygen::lookupCache->insert(key,new LookupInfo);
   }
 
-  ClassDef *bestMatch = 0;
-  MemberDef *bestTypedef = 0;
+  ClassDef *bestMatch=0;
+  MemberDef *bestTypedef=0;
   QCString bestTemplSpec;
   QCString bestResolvedType;
-  int minDistance = 10000; // init at "infinite"
+  int minDistance=10000; // init at "infinite"
 
-  if (di->definitionType() ==
-      DefinitionIntf::TypeSymbolList) // not a unique name
+  if (di->definitionType()==DefinitionIntf::TypeSymbolList) // not a unique name
   {
-    // printf("  name is not unique\n");
-    DefinitionListIterator dli(*(DefinitionList *)di);
+    //printf("  name is not unique\n");
+    DefinitionListIterator dli(*(DefinitionList*)di);
     Definition *d;
-    int count = 0;
-    for (dli.toFirst(); (d = dli.current());
-         ++dli, ++count) // foreach definition
+    int count=0;
+    for (dli.toFirst();(d=dli.current());++dli,++count) // foreach definition
     {
-      getResolvedSymbol(scope, fileScope, d, explicitScopePart, &actTemplParams,
-                        minDistance, bestMatch, bestTypedef, bestTemplSpec,
+      getResolvedSymbol(scope,fileScope,d,explicitScopePart,&actTemplParams,
+                        minDistance,bestMatch,bestTypedef,bestTemplSpec,
                         bestResolvedType);
     }
-  } else // unique name
+  }
+  else // unique name
   {
-    // printf("  name is unique\n");
+    //printf("  name is unique\n");
     Definition *d = (Definition *)di;
-    getResolvedSymbol(scope, fileScope, d, explicitScopePart, &actTemplParams,
-                      minDistance, bestMatch, bestTypedef, bestTemplSpec,
+    getResolvedSymbol(scope,fileScope,d,explicitScopePart,&actTemplParams,
+                      minDistance,bestMatch,bestTypedef,bestTemplSpec,
                       bestResolvedType);
   }
 
-  if (pTypeDef) {
+  if (pTypeDef) 
+  {
     *pTypeDef = bestTypedef;
   }
-  if (pTemplSpec) {
+  if (pTemplSpec)
+  {
     *pTemplSpec = bestTemplSpec;
   }
-  if (pResolvedType) {
+  if (pResolvedType)
+  {
     *pResolvedType = bestResolvedType;
   }
-  // printf("getResolvedClassRec: bestMatch=%p pval->resolvedType=%s\n",
+  //printf("getResolvedClassRec: bestMatch=%p pval->resolvedType=%s\n",
   //    bestMatch,bestResolvedType.data());
 
-  pval = Doxygen::lookupCache->find(key);
-  if (pval) {
-    pval->classDef = bestMatch;
-    pval->typeDef = bestTypedef;
-    pval->templSpec = bestTemplSpec;
+  pval=Doxygen::lookupCache->find(key);
+  if (pval)
+  {
+    pval->classDef     = bestMatch;
+    pval->typeDef      = bestTypedef;
+    pval->templSpec    = bestTemplSpec;
     pval->resolvedType = bestResolvedType;
-  } else {
-    Doxygen::lookupCache->insert(key, new LookupInfo(bestMatch, bestTypedef,
-                                                     bestTemplSpec,
-                                                     bestResolvedType));
   }
-  // printf("] bestMatch=%s distance=%d\n",
+  else
+  {
+    Doxygen::lookupCache->insert(key,new LookupInfo(bestMatch,bestTypedef,bestTemplSpec,bestResolvedType));
+  }
+  //printf("] bestMatch=%s distance=%d\n",
   //    bestMatch?bestMatch->name().data():"<none>",minDistance);
-  // if (pTemplSpec)
+  //if (pTemplSpec) 
   //  printf("templSpec=%s\n",pTemplSpec->data());
   return bestMatch;
 }
@@ -1430,51 +1558,59 @@ static ClassDef *getResolvedClassRec(Definition *scope, FileDef *fileScope,
 /* Find the fully qualified class name referred to by the input class
  * or typedef name against the input scope.
  * Loops through scope and each of its parent scopes looking for a
- * match against the input name.
+ * match against the input name. 
  */
-ClassDef *getResolvedClass(Definition *scope, FileDef *fileScope, const char *n,
-                           MemberDef **pTypeDef, QCString *pTemplSpec,
-                           bool mayBeUnlinkable, bool mayBeHidden,
-                           QCString *pResolvedType) {
+ClassDef *getResolvedClass(Definition *scope,
+    FileDef *fileScope,
+    const char *n,
+    MemberDef **pTypeDef,
+    QCString *pTemplSpec,
+    bool mayBeUnlinkable,
+    bool mayBeHidden,
+    QCString *pResolvedType
+    )
+{
   static bool optimizeOutputVhdl = Config_getBool(OPTIMIZE_OUTPUT_VHDL);
   g_resolvedTypedefs.clear();
-  if (scope == 0 || (scope->definitionType() != Definition::TypeClass &&
-                     scope->definitionType() != Definition::TypeNamespace) ||
-      (scope->getLanguage() == SrcLangExt_Java &&
-       QCString(n).find("::") != -1) ||
-      (scope->getLanguage() == SrcLangExt_Prolog &&
-       QCString(n).find("::") != -1)) {
-    scope = Doxygen::globalScope;
-  }
-  // printf("------------
-  // getResolvedClass(scope=%s,file=%s,name=%s,mayUnlinkable=%d)\n",
+  if (scope==0 ||
+      (scope->definitionType()!=Definition::TypeClass && 
+       scope->definitionType()!=Definition::TypeNamespace
+      ) ||
+      (scope->getLanguage()==SrcLangExt_Java && QCString(n).find("::")!=-1)
+     )
+  {
+    scope=Doxygen::globalScope;
+  }
+  //printf("------------ getResolvedClass(scope=%s,file=%s,name=%s,mayUnlinkable=%d)\n",
   //    scope?scope->name().data():"<global>",
   //    fileScope?fileScope->name().data():"<none>",
   //    n,
   //    mayBeUnlinkable
   //   );
   ClassDef *result;
-  if (optimizeOutputVhdl) {
+  if (optimizeOutputVhdl)
+  {
     result = getClass(n);
-  } else {
-    result = getResolvedClassRec(scope, fileScope, n, pTypeDef, pTemplSpec,
-                                 pResolvedType);
   }
-  if (result ==
-      0) // for nested classes imported via tag files, the scope may not
-         // present, so we check the class name directly as well.
-         // See also bug701314
+  else
+  {
+    result = getResolvedClassRec(scope,fileScope,n,pTypeDef,pTemplSpec,pResolvedType);
+  }
+  if (result==0) // for nested classes imported via tag files, the scope may not
+                 // present, so we check the class name directly as well.
+                 // See also bug701314
   {
     result = getClass(n);
   }
-  if (!mayBeUnlinkable && result && !result->isLinkable()) {
-    if (!mayBeHidden || !result->isHidden()) {
-      // printf("result was %s\n",result?result->name().data():"<none>");
-      result = 0; // don't link to artificial/hidden classes unless explicitly
-                  // allowed
+  if (!mayBeUnlinkable && result && !result->isLinkable()) 
+  {
+    if (!mayBeHidden || !result->isHidden())
+    {
+      //printf("result was %s\n",result?result->name().data():"<none>");
+      result=0; // don't link to artificial/hidden classes unless explicitly allowed
     }
   }
-  // printf("getResolvedClass(%s,%s)=%s\n",scope?scope->name().data():"<global>",
+  //printf("getResolvedClass(%s,%s)=%s\n",scope?scope->name().data():"<global>",
   //                                  n,result?result->name().data():"<none>");
   return result;
 }
@@ -1484,68 +1620,68 @@ ClassDef *getResolvedClass(Definition *scope, FileDef *fileScope, const char *n,
 //-------------------------------------------------------------------------
 //-------------------------------------------------------------------------
 
-static bool findOperator(const QCString &s, int i) {
-  int b = s.findRev("operator", i);
-  if (b == -1)
-    return FALSE; // not found
-  b += 8;
-  while (b < i) // check if there are only spaces in between
-  // the operator and the >
+static bool findOperator(const QCString &s,int i)
+{
+  int b = s.findRev("operator",i);
+  if (b==-1) return FALSE; // not found
+  b+=8;
+  while (b<i) // check if there are only spaces in between 
+    // the operator and the >
   {
-    if (!isspace((uchar)s.at(b)))
-      return FALSE;
+    if (!isspace((uchar)s.at(b))) return FALSE;
     b++;
   }
   return TRUE;
 }
 
-static bool findOperator2(const QCString &s, int i) {
-  int b = s.findRev("operator", i);
-  if (b == -1)
-    return FALSE; // not found
-  b += 8;
-  while (b < i) // check if there are only non-ascii
-                // characters in front of the operator
+static bool findOperator2(const QCString &s,int i)
+{
+  int b = s.findRev("operator",i);
+  if (b==-1) return FALSE; // not found
+  b+=8;
+  while (b<i) // check if there are only non-ascii
+              // characters in front of the operator
   {
-    if (isId((uchar)s.at(b)))
-      return FALSE;
+    if (isId((uchar)s.at(b))) return FALSE;
     b++;
   }
   return TRUE;
 }
 
-static const char constScope[] = {'c', 'o', 'n', 's', 't', ':'};
-static const char virtualScope[] = {'v', 'i', 'r', 't', 'u', 'a', 'l', ':'};
-static const char operatorScope[] = {'o', 'p', 'e', 'r', 'a', 't',
-                                     'o', 'r', '?', '?', '?'};
-
-struct CharAroundSpace {
-  CharAroundSpace() {
-    charMap['('].before = FALSE;
-    charMap['='].before = FALSE;
-    charMap['&'].before = FALSE;
-    charMap['*'].before = FALSE;
-    charMap['['].before = FALSE;
-    charMap['|'].before = FALSE;
-    charMap['+'].before = FALSE;
-    charMap[';'].before = FALSE;
-    charMap[':'].before = FALSE;
-    charMap['/'].before = FALSE;
-
-    charMap['='].after = FALSE;
-    charMap[' '].after = FALSE;
-    charMap[']'].after = FALSE;
-    charMap['\t'].after = FALSE;
-    charMap['\n'].after = FALSE;
-    charMap[')'].after = FALSE;
-    charMap[','].after = FALSE;
-    charMap['<'].after = FALSE;
-    charMap['|'].after = FALSE;
-    charMap['+'].after = FALSE;
-    charMap['('].after = FALSE;
-    charMap['/'].after = FALSE;
-  }
-  struct CharElem {
+static const char constScope[]    = { 'c', 'o', 'n', 's', 't', ':' };
+static const char virtualScope[]  = { 'v', 'i', 'r', 't', 'u', 'a', 'l', ':' };
+static const char operatorScope[] = { 'o', 'p', 'e', 'r', 'a', 't', 'o', 'r', '?', '?', '?' };
+
+struct CharAroundSpace
+{
+  CharAroundSpace()
+  {
+    charMap['('].before=FALSE;
+    charMap['='].before=FALSE;
+    charMap['&'].before=FALSE;
+    charMap['*'].before=FALSE;
+    charMap['['].before=FALSE;
+    charMap['|'].before=FALSE;
+    charMap['+'].before=FALSE;
+    charMap[';'].before=FALSE;
+    charMap[':'].before=FALSE;
+    charMap['/'].before=FALSE;
+
+    charMap['='].after=FALSE;
+    charMap[' '].after=FALSE;
+    charMap[']'].after=FALSE;
+    charMap['\t'].after=FALSE;
+    charMap['\n'].after=FALSE;
+    charMap[')'].after=FALSE;
+    charMap[','].after=FALSE;
+    charMap['<'].after=FALSE;
+    charMap['|'].after=FALSE;
+    charMap['+'].after=FALSE;
+    charMap['('].after=FALSE;
+    charMap['/'].after=FALSE;
+  }
+  struct CharElem
+  {
     CharElem() : before(TRUE), after(TRUE) {}
     bool before;
     bool after;
@@ -1557,99 +1693,84 @@ struct CharAroundSpace {
 static CharAroundSpace g_charAroundSpace;
 
 // Note: this function is not reentrant due to the use of static buffer!
-QCString removeRedundantWhiteSpace(const QCString &s) {
+QCString removeRedundantWhiteSpace(const QCString &s)
+{
   static bool cliSupport = Config_getBool(CPP_CLI_SUPPORT);
   static bool vhdl = Config_getBool(OPTIMIZE_OUTPUT_VHDL);
 
-  if (s.isEmpty() || vhdl)
-    return s;
+  if (s.isEmpty() || vhdl) return s;
 
   // We use a static character array to
   // improve the performance of this function
   static char *growBuf = 0;
   static int growBufLen = 0;
-  if (s.length() * 3 >
-      growBufLen) // For input character we produce at most 3 output characters,
+  if (s.length()*3>growBufLen) // For input character we produce at most 3 output characters,
   {
-    growBufLen = s.length() * 3;
-    growBuf =
-        (char *)realloc(growBuf, growBufLen + 1); // add 1 for 0-terminator
+    growBufLen = s.length()*3;
+    growBuf = (char *)realloc(growBuf,growBufLen+1); // add 1 for 0-terminator
   }
-  if (growBuf == 0)
-    return s; // should not happen, only we run out of memory
+  if (growBuf==0) return s; // should not happen, only we run out of memory
 
-  char *src = s.rawData();
-  char *dst = growBuf;
+  char *src=s.rawData();
+  char *dst=growBuf;
 
-  uint i = 0;
-  uint l = s.length();
-  uint csp = 0;
-  uint vsp = 0;
-  uint osp = 0;
+  uint i=0;
+  uint l=s.length();
+  uint csp=0;
+  uint vsp=0;
+  uint osp=0;
   char c;
-  char pc = 0;
+  char pc=0;
   // skip leading whitespace
-  while (i < l && isspace((uchar)src[i])) {
+  while (i<l && isspace((uchar)src[i]))
+  {
     i++;
   }
-  for (; i < l; i++) {
-    c = src[i];
-    char nc = i < l - 1 ? src[i + 1] : ' ';
+  for (;i<l;i++)
+  {
+    c=src[i];
+    char nc=i<l-1 ? src[i+1] : ' ';
 
     // search for "const"
-    if (csp < 6 &&
-        c == constScope[csp] && // character matches substring "const"
-        (csp > 0 ||             // inside search string
-         i == 0 ||              // if it is the first character
-         !isId(pc)              // the previous may not be a digit
-         ))
+    if (csp<6 && c==constScope[csp] && // character matches substring "const"
+         (csp>0 ||                     // inside search string
+          i==0  ||                     // if it is the first character
+          !isId(pc)                    // the previous may not be a digit
+         )
+       )
       csp++;
     else // reset counter
-      csp = 0;
+      csp=0;
 
     // search for "virtual"
-    if (vsp < 8 &&
-        c == virtualScope[vsp] && // character matches substring "virtual"
-        (vsp > 0 ||               // inside search string
-         i == 0 ||                // if it is the first character
-         !isId(pc)                // the previous may not be a digit
-         ))
+    if (vsp<8 && c==virtualScope[vsp] && // character matches substring "virtual"
+         (vsp>0 ||                       // inside search string
+          i==0  ||                       // if it is the first character
+          !isId(pc)                      // the previous may not be a digit
+         )
+       )
       vsp++;
     else // reset counter
-      vsp = 0;
+      vsp=0;
 
     // search for "operator"
-    if (osp < 11 &&
-        (osp >= 8 || c == operatorScope[osp]) && // character matches substring
-                                                 // "operator" followed by 3
-                                                 // arbitrary characters
-        (osp > 0 ||                              // inside search string
-         i == 0 ||                               // if it is the first character
-         !isId(pc) // the previous may not be a digit
-         ))
+    if (osp<11 && (osp>=8 || c==operatorScope[osp]) && // character matches substring "operator" followed by 3 arbitrary characters
+        (osp>0 ||                         // inside search string
+         i==0 ||                          // if it is the first character
+         !isId(pc)                        // the previous may not be a digit
+        )
+       )
       osp++;
     else // reset counter
-      osp = 0;
+      osp=0;
 
-    switch (c) {
-    case '"': // quoted string
+    switch(c)
     {
-      *dst++ = c;
-      pc = c;
-      i++;
-      for (; i < l; i++) // find end of string
-      {
-        c = src[i];
-        *dst++ = c;
-        if (c == '\\' && i + 1 < l) {
+      case '"': // quoted string
+        {
+          *dst++=c;
           pc = c;
           i++;
-<<<<<<< HEAD
-          c = src[i];
-          *dst += c;
-        } else if (c == '"') {
-          break;
-=======
           for (;i<l;i++) // find end of string
           {
             c = src[i];
@@ -1789,137 +1910,13 @@ QCString removeRedundantWhiteSpace(const QCString &s) {
         {
           *dst++=' ';
           vsp=0;
->>>>>>> 5f01f783e2387a5d44ad70fbff5365aa0e5df938
         }
-        pc = c;
-      }
-    } break;
-    case '<': // current char is a <
-      *dst++ = c;
-      if (i < l - 1 && (isId(nc)) && // next char is an id char
-          (osp < 8)                  // string in front is not "operator"
-          ) {
-        *dst++ = ' '; // add extra space
-      }
-      break;
-    case '>': // current char is a >
-      if (i > 0 && !isspace((uchar)pc) &&
-          (isId(pc) || pc == '*' || pc == '&' ||
-           pc == '.') && // prev char is an id char or space or *&.
-          (osp < 8 ||
-           (osp == 8 &&
-            pc != '-')) // string in front is not "operator>" or "operator->"
-          ) {
-        *dst++ = ' '; // add extra space in front
-      }
-      *dst++ = c;
-      if (i < l - 1 && (nc == '-' || nc == '&')) // '>-' -> '> -'
-      {
-        *dst++ = ' '; // add extra space after
-      }
-      break;
-    case ',': // current char is a ,
-      *dst++ = c;
-      if (i > 0 && !isspace((uchar)pc) &&
-          ((i < l - 1 &&
-            (isId(nc) ||
-             nc == '[')) || // the [ is for attributes (see bug702170)
-           (i < l - 2 && nc == '$' &&
-            isId(src[i + 2])) || // for PHP: ',$name' -> ', $name'
-           (i < l - 3 && nc == '&' && src[i + 2] == '$' &&
-            isId(src[i + 3])) // for PHP: ',&$name' -> ', &$name'
-           )) {
-        *dst++ = ' '; // add extra space after
-      }
-      break;
-    case '^': // CLI 'Type^name' -> 'Type^ name'
-    case '%': // CLI 'Type%name' -> 'Type% name'
-      *dst++ = c;
-      if (cliSupport && i < l - 1 && (isId(nc) || nc == '-')) {
-        *dst++ = ' '; // add extra space after
-      }
-      break;
-    case ')': // current char is a )  -> ')name' -> ') name'
-      *dst++ = c;
-      if (i < l - 1 && (isId(nc) || nc == '-')) {
-        *dst++ = ' '; // add extra space after
-      }
-      break;
-    case '*':
-      if (i > 0 && pc != ' ' && pc != '\t' && pc != ':' && pc != '*' &&
-          pc != '&' && pc != '(' && pc != '/' && pc != '.' &&
-          (osp < 9 || (pc == '>' && osp == 11)))
-      // avoid splitting &&, **, .*, operator*, operator->*
-      {
-        *dst++ = ' ';
-      }
-      *dst++ = c;
-      break;
-    case '&':
-      if (i > 0 && isId(pc)) {
-        *dst++ = ' ';
-      }
-      *dst++ = c;
-      break;
-    case '@':  // '@name' -> ' @name'
-    case '$':  // '$name' -> ' $name'
-    case '\'': // ''name' -> '' name'
-      if (i > 0 && i < l - 1 && pc != '=' && pc != ':' && !isspace(pc) &&
-          isId(nc) && osp < 8) // ")id" -> ") id"
-      {
-        *dst++ = ' ';
-      }
-      *dst++ = c;
-      break;
-    case ':':       // current char is a :
-      if (csp == 6) // replace const::A by const ::A
-      {
-        *dst++ = ' ';
-        csp = 0;
-      } else if (vsp == 8) // replace virtual::A by virtual ::A
-      {
-        *dst++ = ' ';
-        vsp = 0;
-      }
-      *dst++ = c;
-      break;
-    case ' ':  // fallthrough
-    case '\n': // fallthrough
-    case '\t': {
-      if (g_charAroundSpace.charMap[(uchar)pc].before &&
-          g_charAroundSpace.charMap[(uchar)nc].after &&
-          !(pc == ',' && nc == '.'))
-      // remove spaces/tabs
-      {
-        *dst++ = ' ';
-      }
-    } break;
-    default:
-      *dst++ = c;
-      if (c == 't' && csp == 5 && i < l - 1 && // found 't' in 'const'
-          !(isId(nc) || nc == ')' || nc == ',' ||
-            isspace(nc))) // prevent const ::A from being converted to const::A
-      {
-        *dst++ = ' ';
-        csp = 0;
-      } else if (c == 'l' && vsp == 7 && i < l - 1 && // found 'l' in 'virtual'
-                 !(isId(nc) || nc == ')' || nc == ',' ||
-                   isspace(nc))) // prevent virtual ::A from being converted to
-                                 // virtual::A
-      {
-        *dst++ = ' ';
-        vsp = 0;
-      }
-      break;
+        break;
     }
-    pc = c;
+    pc=c;
   }
-<<<<<<< HEAD
-  *dst++ = '\0';
-=======
   *dst++='\0';
   //printf("removeRedundantWhitespace(%s)->%s\n",s.data(),growBuf);
->>>>>>> 5f01f783e2387a5d44ad70fbff5365aa0e5df938
   return growBuf;
 }
 
@@ -1927,329 +1924,345 @@ QCString removeRedundantWhiteSpace(const QCString &s) {
  * Returns the position in the string where a function parameter list
  * begins, or -1 if one is not found.
  */
-int findParameterList(const QCString &name) {
-  int pos = -1;
-  int templateDepth = 0;
-  do {
-    if (templateDepth > 0) {
-      int nextOpenPos = name.findRev('>', pos);
-      int nextClosePos = name.findRev('<', pos);
-      if (nextOpenPos != -1 && nextOpenPos > nextClosePos) {
+int findParameterList(const QCString &name)
+{
+  int pos=-1;
+  int templateDepth=0;
+  do
+  {
+    if (templateDepth > 0)
+    {
+      int nextOpenPos=name.findRev('>', pos);
+      int nextClosePos=name.findRev('<', pos);
+      if (nextOpenPos!=-1 && nextOpenPos>nextClosePos)
+      {
         ++templateDepth;
-        pos = nextOpenPos - 1;
-      } else if (nextClosePos != -1) {
+        pos=nextOpenPos-1;
+      }
+      else if (nextClosePos!=-1)
+      {
         --templateDepth;
-        pos = nextClosePos - 1;
-      } else // more >'s than <'s, see bug701295
+        pos=nextClosePos-1;
+      }
+      else // more >'s than <'s, see bug701295
       {
         return -1;
       }
-    } else {
-      int lastAnglePos = name.findRev('>', pos);
-      int bracePos = name.findRev('(', pos);
-      if (lastAnglePos != -1 && lastAnglePos > bracePos) {
+    }
+    else
+    {
+      int lastAnglePos=name.findRev('>', pos);
+      int bracePos=name.findRev('(', pos);
+      if (lastAnglePos!=-1 && lastAnglePos>bracePos)
+      {
         ++templateDepth;
-        pos = lastAnglePos - 1;
-      } else {
-        int bp = bracePos > 0 ? name.findRev('(', bracePos - 1) : -1;
-        // bp test is to allow foo(int(&)[10]), but we need to make an exception
-        // for operator()
-        return bp == -1 || (bp >= 8 && name.mid(bp - 8, 10) == "operator()")
-                   ? bracePos
-                   : bp;
+        pos=lastAnglePos-1;
+      }
+      else
+      {
+        int bp = bracePos>0 ? name.findRev('(',bracePos-1) : -1;
+        // bp test is to allow foo(int(&)[10]), but we need to make an exception for operator()
+        return bp==-1 || (bp>=8 && name.mid(bp-8,10)=="operator()") ? bracePos : bp;
       }
     }
-  } while (pos != -1);
+  } while (pos!=-1);
   return -1;
 }
 
-bool rightScopeMatch(const QCString &scope, const QCString &name) {
-  int sl = scope.length();
-  int nl = name.length();
-  return (name == scope ||            // equal
-          (scope.right(nl) == name && // substring
-           sl - nl > 1 && scope.at(sl - nl - 1) == ':' &&
-           scope.at(sl - nl - 2) == ':' // scope
-           ));
-}
-
-bool leftScopeMatch(const QCString &scope, const QCString &name) {
-  int sl = scope.length();
-  int nl = name.length();
-  return (name == scope ||           // equal
-          (scope.left(nl) == name && // substring
-           sl > nl + 1 && scope.at(nl) == ':' &&
-           scope.at(nl + 1) == ':' // scope
-           ));
-}
-
-void linkifyText(const TextGeneratorIntf &out, Definition *scope,
-                 FileDef *fileScope, Definition *self, const char *text,
-                 bool autoBreak, bool external, bool keepSpaces,
-                 int indentLevel) {
-  // printf("linkify=`%s'\n",text);
-  static QRegExp regExp(
-      "[a-z_A-Z\\x80-\\xFF][~!a-z_A-Z0-9$\\\\.:\\x80-\\xFF]*(/[0-9]+)*");
+bool rightScopeMatch(const QCString &scope, const QCString &name)
+{
+  int sl=scope.length();
+  int nl=name.length();
+  return (name==scope || // equal 
+          (scope.right(nl)==name && // substring 
+           sl-nl>1 && scope.at(sl-nl-1)==':' && scope.at(sl-nl-2)==':' // scope
+          ) 
+         );
+}
+
+bool leftScopeMatch(const QCString &scope, const QCString &name)
+{
+  int sl=scope.length();
+  int nl=name.length();
+  return (name==scope || // equal 
+          (scope.left(nl)==name && // substring 
+           sl>nl+1 && scope.at(nl)==':' && scope.at(nl+1)==':' // scope
+          ) 
+         );
+}
+
+
+void linkifyText(const TextGeneratorIntf &out,Definition *scope,
+    FileDef *fileScope,Definition *self,
+    const char *text, bool autoBreak,bool external,
+    bool keepSpaces,int indentLevel)
+{
+  //printf("linkify=`%s'\n",text);
+  static QRegExp regExp("[a-z_A-Z\\x80-\\xFF][~!a-z_A-Z0-9$\\\\.:\\x80-\\xFF]*");
   static QRegExp regExpSplit("(?!:),");
-  QCString txtStr = text;
+  QCString txtStr=text;
   int strLen = txtStr.length();
-  // printf("linkifyText scope=%s fileScope=%s strtxt=%s strlen=%d
-  // external=%d\n",
+  //printf("linkifyText scope=%s fileScope=%s strtxt=%s strlen=%d external=%d\n",
   //    scope?scope->name().data():"<none>",
   //    fileScope?fileScope->name().data():"<none>",
   //    txtStr.data(),strLen,external);
   int matchLen;
-  int index = 0;
+  int index=0;
   int newIndex;
-  int skipIndex = 0;
-  int floatingIndex = 0;
-  if (strLen == 0)
-    return;
+  int skipIndex=0;
+  int floatingIndex=0;
+  if (strLen==0) return;
   // read a word from the text string
-  while (
-      (newIndex = regExp.match(txtStr, index, &matchLen)) != -1 &&
-      (newIndex == 0 ||
-       !(txtStr.at(newIndex - 1) >= '0' &&
-         txtStr.at(newIndex - 1) <= '9')) // avoid matching part of hex numbers
-      ) {
+  while ((newIndex=regExp.match(txtStr,index,&matchLen))!=-1 && 
+      (newIndex==0 || !(txtStr.at(newIndex-1)>='0' && txtStr.at(newIndex-1)<='9')) // avoid matching part of hex numbers
+      )
+  {
     // add non-word part to the result
-    floatingIndex += newIndex - skipIndex + matchLen;
-    bool insideString = FALSE;
+    floatingIndex+=newIndex-skipIndex+matchLen;
+    bool insideString=FALSE; 
     int i;
-    for (i = index; i < newIndex; i++) {
-      if (txtStr.at(i) == '"')
-        insideString = !insideString;
+    for (i=index;i<newIndex;i++) 
+    { 
+      if (txtStr.at(i)=='"') insideString=!insideString; 
     }
 
-    // printf("floatingIndex=%d strlen=%d
-    // autoBreak=%d\n",floatingIndex,strLen,autoBreak);
-    if (strLen > 35 && floatingIndex > 30 &&
-        autoBreak) // try to insert a split point
+    //printf("floatingIndex=%d strlen=%d autoBreak=%d\n",floatingIndex,strLen,autoBreak);
+    if (strLen>35 && floatingIndex>30 && autoBreak) // try to insert a split point
     {
-      QCString splitText = txtStr.mid(skipIndex, newIndex - skipIndex);
+      QCString splitText = txtStr.mid(skipIndex,newIndex-skipIndex);
       int splitLength = splitText.length();
-      int offset = 1;
-      i = splitText.find(regExpSplit, 0);
-      if (i == -1) {
-        i = splitText.find('<');
-        if (i != -1)
-          offset = 0;
-      }
-      if (i == -1)
-        i = splitText.find('>');
-      if (i == -1)
-        i = splitText.find(' ');
-      // printf("splitText=[%s] len=%d i=%d
-      // offset=%d\n",splitText.data(),splitLength,i,offset);
-      if (i != -1) // add a link-break at i in case of Html output
-      {
-        out.writeString(splitText.left(i + offset), keepSpaces);
-        out.writeBreak(indentLevel == 0 ? 0 : indentLevel + 1);
-        out.writeString(splitText.right(splitLength - i - offset), keepSpaces);
-        floatingIndex = splitLength - i - offset + matchLen;
-      } else {
-        out.writeString(splitText, keepSpaces);
-      }
-    } else {
-      // ol.docify(txtStr.mid(skipIndex,newIndex-skipIndex));
-      out.writeString(txtStr.mid(skipIndex, newIndex - skipIndex), keepSpaces);
+      int offset=1;
+      i=splitText.find(regExpSplit,0);
+      if (i==-1) { i=splitText.find('<'); if (i!=-1) offset=0; }
+      if (i==-1) i=splitText.find('>');
+      if (i==-1) i=splitText.find(' ');
+      //printf("splitText=[%s] len=%d i=%d offset=%d\n",splitText.data(),splitLength,i,offset);
+      if (i!=-1) // add a link-break at i in case of Html output
+      {
+        out.writeString(splitText.left(i+offset),keepSpaces);
+        out.writeBreak(indentLevel==0 ? 0 : indentLevel+1);
+        out.writeString(splitText.right(splitLength-i-offset),keepSpaces);
+        floatingIndex=splitLength-i-offset+matchLen;
+      } 
+      else
+      {
+        out.writeString(splitText,keepSpaces); 
+      }
+    }
+    else
+    {
+      //ol.docify(txtStr.mid(skipIndex,newIndex-skipIndex)); 
+      out.writeString(txtStr.mid(skipIndex,newIndex-skipIndex),keepSpaces); 
     }
     // get word from string
-    QCString word = txtStr.mid(newIndex, matchLen);
-    QCString matchWord = substitute(substitute(word, "\\", "::"), ".", "::");
-    // printf("linkifyText word=%s matchWord=%s scope=%s\n",
+    QCString word=txtStr.mid(newIndex,matchLen);
+    QCString matchWord = substitute(substitute(word,"\\","::"),".","::");
+    //printf("linkifyText word=%s matchWord=%s scope=%s\n",
     //    word.data(),matchWord.data(),scope?scope->name().data():"<none>");
-    bool found = FALSE;
-    if (!insideString) {
-      ClassDef *cd = 0;
-      FileDef *fd = 0;
-      MemberDef *md = 0;
-      NamespaceDef *nd = 0;
-      GroupDef *gd = 0;
-      // printf("** Match word '%s'\n",matchWord.data());
-
-      MemberDef *typeDef = 0;
-      cd = getResolvedClass(scope, fileScope, matchWord, &typeDef);
+    bool found=FALSE;
+    if (!insideString)
+    {
+      ClassDef     *cd=0;
+      FileDef      *fd=0;
+      MemberDef    *md=0;
+      NamespaceDef *nd=0;
+      GroupDef     *gd=0;
+      //printf("** Match word '%s'\n",matchWord.data());
+
+      MemberDef *typeDef=0;
+      cd=getResolvedClass(scope,fileScope,matchWord,&typeDef);
       if (typeDef) // First look at typedef then class, see bug 584184.
       {
-        // printf("Found typedef %s\n",typeDef->name().data());
-        if (external ? typeDef->isLinkable() : typeDef->isLinkableInProject()) {
-          if (typeDef->getOuterScope() != self) {
-            out.writeLink(typeDef->getReference(), typeDef->getOutputFileBase(),
-                          typeDef->anchor(), word);
-            found = TRUE;
+        //printf("Found typedef %s\n",typeDef->name().data());
+        if (external ? typeDef->isLinkable() : typeDef->isLinkableInProject())
+        {
+          if (typeDef->getOuterScope()!=self)
+          {
+            out.writeLink(typeDef->getReference(),
+                typeDef->getOutputFileBase(),
+                typeDef->anchor(),
+                word);
+            found=TRUE;
           }
         }
       }
-      if (!found && (cd || (cd = getClass(matchWord)))) {
-        // printf("Found class %s\n",cd->name().data());
+      if (!found && (cd || (cd=getClass(matchWord)))) 
+      {
+        //printf("Found class %s\n",cd->name().data());
         // add link to the result
-        if (external ? cd->isLinkable() : cd->isLinkableInProject()) {
-          if (cd != self) {
-            out.writeLink(cd->getReference(), cd->getOutputFileBase(),
-                          cd->anchor(), word);
-            found = TRUE;
+        if (external ? cd->isLinkable() : cd->isLinkableInProject())
+        {
+          if (cd!=self)
+          {
+            out.writeLink(cd->getReference(),cd->getOutputFileBase(),cd->anchor(),word);
+            found=TRUE;
           }
         }
-      } else if ((cd = getClass(matchWord +
-                                "-p"))) // search for Obj-C protocols as well
+      }
+      else if ((cd=getClass(matchWord+"-p"))) // search for Obj-C protocols as well
       {
         // add link to the result
-        if (external ? cd->isLinkable() : cd->isLinkableInProject()) {
-          if (cd != self) {
-            out.writeLink(cd->getReference(), cd->getOutputFileBase(),
-                          cd->anchor(), word);
-            found = TRUE;
+        if (external ? cd->isLinkable() : cd->isLinkableInProject())
+        {
+          if (cd!=self)
+          {
+            out.writeLink(cd->getReference(),cd->getOutputFileBase(),cd->anchor(),word);
+            found=TRUE;
           }
         }
       }
-      //      else if ((cd=getClass(matchWord+"-g"))) // C# generic as well
-      //      {
-      //        // add link to the result
-      //        if (external ? cd->isLinkable() : cd->isLinkableInProject())
-      //        {
-      //          if (cd!=self)
-      //          {
-      //            out.writeLink(cd->getReference(),cd->getOutputFileBase(),cd->anchor(),word);
-      //            found=TRUE;
-      //          }
-      //        }
-      //      }
-      else {
-        // printf("   -> nothing\n");
+//      else if ((cd=getClass(matchWord+"-g"))) // C# generic as well
+//      {
+//        // add link to the result
+//        if (external ? cd->isLinkable() : cd->isLinkableInProject())
+//        {
+//          if (cd!=self)
+//          {
+//            out.writeLink(cd->getReference(),cd->getOutputFileBase(),cd->anchor(),word);
+//            found=TRUE;
+//          }
+//        }
+//      }
+      else
+      {
+        //printf("   -> nothing\n");
       }
 
       int m = matchWord.findRev("::");
       QCString scopeName;
-      if (scope && (scope->definitionType() == Definition::TypeClass ||
-                    scope->definitionType() == Definition::TypeNamespace)) {
-        scopeName = scope->name();
-      } else if (m != -1) {
+      if (scope && 
+          (scope->definitionType()==Definition::TypeClass || 
+           scope->definitionType()==Definition::TypeNamespace
+          ) 
+         )
+      {
+        scopeName=scope->name();
+      }
+      else if (m!=-1)
+      {
         scopeName = matchWord.left(m);
-        matchWord = matchWord.mid(m + 2);
+        matchWord = matchWord.mid(m+2);
       }
 
-      // printf("ScopeName=%s\n",scopeName.data());
-      // if (!found) printf("Trying to link %s in
-      // %s\n",word.data(),scopeName.data());
-      if (!found && getDefs(scopeName, matchWord, 0, md, cd, fd, nd, gd) &&
-          //(md->isTypedef() || md->isEnumerate() ||
+      //printf("ScopeName=%s\n",scopeName.data());
+      //if (!found) printf("Trying to link %s in %s\n",word.data(),scopeName.data()); 
+      if (!found && 
+          getDefs(scopeName,matchWord,0,md,cd,fd,nd,gd) && 
+          //(md->isTypedef() || md->isEnumerate() || 
           // md->isReference() || md->isVariable()
-          //) &&
-          (external ? md->isLinkable() : md->isLinkableInProject())) {
-        // printf("Found ref scope=%s\n",d?d->name().data():"<global>");
-        // ol.writeObjectLink(d->getReference(),d->getOutputFileBase(),
+          //) && 
+          (external ? md->isLinkable() : md->isLinkableInProject()) 
+         )
+      {
+        //printf("Found ref scope=%s\n",d?d->name().data():"<global>");
+        //ol.writeObjectLink(d->getReference(),d->getOutputFileBase(),
         //                       md->anchor(),word);
-        if (md != self && (self == 0 || md->name() != self->name()))
-        // name check is needed for overloaded members, where getDefs just
-        // returns one
+        if (md!=self && (self==0 || md->name()!=self->name())) 
+          // name check is needed for overloaded members, where getDefs just returns one
         {
-          out.writeLink(md->getReference(), md->getOutputFileBase(),
-                        md->anchor(), word);
-          // printf("found symbol %s\n",matchWord.data());
-          found = TRUE;
+          out.writeLink(md->getReference(),md->getOutputFileBase(),
+              md->anchor(),word);
+          //printf("found symbol %s\n",matchWord.data());
+          found=TRUE;
         }
       }
     }
 
     if (!found) // add word to the result
     {
-      out.writeString(word, keepSpaces);
+      out.writeString(word,keepSpaces);
     }
     // set next start point in the string
-    // printf("index=%d/%d\n",index,txtStr.length());
-    skipIndex = index = newIndex + matchLen;
+    //printf("index=%d/%d\n",index,txtStr.length());
+    skipIndex=index=newIndex+matchLen;
   }
   // add last part of the string to the result.
-  // ol.docify(txtStr.right(txtStr.length()-skipIndex));
-  out.writeString(txtStr.right(txtStr.length() - skipIndex), keepSpaces);
+  //ol.docify(txtStr.right(txtStr.length()-skipIndex));
+  out.writeString(txtStr.right(txtStr.length()-skipIndex),keepSpaces);
 }
 
-void writeExample(OutputList &ol, ExampleSDict *ed) {
-  QCString exampleLine = theTranslator->trWriteList(ed->count());
 
-  // bool latexEnabled = ol.isEnabled(OutputGenerator::Latex);
-  // bool manEnabled   = ol.isEnabled(OutputGenerator::Man);
-  // bool htmlEnabled  = ol.isEnabled(OutputGenerator::Html);
+void writeExample(OutputList &ol,ExampleSDict *ed)
+{
+  QCString exampleLine=theTranslator->trWriteList(ed->count());
+
+  //bool latexEnabled = ol.isEnabled(OutputGenerator::Latex);
+  //bool manEnabled   = ol.isEnabled(OutputGenerator::Man);
+  //bool htmlEnabled  = ol.isEnabled(OutputGenerator::Html);
   QRegExp marker("@[0-9]+");
-  int index = 0, newIndex, matchLen;
+  int index=0,newIndex,matchLen;
   // now replace all markers in inheritLine with links to the classes
-  while ((newIndex = marker.match(exampleLine, index, &matchLen)) != -1) {
+  while ((newIndex=marker.match(exampleLine,index,&matchLen))!=-1)
+  {
     bool ok;
-    ol.parseText(exampleLine.mid(index, newIndex - index));
-    uint entryIndex = exampleLine.mid(newIndex + 1, matchLen - 1).toUInt(&ok);
-    Example *e = ed->at(entryIndex);
-    if (ok && e) {
+    ol.parseText(exampleLine.mid(index,newIndex-index));
+    uint entryIndex = exampleLine.mid(newIndex+1,matchLen-1).toUInt(&ok);
+    Example *e=ed->at(entryIndex);
+    if (ok && e) 
+    {
       ol.pushGeneratorState();
-      // if (latexEnabled) ol.disable(OutputGenerator::Latex);
+      //if (latexEnabled) ol.disable(OutputGenerator::Latex);
       ol.disable(OutputGenerator::Latex);
       ol.disable(OutputGenerator::RTF);
       // link for Html / man
-      // printf("writeObjectLink(file=%s)\n",e->file.data());
-      ol.writeObjectLink(0, e->file, e->anchor, e->name);
+      //printf("writeObjectLink(file=%s)\n",e->file.data());
+      ol.writeObjectLink(0,e->file,e->anchor,e->name);
       ol.popGeneratorState();
 
       ol.pushGeneratorState();
-      // if (latexEnabled) ol.enable(OutputGenerator::Latex);
+      //if (latexEnabled) ol.enable(OutputGenerator::Latex);
       ol.disable(OutputGenerator::Man);
       ol.disable(OutputGenerator::Html);
       // link for Latex / pdf with anchor because the sources
       // are not hyperlinked (not possible with a verbatim environment).
-      ol.writeObjectLink(0, e->file, 0, e->name);
-      // if (manEnabled) ol.enable(OutputGenerator::Man);
-      // if (htmlEnabled) ol.enable(OutputGenerator::Html);
+      ol.writeObjectLink(0,e->file,0,e->name);
+      //if (manEnabled) ol.enable(OutputGenerator::Man);
+      //if (htmlEnabled) ol.enable(OutputGenerator::Html);
       ol.popGeneratorState();
     }
-    index = newIndex + matchLen;
-  }
-  ol.parseText(exampleLine.right(exampleLine.length() - index));
+    index=newIndex+matchLen;
+  } 
+  ol.parseText(exampleLine.right(exampleLine.length()-index));
   ol.writeString(".");
 }
 
-QCString argListToString(ArgumentList *al, bool useCanonicalType,
-                         bool showDefVals) {
+
+QCString argListToString(ArgumentList *al,bool useCanonicalType,bool showDefVals)
+{
   QCString result;
-  if (al == 0)
-    return result;
+  if (al==0) return result;
   ArgumentListIterator ali(*al);
-  Argument *a = ali.current();
-  result += "(";
-  while (a) {
-    QCString type1 =
-        useCanonicalType && !a->canType.isEmpty() ? a->canType : a->type;
+  Argument *a=ali.current();
+  result+="(";
+  while (a)
+  {
+    QCString type1 = useCanonicalType && !a->canType.isEmpty() ?
+      a->canType : a->type;
     QCString type2;
-    int i = type1.find(")("); // hack to deal with function pointers
-    if (i != -1) {
-      type2 = type1.mid(i);
-      type1 = type1.left(i);
+    int i=type1.find(")("); // hack to deal with function pointers
+    if (i!=-1)
+    {
+      type2=type1.mid(i);
+      type1=type1.left(i);
+    }
+    if (!a->attrib.isEmpty())
+    {
+      result+=a->attrib+" ";
     }
-    if (!a->attrib.isEmpty()) {
-      result += a->attrib + " ";
+    if (!a->name.isEmpty() || !a->array.isEmpty())
+    {
+      result+= type1+" "+a->name+type2+a->array;
     }
-    if (!a->name.isEmpty() || !a->array.isEmpty()) {
-      result += type1 + " " + a->name + type2 + a->array;
-    } else {
-      result += type1 + type2;
+    else
+    {
+      result+= type1+type2;
     }
-    if (!a->defval.isEmpty() && showDefVals) {
-      result += "=" + a->defval;
+    if (!a->defval.isEmpty() && showDefVals)
+    {
+      result+="="+a->defval;
     }
     ++ali;
     a = ali.current();
-<<<<<<< HEAD
-    if (a)
-      result += ", ";
-  }
-  result += ")";
-  if (al->constSpecifier)
-    result += " const";
-  if (al->volatileSpecifier)
-    result += " volatile";
-  if (!al->trailingReturnType.isEmpty())
-    result += " -> " + al->trailingReturnType;
-  if (al->pureSpecifier)
-    result += " =0";
-=======
     if (a) result+=", ";
   }
   result+=")";
@@ -2259,77 +2272,84 @@ QCString argListToString(ArgumentList *al, bool useCanonicalType,
   else if (al->refQualifier==RefQualifierRValue) result+=" &&";
   if (!al->trailingReturnType.isEmpty()) result+=" -> "+al->trailingReturnType;
   if (al->pureSpecifier) result+=" =0";
->>>>>>> 5f01f783e2387a5d44ad70fbff5365aa0e5df938
   return removeRedundantWhiteSpace(result);
 }
 
-QCString tempArgListToString(ArgumentList *al, SrcLangExt lang) {
+QCString tempArgListToString(ArgumentList *al,SrcLangExt lang)
+{
   QCString result;
-  if (al == 0)
-    return result;
-  result = "<";
+  if (al==0) return result;
+  result="<";
   ArgumentListIterator ali(*al);
-  Argument *a = ali.current();
-  while (a) {
+  Argument *a=ali.current();
+  while (a)
+  {
     if (!a->name.isEmpty()) // add template argument name
     {
-      if (a->type.left(4) == "out") // C# covariance
+      if (a->type.left(4)=="out") // C# covariance
       {
-        result += "out ";
-      } else if (a->type.left(3) == "in") // C# contravariance
+        result+="out ";
+      }
+      else if (a->type.left(3)=="in") // C# contravariance
       {
-        result += "in ";
+        result+="in ";
       }
-      if (lang == SrcLangExt_Java || lang == SrcLangExt_CSharp) {
-        result += a->type + " ";
+      if (lang==SrcLangExt_Java || lang==SrcLangExt_CSharp)
+      {
+        result+=a->type+" ";
       }
-      result += a->name;
-    } else // extract name from type
+      result+=a->name;
+    }
+    else // extract name from type
     {
-      int i = a->type.length() - 1;
-      while (i >= 0 && isId(a->type.at(i)))
-        i--;
-      if (i > 0) {
-        result += a->type.right(a->type.length() - i - 1);
-        if (a->type.find("...") != -1) {
-          result += "...";
+      int i=a->type.length()-1;
+      while (i>=0 && isId(a->type.at(i))) i--;
+      if (i>0)
+      {
+        result+=a->type.right(a->type.length()-i-1);
+        if (a->type.find("...")!=-1)
+        {
+          result+="...";
         }
-      } else // nothing found -> take whole name
+      }
+      else // nothing found -> take whole name
       {
-        result += a->type;
+        result+=a->type;
       }
     }
-    if (!a->typeConstraint.isEmpty() && lang == SrcLangExt_Java) {
-      result += " extends "; // TODO: now Java specific, C# has where...
-      result += a->typeConstraint;
+    if (!a->typeConstraint.isEmpty() && lang==SrcLangExt_Java)
+    {
+      result+=" extends "; // TODO: now Java specific, C# has where...
+      result+=a->typeConstraint;
     }
     ++ali;
-    a = ali.current();
-    if (a)
-      result += ", ";
+    a=ali.current();
+    if (a) result+=", ";
   }
-  result += ">";
+  result+=">";
   return removeRedundantWhiteSpace(result);
 }
 
+
 // compute the HTML anchors for a list of members
-void setAnchors(MemberList *ml) {
-  // int count=0;
-  if (ml == 0)
-    return;
+void setAnchors(MemberList *ml)
+{
+  //int count=0;
+  if (ml==0) return;
   MemberListIterator mli(*ml);
   MemberDef *md;
-  for (; (md = mli.current()); ++mli) {
-    if (!md->isReference()) {
-      // QCString anchor;
-      // if (groupId==-1)
+  for (;(md=mli.current());++mli)
+  {
+    if (!md->isReference())
+    {
+      //QCString anchor;
+      //if (groupId==-1)
       //  anchor.sprintf("%c%d",id,count++);
-      // else
+      //else
       //  anchor.sprintf("%c%d_%d",id,groupId,count++);
-      // if (cd) anchor.prepend(escapeCharsInString(cd->name(),FALSE));
+      //if (cd) anchor.prepend(escapeCharsInString(cd->name(),FALSE));
       md->setAnchor();
-      // printf("setAnchors(): Member %s outputFileBase=%s anchor %s result
-      // %s\n",
+      //printf("setAnchors(): Member %s outputFileBase=%s anchor %s result %s\n",
       //    md->name().data(),md->getOutputFileBase().data(),anchor.data(),md->anchor().data());
     }
   }
@@ -2342,47 +2362,53 @@ void setAnchors(MemberList *ml) {
  * converted content (i.e. the same as \a len (Unix, MAC) or
  * smaller (DOS).
  */
-int filterCRLF(char *buf, int len) {
-  int src = 0;  // source index
-  int dest = 0; // destination index
-  char c;       // current character
+int filterCRLF(char *buf,int len)
+{
+  int src = 0;    // source index
+  int dest = 0;   // destination index
+  char c;         // current character
 
-  while (src < len) {
-    c = buf[src++]; // Remember the processed character.
-    if (c == '\r')  // CR to be solved (MAC, DOS)
+  while (src<len)
+  {
+    c = buf[src++];            // Remember the processed character.
+    if (c == '\r')             // CR to be solved (MAC, DOS)
     {
-      c = '\n'; // each CR to LF
-      if (src < len && buf[src] == '\n')
-        ++src;                             // skip LF just after CR (DOS)
-    } else if (c == '\0' && src < len - 1) // filter out internal \0 characters,
-                                           // as it will confuse the parser
+      c = '\n';                // each CR to LF
+      if (src<len && buf[src] == '\n')
+        ++src;                 // skip LF just after CR (DOS) 
+    }
+    else if ( c == '\0' && src<len-1) // filter out internal \0 characters, as it will confuse the parser
     {
-      c = ' '; // turn into a space
+      c = ' ';                 // turn into a space
     }
-    buf[dest++] = c; // copy the (modified) character to dest
+    buf[dest++] = c;           // copy the (modified) character to dest
   }
-  return dest; // length of the valid part of the buf
+  return dest;                 // length of the valid part of the buf
 }
 
-static QCString getFilterFromList(const char *name, const QStrList &filterList,
-                                  bool &found) {
-  found = FALSE;
+static QCString getFilterFromList(const char *name,const QStrList &filterList,bool &found)
+{
+  found=FALSE;
   // compare the file name to the filter pattern list
   QStrListIterator sli(filterList);
-  char *filterStr;
-  for (sli.toFirst(); (filterStr = sli.current()); ++sli) {
+  char* filterStr;
+  for (sli.toFirst(); (filterStr = sli.current()); ++sli)
+  {
     QCString fs = filterStr;
-    int i_equals = fs.find('=');
-    if (i_equals != -1) {
+    int i_equals=fs.find('=');
+    if (i_equals!=-1)
+    {
       QCString filterPattern = fs.left(i_equals);
-      QRegExp fpat(filterPattern, portable_fileSystemIsCaseSensitive(), TRUE);
-      if (fpat.match(name) != -1) {
+      QRegExp fpat(filterPattern,portable_fileSystemIsCaseSensitive(),TRUE); 
+      if (fpat.match(name)!=-1) 
+      {
         // found a match!
-        QCString filterName = fs.mid(i_equals + 1);
-        if (filterName.find(' ') != -1) { // add quotes if the name has spaces
-          filterName = "\"" + filterName + "\"";
+        QCString filterName = fs.mid(i_equals+1);
+        if (filterName.find(' ')!=-1)
+        { // add quotes if the name has spaces
+          filterName="\""+filterName+"\"";
         }
-        found = TRUE;
+        found=TRUE;
         return filterName;
       }
     }
@@ -2397,66 +2423,75 @@ static QCString getFilterFromList(const char *name, const QStrList &filterList,
  *  In case \a inSourceCode is TRUE then first the source filter list is
  *  considered.
  */
-QCString getFileFilter(const char *name, bool isSourceCode) {
+QCString getFileFilter(const char* name,bool isSourceCode)
+{
   // sanity check
-  if (name == 0)
-    return "";
+  if (name==0) return "";
 
-  QStrList &filterSrcList = Config_getList(FILTER_SOURCE_PATTERNS);
-  QStrList &filterList = Config_getList(FILTER_PATTERNS);
+  QStrList& filterSrcList = Config_getList(FILTER_SOURCE_PATTERNS);
+  QStrList& filterList    = Config_getList(FILTER_PATTERNS);
 
   QCString filterName;
-  bool found = FALSE;
-  if (isSourceCode &&
-      !filterSrcList.isEmpty()) { // first look for source filter pattern list
-    filterName = getFilterFromList(name, filterSrcList, found);
+  bool found=FALSE;
+  if (isSourceCode && !filterSrcList.isEmpty())
+  { // first look for source filter pattern list
+    filterName = getFilterFromList(name,filterSrcList,found);
   }
-  if (!found && filterName.isEmpty()) { // then look for filter pattern list
-    filterName = getFilterFromList(name, filterList, found);
+  if (!found && filterName.isEmpty())
+  { // then look for filter pattern list
+    filterName = getFilterFromList(name,filterList,found);
   }
-  if (!found) { // then use the generic input filter
+  if (!found)
+  { // then use the generic input filter
     return Config_getString(INPUT_FILTER);
-  } else {
+  }
+  else
+  {
     /* remove surrounding double quotes */
-    if ((filterName.right(1) == "\"") && (filterName.left(1) == "\"")) {
-      filterName.remove(filterName.length() - 1, 1);
-      filterName.remove(0, 1);
+    if ((filterName.right(1) == "\"") && (filterName.left(1) == "\""))
+    {
+       filterName.remove(filterName.length() - 1, 1);
+       filterName.remove(0, 1);
     }
     return filterName;
   }
 }
 
-QCString transcodeCharacterStringToUTF8(const QCString &input) {
-  bool error = FALSE;
+
+QCString transcodeCharacterStringToUTF8(const QCString &input)
+{
+  bool error=FALSE;
   static QCString inputEncoding = Config_getString(INPUT_ENCODING);
   const char *outputEncoding = "UTF-8";
-  if (inputEncoding.isEmpty() || qstricmp(inputEncoding, outputEncoding) == 0)
-    return input;
-  int inputSize = input.length();
-  int outputSize = inputSize * 4 + 1;
+  if (inputEncoding.isEmpty() || qstricmp(inputEncoding,outputEncoding)==0) return input;
+  int inputSize=input.length();
+  int outputSize=inputSize*4+1;
   QCString output(outputSize);
-  void *cd = portable_iconv_open(outputEncoding, inputEncoding);
-  if (cd == (void *)(-1)) {
-    err("unsupported character conversion: '%s'->'%s'\n", inputEncoding.data(),
-        outputEncoding);
-    error = TRUE;
-  }
-  if (!error) {
-    size_t iLeft = inputSize;
-    size_t oLeft = outputSize;
+  void *cd = portable_iconv_open(outputEncoding,inputEncoding);
+  if (cd==(void *)(-1)) 
+  {
+    err("unsupported character conversion: '%s'->'%s'\n",
+        inputEncoding.data(),outputEncoding);
+    error=TRUE;
+  }
+  if (!error)
+  {
+    size_t iLeft=inputSize;
+    size_t oLeft=outputSize;
     char *inputPtr = input.rawData();
     char *outputPtr = output.rawData();
-    if (!portable_iconv(cd, &inputPtr, &iLeft, &outputPtr, &oLeft)) {
-      outputSize -= (int)oLeft;
-      output.resize(outputSize + 1);
-      output.at(outputSize) = '\0';
-      // printf("iconv: input size=%d output
-      // size=%d\n[%s]\n",size,newSize,srcBuf.data());
-    } else {
-      err("failed to translate characters from %s to %s: check "
-          "INPUT_ENCODING\ninput=[%s]\n",
-          inputEncoding.data(), outputEncoding, input.data());
-      error = TRUE;
+    if (!portable_iconv(cd, &inputPtr, &iLeft, &outputPtr, &oLeft))
+    {
+      outputSize-=(int)oLeft;
+      output.resize(outputSize+1);
+      output.at(outputSize)='\0';
+      //printf("iconv: input size=%d output size=%d\n[%s]\n",size,newSize,srcBuf.data());
+    }
+    else
+    {
+      err("failed to translate characters from %s to %s: check INPUT_ENCODING\ninput=[%s]\n",
+          inputEncoding.data(),outputEncoding,input.data());
+      error=TRUE;
     }
   }
   portable_iconv_close(cd);
@@ -2465,163 +2500,179 @@ QCString transcodeCharacterStringToUTF8(const QCString &input) {
 
 /*! reads a file with name \a name and returns it as a string. If \a filter
  *  is TRUE the file will be filtered by any user specified input filter.
- *  If \a name is "-" the string will be read from standard input.
+ *  If \a name is "-" the string will be read from standard input. 
  */
-QCString fileToString(const char *name, bool filter, bool isSourceCode) {
-  if (name == 0 || name[0] == 0)
-    return 0;
+QCString fileToString(const char *name,bool filter,bool isSourceCode)
+{
+  if (name==0 || name[0]==0) return 0;
   QFile f;
 
-  bool fileOpened = FALSE;
-  if (name[0] == '-' && name[1] == 0) // read from stdin
+  bool fileOpened=FALSE;
+  if (name[0]=='-' && name[1]==0) // read from stdin
   {
-    fileOpened = f.open(IO_ReadOnly, stdin);
-    if (fileOpened) {
-      const int bSize = 4096;
+    fileOpened=f.open(IO_ReadOnly,stdin);
+    if (fileOpened)
+    {
+      const int bSize=4096;
       QCString contents(bSize);
-      int totalSize = 0;
+      int totalSize=0;
       int size;
-      while ((size = f.readBlock(contents.rawData() + totalSize, bSize)) ==
-             bSize) {
-        totalSize += bSize;
-        contents.resize(totalSize + bSize);
+      while ((size=f.readBlock(contents.rawData()+totalSize,bSize))==bSize)
+      {
+        totalSize+=bSize;
+        contents.resize(totalSize+bSize);
       }
-      totalSize = filterCRLF(contents.rawData(), totalSize + size) + 2;
+      totalSize = filterCRLF(contents.rawData(),totalSize+size)+2;
       contents.resize(totalSize);
-      contents.at(totalSize - 2) = '\n'; // to help the scanner
-      contents.at(totalSize - 1) = '\0';
+      contents.at(totalSize-2)='\n'; // to help the scanner
+      contents.at(totalSize-1)='\0';
       return contents;
     }
-  } else // read from file
+  }
+  else // read from file
   {
     QFileInfo fi(name);
-    if (!fi.exists() || !fi.isFile()) {
-      err("file `%s' not found\n", name);
+    if (!fi.exists() || !fi.isFile())
+    {
+      err("file `%s' not found\n",name);
       return "";
     }
     BufStr buf(fi.size());
-    fileOpened = readInputFile(name, buf, filter, isSourceCode);
-    if (fileOpened) {
+    fileOpened=readInputFile(name,buf,filter,isSourceCode);
+    if (fileOpened)
+    {
       int s = buf.size();
-      if (s > 1 && buf.at(s - 2) != '\n') {
-        buf.at(s - 1) = '\n';
+      if (s>1 && buf.at(s-2)!='\n')
+      {
+        buf.at(s-1)='\n';
         buf.addChar(0);
       }
       return buf.data();
     }
   }
-  if (!fileOpened) {
-    err("cannot open file `%s' for reading\n", name);
+  if (!fileOpened)  
+  {
+    err("cannot open file `%s' for reading\n",name);
   }
   return "";
 }
 
-QCString dateToString(bool includeTime) {
+QCString dateToString(bool includeTime)
+{
   QDateTime current = QDateTime::currentDateTime();
   QCString sourceDateEpoch = portable_getenv("SOURCE_DATE_EPOCH");
-  if (!sourceDateEpoch.isEmpty()) {
+  if (!sourceDateEpoch.isEmpty())
+  {
     bool ok;
     uint64 epoch = sourceDateEpoch.toUInt64(&ok);
-    if (!ok) {
-      static bool warnedOnce = FALSE;
-      if (!warnedOnce) {
-        warn_uncond("Environment variable SOURCE_DATE_EPOCH does not contain a "
-                    "valid number; value is '%s'\n",
-                    sourceDateEpoch.data());
-        warnedOnce = TRUE;
+    if (!ok)
+    {
+      static bool warnedOnce=FALSE;
+      if (!warnedOnce)
+      {
+        warn_uncond("Environment variable SOURCE_DATE_EPOCH does not contain a valid number; value is '%s'\n",
+            sourceDateEpoch.data());
+        warnedOnce=TRUE;
       }
-    } else if (epoch > UINT_MAX) {
-      static bool warnedOnce = FALSE;
-      if (!warnedOnce) {
-        warn_uncond("Environment variable SOURCE_DATA_EPOCH must have a value "
-                    "smaller than or equal to %llu; actual value %llu\n",
-                    UINT_MAX, epoch);
-        warnedOnce = TRUE;
+    }
+    else if (epoch>UINT_MAX)
+    {
+      static bool warnedOnce=FALSE;
+      if (!warnedOnce)
+      {
+        warn_uncond("Environment variable SOURCE_DATA_EPOCH must have a value smaller than or equal to %llu; actual value %llu\n",UINT_MAX,epoch);
+        warnedOnce=TRUE;
       }
-    } else // all ok, replace current time with epoch value
+    }
+    else // all ok, replace current time with epoch value
     {
-      current.setTimeUtc_t(
-          (ulong)epoch); // TODO: add support for 64bit epoch value
+      current.setTimeUtc_t((ulong)epoch); // TODO: add support for 64bit epoch value
     }
   }
-  return theTranslator->trDateTime(
-      current.date().year(), current.date().month(), current.date().day(),
-      current.date().dayOfWeek(), current.time().hour(),
-      current.time().minute(), current.time().second(), includeTime);
+  return theTranslator->trDateTime(current.date().year(),
+                                   current.date().month(),
+                                   current.date().day(),
+                                   current.date().dayOfWeek(),
+                                   current.time().hour(),
+                                   current.time().minute(),
+                                   current.time().second(),
+                                   includeTime);
 }
 
-QCString yearToString() {
-  const QDate &d = QDate::currentDate();
+QCString yearToString()
+{
+  const QDate &d=QDate::currentDate();
   QCString result;
   result.sprintf("%d", d.year());
   return result;
 }
 
 //----------------------------------------------------------------------
-// recursive function that returns the number of branches in the
+// recursive function that returns the number of branches in the 
 // inheritance tree that the base class `bcd' is below the class `cd'
 
-int minClassDistance(const ClassDef *cd, const ClassDef *bcd, int level) {
-  if (bcd->categoryOf()) // use class that is being extended in case of
-  // an Objective-C category
+int minClassDistance(const ClassDef *cd,const ClassDef *bcd,int level)
+{
+  if (bcd->categoryOf()) // use class that is being extended in case of 
+    // an Objective-C category
   {
-    bcd = bcd->categoryOf();
+    bcd=bcd->categoryOf();
   }
-  if (cd == bcd)
-    return level;
-  if (level == 256) {
+  if (cd==bcd) return level; 
+  if (level==256)
+  {
     warn_uncond("class %s seem to have a recursive "
-                "inheritance relation!\n",
-                cd->name().data());
+        "inheritance relation!\n",cd->name().data());
     return -1;
   }
-  int m = maxInheritanceDepth;
-  if (cd->baseClasses()) {
+  int m=maxInheritanceDepth; 
+  if (cd->baseClasses())
+  {
     BaseClassListIterator bcli(*cd->baseClasses());
     BaseClassDef *bcdi;
-    for (; (bcdi = bcli.current()); ++bcli) {
-      int mc = minClassDistance(bcdi->classDef, bcd, level + 1);
-      if (mc < m)
-        m = mc;
-      if (m < 0)
-        break;
+    for (;(bcdi=bcli.current());++bcli)
+    {
+      int mc=minClassDistance(bcdi->classDef,bcd,level+1);
+      if (mc<m) m=mc;
+      if (m<0) break;
     }
   }
   return m;
 }
 
-Protection classInheritedProtectionLevel(ClassDef *cd, ClassDef *bcd,
-                                         Protection prot, int level) {
-  if (bcd->categoryOf()) // use class that is being extended in case of
-  // an Objective-C category
+Protection classInheritedProtectionLevel(ClassDef *cd,ClassDef *bcd,Protection prot,int level)
+{
+  if (bcd->categoryOf()) // use class that is being extended in case of 
+    // an Objective-C category
   {
-    bcd = bcd->categoryOf();
+    bcd=bcd->categoryOf();
   }
-  if (cd == bcd) {
+  if (cd==bcd) 
+  {
     goto exit;
   }
-  if (level == 256) {
+  if (level==256)
+  {
     err("Internal inconsistency: found class %s seem to have a recursive "
-        "inheritance relation! Please send a bug report to dimitri@stack.nl\n",
-        cd->name().data());
-  } else if (cd->baseClasses()) {
+        "inheritance relation! Please send a bug report to dimitri@stack.nl\n",cd->name().data());
+  }
+  else if (cd->baseClasses())
+  {
     BaseClassListIterator bcli(*cd->baseClasses());
     BaseClassDef *bcdi;
-    for (; (bcdi = bcli.current()) && prot != Private; ++bcli) {
-      Protection baseProt = classInheritedProtectionLevel(
-          bcdi->classDef, bcd, bcdi->prot, level + 1);
-      if (baseProt == Private)
-        prot = Private;
-      else if (baseProt == Protected)
-        prot = Protected;
+    for (;(bcdi=bcli.current()) && prot!=Private;++bcli)
+    {
+      Protection baseProt = classInheritedProtectionLevel(bcdi->classDef,bcd,bcdi->prot,level+1);
+      if (baseProt==Private)   prot=Private;
+      else if (baseProt==Protected) prot=Protected;
     }
   }
 exit:
-  // printf("classInheritedProtectionLevel(%s,%s)=%d\n",cd->name().data(),bcd->name().data(),prot);
+  //printf("classInheritedProtectionLevel(%s,%s)=%d\n",cd->name().data(),bcd->name().data(),prot);
   return prot;
 }
 
-// static void printArgList(ArgumentList *al)
+//static void printArgList(ArgumentList *al)
 //{
 //  if (al==0) return;
 //  ArgumentListIterator ali(*al);
@@ -2629,79 +2680,77 @@ exit:
 //  printf("(");
 //  for (;(a=ali.current());++ali)
 //  {
-//    printf("t=`%s' n=`%s' v=`%s'
-//    ",a->type.data(),!a->name.isEmpty()>0?a->name.data():"",!a->defval.isEmpty()>0?a->defval.data():"");
+//    printf("t=`%s' n=`%s' v=`%s' ",a->type.data(),!a->name.isEmpty()>0?a->name.data():"",!a->defval.isEmpty()>0?a->defval.data():""); 
 //  }
 //  printf(")");
 //}
 
 #ifndef NEWMATCH
 // strip any template specifiers that follow className in string s
-static QCString trimTemplateSpecifiers(const QCString &namespaceName,
-                                       const QCString &className,
-                                       const QCString &s) {
-  // printf("trimTemplateSpecifiers(%s,%s,%s)\n",namespaceName.data(),className.data(),s.data());
-  QCString scopeName = mergeScopes(namespaceName, className);
-  ClassDef *cd = getClass(scopeName);
-  if (cd == 0)
-    return s; // should not happen, but guard anyway.
+static QCString trimTemplateSpecifiers(
+    const QCString &namespaceName,
+    const QCString &className,
+    const QCString &s
+    )
+{
+  //printf("trimTemplateSpecifiers(%s,%s,%s)\n",namespaceName.data(),className.data(),s.data());
+  QCString scopeName=mergeScopes(namespaceName,className);
+  ClassDef *cd=getClass(scopeName);
+  if (cd==0) return s; // should not happen, but guard anyway.
 
-  QCString result = s;
+  QCString result=s;
 
-  int i = className.length() - 1;
-  if (i >= 0 && className.at(i) == '>') // template specialization
+  int i=className.length()-1;
+  if (i>=0 && className.at(i)=='>') // template specialization
   {
     // replace unspecialized occurrences in s, with their specialized versions.
-    int count = 1;
-    int cl = i + 1;
-    while (i >= 0) {
-      char c = className.at(i);
-      if (c == '>')
-        count++, i--;
-      else if (c == '<') {
-        count--;
-        if (count == 0)
-          break;
-      } else
-        i--;
-    }
-    QCString unspecClassName = className.left(i);
-    int l = i;
-    int p = 0;
-    while ((i = result.find(unspecClassName, p)) != -1) {
-      if (result.at(i + l) != '<') // unspecialized version
+    int count=1;
+    int cl=i+1;
+    while (i>=0)
+    {
+      char c=className.at(i);
+      if (c=='>') count++,i--;
+      else if (c=='<') { count--; if (count==0) break; }
+      else i--;
+    }
+    QCString unspecClassName=className.left(i);
+    int l=i;
+    int p=0;
+    while ((i=result.find(unspecClassName,p))!=-1)
+    {
+      if (result.at(i+l)!='<') // unspecialized version
       {
-        result =
-            result.left(i) + className + result.right(result.length() - i - l);
-        l = cl;
+        result=result.left(i)+className+result.right(result.length()-i-l);
+        l=cl;
       }
-      p = i + l;
+      p=i+l;
     }
   }
 
-  // printf("result after specialization: %s\n",result.data());
+  //printf("result after specialization: %s\n",result.data());
 
-  QCString qualName = cd->qualifiedNameWithTemplateParameters();
-  // printf("QualifiedName = %s\n",qualName.data());
+  QCString qualName=cd->qualifiedNameWithTemplateParameters();
+  //printf("QualifiedName = %s\n",qualName.data());
   // We strip the template arguments following className (if any)
   if (!qualName.isEmpty()) // there is a class name
   {
-    int is, ps = 0;
-    int p = 0, l, i;
+    int is,ps=0;
+    int p=0,l,i;
 
-    while ((is = getScopeFragment(qualName, ps, &l)) != -1) {
-      QCString qualNamePart = qualName.right(qualName.length() - is);
-      // printf("qualNamePart=%s\n",qualNamePart.data());
-      while ((i = result.find(qualNamePart, p)) != -1) {
-        int ql = qualNamePart.length();
-        result = result.left(i) + cd->name() +
-                 result.right(result.length() - i - ql);
-        p = i + cd->name().length();
+    while ((is=getScopeFragment(qualName,ps,&l))!=-1)
+    {
+      QCString qualNamePart = qualName.right(qualName.length()-is);
+      //printf("qualNamePart=%s\n",qualNamePart.data());
+      while ((i=result.find(qualNamePart,p))!=-1)
+      {
+        int ql=qualNamePart.length();
+        result=result.left(i)+cd->name()+result.right(result.length()-i-ql);
+        p=i+cd->name().length();
       }
-      ps = is + l;
+      ps=is+l;
     }
   }
-  // printf("result=%s\n",result.data());
+  //printf("result=%s\n",result.data());
 
   return result.stripWhiteSpace();
 }
@@ -2713,94 +2762,107 @@ static QCString trimTemplateSpecifiers(const QCString &namespaceName,
  * @param len resulting pattern length
  * @returns position on which string is found, or -1 if not found
  */
-static int findScopePattern(const QCString &pattern, const QCString &s, int p,
-                            int *len) {
-  int sl = s.length();
-  int pl = pattern.length();
-  int sp = 0;
-  *len = 0;
-  while (p < sl) {
-    sp = p;     // start of match
-    int pp = 0; // pattern position
-    while (p < sl && pp < pl) {
-      if (s.at(p) == '<') // skip template arguments while matching
-      {
-        int bc = 1;
-        // printf("skipping pos=%d c=%c\n",p,s.at(p));
+static int findScopePattern(const QCString &pattern,const QCString &s,
+    int p,int *len)
+{
+  int sl=s.length();
+  int pl=pattern.length();
+  int sp=0; 
+  *len=0;
+  while (p<sl)
+  {
+    sp=p; // start of match
+    int pp=0; // pattern position
+    while (p<sl && pp<pl)
+    {
+      if (s.at(p)=='<') // skip template arguments while matching
+      {
+        int bc=1;
+        //printf("skipping pos=%d c=%c\n",p,s.at(p));
         p++;
-        while (p < sl) {
-          if (s.at(p) == '<')
-            bc++;
-          else if (s.at(p) == '>') {
+        while (p<sl)
+        {
+          if (s.at(p)=='<') bc++;
+          else if (s.at(p)=='>') 
+          {
             bc--;
-            if (bc == 0) {
+            if (bc==0) 
+            {
               p++;
               break;
             }
           }
-          // printf("skipping pos=%d c=%c\n",p,s.at(p));
+          //printf("skipping pos=%d c=%c\n",p,s.at(p));
           p++;
         }
-      } else if (s.at(p) == pattern.at(pp)) {
-        // printf("match at position p=%d pp=%d c=%c\n",p,pp,s.at(p));
+      }
+      else if (s.at(p)==pattern.at(pp))
+      {
+        //printf("match at position p=%d pp=%d c=%c\n",p,pp,s.at(p));
         p++;
         pp++;
-      } else // no match
+      }
+      else // no match
       {
-        // printf("restarting at %d c=%c pat=%s\n",p,s.at(p),pattern.data());
-        p = sp + 1;
+        //printf("restarting at %d c=%c pat=%s\n",p,s.at(p),pattern.data());
+        p=sp+1;
         break;
       }
     }
-    if (pp == pl) // whole pattern matches
+    if (pp==pl) // whole pattern matches
     {
-      *len = p - sp;
+      *len=p-sp;
       return sp;
     }
   }
   return -1;
 }
 
-static QCString trimScope(const QCString &name, const QCString &s) {
-  int scopeOffset = name.length();
-  QCString result = s;
+static QCString trimScope(const QCString &name,const QCString &s)
+{
+  int scopeOffset=name.length();
+  QCString result=s;
   do // for each scope
   {
     QCString tmp;
-    QCString scope = name.left(scopeOffset) + "::";
-    // printf("Trying with scope=`%s'\n",scope.data());
+    QCString scope=name.left(scopeOffset)+"::";
+    //printf("Trying with scope=`%s'\n",scope.data());
 
-    int i, p = 0, l;
-    while ((i = findScopePattern(scope, result, p, &l)) !=
-           -1) // for each occurrence
+    int i,p=0,l;
+    while ((i=findScopePattern(scope,result,p,&l))!=-1) // for each occurrence
     {
-      tmp += result.mid(p, i - p); // add part before pattern
-      p = i + l;
+      tmp+=result.mid(p,i-p); // add part before pattern
+      p=i+l;
     }
-    tmp += result.right(result.length() - p); // add trailing part
+    tmp+=result.right(result.length()-p); // add trailing part
 
-    scopeOffset = name.findRev("::", scopeOffset - 1);
+    scopeOffset=name.findRev("::",scopeOffset-1);
     result = tmp;
-  } while (scopeOffset > 0);
-  // printf("trimScope(name=%s,scope=%s)=%s\n",name.data(),s.data(),result.data());
+  } while (scopeOffset>0);   
+  //printf("trimScope(name=%s,scope=%s)=%s\n",name.data(),s.data(),result.data());
   return result;
 }
 #endif
 
-void trimBaseClassScope(BaseClassList *bcl, QCString &s, int level = 0) {
-  // printf("trimBaseClassScope level=%d `%s'\n",level,s.data());
+void trimBaseClassScope(BaseClassList *bcl,QCString &s,int level=0)
+{
+  //printf("trimBaseClassScope level=%d `%s'\n",level,s.data());
   BaseClassListIterator bcli(*bcl);
   BaseClassDef *bcd;
-  for (; (bcd = bcli.current()); ++bcli) {
-    ClassDef *cd = bcd->classDef;
-    // printf("Trying class %s\n",cd->name().data());
-    int spos = s.find(cd->name() + "::");
-    if (spos != -1) {
-      s = s.left(spos) + s.right(s.length() - spos - cd->name().length() - 2);
-    }
-    // printf("base class `%s'\n",cd->name().data());
+  for (;(bcd=bcli.current());++bcli)
+  {
+    ClassDef *cd=bcd->classDef;
+    //printf("Trying class %s\n",cd->name().data());
+    int spos=s.find(cd->name()+"::");
+    if (spos!=-1)
+    {
+      s = s.left(spos)+s.right(
+          s.length()-spos-cd->name().length()-2
+          );
+    }
+    //printf("base class `%s'\n",cd->name().data());
     if (cd->baseClasses())
-      trimBaseClassScope(cd->baseClasses(), s, level + 1);
+      trimBaseClassScope(cd->baseClasses(),s,level+1); 
   }
 }
 
@@ -2881,41 +2943,38 @@ static void trimNamespaceScope(QCString &t1,QCString &t2,const QCString &nsName)
 }
 #endif
 
-static void stripIrrelevantString(QCString &target, const QCString &str) {
-  if (target == str) {
-    target.resize(0);
-    return;
-  }
-  int i, p = 0;
-  int l = str.length();
-  bool changed = FALSE;
-  while ((i = target.find(str, p)) != -1) {
-    bool isMatch =
-        (i == 0 || !isId(target.at(i - 1))) && // not a character before str
-        (i + l == (int)target.length() ||
-         !isId(target.at(i + l))); // not a character after str
-    if (isMatch) {
-      int i1 = target.find('*', i + l);
-      int i2 = target.find('&', i + l);
-      if (i1 == -1 && i2 == -1) {
+static void stripIrrelevantString(QCString &target,const QCString &str)
+{
+  if (target==str) { target.resize(0); return; }
+  int i,p=0;
+  int l=str.length();
+  bool changed=FALSE;
+  while ((i=target.find(str,p))!=-1)
+  {
+    bool isMatch = (i==0 || !isId(target.at(i-1))) && // not a character before str
+      (i+l==(int)target.length() || !isId(target.at(i+l))); // not a character after str
+    if (isMatch)
+    {
+      int i1=target.find('*',i+l);
+      int i2=target.find('&',i+l);
+      if (i1==-1 && i2==-1)
+      {
         // strip str from target at index i
-        target = target.left(i) + target.right(target.length() - i - l);
-        changed = TRUE;
-        i -= l;
-      } else if ((i1 != -1 && i < i1) ||
-                 (i2 != -1 && i < i2)) // str before * or &
+        target=target.left(i)+target.right(target.length()-i-l); 
+        changed=TRUE;
+        i-=l;
+      }
+      else if ((i1!=-1 && i<i1) || (i2!=-1 && i<i2)) // str before * or &
       {
         // move str to front
-        target =
-            str + " " + target.left(i) + target.right(target.length() - i - l);
-        changed = TRUE;
+        target=str+" "+target.left(i)+target.right(target.length()-i-l);
+        changed=TRUE;
         i++;
       }
     }
-    p = i + l;
+    p = i+l;
   }
-  if (changed)
-    target = target.stripWhiteSpace();
+  if (changed) target=target.stripWhiteSpace();
 }
 
 /*! According to the C++ spec and Ivan Vecerina:
@@ -2930,19 +2989,21 @@ static void stripIrrelevantString(QCString &target, const QCString &str) {
 
   \code
   const T param     ->   T param          // not relevant
-  const T& param    ->   const T& param   // const needed
-  T* const param    ->   T* param         // not relevant
+  const T& param    ->   const T& param   // const needed               
+  T* const param    ->   T* param         // not relevant                   
   const T* param    ->   const T* param   // const needed
   \endcode
  */
-void stripIrrelevantConstVolatile(QCString &s) {
-  // printf("stripIrrelevantConstVolatile(%s)=",s.data());
-  stripIrrelevantString(s, "const");
-  stripIrrelevantString(s, "volatile");
-  stripIrrelevantString(s, "final");
-  // printf("%s\n",s.data());
+void stripIrrelevantConstVolatile(QCString &s)
+{
+  //printf("stripIrrelevantConstVolatile(%s)=",s.data());
+  stripIrrelevantString(s,"const");
+  stripIrrelevantString(s,"volatile");
+  stripIrrelevantString(s,"final");
+  //printf("%s\n",s.data());
 }
 
+
 // a bit of debug support for matchArguments
 #define MATCH
 #define NOMATCH
@@ -2950,12 +3011,13 @@ void stripIrrelevantConstVolatile(QCString &s) {
 //#define NOMATCH printf("Nomatch at line %d\n",__LINE__);
 
 #ifndef NEWMATCH
-static bool matchArgument(const Argument *srcA, const Argument *dstA,
-                          const QCString &className,
-                          const QCString &namespaceName,
-                          NamespaceSDict *usingNamespaces,
-                          SDict<Definition> *usingClasses) {
-  // printf("match argument start `%s|%s' <-> `%s|%s' using nsp=%p class=%p\n",
+static bool matchArgument(const Argument *srcA,const Argument *dstA,
+    const QCString &className,
+    const QCString &namespaceName,
+    NamespaceSDict *usingNamespaces,
+    SDict<Definition> *usingClasses)
+{
+  //printf("match argument start `%s|%s' <-> `%s|%s' using nsp=%p class=%p\n",
   //    srcA->type.data(),srcA->name.data(),
   //    dstA->type.data(),dstA->name.data(),
   //    usingNamespaces,
@@ -2966,177 +3028,199 @@ static bool matchArgument(const Argument *srcA, const Argument *dstA,
   //       and usingNamespaces and usingClass to determine which typedefs
   //       are in-scope, so it will not be very efficient :-(
 
-  QCString srcAType =
-      trimTemplateSpecifiers(namespaceName, className, srcA->type);
-  QCString dstAType =
-      trimTemplateSpecifiers(namespaceName, className, dstA->type);
-  QCString srcAName = srcA->name.stripWhiteSpace();
-  QCString dstAName = dstA->name.stripWhiteSpace();
+  QCString srcAType=trimTemplateSpecifiers(namespaceName,className,srcA->type);
+  QCString dstAType=trimTemplateSpecifiers(namespaceName,className,dstA->type);
+  QCString srcAName=srcA->name.stripWhiteSpace();
+  QCString dstAName=dstA->name.stripWhiteSpace();
   srcAType.stripPrefix("class ");
   dstAType.stripPrefix("class ");
 
-  // allow distinguishing "const A" from "const B" even though
-  // from a syntactic point of view they would be two names of the same
-  // type "const". This is not fool prove of course, but should at least
+  // allow distinguishing "const A" from "const B" even though 
+  // from a syntactic point of view they would be two names of the same 
+  // type "const". This is not fool prove of course, but should at least 
   // catch the most common cases.
-  if ((srcAType == "const" || srcAType == "volatile") && !srcAName.isEmpty()) {
-    srcAType += " ";
-    srcAType += srcAName;
-  }
-  if ((dstAType == "const" || dstAType == "volatile") && !dstAName.isEmpty()) {
-    dstAType += " ";
-    dstAType += dstAName;
+  if ((srcAType=="const" || srcAType=="volatile") && !srcAName.isEmpty())
+  {
+    srcAType+=" ";
+    srcAType+=srcAName;
+  } 
+  if ((dstAType=="const" || dstAType=="volatile") && !dstAName.isEmpty())
+  {
+    dstAType+=" ";
+    dstAType+=dstAName;
   }
-  if (srcAName == "const" || srcAName == "volatile") {
-    srcAType += srcAName;
+  if (srcAName=="const" || srcAName=="volatile")
+  {
+    srcAType+=srcAName;
     srcAName.resize(0);
-  } else if (dstA->name == "const" || dstA->name == "volatile") {
-    dstAType += dstA->name;
-    dstAName.resize(0);
+  }
+  else if (dstA->name=="const" || dstA->name=="volatile")
+  {
+    dstAType+=dstA->name;
+    dstAName.resize(0);
   }
 
   stripIrrelevantConstVolatile(srcAType);
   stripIrrelevantConstVolatile(dstAType);
 
   // strip typename keyword
-  if (qstrncmp(srcAType, "typename ", 9) == 0) {
-    srcAType = srcAType.right(srcAType.length() - 9);
+  if (qstrncmp(srcAType,"typename ",9)==0)
+  {
+    srcAType = srcAType.right(srcAType.length()-9); 
   }
-  if (qstrncmp(dstAType, "typename ", 9) == 0) {
-    dstAType = dstAType.right(dstAType.length() - 9);
+  if (qstrncmp(dstAType,"typename ",9)==0)
+  {
+    dstAType = dstAType.right(dstAType.length()-9); 
   }
 
   srcAType = removeRedundantWhiteSpace(srcAType);
   dstAType = removeRedundantWhiteSpace(dstAType);
 
-  // srcAType=stripTemplateSpecifiersFromScope(srcAType,FALSE);
-  // dstAType=stripTemplateSpecifiersFromScope(dstAType,FALSE);
+  //srcAType=stripTemplateSpecifiersFromScope(srcAType,FALSE);
+  //dstAType=stripTemplateSpecifiersFromScope(dstAType,FALSE);
 
-  // printf("srcA=`%s|%s' dstA=`%s|%s'\n",srcAType.data(),srcAName.data(),
+  //printf("srcA=`%s|%s' dstA=`%s|%s'\n",srcAType.data(),srcAName.data(),
   //      dstAType.data(),dstAName.data());
 
-  if (srcA->array != dstA->array) // nomatch for char[] against char
+  if (srcA->array!=dstA->array) // nomatch for char[] against char
   {
     NOMATCH
-    return FALSE;
+      return FALSE;
   }
-  if (srcAType != dstAType) // check if the argument only differs on name
+  if (srcAType!=dstAType) // check if the argument only differs on name 
   {
 
-    // remove a namespace scope that is only in one type
+    // remove a namespace scope that is only in one type 
     // (assuming a using statement was used)
-    // printf("Trimming %s<->%s:
-    // %s\n",srcAType.data(),dstAType.data(),namespaceName.data());
-    // trimNamespaceScope(srcAType,dstAType,namespaceName);
-    // printf("After Trimming %s<->%s\n",srcAType.data(),dstAType.data());
+    //printf("Trimming %s<->%s: %s\n",srcAType.data(),dstAType.data(),namespaceName.data());
+    //trimNamespaceScope(srcAType,dstAType,namespaceName);
+    //printf("After Trimming %s<->%s\n",srcAType.data(),dstAType.data());
 
-    // QCString srcScope;
-    // QCString dstScope;
+    //QCString srcScope;
+    //QCString dstScope;
 
     // strip redundant scope specifiers
-    if (!className.isEmpty()) {
-      srcAType = trimScope(className, srcAType);
-      dstAType = trimScope(className, dstAType);
-      // printf("trimScope: `%s' <=> `%s'\n",srcAType.data(),dstAType.data());
+    if (!className.isEmpty())
+    {
+      srcAType=trimScope(className,srcAType);
+      dstAType=trimScope(className,dstAType);
+      //printf("trimScope: `%s' <=> `%s'\n",srcAType.data(),dstAType.data());
       ClassDef *cd;
       if (!namespaceName.isEmpty())
-        cd = getClass(namespaceName + "::" + className);
+        cd=getClass(namespaceName+"::"+className);
       else
-        cd = getClass(className);
-      if (cd && cd->baseClasses()) {
-        trimBaseClassScope(cd->baseClasses(), srcAType);
-        trimBaseClassScope(cd->baseClasses(), dstAType);
+        cd=getClass(className);
+      if (cd && cd->baseClasses())
+      {
+        trimBaseClassScope(cd->baseClasses(),srcAType); 
+        trimBaseClassScope(cd->baseClasses(),dstAType); 
       }
-      // printf("trimBaseClassScope: `%s' <=>
-      // `%s'\n",srcAType.data(),dstAType.data());
+      //printf("trimBaseClassScope: `%s' <=> `%s'\n",srcAType.data(),dstAType.data());
     }
-    if (!namespaceName.isEmpty()) {
-      srcAType = trimScope(namespaceName, srcAType);
-      dstAType = trimScope(namespaceName, dstAType);
+    if (!namespaceName.isEmpty())
+    {
+      srcAType=trimScope(namespaceName,srcAType);
+      dstAType=trimScope(namespaceName,dstAType);
     }
-    // printf("#usingNamespace=%d\n",usingNamespaces->count());
-    if (usingNamespaces && usingNamespaces->count() > 0) {
+    //printf("#usingNamespace=%d\n",usingNamespaces->count());
+    if (usingNamespaces && usingNamespaces->count()>0)
+    {
       NamespaceSDict::Iterator nli(*usingNamespaces);
       NamespaceDef *nd;
-      for (; (nd = nli.current()); ++nli) {
-        srcAType = trimScope(nd->name(), srcAType);
-        dstAType = trimScope(nd->name(), dstAType);
+      for (;(nd=nli.current());++nli)
+      {
+        srcAType=trimScope(nd->name(),srcAType);
+        dstAType=trimScope(nd->name(),dstAType);
       }
     }
-    // printf("#usingClasses=%d\n",usingClasses->count());
-    if (usingClasses && usingClasses->count() > 0) {
+    //printf("#usingClasses=%d\n",usingClasses->count());
+    if (usingClasses && usingClasses->count()>0)
+    {
       SDict<Definition>::Iterator cli(*usingClasses);
       Definition *cd;
-      for (; (cd = cli.current()); ++cli) {
-        srcAType = trimScope(cd->name(), srcAType);
-        dstAType = trimScope(cd->name(), dstAType);
+      for (;(cd=cli.current());++cli)
+      {
+        srcAType=trimScope(cd->name(),srcAType);
+        dstAType=trimScope(cd->name(),dstAType);
       }
     }
 
-    // printf("2. srcA=%s|%s dstA=%s|%s\n",srcAType.data(),srcAName.data(),
+    //printf("2. srcA=%s|%s dstA=%s|%s\n",srcAType.data(),srcAName.data(),
     //    dstAType.data(),dstAName.data());
 
     if (!srcAName.isEmpty() && !dstA->type.isEmpty() &&
-        (srcAType + " " + srcAName) == dstAType) {
+        (srcAType+" "+srcAName)==dstAType)
+    {
       MATCH
       return TRUE;
-    } else if (!dstAName.isEmpty() && !srcA->type.isEmpty() &&
-               (dstAType + " " + dstAName) == srcAType) {
+    }
+    else if (!dstAName.isEmpty() && !srcA->type.isEmpty() &&
+        (dstAType+" "+dstAName)==srcAType)
+    {
       MATCH
       return TRUE;
     }
 
-    uint srcPos = 0, dstPos = 0;
-    bool equal = TRUE;
-    while (srcPos < srcAType.length() && dstPos < dstAType.length() && equal) {
-      equal = srcAType.at(srcPos) == dstAType.at(dstPos);
-      if (equal)
-        srcPos++, dstPos++;
+
+    uint srcPos=0,dstPos=0; 
+    bool equal=TRUE;
+    while (srcPos<srcAType.length() && dstPos<dstAType.length() && equal)
+    {
+      equal=srcAType.at(srcPos)==dstAType.at(dstPos);
+      if (equal) srcPos++,dstPos++; 
     }
-    uint srcATypeLen = srcAType.length();
-    uint dstATypeLen = dstAType.length();
-    if (srcPos < srcATypeLen && dstPos < dstATypeLen) {
+    uint srcATypeLen=srcAType.length();
+    uint dstATypeLen=dstAType.length();
+    if (srcPos<srcATypeLen && dstPos<dstATypeLen)
+    {
       // if nothing matches or the match ends in the middle or at the
       // end of a string then there is no match
-      if (srcPos == 0 || dstPos == 0) {
+      if (srcPos==0 || dstPos==0) 
+      {
         NOMATCH
         return FALSE;
       }
-      if (isId(srcAType.at(srcPos)) && isId(dstAType.at(dstPos))) {
-        // printf("partial match srcPos=%d dstPos=%d!\n",srcPos,dstPos);
+      if (isId(srcAType.at(srcPos)) && isId(dstAType.at(dstPos)))
+      {
+        //printf("partial match srcPos=%d dstPos=%d!\n",srcPos,dstPos);
         // check if a name if already found -> if no then there is no match
-        if (!srcAName.isEmpty() || !dstAName.isEmpty()) {
+        if (!srcAName.isEmpty() || !dstAName.isEmpty()) 
+        {
           NOMATCH
           return FALSE;
         }
         // types only
-        while (srcPos < srcATypeLen && isId(srcAType.at(srcPos)))
-          srcPos++;
-        while (dstPos < dstATypeLen && isId(dstAType.at(dstPos)))
-          dstPos++;
-        if (srcPos < srcATypeLen || dstPos < dstATypeLen ||
-            (srcPos == srcATypeLen && dstPos == dstATypeLen)) {
+        while (srcPos<srcATypeLen && isId(srcAType.at(srcPos))) srcPos++;
+        while (dstPos<dstATypeLen && isId(dstAType.at(dstPos))) dstPos++;
+        if (srcPos<srcATypeLen || 
+            dstPos<dstATypeLen ||
+            (srcPos==srcATypeLen && dstPos==dstATypeLen)
+           ) 
+        {
           NOMATCH
           return FALSE;
         }
-      } else {
+      }
+      else
+      {
         // otherwise we assume that a name starts at the current position.
-        while (srcPos < srcATypeLen && isId(srcAType.at(srcPos)))
-          srcPos++;
-        while (dstPos < dstATypeLen && isId(dstAType.at(dstPos)))
-          dstPos++;
+        while (srcPos<srcATypeLen && isId(srcAType.at(srcPos))) srcPos++;
+        while (dstPos<dstATypeLen && isId(dstAType.at(dstPos))) dstPos++;
 
         // if nothing more follows for both types then we assume we have
         // found a match. Note that now `signed int' and `signed' match, but
         // seeing that int is not a name can only be done by looking at the
         // semantics.
 
-        if (srcPos != srcATypeLen || dstPos != dstATypeLen) {
+        if (srcPos!=srcATypeLen || dstPos!=dstATypeLen) 
+        { 
           NOMATCH
-          return FALSE;
+          return FALSE; 
         }
       }
-    } else if (dstPos < dstAType.length()) {
+    }
+    else if (dstPos<dstAType.length())
+    {
       if (!isspace((uchar)dstAType.at(dstPos))) // maybe the names differ
       {
         if (!dstAName.isEmpty()) // dst has its name separated from its type
@@ -3144,23 +3228,26 @@ static bool matchArgument(const Argument *srcA, const Argument *dstA,
           NOMATCH
           return FALSE;
         }
-        while (dstPos < dstAType.length() && isId(dstAType.at(dstPos)))
-          dstPos++;
-        if (dstPos != dstAType.length()) {
+        while (dstPos<dstAType.length() && isId(dstAType.at(dstPos))) dstPos++;
+        if (dstPos!=dstAType.length()) 
+        {
           NOMATCH
           return FALSE; // more than a difference in name -> no match
         }
-      } else // maybe dst has a name while src has not
+      }
+      else  // maybe dst has a name while src has not
       {
         dstPos++;
-        while (dstPos < dstAType.length() && isId(dstAType.at(dstPos)))
-          dstPos++;
-        if (dstPos != dstAType.length() || !srcAName.isEmpty()) {
+        while (dstPos<dstAType.length() && isId(dstAType.at(dstPos))) dstPos++;
+        if (dstPos!=dstAType.length() || !srcAName.isEmpty()) 
+        {
           NOMATCH
           return FALSE; // nope not a name -> no match
         }
       }
-    } else if (srcPos < srcAType.length()) {
+    }
+    else if (srcPos<srcAType.length())
+    {
       if (!isspace((uchar)srcAType.at(srcPos))) // maybe the names differ
       {
         if (!srcAName.isEmpty()) // src has its name separated from its type
@@ -3168,18 +3255,19 @@ static bool matchArgument(const Argument *srcA, const Argument *dstA,
           NOMATCH
           return FALSE;
         }
-        while (srcPos < srcAType.length() && isId(srcAType.at(srcPos)))
-          srcPos++;
-        if (srcPos != srcAType.length()) {
+        while (srcPos<srcAType.length() && isId(srcAType.at(srcPos))) srcPos++;
+        if (srcPos!=srcAType.length()) 
+        {
           NOMATCH
           return FALSE; // more than a difference in name -> no match
         }
-      } else // maybe src has a name while dst has not
+      }
+      else // maybe src has a name while dst has not
       {
         srcPos++;
-        while (srcPos < srcAType.length() && isId(srcAType.at(srcPos)))
-          srcPos++;
-        if (srcPos != srcAType.length() || !dstAName.isEmpty()) {
+        while (srcPos<srcAType.length() && isId(srcAType.at(srcPos))) srcPos++;
+        if (srcPos!=srcAType.length() || !dstAName.isEmpty()) 
+        {
           NOMATCH
           return FALSE; // nope not a name -> no match
         }
@@ -3190,29 +3278,30 @@ static bool matchArgument(const Argument *srcA, const Argument *dstA,
   return TRUE;
 }
 
+
 /*!
  * Matches the arguments list srcAl with the argument list dstAl
- * Returns TRUE if the argument lists are equal. Two argument list are
- * considered equal if the number of arguments is equal and the types of all
- * arguments are equal. Furthermore the const and volatile specifiers
+ * Returns TRUE if the argument lists are equal. Two argument list are 
+ * considered equal if the number of arguments is equal and the types of all 
+ * arguments are equal. Furthermore the const and volatile specifiers 
  * stored in the list should be equal.
  */
-bool matchArguments(ArgumentList *srcAl, ArgumentList *dstAl, const char *cl,
-                    const char *ns, bool checkCV,
-                    NamespaceSDict *usingNamespaces,
-                    SDict<Definition> *usingClasses) {
-  QCString className = cl;
-  QCString namespaceName = ns;
+bool matchArguments(ArgumentList *srcAl,ArgumentList *dstAl,
+    const char *cl,const char *ns,bool checkCV,
+    NamespaceSDict *usingNamespaces,
+    SDict<Definition> *usingClasses)
+{
+  QCString className=cl;
+  QCString namespaceName=ns;
 
   // strip template specialization from class name if present
-  // int til=className.find('<'),tir=className.find('>');
-  // if (til!=-1 && tir!=-1 && tir>til)
+  //int til=className.find('<'),tir=className.find('>');
+  //if (til!=-1 && tir!=-1 && tir>til) 
   //{
   //  className=className.left(til)+className.right(className.length()-tir-1);
   //}
 
-  // printf("matchArguments(%s,%s) className=%s namespaceName=%s checkCV=%d
-  // usingNamespaces=%d usingClasses=%d\n",
+  //printf("matchArguments(%s,%s) className=%s namespaceName=%s checkCV=%d usingNamespaces=%d usingClasses=%d\n",
   //    srcAl ? argListToString(srcAl).data() : "",
   //    dstAl ? argListToString(dstAl).data() : "",
   //    cl,ns,checkCV,
@@ -3220,49 +3309,56 @@ bool matchArguments(ArgumentList *srcAl, ArgumentList *dstAl, const char *cl,
   //    usingClasses?usingClasses->count():0
   //    );
 
-  if (srcAl == 0 || dstAl == 0) {
-    bool match =
-        srcAl == dstAl; // at least one of the members is not a function
-    if (match) {
+  if (srcAl==0 || dstAl==0)
+  {
+    bool match = srcAl==dstAl; // at least one of the members is not a function
+    if (match)
+    {
       MATCH
       return TRUE;
-    } else {
+    }
+    else
+    {
       NOMATCH
       return FALSE;
     }
   }
 
   // handle special case with void argument
-  if (srcAl->count() == 0 && dstAl->count() == 1 &&
-      dstAl->getFirst()->type == "void") { // special case for finding match
-                                           // between func() and func(void)
-    Argument *a = new Argument;
+  if ( srcAl->count()==0 && dstAl->count()==1 && 
+      dstAl->getFirst()->type=="void" )
+  { // special case for finding match between func() and func(void)
+    Argument *a=new Argument;
     a->type = "void";
     srcAl->append(a);
     MATCH
     return TRUE;
   }
-  if (dstAl->count() == 0 && srcAl->count() == 1 &&
-      srcAl->getFirst()->type == "void") { // special case for finding match
-                                           // between func(void) and func()
-    Argument *a = new Argument;
+  if ( dstAl->count()==0 && srcAl->count()==1 &&
+      srcAl->getFirst()->type=="void" )
+  { // special case for finding match between func(void) and func()
+    Argument *a=new Argument;
     a->type = "void";
     dstAl->append(a);
     MATCH
     return TRUE;
   }
 
-  if (srcAl->count() != dstAl->count()) {
+  if (srcAl->count() != dstAl->count())
+  {
     NOMATCH
     return FALSE; // different number of arguments -> no match
   }
 
-  if (checkCV) {
-    if (srcAl->constSpecifier != dstAl->constSpecifier) {
+  if (checkCV)
+  {
+    if (srcAl->constSpecifier != dstAl->constSpecifier) 
+    {
       NOMATCH
       return FALSE; // one member is const, the other not -> no match
     }
-    if (srcAl->volatileSpecifier != dstAl->volatileSpecifier) {
+    if (srcAl->volatileSpecifier != dstAl->volatileSpecifier)
+    {
       NOMATCH
       return FALSE; // one member is volatile, the other not -> no match
     }
@@ -3276,18 +3372,19 @@ bool matchArguments(ArgumentList *srcAl, ArgumentList *dstAl, const char *cl,
 
   // so far the argument list could match, so we need to compare the types of
   // all arguments.
-  ArgumentListIterator srcAli(*srcAl), dstAli(*dstAl);
-  Argument *srcA, *dstA;
-  for (; (srcA = srcAli.current()) && (dstA = dstAli.current());
-       ++srcAli, ++dstAli) {
-    if (!matchArgument(srcA, dstA, className, namespaceName, usingNamespaces,
-                       usingClasses)) {
+  ArgumentListIterator srcAli(*srcAl),dstAli(*dstAl);
+  Argument *srcA,*dstA;
+  for (;(srcA=srcAli.current()) && (dstA=dstAli.current());++srcAli,++dstAli)
+  { 
+    if (!matchArgument(srcA,dstA,className,namespaceName,
+          usingNamespaces,usingClasses))
+    {
       NOMATCH
       return FALSE;
     }
   }
   MATCH
-  return TRUE; // all arguments match
+  return TRUE; // all arguments match 
 }
 
 #endif
@@ -3296,7 +3393,7 @@ bool matchArguments(ArgumentList *srcAl, ArgumentList *dstAl, const char *cl,
 static QCString resolveSymbolName(FileDef *fs,Definition *symbol,QCString &templSpec)
 {
   ASSERT(symbol!=0);
-  if (symbol->definitionType()==Definition::TypeMember &&
+  if (symbol->definitionType()==Definition::TypeMember && 
       ((MemberDef*)symbol)->isTypedef()) // if symbol is a typedef then try
     // to resolve it
   {
@@ -3315,64 +3412,62 @@ static QCString resolveSymbolName(FileDef *fs,Definition *symbol,QCString &templ
 }
 #endif
 
-static QCString stripDeclKeywords(const QCString &s) {
-  int i = s.find(" class ");
-  if (i != -1)
-    return s.left(i) + s.mid(i + 6);
-  i = s.find(" typename ");
-  if (i != -1)
-    return s.left(i) + s.mid(i + 9);
-  i = s.find(" union ");
-  if (i != -1)
-    return s.left(i) + s.mid(i + 6);
-  i = s.find(" struct ");
-  if (i != -1)
-    return s.left(i) + s.mid(i + 7);
+static QCString stripDeclKeywords(const QCString &s)
+{
+  int i=s.find(" class ");
+  if (i!=-1) return s.left(i)+s.mid(i+6);
+  i=s.find(" typename ");
+  if (i!=-1) return s.left(i)+s.mid(i+9);
+  i=s.find(" union ");
+  if (i!=-1) return s.left(i)+s.mid(i+6);
+  i=s.find(" struct ");
+  if (i!=-1) return s.left(i)+s.mid(i+7);
   return s;
 }
 
 // forward decl for circular dependencies
-static QCString extractCanonicalType(Definition *d, FileDef *fs, QCString type);
-
-QCString getCanonicalTemplateSpec(Definition *d, FileDef *fs,
-                                  const QCString &spec) {
+static QCString extractCanonicalType(Definition *d,FileDef *fs,QCString type);
 
+QCString getCanonicalTemplateSpec(Definition *d,FileDef *fs,const QCString& spec)
+{
+  
   QCString templSpec = spec.stripWhiteSpace();
-  // this part had been commented out before... but it is needed to match for
-  // instance
+  // this part had been commented out before... but it is needed to match for instance
   // std::list<std::string> against list<string> so it is now back again!
-  if (!templSpec.isEmpty() && templSpec.at(0) == '<') {
-    templSpec =
-        "< " +
-        extractCanonicalType(
-            d, fs, templSpec.right(templSpec.length() - 1).stripWhiteSpace());
+  if (!templSpec.isEmpty() && templSpec.at(0) == '<') 
+  {
+    templSpec = "< " + extractCanonicalType(d,fs,templSpec.right(templSpec.length()-1).stripWhiteSpace());
   }
-  QCString resolvedType = resolveTypeDef(d, templSpec);
+  QCString resolvedType = resolveTypeDef(d,templSpec);
   if (!resolvedType.isEmpty()) // not known as a typedef either
   {
     templSpec = resolvedType;
   }
-  // printf("getCanonicalTemplateSpec(%s)=%s\n",spec.data(),templSpec.data());
+  //printf("getCanonicalTemplateSpec(%s)=%s\n",spec.data(),templSpec.data());
   return templSpec;
 }
 
-static QCString getCanonicalTypeForIdentifier(Definition *d, FileDef *fs,
-                                              const QCString &word,
-                                              QCString *tSpec, int count = 0) {
-  if (count > 10)
-    return word; // oops recursion
 
-  QCString symName, result, templSpec, tmpName;
-  // DefinitionList *defList=0;
-  if (tSpec && !tSpec->isEmpty())
-    templSpec = stripDeclKeywords(getCanonicalTemplateSpec(d, fs, *tSpec));
+static QCString getCanonicalTypeForIdentifier(
+    Definition *d,FileDef *fs,const QCString &word,
+    QCString *tSpec,int count=0)
+{
+  if (count>10) return word; // oops recursion
+
+  QCString symName,result,templSpec,tmpName;
+  //DefinitionList *defList=0;
+  if (tSpec && !tSpec->isEmpty()) 
+    templSpec = stripDeclKeywords(getCanonicalTemplateSpec(d,fs,*tSpec));
 
-  if (word.findRev("::") != -1 && !(tmpName = stripScope(word)).isEmpty()) {
-    symName = tmpName; // name without scope
-  } else {
-    symName = word;
+  if (word.findRev("::")!=-1 && !(tmpName=stripScope(word)).isEmpty())
+  {
+    symName=tmpName; // name without scope
+  }
+  else
+  {
+    symName=word;
   }
-  // printf("getCanonicalTypeForIdentifier(%s,[%s->%s]) start\n",
+  //printf("getCanonicalTypeForIdentifier(%s,[%s->%s]) start\n",
   //    word.data(),tSpec?tSpec->data():"<none>",templSpec.data());
 
   ClassDef *cd = 0;
@@ -3381,19 +3476,17 @@ static QCString getCanonicalTypeForIdentifier(Definition *d, FileDef *fs,
   QCString resolvedType;
 
   // lookup class / class template instance
-  cd = getResolvedClass(d, fs, word + templSpec, &mType, &ts, TRUE, TRUE,
-                        &resolvedType);
+  cd = getResolvedClass(d,fs,word+templSpec,&mType,&ts,TRUE,TRUE,&resolvedType);
   bool isTemplInst = cd && !templSpec.isEmpty();
-  if (!cd && !templSpec.isEmpty()) {
+  if (!cd && !templSpec.isEmpty())
+  {
     // class template specialization not known, look up class template
-    cd = getResolvedClass(d, fs, word, &mType, &ts, TRUE, TRUE, &resolvedType);
+    cd = getResolvedClass(d,fs,word,&mType,&ts,TRUE,TRUE,&resolvedType);
   }
-  if (cd && cd->isUsedOnly())
-    cd = 0; // ignore types introduced by usage relations
+  if (cd && cd->isUsedOnly()) cd=0; // ignore types introduced by usage relations
 
-  // printf("cd=%p mtype=%p\n",cd,mType);
-  // printf("  getCanonicalTypeForIdentifer: symbol=%s word=%s cd=%s d=%s fs=%s
-  // cd->isTemplate=%d\n",
+  //printf("cd=%p mtype=%p\n",cd,mType);
+  //printf("  getCanonicalTypeForIdentifer: symbol=%s word=%s cd=%s d=%s fs=%s cd->isTemplate=%d\n",
   //    symName.data(),
   //    word.data(),
   //    cd?cd->name().data():"<none>",
@@ -3402,8 +3495,7 @@ static QCString getCanonicalTypeForIdentifier(Definition *d, FileDef *fs,
   //    cd?cd->isTemplate():-1
   //   );
 
-  // printf("  >>>> word '%s' => '%s' templSpec=%s ts=%s tSpec=%s isTemplate=%d
-  // resolvedType=%s\n",
+  //printf("  >>>> word '%s' => '%s' templSpec=%s ts=%s tSpec=%s isTemplate=%d resolvedType=%s\n",
   //    (word+templSpec).data(),
   //    cd?cd->qualifiedName().data():"<none>",
   //    templSpec.data(),ts.data(),
@@ -3411,25 +3503,28 @@ static QCString getCanonicalTypeForIdentifier(Definition *d, FileDef *fs,
   //    cd?cd->isTemplate():FALSE,
   //    resolvedType.data());
 
-  // printf("  mtype=%s\n",mType?mType->name().data():"<none>");
+  //printf("  mtype=%s\n",mType?mType->name().data():"<none>");
 
   if (cd) // resolves to a known class type
   {
-    if (cd == d && tSpec)
-      *tSpec = "";
+    if (cd==d && tSpec) *tSpec="";
 
     if (mType && mType->isTypedef()) // but via a typedef
     {
-      result = resolvedType + ts; // the +ts was added for bug 685125
-    } else {
-      if (isTemplInst) {
+      result = resolvedType+ts; // the +ts was added for bug 685125
+    }
+    else
+    {
+      if (isTemplInst)
+      {
         // spec is already part of class type
-        templSpec = "";
-        if (tSpec)
-          *tSpec = "";
-      } else if (!ts.isEmpty() && templSpec.isEmpty()) {
+        templSpec="";
+        if (tSpec) *tSpec="";
+      }
+      else if (!ts.isEmpty() && templSpec.isEmpty())
+      {
         // use formal template args for spec
-        templSpec = stripDeclKeywords(getCanonicalTemplateSpec(d, fs, ts));
+        templSpec = stripDeclKeywords(getCanonicalTemplateSpec(d,fs,ts));
       }
 
       result = removeRedundantWhiteSpace(cd->qualifiedName() + templSpec);
@@ -3438,54 +3533,60 @@ static QCString getCanonicalTypeForIdentifier(Definition *d, FileDef *fs,
       {
         if (!templSpec.isEmpty()) // specific instance
         {
-          result = cd->name() + templSpec;
-        } else // use template type
+          result=cd->name()+templSpec;
+        }
+        else // use template type
         {
-          result = cd->qualifiedNameWithTemplateParameters();
+          result=cd->qualifiedNameWithTemplateParameters();
         }
-        // template class, so remove the template part (it is part of the class
-        // name)
-        *tSpec = "";
-      } else if (ts.isEmpty() && !templSpec.isEmpty() && cd &&
-                 !cd->isTemplate() && tSpec) {
-        // obscure case, where a class is used as a template, but doxygen think
-        // it is
+        // template class, so remove the template part (it is part of the class name)
+        *tSpec="";
+      }
+      else if (ts.isEmpty() && !templSpec.isEmpty() && cd && !cd->isTemplate() && tSpec)
+      {
+        // obscure case, where a class is used as a template, but doxygen think it is
         // not (could happen when loading the class from a tag file).
-        *tSpec = "";
+        *tSpec="";
       }
     }
-  } else if (mType && mType->isEnumerate()) // an enum
+  }
+  else if (mType && mType->isEnumerate()) // an enum
   {
     result = mType->qualifiedName();
-  } else if (mType && mType->isTypedef()) // a typedef
-  {
-    // result = mType->qualifiedName(); // changed after 1.7.2
-    // result = mType->typeString();
-    // printf("word=%s typeString=%s\n",word.data(),mType->typeString());
-    if (word != mType->typeString()) {
-      result = getCanonicalTypeForIdentifier(d, fs, mType->typeString(), tSpec,
-                                             count + 1);
-    } else {
+  }
+  else if (mType && mType->isTypedef()) // a typedef
+  {
+    //result = mType->qualifiedName(); // changed after 1.7.2
+    //result = mType->typeString();
+    //printf("word=%s typeString=%s\n",word.data(),mType->typeString());
+    if (word!=mType->typeString())
+    {
+      result = getCanonicalTypeForIdentifier(d,fs,mType->typeString(),tSpec,count+1);
+    }
+    else
+    {
       result = mType->typeString();
     }
-  } else // fallback
+  }
+  else // fallback
   {
-    resolvedType = resolveTypeDef(d, word);
-    // printf("typedef [%s]->[%s]\n",word.data(),resolvedType.data());
+    resolvedType = resolveTypeDef(d,word);
+    //printf("typedef [%s]->[%s]\n",word.data(),resolvedType.data());
     if (resolvedType.isEmpty()) // not known as a typedef either
     {
       result = word;
-    } else {
+    }
+    else
+    {
       result = resolvedType;
     }
   }
-  // printf("getCanonicalTypeForIdentifier
-  // [%s]->[%s]\n",word.data(),result.data());
+  //printf("getCanonicalTypeForIdentifier [%s]->[%s]\n",word.data(),result.data());
   return result;
 }
 
-static QCString extractCanonicalType(Definition *d, FileDef *fs,
-                                     QCString type) {
+static QCString extractCanonicalType(Definition *d,FileDef *fs,QCString type)
+{
   type = type.stripWhiteSpace();
 
   // strip const and volatile keywords that are not relevant for the type
@@ -3499,187 +3600,204 @@ static QCString extractCanonicalType(Definition *d, FileDef *fs,
   type.stripPrefix("typename ");
 
   type = removeRedundantWhiteSpace(type);
-  // printf("extractCanonicalType(type=%s) start: def=%s file=%s\n",type.data(),
+  //printf("extractCanonicalType(type=%s) start: def=%s file=%s\n",type.data(),
   //    d ? d->name().data() : "<null>",fs ? fs->name().data() : "<null>");
 
-  // static QRegExp id("[a-z_A-Z\\x80-\\xFF][:a-z_A-Z0-9\\x80-\\xFF]*");
+  //static QRegExp id("[a-z_A-Z\\x80-\\xFF][:a-z_A-Z0-9\\x80-\\xFF]*");
 
   QCString canType;
-  QCString templSpec, word;
-  int i, p = 0, pp = 0;
-  while ((i = extractClassNameFromType(type, p, word, templSpec)) != -1)
-  // foreach identifier in the type
+  QCString templSpec,word;
+  int i,p=0,pp=0;
+  while ((i=extractClassNameFromType(type,p,word,templSpec))!=-1)
+    // foreach identifier in the type
   {
-    // printf("     i=%d p=%d\n",i,p);
-    if (i > pp)
-      canType += type.mid(pp, i - pp);
+    //printf("     i=%d p=%d\n",i,p);
+    if (i>pp) canType += type.mid(pp,i-pp);
 
-    QCString ct = getCanonicalTypeForIdentifier(d, fs, word, &templSpec);
+
+    QCString ct = getCanonicalTypeForIdentifier(d,fs,word,&templSpec);
 
     // in case the ct is empty it means that "word" represents scope "d"
-    // and this does not need to be added to the canonical
+    // and this does not need to be added to the canonical 
     // type (it is redundant), so/ we skip it. This solves problem 589616.
-    if (ct.isEmpty() && type.mid(p, 2) == "::") {
-      p += 2;
-    } else {
+    if (ct.isEmpty() && type.mid(p,2)=="::")
+    {
+      p+=2;
+    }
+    else
+    {
       canType += ct;
     }
-    // printf(" word=%s templSpec=%s canType=%s ct=%s\n",
+    //printf(" word=%s templSpec=%s canType=%s ct=%s\n",
     //    word.data(),templSpec.data(),canType.data(),ct.data());
     if (!templSpec.isEmpty()) // if we didn't use up the templSpec already
                               // (i.e. type is not a template specialization)
-                              // then resolve any identifiers inside.
+                              // then resolve any identifiers inside. 
     {
       static QRegExp re("[a-z_A-Z\\x80-\\xFF][a-z_A-Z0-9\\x80-\\xFF]*");
-      int tp = 0, tl, ti;
+      int tp=0,tl,ti;
       // for each identifier template specifier
-      // printf("adding resolved %s to %s\n",templSpec.data(),canType.data());
-      while ((ti = re.match(templSpec, tp, &tl)) != -1) {
-        canType += templSpec.mid(tp, ti - tp);
-        canType +=
-            getCanonicalTypeForIdentifier(d, fs, templSpec.mid(ti, tl), 0);
-        tp = ti + tl;
+      //printf("adding resolved %s to %s\n",templSpec.data(),canType.data());
+      while ((ti=re.match(templSpec,tp,&tl))!=-1)
+      {
+        canType += templSpec.mid(tp,ti-tp);
+        canType += getCanonicalTypeForIdentifier(d,fs,templSpec.mid(ti,tl),0);
+        tp=ti+tl;
       }
-      canType += templSpec.right(templSpec.length() - tp);
+      canType+=templSpec.right(templSpec.length()-tp);
     }
 
-    pp = p;
+    pp=p;
   }
-  canType += type.right(type.length() - pp);
-  // printf("extractCanonicalType = '%s'->'%s'\n",type.data(),canType.data());
+  canType += type.right(type.length()-pp);
+  //printf("extractCanonicalType = '%s'->'%s'\n",type.data(),canType.data());
 
   return removeRedundantWhiteSpace(canType);
 }
 
-static QCString extractCanonicalArgType(Definition *d, FileDef *fs,
-                                        const Argument *arg) {
+static QCString extractCanonicalArgType(Definition *d,FileDef *fs,const Argument *arg)
+{
   QCString type = arg->type.stripWhiteSpace();
   QCString name = arg->name;
-  // printf("-----
-  // extractCanonicalArgType(type=%s,name=%s)\n",type.data(),name.data());
-  if ((type == "const" || type == "volatile") &&
-      !name.isEmpty()) { // name is part of type => correct
-    type += " ";
-    type += name;
-  }
-  if (name == "const" ||
-      name == "volatile") { // name is part of type => correct
-    if (!type.isEmpty())
-      type += " ";
-    type += name;
-  }
-  if (!arg->array.isEmpty()) {
-    type += arg->array;
+  //printf("----- extractCanonicalArgType(type=%s,name=%s)\n",type.data(),name.data());
+  if ((type=="const" || type=="volatile") && !name.isEmpty()) 
+  { // name is part of type => correct
+    type+=" ";
+    type+=name;
+  } 
+  if (name=="const" || name=="volatile")
+  { // name is part of type => correct
+    if (!type.isEmpty()) type+=" ";
+    type+=name;
+  }
+  if (!arg->array.isEmpty())
+  {
+    type+=arg->array;
   }
 
-  return extractCanonicalType(d, fs, type);
+  return extractCanonicalType(d,fs,type);
 }
 
-static bool matchArgument2(Definition *srcScope, FileDef *srcFileScope,
-                           Argument *srcA, Definition *dstScope,
-                           FileDef *dstFileScope, Argument *dstA) {
-  // printf(">> match argument: %s::`%s|%s' (%s) <-> %s::`%s|%s' (%s)\n",
+static bool matchArgument2(
+    Definition *srcScope,FileDef *srcFileScope,Argument *srcA,
+    Definition *dstScope,FileDef *dstFileScope,Argument *dstA
+    )
+{
+  //printf(">> match argument: %s::`%s|%s' (%s) <-> %s::`%s|%s' (%s)\n",
   //    srcScope ? srcScope->name().data() : "",
   //    srcA->type.data(),srcA->name.data(),srcA->canType.data(),
   //    dstScope ? dstScope->name().data() : "",
   //    dstA->type.data(),dstA->name.data(),dstA->canType.data());
 
-  // if (srcA->array!=dstA->array) // nomatch for char[] against char
+  //if (srcA->array!=dstA->array) // nomatch for char[] against char
   //{
   //  NOMATCH
   //  return FALSE;
   //}
-  QCString sSrcName = " " + srcA->name;
-  QCString sDstName = " " + dstA->name;
-  QCString srcType = srcA->type;
-  QCString dstType = dstA->type;
+  QCString sSrcName = " "+srcA->name;
+  QCString sDstName = " "+dstA->name;
+  QCString srcType  = srcA->type;
+  QCString dstType  = dstA->type;
   stripIrrelevantConstVolatile(srcType);
   stripIrrelevantConstVolatile(dstType);
-  // printf("'%s'<->'%s'\n",sSrcName.data(),dstType.right(sSrcName.length()).data());
-  // printf("'%s'<->'%s'\n",sDstName.data(),srcType.right(sDstName.length()).data());
-  if (sSrcName ==
-      dstType.right(
-          sSrcName.length())) { // case "unsigned int" <-> "unsigned int i"
-    srcA->type += sSrcName;
-    srcA->name = "";
-    srcA->canType = ""; // invalidate cached type value
-  } else if (sDstName ==
-             srcType.right(
-                 sDstName
-                     .length())) { // case "unsigned int i" <-> "unsigned int"
-    dstA->type += sDstName;
-    dstA->name = "";
-    dstA->canType = ""; // invalidate cached type value
-  }
-
-  if (srcA->canType.isEmpty()) {
-    srcA->canType = extractCanonicalArgType(srcScope, srcFileScope, srcA);
-  }
-  if (dstA->canType.isEmpty()) {
-    dstA->canType = extractCanonicalArgType(dstScope, dstFileScope, dstA);
-  }
-
-  if (srcA->canType == dstA->canType) {
+  //printf("'%s'<->'%s'\n",sSrcName.data(),dstType.right(sSrcName.length()).data());
+  //printf("'%s'<->'%s'\n",sDstName.data(),srcType.right(sDstName.length()).data());
+  if (sSrcName==dstType.right(sSrcName.length()))
+  { // case "unsigned int" <-> "unsigned int i"
+    srcA->type+=sSrcName;
+    srcA->name="";
+    srcA->canType=""; // invalidate cached type value
+  }
+  else if (sDstName==srcType.right(sDstName.length()))
+  { // case "unsigned int i" <-> "unsigned int"
+    dstA->type+=sDstName;
+    dstA->name="";
+    dstA->canType=""; // invalidate cached type value
+  }
+
+  if (srcA->canType.isEmpty())
+  {
+    srcA->canType = extractCanonicalArgType(srcScope,srcFileScope,srcA);
+  }
+  if (dstA->canType.isEmpty())
+  {
+    dstA->canType = extractCanonicalArgType(dstScope,dstFileScope,dstA);
+  }
+
+  if (srcA->canType==dstA->canType)
+  {
     MATCH
     return TRUE;
-  } else {
-    // printf("   Canonical types do not match [%s]<->[%s]\n",
+  }
+  else
+  {
+    //printf("   Canonical types do not match [%s]<->[%s]\n",
     //    srcA->canType.data(),dstA->canType.data());
     NOMATCH
     return FALSE;
   }
 }
 
+
 // new algorithm for argument matching
-bool matchArguments2(Definition *srcScope, FileDef *srcFileScope,
-                     ArgumentList *srcAl, Definition *dstScope,
-                     FileDef *dstFileScope, ArgumentList *dstAl, bool checkCV) {
-  // printf("*** matchArguments2\n");
-  ASSERT(srcScope != 0 && dstScope != 0);
-
-  if (srcAl == 0 || dstAl == 0) {
-    bool match =
-        srcAl == dstAl; // at least one of the members is not a function
-    if (match) {
+bool matchArguments2(Definition *srcScope,FileDef *srcFileScope,ArgumentList *srcAl,
+    Definition *dstScope,FileDef *dstFileScope,ArgumentList *dstAl,
+    bool checkCV
+    )
+{
+  //printf("*** matchArguments2\n");
+  ASSERT(srcScope!=0 && dstScope!=0);
+
+  if (srcAl==0 || dstAl==0)
+  {
+    bool match = srcAl==dstAl; // at least one of the members is not a function
+    if (match)
+    {
       MATCH
       return TRUE;
-    } else {
+    }
+    else
+    {
       NOMATCH
       return FALSE;
     }
   }
 
   // handle special case with void argument
-  if (srcAl->count() == 0 && dstAl->count() == 1 &&
-      dstAl->getFirst()->type == "void") { // special case for finding match
-                                           // between func() and func(void)
-    Argument *a = new Argument;
+  if ( srcAl->count()==0 && dstAl->count()==1 && 
+      dstAl->getFirst()->type=="void" )
+  { // special case for finding match between func() and func(void)
+    Argument *a=new Argument;
     a->type = "void";
     srcAl->append(a);
     MATCH
     return TRUE;
   }
-  if (dstAl->count() == 0 && srcAl->count() == 1 &&
-      srcAl->getFirst()->type == "void") { // special case for finding match
-                                           // between func(void) and func()
-    Argument *a = new Argument;
+  if ( dstAl->count()==0 && srcAl->count()==1 &&
+      srcAl->getFirst()->type=="void" )
+  { // special case for finding match between func(void) and func()
+    Argument *a=new Argument;
     a->type = "void";
     dstAl->append(a);
     MATCH
     return TRUE;
   }
 
-  if (srcAl->count() != dstAl->count()) {
+  if (srcAl->count() != dstAl->count())
+  {
     NOMATCH
     return FALSE; // different number of arguments -> no match
   }
 
-  if (checkCV) {
-    if (srcAl->constSpecifier != dstAl->constSpecifier) {
+  if (checkCV)
+  {
+    if (srcAl->constSpecifier != dstAl->constSpecifier) 
+    {
       NOMATCH
       return FALSE; // one member is const, the other not -> no match
     }
-    if (srcAl->volatileSpecifier != dstAl->volatileSpecifier) {
+    if (srcAl->volatileSpecifier != dstAl->volatileSpecifier)
+    {
       NOMATCH
       return FALSE; // one member is volatile, the other not -> no match
     }
@@ -3693,160 +3811,198 @@ bool matchArguments2(Definition *srcScope, FileDef *srcFileScope,
 
   // so far the argument list could match, so we need to compare the types of
   // all arguments.
-  ArgumentListIterator srcAli(*srcAl), dstAli(*dstAl);
-  Argument *srcA, *dstA;
-  for (; (srcA = srcAli.current()) && (dstA = dstAli.current());
-       ++srcAli, ++dstAli) {
-    if (!matchArgument2(srcScope, srcFileScope, srcA, dstScope, dstFileScope,
-                        dstA)) {
+  ArgumentListIterator srcAli(*srcAl),dstAli(*dstAl);
+  Argument *srcA,*dstA;
+  for (;(srcA=srcAli.current()) && (dstA=dstAli.current());++srcAli,++dstAli)
+  { 
+    if (!matchArgument2(srcScope,srcFileScope,srcA,
+          dstScope,dstFileScope,dstA)
+       )
+    {
       NOMATCH
       return FALSE;
     }
   }
   MATCH
-  return TRUE; // all arguments match
+  return TRUE; // all arguments match 
 }
 
+
+
 // merges the initializer of two argument lists
 // pre:  the types of the arguments in the list should match.
-void mergeArguments(ArgumentList *srcAl, ArgumentList *dstAl,
-                    bool forceNameOverwrite) {
-  // printf("mergeArguments `%s', `%s'\n",
+void mergeArguments(ArgumentList *srcAl,ArgumentList *dstAl,bool forceNameOverwrite)
+{
+  //printf("mergeArguments `%s', `%s'\n",
   //    argListToString(srcAl).data(),argListToString(dstAl).data());
 
-  if (srcAl == 0 || dstAl == 0 || srcAl->count() != dstAl->count()) {
+  if (srcAl==0 || dstAl==0 || srcAl->count()!=dstAl->count())
+  {
     return; // invalid argument lists -> do not merge
   }
 
-  ArgumentListIterator srcAli(*srcAl), dstAli(*dstAl);
-  Argument *srcA, *dstA;
-  for (; (srcA = srcAli.current()) && (dstA = dstAli.current());
-       ++srcAli, ++dstAli) {
-    if (srcA->defval.isEmpty() && !dstA->defval.isEmpty()) {
-      // printf("Defval changing
-      // `%s'->`%s'\n",srcA->defval.data(),dstA->defval.data());
-      srcA->defval = dstA->defval.copy();
-    } else if (!srcA->defval.isEmpty() && dstA->defval.isEmpty()) {
-      // printf("Defval changing
-      // `%s'->`%s'\n",dstA->defval.data(),srcA->defval.data());
-      dstA->defval = srcA->defval.copy();
+  ArgumentListIterator srcAli(*srcAl),dstAli(*dstAl);
+  Argument *srcA,*dstA;
+  for (;(srcA=srcAli.current()) && (dstA=dstAli.current());++srcAli,++dstAli)
+  {
+    if (srcA->defval.isEmpty() && !dstA->defval.isEmpty())
+    {
+      //printf("Defval changing `%s'->`%s'\n",srcA->defval.data(),dstA->defval.data());
+      srcA->defval=dstA->defval.copy();
+    }
+    else if (!srcA->defval.isEmpty() && dstA->defval.isEmpty())
+    {
+      //printf("Defval changing `%s'->`%s'\n",dstA->defval.data(),srcA->defval.data());
+      dstA->defval=srcA->defval.copy();
     }
 
     // fix wrongly detected const or volatile specifiers before merging.
     // example: "const A *const" is detected as type="const A *" name="const"
-    if (srcA->name == "const" || srcA->name == "volatile") {
-      srcA->type += " " + srcA->name;
+    if (srcA->name=="const" || srcA->name=="volatile")
+    {
+      srcA->type+=" "+srcA->name;
       srcA->name.resize(0);
     }
-    if (dstA->name == "const" || dstA->name == "volatile") {
-      dstA->type += " " + dstA->name;
+    if (dstA->name=="const" || dstA->name=="volatile")
+    {
+      dstA->type+=" "+dstA->name;
       dstA->name.resize(0);
     }
 
-    if (srcA->type == dstA->type) {
-      // printf("1. merging %s:%s <->
-      // %s:%s\n",srcA->type.data(),srcA->name.data(),dstA->type.data(),dstA->name.data());
-      if (srcA->name.isEmpty() && !dstA->name.isEmpty()) {
-        // printf("type: `%s':=`%s'\n",srcA->type.data(),dstA->type.data());
-        // printf("name: `%s':=`%s'\n",srcA->name.data(),dstA->name.data());
+    if (srcA->type==dstA->type)
+    {
+      //printf("1. merging %s:%s <-> %s:%s\n",srcA->type.data(),srcA->name.data(),dstA->type.data(),dstA->name.data());
+      if (srcA->name.isEmpty() && !dstA->name.isEmpty())
+      {
+        //printf("type: `%s':=`%s'\n",srcA->type.data(),dstA->type.data());
+        //printf("name: `%s':=`%s'\n",srcA->name.data(),dstA->name.data());
         srcA->type = dstA->type.copy();
         srcA->name = dstA->name.copy();
-      } else if (!srcA->name.isEmpty() && dstA->name.isEmpty()) {
-        // printf("type: `%s':=`%s'\n",dstA->type.data(),srcA->type.data());
-        // printf("name: `%s':=`%s'\n",dstA->name.data(),srcA->name.data());
+      }
+      else if (!srcA->name.isEmpty() && dstA->name.isEmpty())
+      {
+        //printf("type: `%s':=`%s'\n",dstA->type.data(),srcA->type.data());
+        //printf("name: `%s':=`%s'\n",dstA->name.data(),srcA->name.data());
         dstA->type = srcA->type.copy();
         dstA->name = dstA->name.copy();
-      } else if (!srcA->name.isEmpty() && !dstA->name.isEmpty()) {
-        // printf("srcA->name=%s
-        // dstA->name=%s\n",srcA->name.data(),dstA->name.data());
-        if (forceNameOverwrite) {
+      }
+      else if (!srcA->name.isEmpty() && !dstA->name.isEmpty())
+      {
+        //printf("srcA->name=%s dstA->name=%s\n",srcA->name.data(),dstA->name.data());
+        if (forceNameOverwrite)
+        {
           srcA->name = dstA->name;
-        } else {
-          if (srcA->docs.isEmpty() && !dstA->docs.isEmpty()) {
+        }
+        else
+        {
+          if (srcA->docs.isEmpty() && !dstA->docs.isEmpty())
+          {
             srcA->name = dstA->name;
-          } else if (!srcA->docs.isEmpty() && dstA->docs.isEmpty()) {
+          }
+          else if (!srcA->docs.isEmpty() && dstA->docs.isEmpty())
+          {
             dstA->name = srcA->name;
           }
         }
       }
-    } else {
-      // printf("2. merging '%s':'%s' <->
-      // '%s':'%s'\n",srcA->type.data(),srcA->name.data(),dstA->type.data(),dstA->name.data());
-      srcA->type = srcA->type.stripWhiteSpace();
-      dstA->type = dstA->type.stripWhiteSpace();
-      if (srcA->type + " " + srcA->name ==
-          dstA->type) // "unsigned long:int" <-> "unsigned long int:bla"
+    }
+    else
+    {
+      //printf("2. merging '%s':'%s' <-> '%s':'%s'\n",srcA->type.data(),srcA->name.data(),dstA->type.data(),dstA->name.data());
+      srcA->type=srcA->type.stripWhiteSpace();
+      dstA->type=dstA->type.stripWhiteSpace();
+      if (srcA->type+" "+srcA->name==dstA->type) // "unsigned long:int" <-> "unsigned long int:bla"
       {
-        srcA->type += " " + srcA->name;
-        srcA->name = dstA->name;
-      } else if (dstA->type + " " + dstA->name ==
-                 srcA->type) // "unsigned long int bla" <-> "unsigned long int"
+        srcA->type+=" "+srcA->name;
+        srcA->name=dstA->name;
+      }
+      else if (dstA->type+" "+dstA->name==srcA->type) // "unsigned long int bla" <-> "unsigned long int"
+      {
+        dstA->type+=" "+dstA->name;
+        dstA->name=srcA->name;
+      }
+      else if (srcA->name.isEmpty() && !dstA->name.isEmpty())
       {
-        dstA->type += " " + dstA->name;
-        dstA->name = srcA->name;
-      } else if (srcA->name.isEmpty() && !dstA->name.isEmpty()) {
         srcA->name = dstA->name;
-      } else if (dstA->name.isEmpty() && !srcA->name.isEmpty()) {
+      }
+      else if (dstA->name.isEmpty() && !srcA->name.isEmpty())
+      {
         dstA->name = srcA->name;
       }
     }
-    int i1 = srcA->type.find("::"), i2 = dstA->type.find("::"),
-        j1 = srcA->type.length() - i1 - 2, j2 = dstA->type.length() - i2 - 2;
-    if (i1 != -1 && i2 == -1 && srcA->type.right(j1) == dstA->type) {
-      // printf("type: `%s':=`%s'\n",dstA->type.data(),srcA->type.data());
-      // printf("name: `%s':=`%s'\n",dstA->name.data(),srcA->name.data());
-      dstA->type = srcA->type.left(i1 + 2) + dstA->type;
+    int i1=srcA->type.find("::"),
+        i2=dstA->type.find("::"),
+        j1=srcA->type.length()-i1-2,
+        j2=dstA->type.length()-i2-2;
+    if (i1!=-1 && i2==-1 && srcA->type.right(j1)==dstA->type)
+    {
+      //printf("type: `%s':=`%s'\n",dstA->type.data(),srcA->type.data());
+      //printf("name: `%s':=`%s'\n",dstA->name.data(),srcA->name.data());
+      dstA->type = srcA->type.left(i1+2)+dstA->type;
       dstA->name = dstA->name.copy();
-    } else if (i1 == -1 && i2 != -1 && dstA->type.right(j2) == srcA->type) {
-      // printf("type: `%s':=`%s'\n",srcA->type.data(),dstA->type.data());
-      // printf("name: `%s':=`%s'\n",dstA->name.data(),srcA->name.data());
-      srcA->type = dstA->type.left(i2 + 2) + srcA->type;
+    }
+    else if (i1==-1 && i2!=-1 && dstA->type.right(j2)==srcA->type)
+    {
+      //printf("type: `%s':=`%s'\n",srcA->type.data(),dstA->type.data());
+      //printf("name: `%s':=`%s'\n",dstA->name.data(),srcA->name.data());
+      srcA->type = dstA->type.left(i2+2)+srcA->type;
       srcA->name = dstA->name.copy();
     }
-    if (srcA->docs.isEmpty() && !dstA->docs.isEmpty()) {
+    if (srcA->docs.isEmpty() && !dstA->docs.isEmpty())
+    {
       srcA->docs = dstA->docs.copy();
-    } else if (dstA->docs.isEmpty() && !srcA->docs.isEmpty()) {
+    }
+    else if (dstA->docs.isEmpty() && !srcA->docs.isEmpty())
+    {
       dstA->docs = srcA->docs.copy();
     }
-    // printf("Merge argument `%s|%s' `%s|%s'\n",
+    //printf("Merge argument `%s|%s' `%s|%s'\n",
     //  srcA->type.data(),srcA->name.data(),
     //  dstA->type.data(),dstA->name.data());
   }
 }
 
-static void findMembersWithSpecificName(MemberName *mn, const char *args,
-                                        bool checkStatics, FileDef *currentFile,
-                                        bool checkCV, const char *forceTagFile,
-                                        QList<MemberDef> &members) {
-  // printf("  Function with global scope name `%s' args=`%s'\n",
+static void findMembersWithSpecificName(MemberName *mn,
+                                        const char *args,
+                                        bool checkStatics,
+                                        FileDef *currentFile,
+                                        bool checkCV,
+                                        const char *forceTagFile,
+                                        QList<MemberDef> &members)
+{
+  //printf("  Function with global scope name `%s' args=`%s'\n",
   //       mn->memberName(),args);
   MemberNameIterator mli(*mn);
   MemberDef *md;
-  for (mli.toFirst(); (md = mli.current()); ++mli) {
-    FileDef *fd = md->getFileDef();
-    GroupDef *gd = md->getGroupDef();
-    // printf("  md->name()=`%s' md->args=`%s' fd=%p gd=%p current=%p ref=%s\n",
+  for (mli.toFirst();(md=mli.current());++mli)
+  {
+    FileDef  *fd=md->getFileDef();
+    GroupDef *gd=md->getGroupDef();
+    //printf("  md->name()=`%s' md->args=`%s' fd=%p gd=%p current=%p ref=%s\n",
     //    md->name().data(),args,fd,gd,currentFile,md->getReference().data());
-    if (((gd && gd->isLinkable()) || (fd && fd->isLinkable()) ||
-         md->isReference()) &&
-        md->getNamespaceDef() == 0 && md->isLinkable() &&
-        (!checkStatics || (!md->isStatic() && !md->isDefine()) ||
-         currentFile == 0 ||
-         fd == currentFile) // statics must appear in the same file
-        ) {
-      bool match = TRUE;
-      ArgumentList *argList = 0;
-      if (args && !md->isDefine() && qstrcmp(args, "()") != 0) {
-        argList = new ArgumentList;
+    if (
+        ((gd && gd->isLinkable()) || (fd && fd->isLinkable()) || md->isReference()) && 
+        md->getNamespaceDef()==0 && md->isLinkable() &&
+        (!checkStatics || (!md->isStatic() && !md->isDefine()) || 
+         currentFile==0 || fd==currentFile) // statics must appear in the same file
+       ) 
+    {
+      bool match=TRUE;
+      ArgumentList *argList=0;
+      if (args && !md->isDefine() && qstrcmp(args,"()")!=0)
+      {
+        argList=new ArgumentList;
         ArgumentList *mdAl = md->argumentList();
-        stringToArgumentList(args, argList);
-        match = matchArguments2(md->getOuterScope(), fd, mdAl,
-                                Doxygen::globalScope, fd, argList, checkCV);
-        delete argList;
-        argList = 0;
-      }
-      if (match && (forceTagFile == 0 || md->getReference() == forceTagFile)) {
-        // printf("Found match!\n");
+        stringToArgumentList(args,argList);
+        match=matchArguments2(
+            md->getOuterScope(),fd,mdAl,
+            Doxygen::globalScope,fd,argList,
+            checkCV); 
+        delete argList; argList=0;
+      }
+      if (match && (forceTagFile==0 || md->getReference()==forceTagFile)) 
+      {
+        //printf("Found match!\n");
         members.append(md);
       }
     }
@@ -3858,186 +4014,214 @@ static void findMembersWithSpecificName(MemberName *mn, const char *args,
  * memberName may also include a (partial) scope to indicate the scope
  * in which the member is located.
  *
- * The parameter `scName' is a string representing the name of the scope in
+ * The parameter `scName' is a string representing the name of the scope in 
  * which the link was found.
  *
- * In case of a function args contains a string representation of the
- * argument list. Passing 0 means the member has no arguments.
+ * In case of a function args contains a string representation of the 
+ * argument list. Passing 0 means the member has no arguments. 
  * Passing "()" means any argument list will do, but "()" is preferred.
  *
  * The function returns TRUE if the member is known and documented or
  * FALSE if it is not.
- * If TRUE is returned parameter `md' contains a pointer to the member
- * definition. Furthermore exactly one of the parameter `cd', `nd', or `fd'
+ * If TRUE is returned parameter `md' contains a pointer to the member 
+ * definition. Furthermore exactly one of the parameter `cd', `nd', or `fd' 
  * will be non-zero:
  *   - if `cd' is non zero, the member was found in a class pointed to by cd.
- *   - if `nd' is non zero, the member was found in a namespace pointed to by
- * nd.
+ *   - if `nd' is non zero, the member was found in a namespace pointed to by nd.
  *   - if `fd' is non zero, the member was found in the global namespace of
  *     file fd.
  */
-bool getDefs(const QCString &scName, const QCString &mbName, const char *args,
-             MemberDef *&md, ClassDef *&cd, FileDef *&fd, NamespaceDef *&nd,
-             GroupDef *&gd, bool forceEmptyScope, FileDef *currentFile,
-             bool checkCV, const char *forceTagFile) {
-  fd = 0, md = 0, cd = 0, nd = 0, gd = 0;
-  if (mbName.isEmpty())
-    return FALSE; /* empty name => nothing to link */
-
-  QCString scopeName = scName;
-  QCString memberName = mbName;
-  scopeName = substitute(scopeName, "\\", "::");   // for PHP
-  memberName = substitute(memberName, "\\", "::"); // for PHP
-  // printf("Search for name=%s args=%s in scope=%s forceEmpty=%d\n",
+bool getDefs(const QCString &scName,
+             const QCString &mbName, 
+             const char *args,
+             MemberDef *&md, 
+             ClassDef *&cd, 
+             FileDef *&fd, 
+             NamespaceDef *&nd, 
+             GroupDef *&gd,
+             bool forceEmptyScope,
+             FileDef *currentFile,
+             bool checkCV,
+             const char *forceTagFile
+            )
+{
+  fd=0, md=0, cd=0, nd=0, gd=0;
+  if (mbName.isEmpty()) return FALSE; /* empty name => nothing to link */
+
+  QCString scopeName=scName;
+  QCString memberName=mbName;
+  scopeName = substitute(scopeName,"\\","::"); // for PHP
+  memberName = substitute(memberName,"\\","::"); // for PHP
+  //printf("Search for name=%s args=%s in scope=%s forceEmpty=%d\n",
   //          memberName.data(),args,scopeName.data(),forceEmptyScope);
 
-  int is, im = 0, pm = 0;
+  int is,im=0,pm=0;
   // strip common part of the scope from the scopeName
-  while ((is = scopeName.findRev("::")) != -1 &&
-         (im = memberName.find("::", pm)) != -1 &&
-         (scopeName.right(scopeName.length() - is - 2) ==
-          memberName.mid(pm, im - pm))) {
-    scopeName = scopeName.left(is);
-    pm = im + 2;
-  }
-  // printf("result after scope corrections scope=%s name=%s\n",
+  while ((is=scopeName.findRev("::"))!=-1 && 
+         (im=memberName.find("::",pm))!=-1 &&
+          (scopeName.right(scopeName.length()-is-2)==memberName.mid(pm,im-pm))
+        )
+  {
+    scopeName=scopeName.left(is); 
+    pm=im+2;
+  }
+  //printf("result after scope corrections scope=%s name=%s\n",
   //          scopeName.data(),memberName.data());
 
-  QCString mName = memberName;
+  QCString mName=memberName;
   QCString mScope;
-  if (memberName.left(9) != "operator " && // treat operator conversion methods
+  if (memberName.left(9)!="operator " && // treat operator conversion methods
       // as a special case
-      (im = memberName.findRev("::")) != -1 &&
-      im < (int)memberName.length() - 2 // not A::
-      ) {
-    mScope = memberName.left(im);
-    mName = memberName.right(memberName.length() - im - 2);
+      (im=memberName.findRev("::"))!=-1 && 
+      im<(int)memberName.length()-2 // not A::
+     )
+  {
+    mScope=memberName.left(im); 
+    mName=memberName.right(memberName.length()-im-2);
   }
 
   // handle special the case where both scope name and member scope are equal
-  if (mScope == scopeName)
-    scopeName.resize(0);
+  if (mScope==scopeName) scopeName.resize(0);
 
-  // printf("mScope=`%s' mName=`%s'\n",mScope.data(),mName.data());
+  //printf("mScope=`%s' mName=`%s'\n",mScope.data(),mName.data());
 
   MemberName *mn = Doxygen::memberNameSDict->find(mName);
-  // printf("mName=%s mn=%p\n",mName.data(),mn);
-
-  if ((!forceEmptyScope || scopeName.isEmpty()) && // this was changed for
-                                                   // bug638856, forceEmptyScope
-                                                   // => empty scopeName
-      mn && !(scopeName.isEmpty() && mScope.isEmpty())) {
-    // printf("  >member name '%s' found\n",mName.data());
-    int scopeOffset = scopeName.length();
-    do {
+  //printf("mName=%s mn=%p\n",mName.data(),mn);
+
+  if ((!forceEmptyScope || scopeName.isEmpty()) && // this was changed for bug638856, forceEmptyScope => empty scopeName
+      mn && !(scopeName.isEmpty() && mScope.isEmpty()))
+  {
+    //printf("  >member name '%s' found\n",mName.data());
+    int scopeOffset=scopeName.length();
+    do
+    {
       QCString className = scopeName.left(scopeOffset);
-      if (!className.isEmpty() && !mScope.isEmpty()) {
-        className += "::" + mScope;
-      } else if (!mScope.isEmpty()) {
-        className = mScope;
+      if (!className.isEmpty() && !mScope.isEmpty())
+      {
+        className+="::"+mScope;
+      }
+      else if (!mScope.isEmpty())
+      {
+        className=mScope;
       }
 
-      MemberDef *tmd = 0;
-      ClassDef *fcd =
-          getResolvedClass(Doxygen::globalScope, 0, className, &tmd);
-      if (fcd == 0 &&
-          className.find('<') != -1) // try without template specifiers as well
+      MemberDef *tmd=0;
+      ClassDef *fcd=getResolvedClass(Doxygen::globalScope,0,className,&tmd);
+      if (fcd==0 && className.find('<')!=-1) // try without template specifiers as well
       {
-        QCString nameWithoutTemplates =
-            stripTemplateSpecifiersFromScope(className, FALSE);
-        fcd = getResolvedClass(Doxygen::globalScope, 0, nameWithoutTemplates,
-                               &tmd);
+         QCString nameWithoutTemplates = stripTemplateSpecifiersFromScope(className,FALSE);
+         fcd=getResolvedClass(Doxygen::globalScope,0,nameWithoutTemplates,&tmd);
       }
-      // printf("Trying class scope %s: fcd=%p
-      // tmd=%p\n",className.data(),fcd,tmd);
+      //printf("Trying class scope %s: fcd=%p tmd=%p\n",className.data(),fcd,tmd);
       // todo: fill in correct fileScope!
-      if (fcd && // is it a documented class
-          fcd->isLinkable()) {
-        // printf("  Found fcd=%p\n",fcd);
+      if (fcd &&  // is it a documented class
+          fcd->isLinkable() 
+         )
+      {
+        //printf("  Found fcd=%p\n",fcd);
         MemberNameIterator mmli(*mn);
         MemberDef *mmd;
-        int mdist = maxInheritanceDepth;
-        ArgumentList *argList = 0;
-        if (args) {
-          argList = new ArgumentList;
-          stringToArgumentList(args, argList);
+        int mdist=maxInheritanceDepth; 
+        ArgumentList *argList=0;
+        if (args)
+        {
+          argList=new ArgumentList;
+          stringToArgumentList(args,argList);
         }
-        for (mmli.toFirst(); (mmd = mmli.current()); ++mmli) {
-          if (!mmd->isStrongEnumValue()) {
+        for (mmli.toFirst();(mmd=mmli.current());++mmli)
+        {
+          if (!mmd->isStrongEnumValue())
+          {
             ArgumentList *mmdAl = mmd->argumentList();
-            bool match =
-                args == 0 ||
-                matchArguments2(mmd->getOuterScope(), mmd->getFileDef(), mmdAl,
-                                fcd, fcd->getFileDef(), argList, checkCV);
-            // printf("match=%d\n",match);
-            if (match) {
-              ClassDef *mcd = mmd->getClassDef();
-              if (mcd) {
-                int m = minClassDistance(fcd, mcd);
-                if (m < mdist && mcd->isLinkable()) {
-                  mdist = m;
-                  cd = mcd;
-                  md = mmd;
+            bool match=args==0 || 
+              matchArguments2(mmd->getOuterScope(),mmd->getFileDef(),mmdAl,
+                  fcd,fcd->getFileDef(),argList,
+                  checkCV
+                  );  
+            //printf("match=%d\n",match);
+            if (match)
+            {
+              ClassDef *mcd=mmd->getClassDef();
+              if (mcd)
+              {
+                int m=minClassDistance(fcd,mcd);
+                if (m<mdist && mcd->isLinkable())
+                {
+                  mdist=m;
+                  cd=mcd;
+                  md=mmd;
                 }
               }
             }
           }
         }
-        if (argList) {
-          delete argList;
-          argList = 0;
+        if (argList)
+        {
+          delete argList; argList=0;
         }
-        if (mdist == maxInheritanceDepth && args && qstrcmp(args, "()") == 0)
-        // no exact match found, but if args="()" an arbitrary member will do
+        if (mdist==maxInheritanceDepth && args && qstrcmp(args,"()")==0)
+          // no exact match found, but if args="()" an arbitrary member will do
         {
-          // printf("  >Searching for arbitrary member\n");
-          for (mmli.toFirst(); (mmd = mmli.current()); ++mmli) {
-            // if (mmd->isLinkable())
+          //printf("  >Searching for arbitrary member\n");
+          for (mmli.toFirst();(mmd=mmli.current());++mmli)
+          {
+            //if (mmd->isLinkable())
             //{
-            ClassDef *mcd = mmd->getClassDef();
-            // printf("  >Class %s found\n",mcd->name().data());
-            if (mcd) {
-              int m = minClassDistance(fcd, mcd);
-              if (m < mdist /* && mcd->isLinkable()*/) {
-                // printf("Class distance %d\n",m);
-                mdist = m;
-                cd = mcd;
-                md = mmd;
+            ClassDef *mcd=mmd->getClassDef();
+            //printf("  >Class %s found\n",mcd->name().data());
+            if (mcd)
+            {
+              int m=minClassDistance(fcd,mcd);
+              if (m<mdist /* && mcd->isLinkable()*/ )
+              {
+                //printf("Class distance %d\n",m);
+                mdist=m;
+                cd=mcd;
+                md=mmd;
               }
             }
             //}
           }
         }
-        // printf("  >Succes=%d\n",mdist<maxInheritanceDepth);
-        if (mdist < maxInheritanceDepth) {
-          if (!md->isLinkable() || md->isStrongEnumValue()) {
-            md = 0; // avoid returning things we cannot link to
-            cd = 0;
+        //printf("  >Succes=%d\n",mdist<maxInheritanceDepth);
+        if (mdist<maxInheritanceDepth) 
+        {
+          if (!md->isLinkable() || md->isStrongEnumValue()) 
+          {
+            md=0; // avoid returning things we cannot link to
+            cd=0;
             return FALSE; // match found, but was not linkable
-          } else {
-            gd = md->getGroupDef();
-            if (gd)
-              cd = 0;
+          }
+          else
+          {
+            gd=md->getGroupDef();
+            if (gd) cd=0;
             return TRUE; /* found match */
           }
         }
-      }
+      } 
       if (tmd && tmd->isEnumerate() && tmd->isStrong()) // scoped enum
       {
-        // printf("Found scoped enum!\n");
+        //printf("Found scoped enum!\n");
         MemberList *tml = tmd->enumFieldList();
-        if (tml) {
+        if (tml)
+        {
           MemberListIterator tmi(*tml);
           MemberDef *emd;
-          for (; (emd = tmi.current()); ++tmi) {
-            if (emd->localName() == mName) {
-              if (emd->isLinkable()) {
-                cd = tmd->getClassDef();
-                md = emd;
+          for (;(emd=tmi.current());++tmi)
+          {
+            if (emd->localName()==mName)
+            {
+              if (emd->isLinkable())
+              {
+                cd=tmd->getClassDef();
+                md=emd;
                 return TRUE;
-              } else {
-                cd = 0;
-                md = 0;
+              }
+              else
+              {
+                cd=0;
+                md=0;
                 return FALSE;
               }
             }
@@ -4045,18 +4229,20 @@ bool getDefs(const QCString &scName, const QCString &mbName, const char *args,
         }
       }
       /* go to the parent scope */
-      if (scopeOffset == 0) {
-        scopeOffset = -1;
-      } else if ((scopeOffset = scopeName.findRev("::", scopeOffset - 1)) ==
-                 -1) {
-        scopeOffset = 0;
+      if (scopeOffset==0)
+      {
+        scopeOffset=-1;
+      }
+      else if ((scopeOffset=scopeName.findRev("::",scopeOffset-1))==-1)
+      {
+        scopeOffset=0;
       }
-    } while (scopeOffset >= 0);
+    } while (scopeOffset>=0);
+
   }
-  if (mn && scopeName.isEmpty() &&
-      mScope.isEmpty()) // Maybe a related function?
+  if (mn && scopeName.isEmpty() && mScope.isEmpty()) // Maybe a related function?
   {
-    // printf("Global symbol\n");
+    //printf("Global symbol\n");
     MemberNameIterator mmli(*mn);
     MemberDef *mmd, *fuzzy_mmd = 0;
     ArgumentList *argList = 0;
@@ -4065,231 +4251,249 @@ bool getDefs(const QCString &scName, const QCString &mbName, const char *args,
     if (args)
       stringToArgumentList(args, argList = new ArgumentList);
 
-    for (mmli.toFirst(); (mmd = mmli.current()); ++mmli) {
+    for (mmli.toFirst(); (mmd = mmli.current()); ++mmli)
+    {
       if (!mmd->isLinkable() || (!mmd->isRelated() && !mmd->isForeign()) ||
-          !mmd->getClassDef())
+           !mmd->getClassDef())
         continue;
 
-      if (!args)
-        break;
+      if (!args) break;
 
       ArgumentList *mmdAl = mmd->argumentList();
-      if (matchArguments2(mmd->getOuterScope(), mmd->getFileDef(), mmdAl,
-                          Doxygen::globalScope, mmd->getFileDef(), argList,
-                          checkCV))
-        break;
+      if (matchArguments2(mmd->getOuterScope(),mmd->getFileDef(),mmdAl,
+            Doxygen::globalScope,mmd->getFileDef(),argList,
+            checkCV
+            )
+         ) break;
 
       if (!fuzzy_mmd && hasEmptyArgs)
         fuzzy_mmd = mmd;
     }
 
-    if (argList)
-      delete argList, argList = 0;
+    if (argList) delete argList, argList = 0;
 
     mmd = mmd ? mmd : fuzzy_mmd;
 
-    if (mmd && !mmd->isStrongEnumValue()) {
+    if (mmd && !mmd->isStrongEnumValue())
+    {
       md = mmd;
       cd = mmd->getClassDef();
       return TRUE;
     }
   }
 
+
   // maybe an namespace, file or group member ?
-  // printf("Testing for global symbol scopeName=`%s' mScope=`%s' ::
-  // mName=`%s'\n",
+  //printf("Testing for global symbol scopeName=`%s' mScope=`%s' :: mName=`%s'\n",
   //              scopeName.data(),mScope.data(),mName.data());
-  if ((mn = Doxygen::functionNameSDict->find(mName))) // name is known
+  if ((mn=Doxygen::functionNameSDict->find(mName))) // name is known
   {
-    // printf("  >symbol name found\n");
-    NamespaceDef *fnd = 0;
-    int scopeOffset = scopeName.length();
-    do {
+    //printf("  >symbol name found\n");
+    NamespaceDef *fnd=0;
+    int scopeOffset=scopeName.length();
+    do
+    {
       QCString namespaceName = scopeName.left(scopeOffset);
-      if (!namespaceName.isEmpty() && !mScope.isEmpty()) {
-        namespaceName += "::" + mScope;
-      } else if (!mScope.isEmpty()) {
-        namespaceName = mScope.copy();
-      }
-      // printf("Trying namespace %s\n",namespaceName.data());
-      if (!namespaceName.isEmpty() &&
-          (fnd = Doxygen::namespaceSDict->find(namespaceName)) &&
-          fnd->isLinkable()) {
-        // printf("Symbol inside existing namespace `%s' count=%d\n",
+      if (!namespaceName.isEmpty() && !mScope.isEmpty())
+      {
+        namespaceName+="::"+mScope;
+      }
+      else if (!mScope.isEmpty())
+      {
+        namespaceName=mScope.copy();
+      }
+      //printf("Trying namespace %s\n",namespaceName.data());
+      if (!namespaceName.isEmpty() && 
+          (fnd=Doxygen::namespaceSDict->find(namespaceName)) &&
+          fnd->isLinkable()
+         )
+      {
+        //printf("Symbol inside existing namespace `%s' count=%d\n",
         //    namespaceName.data(),mn->count());
-        bool found = FALSE;
+        bool found=FALSE;
         MemberNameIterator mmli(*mn);
         MemberDef *mmd;
-        for (mmli.toFirst(); ((mmd = mmli.current()) && !found); ++mmli) {
-          // printf("mmd->getNamespaceDef()=%p fnd=%p\n",
+        for (mmli.toFirst();((mmd=mmli.current()) && !found);++mmli)
+        {
+          //printf("mmd->getNamespaceDef()=%p fnd=%p\n",
           //    mmd->getNamespaceDef(),fnd);
           MemberDef *emd = mmd->getEnumScope();
-          if (emd && emd->isStrong()) {
-            // printf("yes match
-            // %s<->%s!\n",mScope.data(),emd->localName().data());
-            if (emd->getNamespaceDef() == fnd &&
-                rightScopeMatch(mScope, emd->localName())) {
-              // printf("found it!\n");
-              nd = fnd;
-              md = mmd;
-              found = TRUE;
-            } else {
-              md = 0;
-              cd = 0;
+          if (emd && emd->isStrong())
+          {
+            //printf("yes match %s<->%s!\n",mScope.data(),emd->localName().data());
+            if (emd->getNamespaceDef()==fnd && 
+                rightScopeMatch(mScope,emd->localName()))
+            {
+              //printf("found it!\n");
+              nd=fnd;
+              md=mmd;
+              found=TRUE;
+            }
+            else
+            {
+              md=0;
+              cd=0;
               return FALSE;
             }
-          } else if (mmd->getNamespaceDef() ==
-                     fnd /* && mmd->isLinkable() */) { // namespace is found
-            bool match = TRUE;
-            ArgumentList *argList = 0;
-            if (args && qstrcmp(args, "()") != 0) {
-              argList = new ArgumentList;
+          }
+          else if (mmd->getNamespaceDef()==fnd /* && mmd->isLinkable() */ )
+          { // namespace is found
+            bool match=TRUE;
+            ArgumentList *argList=0;
+            if (args && qstrcmp(args,"()")!=0)
+            {
+              argList=new ArgumentList;
               ArgumentList *mmdAl = mmd->argumentList();
-              stringToArgumentList(args, argList);
-              match = matchArguments2(mmd->getOuterScope(), mmd->getFileDef(),
-                                      mmdAl, fnd, mmd->getFileDef(), argList,
-                                      checkCV);
+              stringToArgumentList(args,argList);
+              match=matchArguments2(
+                  mmd->getOuterScope(),mmd->getFileDef(),mmdAl,
+                  fnd,mmd->getFileDef(),argList,
+                  checkCV); 
             }
-            if (match) {
-              nd = fnd;
-              md = mmd;
-              found = TRUE;
+            if (match)
+            {
+              nd=fnd;
+              md=mmd;
+              found=TRUE;
             }
-            if (args) {
-              delete argList;
-              argList = 0;
+            if (args)
+            {
+              delete argList; argList=0;
             }
           }
         }
-        if (!found && args && !qstrcmp(args, "()"))
-        // no exact match found, but if args="()" an arbitrary
-        // member will do
+        if (!found && args && !qstrcmp(args,"()")) 
+          // no exact match found, but if args="()" an arbitrary 
+          // member will do
         {
-          for (mmli.toFirst(); ((mmd = mmli.current()) && !found); ++mmli) {
-            if (mmd->getNamespaceDef() == fnd /*&& mmd->isLinkable() */) {
-              nd = fnd;
-              md = mmd;
-              found = TRUE;
+          for (mmli.toFirst();((mmd=mmli.current()) && !found);++mmli)
+          {
+            if (mmd->getNamespaceDef()==fnd /*&& mmd->isLinkable() */ )
+            {
+              nd=fnd;
+              md=mmd;
+              found=TRUE;
             }
           }
         }
-        if (found) {
-          if (!md->isLinkable()) {
-            md = 0; // avoid returning things we cannot link to
-            nd = 0;
+        if (found) 
+        {
+          if (!md->isLinkable()) 
+          {
+            md=0; // avoid returning things we cannot link to
+            nd=0;
             return FALSE; // match found but not linkable
-          } else {
-            gd = md->getGroupDef();
-            if (gd && gd->isLinkable())
-              nd = 0;
-            else
-              gd = 0;
+          }
+          else
+          {
+            gd=md->getGroupDef();
+            if (gd && gd->isLinkable()) nd=0; else gd=0;
             return TRUE;
           }
         }
-      } else {
-        // printf("not a namespace\n");
+      }
+      else
+      {
+        //printf("not a namespace\n");
         MemberNameIterator mmli(*mn);
         MemberDef *mmd;
-        for (mmli.toFirst(); (mmd = mmli.current()); ++mmli) {
+        for (mmli.toFirst();(mmd=mmli.current());++mmli)
+        {
           MemberDef *tmd = mmd->getEnumScope();
-          // printf("try member %s
-          // tmd=%s\n",mmd->name().data(),tmd?tmd->name().data():"<none>");
-          int ni = namespaceName.findRev("::");
-          // printf("namespaceName=%s ni=%d\n",namespaceName.data(),ni);
-          bool notInNS = tmd && ni == -1 && tmd->getNamespaceDef() == 0 &&
-                         (mScope.isEmpty() || mScope == tmd->name());
-          bool sameNS =
-              tmd && tmd->getNamespaceDef() &&
-              namespaceName.left(ni) == tmd->getNamespaceDef()->name();
-          // printf("notInNS=%d sameNS=%d\n",notInNS,sameNS);
+          //printf("try member %s tmd=%s\n",mmd->name().data(),tmd?tmd->name().data():"<none>");
+          int ni=namespaceName.findRev("::");
+          //printf("namespaceName=%s ni=%d\n",namespaceName.data(),ni);
+          bool notInNS = tmd && ni==-1 && tmd->getNamespaceDef()==0 && (mScope.isEmpty() || mScope==tmd->name());
+          bool sameNS  = tmd && tmd->getNamespaceDef() && namespaceName.left(ni)==tmd->getNamespaceDef()->name();
+          //printf("notInNS=%d sameNS=%d\n",notInNS,sameNS);
           if (tmd && tmd->isStrong() && // C++11 enum class
               (notInNS || sameNS) &&
-              namespaceName.length() >
-                  0 // enum is part of namespace so this should not be empty
-              ) {
-            md = mmd;
-            fd = mmd->getFileDef();
-            gd = mmd->getGroupDef();
-            if (gd && gd->isLinkable())
-              fd = 0;
-            else
-              gd = 0;
-            // printf("Found scoped enum %s fd=%p gd=%p\n",
+              namespaceName.length()>0  // enum is part of namespace so this should not be empty
+             )
+          {
+            md=mmd;
+            fd=mmd->getFileDef();
+            gd=mmd->getGroupDef();
+            if (gd && gd->isLinkable()) fd=0; else gd=0;
+            //printf("Found scoped enum %s fd=%p gd=%p\n",
             //    mmd->name().data(),fd,gd);
             return TRUE;
           }
         }
       }
-      if (scopeOffset == 0) {
-        scopeOffset = -1;
-      } else if ((scopeOffset = scopeName.findRev("::", scopeOffset - 1)) ==
-                 -1) {
-        scopeOffset = 0;
+      if (scopeOffset==0)
+      {
+        scopeOffset=-1;
+      }
+      else if ((scopeOffset=scopeName.findRev("::",scopeOffset-1))==-1)
+      {
+        scopeOffset=0;
       }
-    } while (scopeOffset >= 0);
+    } while (scopeOffset>=0);
 
-    // else // no scope => global function
+    //else // no scope => global function
     {
       QList<MemberDef> members;
       // search for matches with strict static checking
-      findMembersWithSpecificName(mn, args, TRUE, currentFile, checkCV,
-                                  forceTagFile, members);
-      if (members.count() == 0) // nothing found
+      findMembersWithSpecificName(mn,args,TRUE,currentFile,checkCV,forceTagFile,members);
+      if (members.count()==0) // nothing found
       {
         // search again without strict static checking
-        findMembersWithSpecificName(mn, args, FALSE, currentFile, checkCV,
-                                    forceTagFile, members);
+        findMembersWithSpecificName(mn,args,FALSE,currentFile,checkCV,forceTagFile,members);
       }
-      // printf("found %d members\n",members.count());
-      if (members.count() != 1 && args && !qstrcmp(args, "()")) {
+      //printf("found %d members\n",members.count());
+      if (members.count()!=1 && args && !qstrcmp(args,"()"))
+      {
         // no exact match found, but if args="()" an arbitrary
         // member will do
         MemberNameIterator mni(*mn);
-        for (mni.toLast(); (md = mni.current()); --mni) {
-          // printf("Found member `%s'\n",md->name().data());
-          // printf("member is linkable md->name()=`%s'\n",md->name().data());
-          fd = md->getFileDef();
-          gd = md->getGroupDef();
+        for (mni.toLast();(md=mni.current());--mni)
+        {
+          //printf("Found member `%s'\n",md->name().data());
+          //printf("member is linkable md->name()=`%s'\n",md->name().data());
+          fd=md->getFileDef();
+          gd=md->getGroupDef();
           MemberDef *tmd = md->getEnumScope();
-          if ((gd && gd->isLinkable()) || (fd && fd->isLinkable()) ||
-              (tmd && tmd->isStrong())) {
+          if (
+              (gd && gd->isLinkable()) || (fd && fd->isLinkable()) ||
+              (tmd && tmd->isStrong())
+             )
+          {
             members.append(md);
           }
         }
       }
-      // printf("found %d candidate members\n",members.count());
-      if (members.count() > 0) // at least one match
+      //printf("found %d candidate members\n",members.count());
+      if (members.count()>0) // at least one match
       {
-        if (currentFile) {
-          // printf("multiple results; pick one from file:%s\n",
-          // currentFile->name().data());
+        if (currentFile)
+        {
+          //printf("multiple results; pick one from file:%s\n", currentFile->name().data());
           QListIterator<MemberDef> mit(members);
-          for (mit.toFirst(); (md = mit.current()); ++mit) {
-            if (md->getFileDef() &&
-                md->getFileDef()->name() == currentFile->name()) {
+          for (mit.toFirst();(md=mit.current());++mit)
+          {
+            if (md->getFileDef() && md->getFileDef()->name() == currentFile->name()) 
+            {
               break; // found match in the current file
             }
           }
           if (!md) // member not in the current file
           {
-            md = members.getLast();
+            md=members.getLast();
           }
-        } else {
-          md = members.getLast();
+        }
+        else
+        {
+          md=members.getLast();
         }
       }
-      if (md && (md->getEnumScope() == 0 || !md->getEnumScope()->isStrong()))
-      // found a matching global member, that is not a scoped enum value (or
-      // uniquely matches)
+      if (md && (md->getEnumScope()==0 || !md->getEnumScope()->isStrong())) 
+           // found a matching global member, that is not a scoped enum value (or uniquely matches)
       {
-        fd = md->getFileDef();
-        gd = md->getGroupDef();
-        // printf("fd=%p gd=%p gd->isLinkable()=%d\n",fd,gd,gd->isLinkable());
-        if (gd && gd->isLinkable())
-          fd = 0;
-        else
-          gd = 0;
+        fd=md->getFileDef();
+        gd=md->getGroupDef();
+        //printf("fd=%p gd=%p gd->isLinkable()=%d\n",fd,gd,gd->isLinkable());
+        if (gd && gd->isLinkable()) fd=0; else gd=0;
         return TRUE;
       }
     }
@@ -4301,137 +4505,146 @@ bool getDefs(const QCString &scName, const QCString &mbName, const char *args,
 
 /*!
  * Searches for a scope definition given its name as a string via parameter
- * `scope`.
+ * `scope`. 
  *
- * The parameter `docScope` is a string representing the name of the scope in
+ * The parameter `docScope` is a string representing the name of the scope in 
  * which the `scope` string was found.
  *
  * The function returns TRUE if the scope is known and documented or
  * FALSE if it is not.
- * If TRUE is returned exactly one of the parameter `cd`, `nd`
+ * If TRUE is returned exactly one of the parameter `cd`, `nd` 
  * will be non-zero:
  *   - if `cd` is non zero, the scope was a class pointed to by cd.
  *   - if `nd` is non zero, the scope was a namespace pointed to by nd.
  */
-static bool getScopeDefs(const char *docScope, const char *scope, ClassDef *&cd,
-                         NamespaceDef *&nd) {
-  cd = 0;
-  nd = 0;
-
-  QCString scopeName = scope;
-  // printf("getScopeDefs: docScope=`%s' scope=`%s'\n",docScope,scope);
-  if (scopeName.isEmpty())
-    return FALSE;
+static bool getScopeDefs(const char *docScope,const char *scope,
+    ClassDef *&cd, NamespaceDef *&nd)
+{
+  cd=0;nd=0;
 
-  bool explicitGlobalScope = FALSE;
-  if (scopeName.at(0) == ':' && scopeName.at(1) == ':') {
-    scopeName = scopeName.right(scopeName.length() - 2);
-    explicitGlobalScope = TRUE;
+  QCString scopeName=scope;
+  //printf("getScopeDefs: docScope=`%s' scope=`%s'\n",docScope,scope);
+  if (scopeName.isEmpty()) return FALSE;
+
+  bool explicitGlobalScope=FALSE;
+  if (scopeName.at(0)==':' && scopeName.at(1)==':')
+  {
+    scopeName=scopeName.right(scopeName.length()-2);  
+    explicitGlobalScope=TRUE;
   }
 
-  QCString docScopeName = docScope;
-  int scopeOffset = explicitGlobalScope ? 0 : docScopeName.length();
+  QCString docScopeName=docScope;
+  int scopeOffset=explicitGlobalScope ? 0 : docScopeName.length();
 
   do // for each possible docScope (from largest to and including empty)
   {
-    QCString fullName = scopeName.copy();
-    if (scopeOffset > 0)
-      fullName.prepend(docScopeName.left(scopeOffset) + "::");
+    QCString fullName=scopeName.copy();
+    if (scopeOffset>0) fullName.prepend(docScopeName.left(scopeOffset)+"::");
 
-    if (((cd = getClass(fullName)) ||     // normal class
-         (cd = getClass(fullName + "-p")) //||    // ObjC protocol
+    if (((cd=getClass(fullName)) ||         // normal class
+         (cd=getClass(fullName+"-p")) //||    // ObjC protocol
          //(cd=getClass(fullName+"-g"))       // C# generic
-         ) &&
-        cd->isLinkable()) {
-      return TRUE; // class link written => quit
-    } else if ((nd = Doxygen::namespaceSDict->find(fullName)) &&
-               nd->isLinkable()) {
-      return TRUE; // namespace link written => quit
+        ) && cd->isLinkable())
+    {
+      return TRUE; // class link written => quit 
     }
-    if (scopeOffset == 0) {
-      scopeOffset = -1;
-    } else if ((scopeOffset = docScopeName.findRev("::", scopeOffset - 1)) ==
-               -1) {
-      scopeOffset = 0;
+    else if ((nd=Doxygen::namespaceSDict->find(fullName)) && nd->isLinkable())
+    {
+      return TRUE; // namespace link written => quit 
     }
-  } while (scopeOffset >= 0);
+    if (scopeOffset==0)
+    {
+      scopeOffset=-1;
+    }
+    else if ((scopeOffset=docScopeName.findRev("::",scopeOffset-1))==-1)
+    {
+      scopeOffset=0;
+    }
+  } while (scopeOffset>=0);
 
   return FALSE;
 }
 
-static bool isLowerCase(QCString &s) {
-  uchar *p = (uchar *)s.data();
-  if (p == 0)
-    return TRUE;
+static bool isLowerCase(QCString &s)
+{
+  uchar *p=(uchar*)s.data();
+  if (p==0) return TRUE;
   int c;
-  while ((c = *p++))
-    if (!islower(c))
-      return FALSE;
-  return TRUE;
+  while ((c=*p++)) if (!islower(c)) return FALSE;
+  return TRUE; 
 }
 
-/*! Returns an object to reference to given its name and context
+/*! Returns an object to reference to given its name and context 
  *  @post return value TRUE implies *resContext!=0 or *resMember!=0
  */
-bool resolveRef(/* in */ const char *scName,
-                /* in */ const char *name,
-                /* in */ bool inSeeBlock,
-                /* out */ Definition **resContext,
-                /* out */ MemberDef **resMember, bool lookForSpecialization,
-                FileDef *currentFile, bool checkScope) {
-  // printf("resolveRef(scope=%s,name=%s,inSeeBlock=%d)\n",scName,name,inSeeBlock);
+bool resolveRef(/* in */  const char *scName,
+    /* in */  const char *name,
+    /* in */  bool inSeeBlock,
+    /* out */ Definition **resContext,
+    /* out */ MemberDef  **resMember,
+    bool lookForSpecialization,
+    FileDef *currentFile,
+    bool checkScope
+    )
+{
+  //printf("resolveRef(scope=%s,name=%s,inSeeBlock=%d)\n",scName,name,inSeeBlock);
   QCString tsName = name;
-  // bool memberScopeFirst = tsName.find('#')!=-1;
-  QCString fullName = substitute(tsName, "#", "::");
-  if (fullName.find("anonymous_namespace{") == -1) {
-    fullName = removeRedundantWhiteSpace(substitute(fullName, ".", "::"));
-  } else {
+  //bool memberScopeFirst = tsName.find('#')!=-1;
+  QCString fullName = substitute(tsName,"#","::");
+  if (fullName.find("anonymous_namespace{")==-1)
+  {
+    fullName = removeRedundantWhiteSpace(substitute(fullName,".","::"));
+  }
+  else
+  {
     fullName = removeRedundantWhiteSpace(fullName);
   }
 
-  int bracePos = findParameterList(fullName);
-  int endNamePos = bracePos != -1 ? bracePos : fullName.length();
-  int scopePos = fullName.findRev("::", endNamePos);
-  bool explicitScope = fullName.left(2) == "::" && // ::scope or #scope
-                       (scopePos > 2 ||            // ::N::A
-                        tsName.left(2) == "::" ||  // ::foo in local scope
-                        scName == 0                // #foo  in global scope
-                        );
+  int bracePos=findParameterList(fullName);
+  int endNamePos=bracePos!=-1 ? bracePos : fullName.length();
+  int scopePos=fullName.findRev("::",endNamePos);
+  bool explicitScope = fullName.left(2)=="::" &&   // ::scope or #scope
+                       (scopePos>2 ||              // ::N::A
+                        tsName.left(2)=="::" ||    // ::foo in local scope
+                        scName==0                  // #foo  in global scope
+                       );
 
   // default result values
-  *resContext = 0;
-  *resMember = 0;
+  *resContext=0;
+  *resMember=0;
 
-  if (bracePos == -1) // simple name
+  if (bracePos==-1) // simple name
   {
-    ClassDef *cd = 0;
-    NamespaceDef *nd = 0;
+    ClassDef *cd=0;
+    NamespaceDef *nd=0;
 
-    // the following if() was commented out for releases in the range
+    // the following if() was commented out for releases in the range 
     // 1.5.2 to 1.6.1, but has been restored as a result of bug report 594787.
-    if (!inSeeBlock && scopePos == -1 &&
-        isLowerCase(
-            tsName)) { // link to lower case only name => do not try to autolink
+    if (!inSeeBlock && scopePos==-1 && isLowerCase(tsName))
+    { // link to lower case only name => do not try to autolink 
       return FALSE;
     }
 
-    // printf("scName=%s fullName=%s\n",scName,fullName.data());
+    //printf("scName=%s fullName=%s\n",scName,fullName.data());
 
     // check if this is a class or namespace reference
-    if (scName != fullName && getScopeDefs(scName, fullName, cd, nd)) {
+    if (scName!=fullName && getScopeDefs(scName,fullName,cd,nd))
+    {
       if (cd) // scope matches that of a class
       {
         *resContext = cd;
-      } else // scope matches that of a namespace
+      }
+      else // scope matches that of a namespace
       {
-        ASSERT(nd != 0);
+        ASSERT(nd!=0);
         *resContext = nd;
       }
       return TRUE;
-    } else if (scName == fullName || (!inSeeBlock && scopePos == -1))
-    // nothing to link => output plain text
+    }
+    else if (scName==fullName || (!inSeeBlock && scopePos==-1)) 
+      // nothing to link => output plain text
     {
-      // printf("found scName=%s fullName=%s scName==fullName=%d "
+      //printf("found scName=%s fullName=%s scName==fullName=%d "
       //    "inSeeBlock=%d scopePos=%d!\n",
       //    scName,fullName.data(),scName==fullName,inSeeBlock,scopePos);
       return FALSE;
@@ -4440,148 +4653,129 @@ bool resolveRef(/* in */ const char *scName,
   }
 
   // extract userscope+name
-  QCString nameStr = fullName.left(endNamePos);
-  if (explicitScope)
-    nameStr = nameStr.mid(2);
+  QCString nameStr=fullName.left(endNamePos);
+  if (explicitScope) nameStr=nameStr.mid(2);
 
   // extract arguments
   QCString argsStr;
-  if (bracePos != -1)
-    argsStr = fullName.right(fullName.length() - bracePos);
+  if (bracePos!=-1) argsStr=fullName.right(fullName.length()-bracePos);
 
   // strip template specifier
-  // TODO: match against the correct partial template instantiation
-  int templPos = nameStr.find('<');
+  // TODO: match against the correct partial template instantiation 
+  int templPos=nameStr.find('<');
   bool tryUnspecializedVersion = FALSE;
-  if (templPos != -1 && nameStr.find("operator") == -1) {
-    int endTemplPos = nameStr.findRev('>');
-    if (endTemplPos != -1) {
-      if (!lookForSpecialization) {
-        nameStr = nameStr.left(templPos) +
-                  nameStr.right(nameStr.length() - endTemplPos - 1);
-      } else {
+  if (templPos!=-1 && nameStr.find("operator")==-1)
+  {
+    int endTemplPos=nameStr.findRev('>');
+    if (endTemplPos!=-1)
+    {
+      if (!lookForSpecialization)
+      {
+        nameStr=nameStr.left(templPos)+nameStr.right(nameStr.length()-endTemplPos-1);
+      }
+      else
+      {
         tryUnspecializedVersion = TRUE;
       }
     }
   }
 
-  QCString scopeStr = scName;
+  QCString scopeStr=scName;
 
-  MemberDef *md = 0;
-  ClassDef *cd = 0;
-  FileDef *fd = 0;
+  MemberDef    *md = 0;
+  ClassDef     *cd = 0;
+  FileDef      *fd = 0;
   NamespaceDef *nd = 0;
-  GroupDef *gd = 0;
+  GroupDef     *gd = 0;
 
   // check if nameStr is a member or global.
-  // printf("getDefs(scope=%s,name=%s,args=%s checkScope=%d)\n",
+  //printf("getDefs(scope=%s,name=%s,args=%s checkScope=%d)\n",
   //    scopeStr.data(),nameStr.data(),argsStr.data(),checkScope);
-  if (getDefs(scopeStr, nameStr, argsStr, md, cd, fd, nd, gd,
-              // scopePos==0 && !memberScopeFirst, // forceEmptyScope
-              explicitScope, // replaces prev line due to bug 600829
-              currentFile,
-              TRUE // checkCV
-              )) {
-    // printf("after getDefs checkScope=%d nameStr=%s cd=%p
-    // nd=%p\n",checkScope,nameStr.data(),cd,nd);
-    if (checkScope && md && md->getOuterScope() == Doxygen::globalScope &&
+  if (getDefs(scopeStr,nameStr,argsStr,
+        md,cd,fd,nd,gd,
+        //scopePos==0 && !memberScopeFirst, // forceEmptyScope
+        explicitScope, // replaces prev line due to bug 600829
+        currentFile,
+        TRUE                              // checkCV
+        )
+     )
+  {
+    //printf("after getDefs checkScope=%d nameStr=%s cd=%p nd=%p\n",checkScope,nameStr.data(),cd,nd);
+    if (checkScope && md && md->getOuterScope()==Doxygen::globalScope && 
         !md->isStrongEnumValue() &&
-        (!scopeStr.isEmpty() || nameStr.find("::") > 0)) {
-      // we did find a member, but it is a global one while we were explicitly
-      // looking for a scoped variable. See bug 616387 for an example why this
-      // check is needed.
+        (!scopeStr.isEmpty() || nameStr.find("::")>0))
+    {
+      // we did find a member, but it is a global one while we were explicitly 
+      // looking for a scoped variable. See bug 616387 for an example why this check is needed.
       // note we do need to support autolinking to "::symbol" hence the >0
-      // printf("not global member!\n");
-      *resContext = 0;
-      *resMember = 0;
-      return FALSE;
-    }
-    // printf("after getDefs md=%p cd=%p fd=%p nd=%p gd=%p\n",md,cd,fd,nd,gd);
-    if (md) {
-      *resMember = md;
-      *resContext = md;
-    } else if (cd)
-      *resContext = cd;
-    else if (nd)
-      *resContext = nd;
-    else if (fd)
-      *resContext = fd;
-    else if (gd)
-      *resContext = gd;
-    else {
-      *resContext = 0;
-      *resMember = 0;
+      //printf("not global member!\n");
+      *resContext=0;
+      *resMember=0;
       return FALSE;
     }
-    // printf("member=%s (md=%p) anchor=%s linkable()=%d context=%s\n",
+    //printf("after getDefs md=%p cd=%p fd=%p nd=%p gd=%p\n",md,cd,fd,nd,gd);
+    if      (md) { *resMember=md; *resContext=md; }
+    else if (cd) *resContext=cd;
+    else if (nd) *resContext=nd;
+    else if (fd) *resContext=fd;
+    else if (gd) *resContext=gd;
+    else         { *resContext=0; *resMember=0; return FALSE; }
+    //printf("member=%s (md=%p) anchor=%s linkable()=%d context=%s\n",
     //    md->name().data(),md,md->anchor().data(),md->isLinkable(),(*resContext)->name().data());
     return TRUE;
-  } else if (inSeeBlock && !nameStr.isEmpty() &&
-             (gd = Doxygen::groupSDict->find(nameStr))) { // group link
-    *resContext = gd;
+  }
+  else if (inSeeBlock && !nameStr.isEmpty() && (gd=Doxygen::groupSDict->find(nameStr)))
+  { // group link
+    *resContext=gd;
     return TRUE;
-  } else if (tsName.find('.') != -1) // maybe a link to a file
+  }
+  else if (tsName.find('.')!=-1) // maybe a link to a file
   {
     bool ambig;
-    fd = findFileDef(Doxygen::inputNameDict, tsName, ambig);
-    if (fd && !ambig) {
-      *resContext = fd;
+    fd=findFileDef(Doxygen::inputNameDict,tsName,ambig);
+    if (fd && !ambig)
+    {
+      *resContext=fd;
       return TRUE;
     }
   }
 
-  if (tryUnspecializedVersion) {
-    return resolveRef(scName, name, inSeeBlock, resContext, resMember, FALSE, 0,
-                      checkScope);
+  if (tryUnspecializedVersion)
+  {
+    return resolveRef(scName,name,inSeeBlock,resContext,resMember,FALSE,0,checkScope);
   }
-  if (bracePos !=
-      -1) // Try without parameters as well, could be a contructor invocation
+  if (bracePos!=-1) // Try without parameters as well, could be a contructor invocation
   {
-    *resContext = getClass(fullName.left(bracePos));
-    if (*resContext) {
+    *resContext=getClass(fullName.left(bracePos));
+    if (*resContext)
+    {
       return TRUE;
     }
   }
-  // printf("resolveRef: %s not found!\n",name);
+  //printf("resolveRef: %s not found!\n",name);
 
   return FALSE;
 }
 
-static bool isArity(char *beg, const char *end) {
-  // arity < 10
-  if (beg + 1 != end)
-    return false;
-  int ch = *beg;
-  if (ch < '0' || ch > '9')
-    return false;
-#if 0
-  if (beg == end)
-    return false;
-  while (beg < end) {
-    int ch = *beg++;
-    if (ch < '0' || ch > '9')
-      return false;
-  }
-#endif
-  return true;
-}
-
-QCString linkToText(SrcLangExt lang, const char *link, bool isFileName) {
-  // static bool optimizeOutputJava = Config_getBool(OPTIMIZE_OUTPUT_JAVA);
-  QCString result = link;
-  if (!result.isEmpty()) {
+QCString linkToText(SrcLangExt lang,const char *link,bool isFileName)
+{
+  //static bool optimizeOutputJava = Config_getBool(OPTIMIZE_OUTPUT_JAVA);
+  QCString result=link;
+  if (!result.isEmpty())
+  {
     // replace # by ::
-    result = substitute(result, "#", "::");
+    result=substitute(result,"#","::");
     // replace . by ::
-    if (!isFileName && result.find('<') == -1)
-      result = substitute(result, ".", "::");
+    if (!isFileName && result.find('<')==-1) result=substitute(result,".","::");
     // strip leading :: prefix if present
-    if (result.at(0) == ':' && result.at(1) == ':') {
-      result = result.right(result.length() - 2);
+    if (result.at(0)==':' && result.at(1)==':')
+    {
+      result=result.right(result.length()-2);
     }
     QCString sep = getLanguageSpecificSeparator(lang);
-    if (sep != "::") {
-      result = substitute(result, "::", sep);
+    if (sep!="::")
+    {
+      result=substitute(result,"::",sep);
     }
   }
   return result;
@@ -4590,20 +4784,20 @@ QCString linkToText(SrcLangExt lang, const char *link, bool isFileName) {
 #if 0
 /*
  * generate a reference to a class, namespace or member.
- * `scName' is the name of the scope that contains the documentation
+ * `scName' is the name of the scope that contains the documentation 
  * string that is returned.
  * `name' is the name that we want to link to.
  * `name' may have five formats:
  *    1) "ScopeName"
- *    2) "memberName()"    one of the (overloaded) function or define
+ *    2) "memberName()"    one of the (overloaded) function or define 
  *                         with name memberName.
- *    3) "memberName(...)" a specific (overloaded) function or define
+ *    3) "memberName(...)" a specific (overloaded) function or define 
  *                         with name memberName
  *    4) "::name           a global variable or define
  *    4) "\#memberName     member variable, global variable or define
- *    5) ("Scopename::")+"memberName()"
- *    6) ("ScopeName::")+"memberName(...)"
- *    7) ("ScopeName::")+"memberName"
+ *    5) ("ScopeName::")+"memberName()" 
+ *    6) ("ScopeName::")+"memberName(...)" 
+ *    7) ("ScopeName::")+"memberName" 
  * instead of :: the \# symbol may also be used.
  */
 
@@ -4658,174 +4852,173 @@ bool generateRef(OutputDocInterface &od,const char *scName,
 #endif
 
 bool resolveLink(/* in */ const char *scName,
-                 /* in */ const char *lr,
-                 /* in */ bool /*inSeeBlock*/,
-                 /* out */ Definition **resContext,
-                 /* out */ QCString &resAnchor) {
-  *resContext = 0;
-
-  QCString linkRef = lr;
-  QCString linkRefWithoutTemplates =
-      stripTemplateSpecifiersFromScope(linkRef, FALSE);
-  // printf("ResolveLink linkRef=%s\n",lr);
-  FileDef *fd;
+    /* in */ const char *lr,
+    /* in */ bool /*inSeeBlock*/,
+    /* out */ Definition **resContext,
+    /* out */ QCString &resAnchor
+    )
+{
+  *resContext=0;
+
+  QCString linkRef=lr;
+  QCString linkRefWithoutTemplates = stripTemplateSpecifiersFromScope(linkRef,FALSE);
+  //printf("ResolveLink linkRef=%s\n",lr);
+  FileDef  *fd;
   GroupDef *gd;
-  PageDef *pd;
+  PageDef  *pd;
   ClassDef *cd;
-  DirDef *dir;
+  DirDef   *dir;
   NamespaceDef *nd;
-  SectionInfo *si = 0;
+  SectionInfo *si=0;
   bool ambig;
-  char *slashp;
-  QCString res;
   if (linkRef.isEmpty()) // no reference name!
   {
     return FALSE;
-  } else if (Config_getBool(OPTIMIZE_OUTPUT_FOR_PROLOG) &&
-             (slashp = strrchr((char *)(linkRef.data()), '/')) != 0 &&
-             isArity(slashp + 1, linkRef.data() + linkRef.length())) {
-    QCString o;
-    normalizeIndicator(linkRef.data(), o);
-    const char *result = o;
-    if (!result || !strcmp(result, linkRef.data())) {
-      // do nothing
-    } else if ((res = g_foreignCache[result])) {
-      linkRef = res;
-    } else {
-      linkRef = result;
-    }
-    printf("? %s\n", linkRef.data());
-  }
-  if ((pd = Doxygen::pageSDict->find(linkRef))) // link to a page
+  }
+  else if ((pd=Doxygen::pageSDict->find(linkRef))) // link to a page
   {
     GroupDef *gd = pd->getGroupDef();
-    if (gd) {
-      if (!pd->name().isEmpty())
-        si = Doxygen::sectionDict->find(pd->name());
-      *resContext = gd;
-      if (si)
-        resAnchor = si->label;
-    } else {
-      *resContext = pd;
+    if (gd)
+    {
+      if (!pd->name().isEmpty()) si=Doxygen::sectionDict->find(pd->name());
+      *resContext=gd;
+      if (si) resAnchor = si->label;
+    }
+    else
+    {
+      *resContext=pd;
     }
     return TRUE;
-  } else if ((si = Doxygen::sectionDict->find(linkRef))) {
-    *resContext = si->definition;
+  }
+  else if ((si=Doxygen::sectionDict->find(linkRef)))
+  {
+    *resContext=si->definition;
     resAnchor = si->label;
     return TRUE;
-  } else if ((pd = Doxygen::exampleSDict->find(linkRef))) // link to an example
+  }
+  else if ((pd=Doxygen::exampleSDict->find(linkRef))) // link to an example
   {
-    *resContext = pd;
+    *resContext=pd;
     return TRUE;
-  } else if ((gd = Doxygen::groupSDict->find(linkRef))) // link to a group
+  }
+  else if ((gd=Doxygen::groupSDict->find(linkRef))) // link to a group
   {
-    *resContext = gd;
+    *resContext=gd;
     return TRUE;
-  } else if ((fd = findFileDef(Doxygen::inputNameDict, linkRef,
-                               ambig)) // file link
-             && fd->isLinkable()) {
-    *resContext = fd;
+  }
+  else if ((fd=findFileDef(Doxygen::inputNameDict,linkRef,ambig)) // file link
+      && fd->isLinkable())
+  {
+    *resContext=fd;
     return TRUE;
-  } else if ((cd = getClass(linkRef))) // class link
+  }
+  else if ((cd=getClass(linkRef))) // class link
   {
-    *resContext = cd;
-    resAnchor = cd->anchor();
+    *resContext=cd;
+    resAnchor=cd->anchor();
     return TRUE;
-  } else if ((cd = getClass(
-                  linkRefWithoutTemplates))) // C#/Java generic class link
+  }
+  else if ((cd=getClass(linkRefWithoutTemplates))) // C#/Java generic class link
   {
-    *resContext = cd;
-    resAnchor = cd->anchor();
+    *resContext=cd;
+    resAnchor=cd->anchor();
     return TRUE;
-  } else if ((cd = getClass(linkRef + "-p"))) // Obj-C protocol link
+  }
+  else if ((cd=getClass(linkRef+"-p"))) // Obj-C protocol link
   {
-    *resContext = cd;
-    resAnchor = cd->anchor();
+    *resContext=cd;
+    resAnchor=cd->anchor();
     return TRUE;
   }
-  //  else if ((cd=getClass(linkRef+"-g"))) // C# generic link
-  //  {
-  //    *resContext=cd;
-  //    resAnchor=cd->anchor();
-  //    return TRUE;
-  //  }
-  else if ((nd = Doxygen::namespaceSDict->find(linkRef))) {
-    *resContext = nd;
+//  else if ((cd=getClass(linkRef+"-g"))) // C# generic link
+//  {
+//    *resContext=cd;
+//    resAnchor=cd->anchor();
+//    return TRUE;
+//  }
+  else if ((nd=Doxygen::namespaceSDict->find(linkRef)))
+  {
+    *resContext=nd;
     return TRUE;
-  } else if ((dir = Doxygen::directories->find(
-                  QFileInfo(linkRef).absFilePath().utf8() + "/")) &&
-             dir->isLinkable()) // TODO: make this location independent like
-                                // filedefs
+  }
+  else if ((dir=Doxygen::directories->find(QFileInfo(linkRef).absFilePath().utf8()+"/"))
+      && dir->isLinkable()) // TODO: make this location independent like filedefs
   {
-    *resContext = dir;
+    *resContext=dir;
     return TRUE;
-  } else // probably a member reference
+  }
+  else // probably a member reference
   {
     MemberDef *md;
-    bool res = resolveRef(scName, lr, TRUE, resContext, &md);
-    if (md)
-      resAnchor = md->anchor();
+    bool res = resolveRef(scName,lr,TRUE,resContext,&md);
+    if (md) resAnchor=md->anchor();
     return res;
   }
 }
 
+
 //----------------------------------------------------------------------
 // General function that generates the HTML code for a reference to some
-// file, class or member from text `lr' within the context of class `clName'.
+// file, class or member from text `lr' within the context of class `clName'. 
 // This link has the text 'lt' (if not 0), otherwise `lr' is used as a
 // basis for the link's text.
 // returns TRUE if a link could be generated.
 
-bool generateLink(OutputDocInterface &od, const char *clName, const char *lr,
-                  bool inSeeBlock, const char *lt) {
-  // printf("generateLink(clName=%s,lr=%s,lr=%s)\n",clName,lr,lt);
+bool generateLink(OutputDocInterface &od,const char *clName,
+    const char *lr,bool inSeeBlock,const char *lt)
+{
+  //printf("generateLink(clName=%s,lr=%s,lr=%s)\n",clName,lr,lt);
   Definition *compound;
-  // PageDef *pageDef=0;
-  QCString anchor, linkText = linkToText(SrcLangExt_Unknown, lt, FALSE);
-  // printf("generateLink linkText=%s\n",linkText.data());
-  if (resolveLink(clName, lr, inSeeBlock, &compound, anchor)) {
+  //PageDef *pageDef=0;
+  QCString anchor,linkText=linkToText(SrcLangExt_Unknown,lt,FALSE);
+  //printf("generateLink linkText=%s\n",linkText.data());
+  if (resolveLink(clName,lr,inSeeBlock,&compound,anchor))
+  {
     if (compound) // link to compound
     {
-      if (lt == 0 && anchor.isEmpty() && /* compound link */
-          compound->definitionType() == Definition::TypeGroup /* is group */
-          ) {
-        linkText =
-            ((GroupDef *)compound)->groupTitle(); // use group's title as link
-      } else if (compound->definitionType() == Definition::TypeFile) {
-        linkText = linkToText(compound->getLanguage(), lt, TRUE);
+      if (lt==0 && anchor.isEmpty() &&                      /* compound link */
+          compound->definitionType()==Definition::TypeGroup /* is group */ 
+         )
+      {
+        linkText=((GroupDef *)compound)->groupTitle(); // use group's title as link
+      }
+      else if (compound->definitionType()==Definition::TypeFile)
+      {
+        linkText=linkToText(compound->getLanguage(),lt,TRUE); 
       }
       od.writeObjectLink(compound->getReference(),
-                         compound->getOutputFileBase(), anchor, linkText);
-      if (!compound->isReference()) {
-        writePageRef(od, compound->getOutputFileBase(), anchor);
+          compound->getOutputFileBase(),anchor,linkText);
+      if (!compound->isReference())
+      {
+        writePageRef(od,compound->getOutputFileBase(),anchor);
       }
-    } else {
-      err("%s:%d: Internal error: resolveLink successful but no compound "
-          "found!",
-          __FILE__, __LINE__);
+    }
+    else
+    {
+      err("%s:%d: Internal error: resolveLink successful but no compound found!",__FILE__,__LINE__);
     }
     return TRUE;
-  } else // link could not be found
+  }
+  else // link could not be found
   {
     od.docify(linkText);
     return FALSE;
   }
 }
 
-void generateFileRef(OutputDocInterface &od, const char *name,
-                     const char *text) {
-  // printf("generateFileRef(%s,%s)\n",name,text);
+void generateFileRef(OutputDocInterface &od,const char *name,const char *text)
+{
+  //printf("generateFileRef(%s,%s)\n",name,text);
   QCString linkText = text ? text : name;
-  // FileInfo *fi;
+  //FileInfo *fi;
   FileDef *fd;
   bool ambig;
-  if ((fd = findFileDef(Doxygen::inputNameDict, name, ambig)) &&
-      fd->isLinkable())
+  if ((fd=findFileDef(Doxygen::inputNameDict,name,ambig)) && 
+      fd->isLinkable()) 
     // link to documented input file
-    od.writeObjectLink(fd->getReference(), fd->getOutputFileBase(), 0,
-                       linkText);
+    od.writeObjectLink(fd->getReference(),fd->getOutputFileBase(),0,linkText);
   else
-    od.docify(linkText);
+    od.docify(linkText); 
 }
 
 //----------------------------------------------------------------------
@@ -4859,117 +5052,131 @@ QCString substituteClassNames(const QCString &s)
 //----------------------------------------------------------------------
 
 /** Cache element for the file name to FileDef mapping cache. */
-struct FindFileCacheElem {
-  FindFileCacheElem(FileDef *fd, bool ambig) : fileDef(fd), isAmbig(ambig) {}
+struct FindFileCacheElem
+{
+  FindFileCacheElem(FileDef *fd,bool ambig) : fileDef(fd), isAmbig(ambig) {}
   FileDef *fileDef;
   bool isAmbig;
 };
 
 static QCache<FindFileCacheElem> g_findFileDefCache(5000);
 
-FileDef *findFileDef(const FileNameDict *fnDict, const char *n, bool &ambig) {
-  ambig = FALSE;
-  if (n == 0)
-    return 0;
+FileDef *findFileDef(const FileNameDict *fnDict,const char *n,bool &ambig)
+{
+  ambig=FALSE;
+  if (n==0) return 0;
 
   const int maxAddrSize = 20;
   char addr[maxAddrSize];
-  qsnprintf(addr, maxAddrSize, "%p:", fnDict);
+  qsnprintf(addr,maxAddrSize,"%p:",fnDict);
   QCString key = addr;
-  key += n;
+  key+=n;
 
   g_findFileDefCache.setAutoDelete(TRUE);
   FindFileCacheElem *cachedResult = g_findFileDefCache.find(key);
-  // printf("key=%s cachedResult=%p\n",key.data(),cachedResult);
-  if (cachedResult) {
+  //printf("key=%s cachedResult=%p\n",key.data(),cachedResult);
+  if (cachedResult)
+  {
     ambig = cachedResult->isAmbig;
-    // printf("cached: fileDef=%p\n",cachedResult->fileDef);
+    //printf("cached: fileDef=%p\n",cachedResult->fileDef);
     return cachedResult->fileDef;
-  } else {
-    cachedResult = new FindFileCacheElem(0, FALSE);
+  }
+  else
+  {
+    cachedResult = new FindFileCacheElem(0,FALSE);
   }
 
-  QCString name = QDir::cleanDirPath(n).utf8();
+  QCString name=QDir::cleanDirPath(n).utf8();
   QCString path;
   int slashPos;
   FileName *fn;
-  if (name.isEmpty())
-    goto exit;
-  slashPos = QMAX(name.findRev('/'), name.findRev('\\'));
-  if (slashPos != -1) {
-    path = name.left(slashPos + 1);
-    name = name.right(name.length() - slashPos - 1);
-    // printf("path=%s name=%s\n",path.data(),name.data());
+  if (name.isEmpty()) goto exit;
+  slashPos=QMAX(name.findRev('/'),name.findRev('\\'));
+  if (slashPos!=-1)
+  {
+    path=name.left(slashPos+1);
+    name=name.right(name.length()-slashPos-1); 
+    //printf("path=%s name=%s\n",path.data(),name.data());
   }
-  if (name.isEmpty())
-    goto exit;
-  if ((fn = (*fnDict)[name])) {
-    // printf("fn->count()=%d\n",fn->count());
-    if (fn->count() == 1) {
+  if (name.isEmpty()) goto exit;
+  if ((fn=(*fnDict)[name]))
+  {
+    //printf("fn->count()=%d\n",fn->count());
+    if (fn->count()==1)
+    {
       FileDef *fd = fn->getFirst();
 #if defined(_WIN32) || defined(__MACOSX__) // Windows or MacOSX
-      bool isSamePath =
-          fd->getPath().right(path.length()).lower() == path.lower();
+      bool isSamePath = fd->getPath().right(path.length()).lower()==path.lower();
 #else // Unix
-      bool isSamePath = fd->getPath().right(path.length()) == path;
+      bool isSamePath = fd->getPath().right(path.length())==path;
 #endif
-      if (path.isEmpty() || isSamePath) {
+      if (path.isEmpty() || isSamePath)
+      {
         cachedResult->fileDef = fd;
-        g_findFileDefCache.insert(key, cachedResult);
-        // printf("=1 ===> add to cache %p\n",fd);
+        g_findFileDefCache.insert(key,cachedResult);
+        //printf("=1 ===> add to cache %p\n",fd);
         return fd;
       }
-    } else // file name alone is ambiguous
+    }
+    else // file name alone is ambiguous
     {
-      int count = 0;
+      int count=0;
       FileNameIterator fni(*fn);
       FileDef *fd;
-      FileDef *lastMatch = 0;
+      FileDef *lastMatch=0;
       QCString pathStripped = stripFromIncludePath(path);
-      for (fni.toFirst(); (fd = fni.current()); ++fni) {
+      for (fni.toFirst();(fd=fni.current());++fni)
+      {
         QCString fdStripPath = stripFromIncludePath(fd->getPath());
-        if (path.isEmpty() ||
-            fdStripPath.right(pathStripped.length()) == pathStripped) {
-          count++;
-          lastMatch = fd;
+        if (path.isEmpty() || fdStripPath.right(pathStripped.length())==pathStripped) 
+        { 
+          count++; 
+          lastMatch=fd; 
         }
       }
-      // printf(">1 ===> add to cache %p\n",fd);
+      //printf(">1 ===> add to cache %p\n",fd);
 
-      ambig = (count > 1);
+      ambig=(count>1);
       cachedResult->isAmbig = ambig;
       cachedResult->fileDef = lastMatch;
-      g_findFileDefCache.insert(key, cachedResult);
+      g_findFileDefCache.insert(key,cachedResult);
       return lastMatch;
     }
-  } else {
-    // printf("not found!\n");
+  }
+  else
+  {
+    //printf("not found!\n");
   }
 exit:
-  // printf("0  ===> add to cache %p: %s\n",cachedResult,n);
-  g_findFileDefCache.insert(key, cachedResult);
-  // delete cachedResult;
+  //printf("0  ===> add to cache %p: %s\n",cachedResult,n);
+  g_findFileDefCache.insert(key,cachedResult);
+  //delete cachedResult;
   return 0;
 }
 
 //----------------------------------------------------------------------
 
-QCString showFileDefMatches(const FileNameDict *fnDict, const char *n) {
+QCString showFileDefMatches(const FileNameDict *fnDict,const char *n)
+{
   QCString result;
-  QCString name = n;
+  QCString name=n;
   QCString path;
-  int slashPos = QMAX(name.findRev('/'), name.findRev('\\'));
-  if (slashPos != -1) {
-    path = name.left(slashPos + 1);
-    name = name.right(name.length() - slashPos - 1);
+  int slashPos=QMAX(name.findRev('/'),name.findRev('\\'));
+  if (slashPos!=-1)
+  {
+    path=name.left(slashPos+1);
+    name=name.right(name.length()-slashPos-1); 
   }
   FileName *fn;
-  if ((fn = (*fnDict)[name])) {
+  if ((fn=(*fnDict)[name]))
+  {
     FileNameIterator fni(*fn);
     FileDef *fd;
-    for (fni.toFirst(); (fd = fni.current()); ++fni) {
-      if (path.isEmpty() || fd->getPath().right(path.length()) == path) {
-        result += "   " + fd->absFilePath() + "\n";
+    for (fni.toFirst();(fd=fni.current());++fni)
+    {
+      if (path.isEmpty() || fd->getPath().right(path.length())==path)
+      {
+        result+="   "+fd->absFilePath()+"\n";
       }
     }
   }
@@ -4979,55 +5186,53 @@ QCString showFileDefMatches(const FileNameDict *fnDict, const char *n) {
 //----------------------------------------------------------------------
 
 /// substitute all occurrences of \a src in \a s by \a dst
-QCString substitute(const QCString &s, const QCString &src,
-                    const QCString &dst) {
-  if (s.isEmpty() || src.isEmpty())
-    return s;
+QCString substitute(const QCString &s,const QCString &src,const QCString &dst)
+{
+  if (s.isEmpty() || src.isEmpty()) return s;
   const char *p, *q;
   int srcLen = src.length();
   int dstLen = dst.length();
   int resLen;
-  if (srcLen != dstLen) {
+  if (srcLen!=dstLen)
+  {
     int count;
-    for (count = 0, p = s.data(); (q = strstr(p, src)) != 0; p = q + srcLen)
-      count++;
-    resLen = s.length() + count * (dstLen - srcLen);
-  } else // result has same size as s
+    for (count=0, p=s.data(); (q=strstr(p,src))!=0; p=q+srcLen) count++;
+    resLen = s.length()+count*(dstLen-srcLen);
+  }
+  else // result has same size as s
   {
     resLen = s.length();
   }
-  QCString result(resLen + 1);
+  QCString result(resLen+1);
   char *r;
-  for (r = result.rawData(), p = s; (q = strstr(p, src)) != 0; p = q + srcLen) {
-    int l = (int)(q - p);
-    memcpy(r, p, l);
-    r += l;
-    if (dst)
-      memcpy(r, dst, dstLen);
-    r += dstLen;
-  }
-  qstrcpy(r, p);
-  // printf("substitute(%s,%s,%s)->%s\n",s,src,dst,result.data());
+  for (r=result.rawData(), p=s; (q=strstr(p,src))!=0; p=q+srcLen)
+  {
+    int l = (int)(q-p);
+    memcpy(r,p,l);
+    r+=l;
+    if (dst) memcpy(r,dst,dstLen);
+    r+=dstLen;
+  }
+  qstrcpy(r,p);
+  //printf("substitute(%s,%s,%s)->%s\n",s,src,dst,result.data());
   return result;
 }
 
 //----------------------------------------------------------------------
 
-QCString substituteKeywords(const QCString &s, const char *title,
-                            const char *projName, const char *projNum,
-                            const char *projBrief) {
+QCString substituteKeywords(const QCString &s,const char *title,
+         const char *projName,const char *projNum,const char *projBrief)
+{
   QCString result = s;
-  if (title)
-    result = substitute(result, "$title", title);
-  result = substitute(result, "$datetime", dateToString(TRUE));
-  result = substitute(result, "$date", dateToString(FALSE));
-  result = substitute(result, "$year", yearToString());
-  result = substitute(result, "$doxygenversion", versionString);
-  result = substitute(result, "$projectname", projName);
-  result = substitute(result, "$projectnumber", projNum);
-  result = substitute(result, "$projectbrief", projBrief);
-  result = substitute(result, "$projectlogo",
-                      stripPath(Config_getString(PROJECT_LOGO)));
+  if (title) result = substitute(result,"$title",title);
+  result = substitute(result,"$datetime",dateToString(TRUE));
+  result = substitute(result,"$date",dateToString(FALSE));
+  result = substitute(result,"$year",yearToString());
+  result = substitute(result,"$doxygenversion",versionString);
+  result = substitute(result,"$projectname",projName);
+  result = substitute(result,"$projectnumber",projNum);
+  result = substitute(result,"$projectbrief",projBrief);
+  result = substitute(result,"$projectlogo",stripPath(Config_getString(PROJECT_LOGO)));
   return result;
 }
 
@@ -5036,19 +5241,20 @@ QCString substituteKeywords(const QCString &s, const char *title,
 /*! Returns the character index within \a name of the first prefix
  *  in Config_getList(IGNORE_PREFIX) that matches \a name at the left hand side,
  *  or zero if no match was found
- */
-int getPrefixIndex(const QCString &name) {
-  if (name.isEmpty())
-    return 0;
+ */ 
+int getPrefixIndex(const QCString &name)
+{
+  if (name.isEmpty()) return 0;
   static QStrList &sl = Config_getList(IGNORE_PREFIX);
   char *s = sl.first();
-  while (s) {
-    const char *ps = s;
-    const char *pd = name.data();
-    int i = 0;
-    while (*ps != 0 && *pd != 0 && *ps == *pd)
-      ps++, pd++, i++;
-    if (*ps == 0 && *pd != 0) {
+  while (s)
+  {
+    const char *ps=s;
+    const char *pd=name.data();
+    int i=0;
+    while (*ps!=0 && *pd!=0 && *ps==*pd) ps++,pd++,i++;
+    if (*ps==0 && *pd!=0)
+    {
       return i;
     }
     s = sl.next();
@@ -5058,65 +5264,73 @@ int getPrefixIndex(const QCString &name) {
 
 //----------------------------------------------------------------------------
 
-static void initBaseClassHierarchy(BaseClassList *bcl) {
-  if (bcl == 0)
-    return;
+static void initBaseClassHierarchy(BaseClassList *bcl)
+{
+  if (bcl==0) return;
   BaseClassListIterator bcli(*bcl);
-  for (; bcli.current(); ++bcli) {
-    ClassDef *cd = bcli.current()->classDef;
-    if (cd->baseClasses() == 0) // no base classes => new root
+  for ( ; bcli.current(); ++bcli)
+  {
+    ClassDef *cd=bcli.current()->classDef;
+    if (cd->baseClasses()==0) // no base classes => new root
     {
       initBaseClassHierarchy(cd->baseClasses());
     }
-    cd->visited = FALSE;
+    cd->visited=FALSE;
   }
 }
 //----------------------------------------------------------------------------
 
-bool classHasVisibleChildren(ClassDef *cd) {
+bool classHasVisibleChildren(ClassDef *cd)
+{
   BaseClassList *bcl;
 
-  if (cd->getLanguage() ==
-      SrcLangExt_VHDL) // reverse baseClass/subClass relation
+  if (cd->getLanguage()==SrcLangExt_VHDL) // reverse baseClass/subClass relation
   {
-    if (cd->baseClasses() == 0)
-      return FALSE;
-    bcl = cd->baseClasses();
-  } else {
-    if (cd->subClasses() == 0)
-      return FALSE;
-    bcl = cd->subClasses();
+    if (cd->baseClasses()==0) return FALSE;
+    bcl=cd->baseClasses();
+  }
+  else 
+  {
+    if (cd->subClasses()==0) return FALSE;
+    bcl=cd->subClasses();
   }
 
   BaseClassListIterator bcli(*bcl);
-  for (; bcli.current(); ++bcli) {
-    if (bcli.current()->classDef->isVisibleInHierarchy()) {
+  for ( ; bcli.current() ; ++bcli)
+  {
+    if (bcli.current()->classDef->isVisibleInHierarchy())
+    {
       return TRUE;
     }
   }
   return FALSE;
 }
 
+
 //----------------------------------------------------------------------------
 
-void initClassHierarchy(ClassSDict *cl) {
+void initClassHierarchy(ClassSDict *cl)
+{
   ClassSDict::Iterator cli(*cl);
   ClassDef *cd;
-  for (; (cd = cli.current()); ++cli) {
-    cd->visited = FALSE;
+  for ( ; (cd=cli.current()); ++cli)
+  {
+    cd->visited=FALSE;
     initBaseClassHierarchy(cd->baseClasses());
   }
 }
 
 //----------------------------------------------------------------------------
 
-bool hasVisibleRoot(BaseClassList *bcl) {
-  if (bcl) {
+bool hasVisibleRoot(BaseClassList *bcl)
+{
+  if (bcl)
+  {
     BaseClassListIterator bcli(*bcl);
-    for (; bcli.current(); ++bcli) {
-      ClassDef *cd = bcli.current()->classDef;
-      if (cd->isVisibleInHierarchy())
-        return TRUE;
+    for ( ; bcli.current(); ++bcli)
+    {
+      ClassDef *cd=bcli.current()->classDef;
+      if (cd->isVisibleInHierarchy()) return TRUE;
       hasVisibleRoot(cd->baseClasses());
     }
   }
@@ -5126,151 +5340,108 @@ bool hasVisibleRoot(BaseClassList *bcl) {
 //----------------------------------------------------------------------
 
 // note that this function is not reentrant due to the use of static growBuf!
-QCString escapeCharsInString(const char *name, bool allowDots,
-                             bool allowUnderscore) {
+QCString escapeCharsInString(const char *name,bool allowDots,bool allowUnderscore)
+{
   static bool caseSenseNames = Config_getBool(CASE_SENSE_NAMES);
   static bool allowUnicodeNames = Config_getBool(ALLOW_UNICODE_NAMES);
   static GrowBuf growBuf;
   growBuf.clear();
   char c;
-  const char *p = name;
-  while ((c = *p++) != 0) {
-    switch (c) {
-    case '_':
-      if (allowUnderscore)
-        growBuf.addChar('_');
-      else
-        growBuf.addStr("__");
-      break;
-    case '-':
-      growBuf.addChar('-');
-      break;
-    case ':':
-      growBuf.addStr("_1");
-      break;
-    case '/':
-      growBuf.addStr("_2");
-      break;
-    case '<':
-      growBuf.addStr("_3");
-      break;
-    case '>':
-      growBuf.addStr("_4");
-      break;
-    case '*':
-      growBuf.addStr("_5");
-      break;
-    case '&':
-      growBuf.addStr("_6");
-      break;
-    case '|':
-      growBuf.addStr("_7");
-      break;
-    case '.':
-      if (allowDots)
-        growBuf.addChar('.');
-      else
-        growBuf.addStr("_8");
-      break;
-    case '!':
-      growBuf.addStr("_9");
-      break;
-    case ',':
-      growBuf.addStr("_00");
-      break;
-    case ' ':
-      growBuf.addStr("_01");
-      break;
-    case '{':
-      growBuf.addStr("_02");
-      break;
-    case '}':
-      growBuf.addStr("_03");
-      break;
-    case '?':
-      growBuf.addStr("_04");
-      break;
-    case '^':
-      growBuf.addStr("_05");
-      break;
-    case '%':
-      growBuf.addStr("_06");
-      break;
-    case '(':
-      growBuf.addStr("_07");
-      break;
-    case ')':
-      growBuf.addStr("_08");
-      break;
-    case '+':
-      growBuf.addStr("_09");
-      break;
-    case '=':
-      growBuf.addStr("_0A");
-      break;
-    case '$':
-      growBuf.addStr("_0B");
-      break;
-    case '\\':
-      growBuf.addStr("_0C");
-      break;
-    case '@':
-      growBuf.addStr("_0D");
-      break;
-
-    default:
-      if (c < 0) {
-        char ids[5];
-        const unsigned char uc = (unsigned char)c;
-        bool doEscape = TRUE;
-        if (allowUnicodeNames && uc <= 0xf7) {
-          const char *pt = p;
-          ids[0] = c;
-          int l = 0;
-          if ((uc & 0xE0) == 0xC0) {
-            l = 2; // 11xx.xxxx: >=2 byte character
-          }
-          if ((uc & 0xF0) == 0xE0) {
-            l = 3; // 111x.xxxx: >=3 byte character
-          }
-          if ((uc & 0xF8) == 0xF0) {
-            l = 4; // 1111.xxxx: >=4 byte character
-          }
-          doEscape = l == 0;
-          for (int m = 1; m < l && !doEscape; ++m) {
-            unsigned char ct = (unsigned char)*pt;
-            if (ct == 0 || (ct & 0xC0) != 0x80) // invalid unicode character
-            {
-              doEscape = TRUE;
-            } else {
-              ids[m] = *pt++;
-            }
-          }
-          if (!doEscape) // got a valid unicode character
-          {
-            ids[l] = 0;
-            growBuf.addStr(ids);
-            p += l - 1;
-          }
-        }
-        if (doEscape) // not a valid unicode char or escaping needed
-        {
-          static char map[] = "0123456789ABCDEF";
-          unsigned char id = (unsigned char)c;
-          ids[0] = '_';
-          ids[1] = 'x';
-          ids[2] = map[id >> 4];
-          ids[3] = map[id & 0xF];
-          ids[4] = 0;
-          growBuf.addStr(ids);
-        }
-      } else if (caseSenseNames || !isupper(c)) {
-        growBuf.addChar(c);
-      } else {
-        growBuf.addChar('_');
-        growBuf.addChar(tolower(c));
-      }
-      break;
+  const char *p=name;
+  while ((c=*p++)!=0)
+  {
+    switch(c)
+    {
+      case '_': if (allowUnderscore) growBuf.addChar('_'); else growBuf.addStr("__"); break;
+      case '-': growBuf.addChar('-');  break;
+      case ':': growBuf.addStr("_1"); break;
+      case '/': growBuf.addStr("_2"); break;
+      case '<': growBuf.addStr("_3"); break;
+      case '>': growBuf.addStr("_4"); break;
+      case '*': growBuf.addStr("_5"); break;
+      case '&': growBuf.addStr("_6"); break;
+      case '|': growBuf.addStr("_7"); break;
+      case '.': if (allowDots) growBuf.addChar('.'); else growBuf.addStr("_8"); break;
+      case '!': growBuf.addStr("_9"); break;
+      case ',': growBuf.addStr("_00"); break;
+      case ' ': growBuf.addStr("_01"); break;
+      case '{': growBuf.addStr("_02"); break;
+      case '}': growBuf.addStr("_03"); break;
+      case '?': growBuf.addStr("_04"); break;
+      case '^': growBuf.addStr("_05"); break;
+      case '%': growBuf.addStr("_06"); break;
+      case '(': growBuf.addStr("_07"); break;
+      case ')': growBuf.addStr("_08"); break;
+      case '+': growBuf.addStr("_09"); break;
+      case '=': growBuf.addStr("_0A"); break;
+      case '$': growBuf.addStr("_0B"); break;
+      case '\\': growBuf.addStr("_0C"); break;
+      case '@': growBuf.addStr("_0D"); break;
+      default: 
+                if (c<0)
+                {
+                  char ids[5];
+                  const unsigned char uc = (unsigned char)c;
+                  bool doEscape = TRUE;
+                  if (allowUnicodeNames && uc <= 0xf7)
+                  {
+                    const char* pt = p;
+                    ids[ 0 ] = c;
+                    int l = 0;
+                    if ((uc&0xE0)==0xC0)
+                    {
+                      l=2; // 11xx.xxxx: >=2 byte character
+                    }
+                    if ((uc&0xF0)==0xE0)
+                    {
+                      l=3; // 111x.xxxx: >=3 byte character
+                    }
+                    if ((uc&0xF8)==0xF0)
+                    {
+                      l=4; // 1111.xxxx: >=4 byte character
+                    }
+                    doEscape = l==0;
+                    for (int m=1; m<l && !doEscape; ++m)
+                    {
+                      unsigned char ct = (unsigned char)*pt;
+                      if (ct==0 || (ct&0xC0)!=0x80) // invalid unicode character
+                      {
+                        doEscape=TRUE;
+                      }
+                      else
+                      {
+                        ids[ m ] = *pt++;
+                      }
+                    }
+                    if ( !doEscape ) // got a valid unicode character
+                    {
+                      ids[ l ] = 0;
+                      growBuf.addStr( ids );
+                      p += l - 1;
+                    }
+                  }
+                  if (doEscape) // not a valid unicode char or escaping needed
+                  {
+                    static char map[] = "0123456789ABCDEF";
+                    unsigned char id = (unsigned char)c;
+                    ids[0]='_';
+                    ids[1]='x';
+                    ids[2]=map[id>>4];
+                    ids[3]=map[id&0xF];
+                    ids[4]=0;
+                    growBuf.addStr(ids);
+                  }
+                }
+                else if (caseSenseNames || !isupper(c))
+                {
+                  growBuf.addChar(c);
+                }
+                else
+                {
+                  growBuf.addChar('_');
+                  growBuf.addChar(tolower(c)); 
+                }
+                break;
     }
   }
   growBuf.addChar(0);
@@ -5278,13 +5449,12 @@ QCString escapeCharsInString(const char *name, bool allowDots,
 }
 
 /*! This function determines the file name on disk of an item
- *  given its name, which could be a class name with template
+ *  given its name, which could be a class name with template 
  *  arguments, so special characters need to be escaped.
  */
-QCString convertNameToFile(const char *name, bool allowDots,
-                           bool allowUnderscore) {
-  if (name == 0 || name[0] == '\0')
-    return "";
+QCString convertNameToFile(const char *name,bool allowDots,bool allowUnderscore)
+{
+  if (name==0 || name[0]=='\0') return "";
   static bool shortNames = Config_getBool(SHORT_NAMES);
   static bool createSubdirs = Config_getBool(CREATE_SUBDIRS);
   QCString result;
@@ -5292,96 +5462,113 @@ QCString convertNameToFile(const char *name, bool allowDots,
   {
     static QDict<int> usedNames(10007);
     usedNames.setAutoDelete(TRUE);
-    static int count = 1;
+    static int count=1;
 
-    int *value = usedNames.find(name);
+    int *value=usedNames.find(name);
     int num;
-    if (value == 0) {
-      usedNames.insert(name, new int(count));
+    if (value==0)
+    {
+      usedNames.insert(name,new int(count));
       num = count++;
-    } else {
+    }
+    else
+    {
       num = *value;
     }
-    result.sprintf("a%05d", num);
-  } else // long names
+    result.sprintf("a%05d",num); 
+  }
+  else // long names
   {
-    result = escapeCharsInString(name, allowDots, allowUnderscore);
+    result=escapeCharsInString(name,allowDots,allowUnderscore);
     int resultLen = result.length();
-    if (resultLen >= 128) // prevent names that cannot be created!
+    if (resultLen>=128) // prevent names that cannot be created!
     {
       // third algorithm based on MD5 hash
       uchar md5_sig[16];
       QCString sigStr(33);
-      MD5Buffer((const unsigned char *)result.data(), resultLen, md5_sig);
-      MD5SigToString(md5_sig, sigStr.rawData(), 33);
-      result = result.left(128 - 32) + sigStr;
+      MD5Buffer((const unsigned char *)result.data(),resultLen,md5_sig);
+      MD5SigToString(md5_sig,sigStr.rawData(),33);
+      result=result.left(128-32)+sigStr; 
     }
   }
-  if (createSubdirs) {
-    int l1Dir = 0, l2Dir = 0;
+  if (createSubdirs)
+  {
+    int l1Dir=0,l2Dir=0;
 
-#if MAP_ALGO == ALGO_COUNT
+#if MAP_ALGO==ALGO_COUNT 
     // old algorithm, has the problem that after regeneration the
     // output can be located in a different dir.
-    if (Doxygen::htmlDirMap == 0) {
-      Doxygen::htmlDirMap = new QDict<int>(100003);
+    if (Doxygen::htmlDirMap==0) 
+    {
+      Doxygen::htmlDirMap=new QDict<int>(100003);
       Doxygen::htmlDirMap->setAutoDelete(TRUE);
     }
-    static int curDirNum = 0;
+    static int curDirNum=0;
     int *dirNum = Doxygen::htmlDirMap->find(result);
-    if (dirNum == 0) // new name
+    if (dirNum==0) // new name
     {
-      Doxygen::htmlDirMap->insert(result, new int(curDirNum));
-      l1Dir = (curDirNum)&0xf;         // bits 0-3
-      l2Dir = (curDirNum >> 4) & 0xff; // bits 4-11
+      Doxygen::htmlDirMap->insert(result,new int(curDirNum)); 
+      l1Dir = (curDirNum)&0xf;    // bits 0-3
+      l2Dir = (curDirNum>>4)&0xff; // bits 4-11
       curDirNum++;
-    } else // existing name
+    }
+    else // existing name
     {
-      l1Dir = (*dirNum) & 0xf;         // bits 0-3
-      l2Dir = ((*dirNum) >> 4) & 0xff; // bits 4-11
+      l1Dir = (*dirNum)&0xf;       // bits 0-3
+      l2Dir = ((*dirNum)>>4)&0xff; // bits 4-11
     }
-#elif MAP_ALGO == ALGO_CRC16
+#elif MAP_ALGO==ALGO_CRC16
     // second algorithm based on CRC-16 checksum
-    int dirNum = qChecksum(result, result.length());
-    l1Dir = dirNum & 0xf;
-    l2Dir = (dirNum >> 4) & 0xff;
-#elif MAP_ALGO == ALGO_MD5
+    int dirNum = qChecksum(result,result.length());
+    l1Dir = dirNum&0xf;
+    l2Dir = (dirNum>>4)&0xff;
+#elif MAP_ALGO==ALGO_MD5
     // third algorithm based on MD5 hash
     uchar md5_sig[16];
-    MD5Buffer((const unsigned char *)result.data(), result.length(), md5_sig);
-    l1Dir = md5_sig[14] & 0xf;
+    MD5Buffer((const unsigned char *)result.data(),result.length(),md5_sig);
+    l1Dir = md5_sig[14]&0xf;
     l2Dir = md5_sig[15];
 #endif
-    result.prepend(QCString().sprintf("d%x/d%02x/", l1Dir, l2Dir));
+    result.prepend(QCString().sprintf("d%x/d%02x/",l1Dir,l2Dir));
   }
-  // printf("*** convertNameToFile(%s)->%s\n",name,result.data());
+  //printf("*** convertNameToFile(%s)->%s\n",name,result.data());
   return result;
 }
 
-QCString relativePathToRoot(const char *name) {
+QCString relativePathToRoot(const char *name)
+{
   QCString result;
-  if (Config_getBool(CREATE_SUBDIRS)) {
-    if (name == 0) {
+  if (Config_getBool(CREATE_SUBDIRS))
+  {
+    if (name==0)
+    {
       return REL_PATH_TO_ROOT;
-    } else {
+    }
+    else
+    {
       QCString n = name;
       int i = n.findRev('/');
-      if (i != -1) {
-        result = REL_PATH_TO_ROOT;
+      if (i!=-1)
+      {
+        result=REL_PATH_TO_ROOT;
       }
     }
   }
   return result;
 }
 
-void createSubDirs(QDir &d) {
-  if (Config_getBool(CREATE_SUBDIRS)) {
+void createSubDirs(QDir &d)
+{
+  if (Config_getBool(CREATE_SUBDIRS))
+  {
     // create 4096 subdirectories
-    int l1, l2;
-    for (l1 = 0; l1 < 16; l1++) {
-      d.mkdir(QCString().sprintf("d%x", l1));
-      for (l2 = 0; l2 < 256; l2++) {
-        d.mkdir(QCString().sprintf("d%x/d%02x", l1, l2));
+    int l1,l2;
+    for (l1=0;l1<16;l1++)
+    {
+      d.mkdir(QCString().sprintf("d%x",l1));
+      for (l2=0;l2<256;l2++)
+      {
+        d.mkdir(QCString().sprintf("d%x/d%02x",l1,l2));
       }
     }
   }
@@ -5390,74 +5577,80 @@ void createSubDirs(QDir &d) {
 /*! Input is a scopeName, output is the scopename split into a
  *  namespace part (as large as possible) and a classname part.
  */
-void extractNamespaceName(const QCString &scopeName, QCString &className,
-                          QCString &namespaceName, bool allowEmptyClass) {
-  int i, p;
-  QCString clName = scopeName;
+void extractNamespaceName(const QCString &scopeName,
+    QCString &className,QCString &namespaceName,
+    bool allowEmptyClass)
+{
+  int i,p;
+  QCString clName=scopeName;
   NamespaceDef *nd = 0;
-  if (!clName.isEmpty() && (nd = getResolvedNamespace(clName)) &&
-      getClass(clName) ==
-          0) { // the whole name is a namespace (and not a class)
-    namespaceName = nd->name().copy();
+  if (!clName.isEmpty() && (nd=getResolvedNamespace(clName)) && getClass(clName)==0)
+  { // the whole name is a namespace (and not a class)
+    namespaceName=nd->name().copy();
     className.resize(0);
     goto done;
   }
-  p = clName.length() - 2;
-  while (p >= 0 && (i = clName.findRev("::", p)) != -1)
-  // see if the first part is a namespace (and not a class)
+  p=clName.length()-2;
+  while (p>=0 && (i=clName.findRev("::",p))!=-1) 
+    // see if the first part is a namespace (and not a class)
   {
-    // printf("Trying %s\n",clName.left(i).data());
-    if (i > 0 && (nd = getResolvedNamespace(clName.left(i))) &&
-        getClass(clName.left(i)) == 0) {
-      // printf("found!\n");
-      namespaceName = nd->name().copy();
-      className = clName.right(clName.length() - i - 2);
+    //printf("Trying %s\n",clName.left(i).data());
+    if (i>0 && (nd=getResolvedNamespace(clName.left(i))) && getClass(clName.left(i))==0)
+    {
+      //printf("found!\n");
+      namespaceName=nd->name().copy();
+      className=clName.right(clName.length()-i-2);
       goto done;
-    }
-    p = i - 2; // try a smaller piece of the scope
+    } 
+    p=i-2; // try a smaller piece of the scope
   }
-  // printf("not found!\n");
+  //printf("not found!\n");
 
   // not found, so we just have to guess.
-  className = scopeName.copy();
+  className=scopeName.copy();
   namespaceName.resize(0);
 
 done:
-  if (className.isEmpty() && !namespaceName.isEmpty() && !allowEmptyClass) {
+  if (className.isEmpty() && !namespaceName.isEmpty() && !allowEmptyClass)
+  {
     // class and namespace with the same name, correct to return the class.
-    className = namespaceName.copy();
+    className=namespaceName.copy();
     namespaceName.resize(0);
   }
-  // printf("extractNamespace `%s' => `%s|%s'\n",scopeName.data(),
+  //printf("extractNamespace `%s' => `%s|%s'\n",scopeName.data(),
   //       className.data(),namespaceName.data());
-  if (/*className.right(2)=="-g" ||*/ className.right(2) == "-p") {
-    className = className.left(className.length() - 2);
+  if (/*className.right(2)=="-g" ||*/ className.right(2)=="-p")
+  {
+    className = className.left(className.length()-2);
   }
   return;
 }
 
-QCString insertTemplateSpecifierInScope(const QCString &scope,
-                                        const QCString &templ) {
-  QCString result = scope.copy();
-  if (!templ.isEmpty() && scope.find('<') == -1) {
-    int si, pi = 0;
-    ClassDef *cd = 0;
-    while ((si = scope.find("::", pi)) != -1 &&
-           !getClass(scope.left(si) + templ) &&
-           ((cd = getClass(scope.left(si))) == 0 ||
-            cd->templateArguments() == 0)) {
-      // printf("Tried `%s'\n",(scope.left(si)+templ).data());
-      pi = si + 2;
-    }
-    if (si == -1) // not nested => append template specifier
+QCString insertTemplateSpecifierInScope(const QCString &scope,const QCString &templ)
+{
+  QCString result=scope.copy();
+  if (!templ.isEmpty() && scope.find('<')==-1)
+  {
+    int si,pi=0;
+    ClassDef *cd=0;
+    while (
+        (si=scope.find("::",pi))!=-1 && !getClass(scope.left(si)+templ) && 
+        ((cd=getClass(scope.left(si)))==0 || cd->templateArguments()==0) 
+        ) 
+    { 
+      //printf("Tried `%s'\n",(scope.left(si)+templ).data()); 
+      pi=si+2; 
+    }
+    if (si==-1) // not nested => append template specifier
     {
-      result += templ;
-    } else // nested => insert template specifier before after first class name
+      result+=templ; 
+    }
+    else // nested => insert template specifier before after first class name
     {
-      result = scope.left(si) + templ + scope.right(scope.length() - si);
+      result=scope.left(si) + templ + scope.right(scope.length()-si);
     }
   }
-  // printf("insertTemplateSpecifierInScope(`%s',`%s')=%s\n",
+  //printf("insertTemplateSpecifierInScope(`%s',`%s')=%s\n",
   //    scope.data(),templ.data(),result.data());
   return result;
 }
@@ -5479,7 +5672,7 @@ QCString stripScope(const char *name)
     char c=result.at(p);
     switch (c)
     {
-      case ':':
+      case ':': 
         //printf("stripScope(%s)=%s\n",name,result.right(l-p-1).data());
         return result.right(l-p-1);
       case '>':
@@ -5494,7 +5687,7 @@ QCString stripScope(const char *name)
           {
             case '>': count++; break;
             case '<': count--; if (count<=0) done=TRUE; break;
-            default:
+            default: 
                       //printf("c=%c count=%d\n",c,count);
                       break;
           }
@@ -5511,168 +5704,140 @@ QCString stripScope(const char *name)
 #endif
 
 // new version by Davide Cesari which also works for Fortran
-QCString stripScope(const char *name) {
+QCString stripScope(const char *name)
+{
   QCString result = name;
-  int l = result.length();
+  int l=result.length();
   int p;
   bool done = FALSE;
-  bool skipBracket =
-      FALSE; // if brackets do not match properly, ignore them altogether
-  int count = 0;
-
-  do {
-    p = l - 1; // start at the end of the string
-    while (p >= 0 && count >= 0) {
-      char c = result.at(p);
-      switch (c) {
-      case ':':
-        // only exit in the case of ::
-        // printf("stripScope(%s)=%s\n",name,result.right(l-p-1).data());
-        if (p > 0 && result.at(p - 1) == ':')
-          return result.right(l - p - 1);
-        p--;
-        break;
-      case '>':
-        if (skipBracket) // we don't care about brackets
-        {
+  bool skipBracket=FALSE; // if brackets do not match properly, ignore them altogether
+  int count=0;
+
+  do
+  {
+    p=l-1; // start at the end of the string
+    while (p>=0 && count>=0)
+    {
+      char c=result.at(p);
+      switch (c)
+      {
+        case ':': 
+          // only exit in the case of ::
+          //printf("stripScope(%s)=%s\n",name,result.right(l-p-1).data());
+          if (p>0 && result.at(p-1)==':') return result.right(l-p-1);
           p--;
-        } else // count open/close brackets
-        {
-          if (p > 0 && result.at(p - 1) == '>') // skip >> operator
+          break;
+        case '>':
+          if (skipBracket) // we don't care about brackets
           {
-            p -= 2;
-            break;
+            p--;
           }
-          count = 1;
-          // printf("pos < = %d\n",p);
-          p--;
-          bool foundMatch = false;
-          while (p >= 0 && !foundMatch) {
-            c = result.at(p--);
-            switch (c) {
-            case '>':
-              count++;
+          else // count open/close brackets
+          {
+            if (p>0 && result.at(p-1)=='>') // skip >> operator
+            {
+              p-=2;
               break;
-            case '<':
-              if (p > 0) {
-                if (result.at(p - 1) == '<') // skip << operator
-                {
-                  p--;
+            }
+            count=1;
+            //printf("pos < = %d\n",p);
+            p--;
+            bool foundMatch=false;
+            while (p>=0 && !foundMatch)
+            {
+              c=result.at(p--);
+              switch (c)
+              {
+                case '>': 
+                  count++; 
+                  break;
+                case '<': 
+                  if (p>0)
+                  {
+                    if (result.at(p-1) == '<') // skip << operator
+                    {
+                      p--;
+                      break;
+                    }
+                  }
+                  count--; 
+                  foundMatch = count==0;
+                  break;
+                default: 
+                  //printf("c=%c count=%d\n",c,count);
                   break;
-                }
               }
-              count--;
-              foundMatch = count == 0;
-              break;
-            default:
-              // printf("c=%c count=%d\n",c,count);
-              break;
             }
           }
-        }
-        // printf("pos > = %d\n",p+1);
-        break;
-      default:
-        p--;
+          //printf("pos > = %d\n",p+1);
+          break;
+        default:
+          p--;
       }
     }
-    done = count == 0 || skipBracket; // reparse if brackets do not match
-    skipBracket = TRUE;
-  } while (!done); // if < > unbalanced repeat ignoring them
-  // printf("stripScope(%s)=%s\n",name,name);
+    done = count==0 || skipBracket; // reparse if brackets do not match
+    skipBracket=TRUE;
+  }
+  while (!done); // if < > unbalanced repeat ignoring them
+  //printf("stripScope(%s)=%s\n",name,name);
   return name;
 }
 
 /*! Converts a string to a HTML id string */
-QCString convertToId(const char *s) {
+QCString convertToId(const char *s)
+{
   static const char hex[] = "0123456789ABCDEF";
   static GrowBuf growBuf;
   growBuf.clear();
-  if (s == 0)
-    return "";
-  const char *p = s;
+  if (s==0) return "";
+  const char *p=s;
   char c;
-  bool first = TRUE;
-  while ((c = *p++)) {
+  bool first=TRUE;
+  while ((c=*p++))
+  {
     char encChar[4];
-    if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') ||
-        (c >= 'A' && c <= 'Z') || c == '-' || c == ':' ||
-        c == '.') { // any permissive character except _
-      if (first && c >= '0' && c <= '9')
-        growBuf.addChar('a'); // don't start with a digit
+    if ((c>='0' && c<='9') || (c>='a' && c<='z') || (c>='A' && c<='Z') || c=='-' || c==':' || c=='.')
+    { // any permissive character except _
+      if (first && c>='0' && c<='9') growBuf.addChar('a'); // don't start with a digit
       growBuf.addChar(c);
-    } else {
-      encChar[0] = '_';
-      encChar[1] = hex[((unsigned char)c) >> 4];
-      encChar[2] = hex[((unsigned char)c) & 0xF];
-      encChar[3] = 0;
+    }
+    else
+    {
+      encChar[0]='_';
+      encChar[1]=hex[((unsigned char)c)>>4];
+      encChar[2]=hex[((unsigned char)c)&0xF];
+      encChar[3]=0;
       growBuf.addStr(encChar);
     }
-    first = FALSE;
+    first=FALSE;
   }
   growBuf.addChar(0);
   return growBuf.get();
 }
 
 /*! Converts a string to an XML-encoded string */
-QCString convertToXML(const char *s) {
+QCString convertToXML(const char *s)
+{
   static GrowBuf growBuf;
   growBuf.clear();
-  if (s == 0)
-    return "";
-  const char *p = s;
+  if (s==0) return "";
+  const char *p=s;
   char c;
-  while ((c = *p++)) {
-    switch (c) {
-    case '<':
-      growBuf.addStr("&lt;");
-      break;
-    case '>':
-      growBuf.addStr("&gt;");
-      break;
-    case '&':
-      growBuf.addStr("&amp;");
-      break;
-    case '\'':
-      growBuf.addStr("&apos;");
-      break;
-    case '"':
-      growBuf.addStr("&quot;");
-      break;
-    case 1:
-    case 2:
-    case 3:
-    case 4:
-    case 5:
-    case 6:
-    case 7:
-    case 8:
-    case 11:
-    case 12:
-    case 13:
-    case 14:
-    case 15:
-    case 16:
-    case 17:
-    case 18:
-    case 19:
-    case 20:
-    case 21:
-    case 22:
-    case 23:
-    case 24:
-    case 25:
-    case 26:
-    case 27:
-    case 28:
-    case 29:
-    case 30:
-    case 31:
-      break; // skip invalid XML characters (see
-             // http://www.w3.org/TR/2000/REC-xml-20001006#NT-Char)
-    default:
-      growBuf.addChar(c);
-      break;
+  while ((c=*p++))
+  {
+    switch (c)
+    {
+      case '<':  growBuf.addStr("&lt;");   break;
+      case '>':  growBuf.addStr("&gt;");   break;
+      case '&':  growBuf.addStr("&amp;");  break;
+      case '\'': growBuf.addStr("&apos;"); break; 
+      case '"':  growBuf.addStr("&quot;"); break;
+      case  1: case  2: case  3: case  4: case  5: case  6: case  7: case  8:
+      case 11: case 12: case 13: case 14: case 15: case 16: case 17: case 18:
+      case 19: case 20: case 21: case 22: case 23: case 24: case 25: case 26:
+      case 27: case 28: case 29: case 30: case 31:
+        break; // skip invalid XML characters (see http://www.w3.org/TR/2000/REC-xml-20001006#NT-Char)
+      default:   growBuf.addChar(c);       break;
     }
   }
   growBuf.addChar(0);
@@ -5680,123 +5845,121 @@ QCString convertToXML(const char *s) {
 }
 
 /*! Converts a string to a HTML-encoded string */
-QCString convertToHtml(const char *s, bool keepEntities) {
+QCString convertToHtml(const char *s,bool keepEntities)
+{
   static GrowBuf growBuf;
   growBuf.clear();
-  if (s == 0)
-    return "";
-  const char *p = s;
+  if (s==0) return "";
+  const char *p=s;
   char c;
-  while ((c = *p++)) {
-    switch (c) {
-    case '<':
-      growBuf.addStr("&lt;");
-      break;
-    case '>':
-      growBuf.addStr("&gt;");
-      break;
-    case '&':
-      if (keepEntities) {
-        const char *e = p;
-        char ce;
-        while ((ce = *e++)) {
-          if (ce == ';' || (!(isId(ce) || ce == '#')))
-            break;
-        }
-        if (ce == ';') // found end of an entity
-        {
-          // copy entry verbatim
-          growBuf.addChar(c);
-          while (p < e)
-            growBuf.addChar(*p++);
-        } else {
-          growBuf.addStr("&amp;");
-        }
-      } else {
-        growBuf.addStr("&amp;");
-      }
-      break;
-    case '\'':
-      growBuf.addStr("&#39;");
-      break;
-    case '"':
-      growBuf.addStr("&quot;");
-      break;
-    default:
-      growBuf.addChar(c);
-      break;
+  while ((c=*p++))
+  {
+    switch (c)
+    {
+      case '<':  growBuf.addStr("&lt;");   break;
+      case '>':  growBuf.addStr("&gt;");   break;
+      case '&':  if (keepEntities)
+                 {
+                   const char *e=p;
+                   char ce;
+                   while ((ce=*e++))
+                   {
+                     if (ce==';' || (!(isId(ce) || ce=='#'))) break;
+                   }
+                   if (ce==';') // found end of an entity
+                   {
+                     // copy entry verbatim
+                     growBuf.addChar(c);
+                     while (p<e) growBuf.addChar(*p++);
+                   }
+                   else
+                   {
+                     growBuf.addStr("&amp;");
+                   }
+                 }
+                 else
+                 {
+                   growBuf.addStr("&amp;");  
+                 }
+                 break;
+      case '\'': growBuf.addStr("&#39;");  break; 
+      case '"':  growBuf.addStr("&quot;"); break;
+      default:   growBuf.addChar(c);       break;
     }
   }
   growBuf.addChar(0);
   return growBuf.get();
 }
 
-QCString convertToJSString(const char *s) {
+QCString convertToJSString(const char *s)
+{
   static GrowBuf growBuf;
   growBuf.clear();
-  if (s == 0)
-    return "";
-  const char *p = s;
+  if (s==0) return "";
+  const char *p=s;
   char c;
-  while ((c = *p++)) {
-    switch (c) {
-    case '"':
-      growBuf.addStr("\\\"");
-      break;
-    case '\\':
-      growBuf.addStr("\\\\");
-      break;
-    default:
-      growBuf.addChar(c);
-      break;
+  while ((c=*p++))
+  {
+    switch (c)
+    {
+      case '"':  growBuf.addStr("\\\""); break;
+      case '\\': growBuf.addStr("\\\\"); break;
+      default:   growBuf.addChar(c);   break;
     }
   }
   growBuf.addChar(0);
   return convertCharEntitiesToUTF8(growBuf.get());
 }
 
-QCString convertToLaTeX(const QCString &s, bool insideTabbing,
-                        bool keepSpaces) {
+QCString convertToLaTeX(const QCString &s,bool insideTabbing,bool keepSpaces)
+{
   QGString result;
   FTextStream t(&result);
-  filterLatexString(t, s, insideTabbing, FALSE, FALSE, keepSpaces);
+  filterLatexString(t,s,insideTabbing,FALSE,FALSE,keepSpaces);
   return result.data();
 }
 
-QCString convertCharEntitiesToUTF8(const QCString &s) {
+
+
+QCString convertCharEntitiesToUTF8(const QCString &s)
+{
   QCString result;
   static QRegExp entityPat("&[a-zA-Z]+[0-9]*;");
 
-  if (s.length() == 0)
-    return result;
+  if (s.length()==0) return result;
   static GrowBuf growBuf;
   growBuf.clear();
-  int p, i = 0, l;
-  while ((p = entityPat.match(s, i, &l)) != -1) {
-    if (p > i) {
-      growBuf.addStr(s.mid(i, p - i));
+  int p,i=0,l;
+  while ((p=entityPat.match(s,i,&l))!=-1)
+  {
+    if (p>i)
+    {
+      growBuf.addStr(s.mid(i,p-i));
     }
-    QCString entity = s.mid(p, l);
+    QCString entity = s.mid(p,l);
     DocSymbol::SymType symType = HtmlEntityMapper::instance()->name2sym(entity);
-    const char *code = 0;
-    if (symType != DocSymbol::Sym_Unknown &&
-        (code = HtmlEntityMapper::instance()->utf8(symType))) {
+    const char *code=0;
+    if (symType!=DocSymbol::Sym_Unknown && (code=HtmlEntityMapper::instance()->utf8(symType)))
+    {
       growBuf.addStr(code);
-    } else {
-      growBuf.addStr(s.mid(p, l));
     }
-    i = p + l;
+    else
+    {
+      growBuf.addStr(s.mid(p,l));
+    }
+    i=p+l;
   }
-  growBuf.addStr(s.mid(i, s.length() - i));
+  growBuf.addStr(s.mid(i,s.length()-i));
   growBuf.addChar(0);
-  // printf("convertCharEntitiesToUTF8(%s)->%s\n",s.data(),growBuf.get());
+  //printf("convertCharEntitiesToUTF8(%s)->%s\n",s.data(),growBuf.get());
   return growBuf.get();
 }
 
 /*! Returns the standard string that is generated when the \\overload
  * command is used.
  */
-QCString getOverloadDocs() {
+QCString getOverloadDocs()
+{
   return theTranslator->trOverloadText();
   //"This is an overloaded member function, "
   //       "provided for convenience. It differs from the above "
@@ -5804,38 +5967,51 @@ QCString getOverloadDocs() {
 }
 
 void addMembersToMemberGroup(MemberList *ml,
-                             MemberGroupSDict **ppMemberGroupSDict,
-                             Definition *context) {
-  ASSERT(context != 0);
-  // printf("addMemberToMemberGroup()\n");
-  if (ml == 0)
-    return;
+    MemberGroupSDict **ppMemberGroupSDict,
+    Definition *context)
+{
+  ASSERT(context!=0);
+  //printf("addMemberToMemberGroup()\n");
+  if (ml==0) return;
   MemberListIterator mli(*ml);
   MemberDef *md;
   uint index;
-  for (index = 0; (md = mli.current());) {
+  for (index=0;(md=mli.current());)
+  {
     if (md->isEnumerate()) // insert enum value of this enum into groups
     {
-      MemberList *fmdl = md->enumFieldList();
-      if (fmdl != 0) {
+      MemberList *fmdl=md->enumFieldList();
+      if (fmdl!=0)
+      {
         MemberListIterator fmli(*fmdl);
         MemberDef *fmd;
-        for (fmli.toFirst(); (fmd = fmli.current()); ++fmli) {
-          int groupId = fmd->getMemberGroupId();
-          if (groupId != -1) {
+        for (fmli.toFirst();(fmd=fmli.current());++fmli)
+        {
+          int groupId=fmd->getMemberGroupId();
+          if (groupId!=-1)
+          {
             MemberGroupInfo *info = Doxygen::memGrpInfoDict[groupId];
-            // QCString *pGrpHeader = Doxygen::memberHeaderDict[groupId];
-            // QCString *pDocs      = Doxygen::memberDocDict[groupId];
-            if (info) {
-              if (*ppMemberGroupSDict == 0) {
+            //QCString *pGrpHeader = Doxygen::memberHeaderDict[groupId];
+            //QCString *pDocs      = Doxygen::memberDocDict[groupId];
+            if (info)
+            {
+              if (*ppMemberGroupSDict==0)
+              {
                 *ppMemberGroupSDict = new MemberGroupSDict;
                 (*ppMemberGroupSDict)->setAutoDelete(TRUE);
               }
               MemberGroup *mg = (*ppMemberGroupSDict)->find(groupId);
-              if (mg == 0) {
-                mg = new MemberGroup(context, groupId, info->header, info->doc,
-                                     info->docFile, info->docLine);
-                (*ppMemberGroupSDict)->append(groupId, mg);
+              if (mg==0)
+              {
+                mg = new MemberGroup(
+                    context,
+                    groupId,
+                    info->header,
+                    info->doc,
+                    info->docFile,
+                    info->docLine
+                    );
+                (*ppMemberGroupSDict)->append(groupId,mg);
               }
               mg->insertMember(fmd); // insert in member group
               fmd->setMemberGroup(mg);
@@ -5844,21 +6020,31 @@ void addMembersToMemberGroup(MemberList *ml,
         }
       }
     }
-    int groupId = md->getMemberGroupId();
-    if (groupId != -1) {
+    int groupId=md->getMemberGroupId();
+    if (groupId!=-1)
+    {
       MemberGroupInfo *info = Doxygen::memGrpInfoDict[groupId];
-      // QCString *pGrpHeader = Doxygen::memberHeaderDict[groupId];
-      // QCString *pDocs      = Doxygen::memberDocDict[groupId];
-      if (info) {
-        if (*ppMemberGroupSDict == 0) {
+      //QCString *pGrpHeader = Doxygen::memberHeaderDict[groupId];
+      //QCString *pDocs      = Doxygen::memberDocDict[groupId];
+      if (info)
+      {
+        if (*ppMemberGroupSDict==0)
+        {
           *ppMemberGroupSDict = new MemberGroupSDict;
           (*ppMemberGroupSDict)->setAutoDelete(TRUE);
         }
         MemberGroup *mg = (*ppMemberGroupSDict)->find(groupId);
-        if (mg == 0) {
-          mg = new MemberGroup(context, groupId, info->header, info->doc,
-                               info->docFile, info->docLine);
-          (*ppMemberGroupSDict)->append(groupId, mg);
+        if (mg==0)
+        {
+          mg = new MemberGroup(
+              context,
+              groupId,
+              info->header,
+              info->doc,
+              info->docFile,
+              info->docLine
+              );
+          (*ppMemberGroupSDict)->append(groupId,mg);
         }
         md = ml->take(index); // remove from member list
         mg->insertMember(md); // insert in member group
@@ -5867,8 +6053,7 @@ void addMembersToMemberGroup(MemberList *ml,
         continue;
       }
     }
-    ++mli;
-    ++index;
+    ++mli;++index;
   }
 }
 
@@ -5877,149 +6062,158 @@ void addMembersToMemberGroup(MemberList *ml,
  *  class \a name and a template argument list \a templSpec. If -1 is returned
  *  there are no more matches.
  */
-int extractClassNameFromType(const QCString &type, int &pos, QCString &name,
-                             QCString &templSpec, SrcLangExt lang) {
+int extractClassNameFromType(const QCString &type,int &pos,QCString &name,QCString &templSpec,SrcLangExt lang)
+{
   static const QRegExp re_norm("[a-z_A-Z\\x80-\\xFF][a-z_A-Z0-9:\\x80-\\xFF]*");
-  static const QRegExp re_ftn(
-      "[a-z_A-Z\\x80-\\xFF][()=_a-z_A-Z0-9:\\x80-\\xFF]*");
+  static const QRegExp re_ftn("[a-z_A-Z\\x80-\\xFF][()=_a-z_A-Z0-9:\\x80-\\xFF]*");
   QRegExp re;
 
   name.resize(0);
   templSpec.resize(0);
-  int i, l;
-  int typeLen = type.length();
-  if (typeLen > 0) {
-    if (lang == SrcLangExt_Fortran) {
-      if (type.at(pos) == ',')
-        return -1;
-      if (type.left(4).lower() == "type") {
+  int i,l;
+  int typeLen=type.length();
+  if (typeLen>0)
+  {
+    if (lang == SrcLangExt_Fortran)
+    {
+      if (type.at(pos)==',') return -1;
+      if (type.left(4).lower()=="type")
+      {
         re = re_norm;
-      } else {
+      }
+      else
+      {
         re = re_ftn;
       }
-    } else {
+    }
+    else
+    {
       re = re_norm;
     }
 
-    if ((i = re.match(type, pos, &l)) != -1) // for each class name in the type
+    if ((i=re.match(type,pos,&l))!=-1) // for each class name in the type
     {
-      int ts = i + l;
-      int te = ts;
-      int tl = 0;
-      while (type.at(ts) == ' ' && ts < typeLen)
-        ts++, tl++;           // skip any whitespace
-      if (type.at(ts) == '<') // assume template instance
+      int ts=i+l;
+      int te=ts;
+      int tl=0;
+      while (type.at(ts)==' ' && ts<typeLen) ts++,tl++; // skip any whitespace
+      if (type.at(ts)=='<') // assume template instance
       {
         // locate end of template
-        te = ts + 1;
-        int brCount = 1;
-        while (te < typeLen && brCount != 0) {
-          if (type.at(te) == '<') {
-            if (te < typeLen - 1 && type.at(te + 1) == '<')
-              te++;
-            else
-              brCount++;
+        te=ts+1;
+        int brCount=1;
+        while (te<typeLen && brCount!=0)
+        {
+          if (type.at(te)=='<') 
+          {
+            if (te<typeLen-1 && type.at(te+1)=='<') te++; else brCount++;
           }
-          if (type.at(te) == '>') {
-            if (te < typeLen - 1 && type.at(te + 1) == '>')
-              te++;
-            else
-              brCount--;
+          if (type.at(te)=='>') 
+          {
+            if (te<typeLen-1 && type.at(te+1)=='>') te++; else brCount--;
           }
           te++;
         }
       }
-      name = type.mid(i, l);
-      if (te > ts) {
-        templSpec = type.mid(ts, te - ts), tl += te - ts;
-        pos = i + l + tl;
-      } else // no template part
+      name = type.mid(i,l);
+      if (te>ts) 
+      {
+        templSpec = type.mid(ts,te-ts),tl+=te-ts;
+        pos=i+l+tl;
+      }
+      else // no template part
       {
-        pos = i + l;
+        pos=i+l;
       }
-      // printf("extractClassNameFromType([in] type=%s,[out] pos=%d,[out]
-      // name=%s,[out] templ=%s)=TRUE\n",
+      //printf("extractClassNameFromType([in] type=%s,[out] pos=%d,[out] name=%s,[out] templ=%s)=TRUE\n",
       //    type.data(),pos,name.data(),templSpec.data());
       return i;
     }
   }
   pos = typeLen;
-  // printf("extractClassNameFromType([in] type=%s,[out] pos=%d,[out]
-  // name=%s,[out] templ=%s)=FALSE\n",
+  //printf("extractClassNameFromType([in] type=%s,[out] pos=%d,[out] name=%s,[out] templ=%s)=FALSE\n",
   //       type.data(),pos,name.data(),templSpec.data());
   return -1;
 }
 
-QCString normalizeNonTemplateArgumentsInString(const QCString &name,
-                                               Definition *context,
-                                               const ArgumentList *formalArgs) {
+QCString normalizeNonTemplateArgumentsInString(
+       const QCString &name,
+       Definition *context,
+       const ArgumentList * formalArgs)
+{
   // skip until <
-  int p = name.find('<');
-  if (p == -1)
-    return name;
+  int p=name.find('<');
+  if (p==-1) return name;
   p++;
   QCString result = name.left(p);
 
-<<<<<<< HEAD
-  static QRegExp re("[a-z_A-Z\\x80-\\xFF][a-z_A-Z0-9\\x80-\\xFF]*");
-  int l, i;
-=======
   static QRegExp re("[a-z:_A-Z\\x80-\\xFF][a-z:_A-Z0-9\\x80-\\xFF]*");
   int l,i;
->>>>>>> 5f01f783e2387a5d44ad70fbff5365aa0e5df938
   // for each identifier in the template part (e.g. B<T> -> T)
-  while ((i = re.match(name, p, &l)) != -1) {
-    result += name.mid(p, i - p);
-    QCString n = name.mid(i, l);
-    bool found = FALSE;
+  while ((i=re.match(name,p,&l))!=-1)
+  {
+    result += name.mid(p,i-p);
+    QCString n = name.mid(i,l);
+    bool found=FALSE;
     if (formalArgs) // check that n is not a formal template argument
     {
       ArgumentListIterator formAli(*formalArgs);
       Argument *formArg;
-      for (formAli.toFirst(); (formArg = formAli.current()) && !found;
-           ++formAli) {
-        found = formArg->name == n;
+      for (formAli.toFirst();
+          (formArg=formAli.current()) && !found;
+          ++formAli
+          )
+      {
+        found = formArg->name==n;
       }
     }
-    if (!found) {
+    if (!found)
+    {
       // try to resolve the type
-      ClassDef *cd = getResolvedClass(context, 0, n);
-      if (cd) {
-        result += cd->name();
-      } else {
-        result += n;
+      ClassDef *cd = getResolvedClass(context,0,n);
+      if (cd)
+      {
+        result+=cd->name();
+      }
+      else
+      {
+        result+=n;
       }
-    } else {
-      result += n;
     }
-    p = i + l;
+    else
+    {
+      result+=n;
+    }
+    p=i+l;
   }
-  result += name.right(name.length() - p);
-  // printf("normalizeNonTemplateArgumentInString(%s)=%s\n",name.data(),result.data());
+  result+=name.right(name.length()-p);
+  //printf("normalizeNonTemplateArgumentInString(%s)=%s\n",name.data(),result.data());
   return removeRedundantWhiteSpace(result);
 }
 
+
 /*! Substitutes any occurrence of a formal argument from argument list
  *  \a formalArgs in \a name by the corresponding actual argument in
  *  argument list \a actualArgs. The result after substitution
  *  is returned as a string. The argument \a name is used to
  *  prevent recursive substitution.
  */
-QCString substituteTemplateArgumentsInString(const QCString &name,
-                                             ArgumentList *formalArgs,
-                                             ArgumentList *actualArgs) {
-  // printf("substituteTemplateArgumentsInString(name=%s formal=%s
-  // actualArg=%s)\n",
+QCString substituteTemplateArgumentsInString(
+    const QCString &name,
+    ArgumentList *formalArgs,
+    ArgumentList *actualArgs)
+{
+  //printf("substituteTemplateArgumentsInString(name=%s formal=%s actualArg=%s)\n",
   //    name.data(),argListToString(formalArgs).data(),argListToString(actualArgs).data());
-  if (formalArgs == 0)
-    return name;
+  if (formalArgs==0) return name;
   QCString result;
   static QRegExp re("[a-z_A-Z\\x80-\\xFF][a-z_A-Z0-9\\x80-\\xFF]*");
-  int p = 0, l, i;
+  int p=0,l,i;
   // for each identifier in the base class name (e.g. B<T> -> B and T)
-  while ((i = re.match(name, p, &l)) != -1) {
-    result += name.mid(p, i - p);
-    QCString n = name.mid(i, l);
+  while ((i=re.match(name,p,&l))!=-1)
+  {
+    result += name.mid(p,i-p);
+    QCString n = name.mid(i,l);
     ArgumentListIterator formAli(*formalArgs);
     ArgumentListIterator actAli(*actualArgs);
     Argument *formArg;
@@ -6027,142 +6221,159 @@ QCString substituteTemplateArgumentsInString(const QCString &name,
 
     // if n is a template argument, then we substitute it
     // for its template instance argument.
-    bool found = FALSE;
-    for (formAli.toFirst(); (formArg = formAli.current()) && !found;
-         ++formAli, ++actAli) {
+    bool found=FALSE;
+    for (formAli.toFirst();
+        (formArg=formAli.current()) && !found;
+        ++formAli,++actAli
+        )
+    {
       actArg = actAli.current();
-      if (formArg->type.left(6) == "class " && formArg->name.isEmpty()) {
+      if (formArg->type.left(6)=="class " && formArg->name.isEmpty())
+      {
         formArg->name = formArg->type.mid(6);
         formArg->type = "class";
       }
-      if (formArg->type.left(9) == "typename " && formArg->name.isEmpty()) {
+      if (formArg->type.left(9)=="typename " && formArg->name.isEmpty())
+      {
         formArg->name = formArg->type.mid(9);
         formArg->type = "typename";
       }
-      if (formArg->type == "class" || formArg->type == "typename" ||
-          formArg->type.left(8) == "template") {
-        // printf("n=%s formArg->type='%s' formArg->name='%s'
-        // formArg->defval='%s'\n",
+      if (formArg->type=="class" || formArg->type=="typename" || formArg->type.left(8)=="template")
+      {
+        //printf("n=%s formArg->type='%s' formArg->name='%s' formArg->defval='%s'\n",
         //  n.data(),formArg->type.data(),formArg->name.data(),formArg->defval.data());
-        // printf(">> formArg->name='%s' actArg->type='%s' actArg->name='%s'\n",
-        //    formArg->name.data(),actArg ? actArg->type.data() : "",actArg ?
-        //    actArg->name.data() : ""
+        //printf(">> formArg->name='%s' actArg->type='%s' actArg->name='%s'\n",
+        //    formArg->name.data(),actArg ? actArg->type.data() : "",actArg ? actArg->name.data() : ""
         //    );
-        if (formArg->name == n && actArg &&
-            !actArg->type.isEmpty()) // base class is a template argument
+        if (formArg->name==n && actArg && !actArg->type.isEmpty()) // base class is a template argument
         {
           // replace formal argument with the actual argument of the instance
-          if (!leftScopeMatch(actArg->type, n))
-          // the scope guard is to prevent recursive lockup for
-          // template<class A> class C : public<A::T>,
-          // where A::T would become A::T::T here,
-          // since n==A and actArg->type==A::T
-          // see bug595833 for an example
+          if (!leftScopeMatch(actArg->type,n)) 
+            // the scope guard is to prevent recursive lockup for 
+            // template<class A> class C : public<A::T>, 
+            // where A::T would become A::T::T here, 
+            // since n==A and actArg->type==A::T
+            // see bug595833 for an example
           {
-            if (actArg->name.isEmpty()) {
-              result += actArg->type + " ";
-              found = TRUE;
-            } else
-            // for case where the actual arg is something like "unsigned int"
-            // the "int" part is in actArg->name.
+            if (actArg->name.isEmpty())
             {
-              result += actArg->type + " " + actArg->name + " ";
-              found = TRUE;
+              result += actArg->type+" "; 
+              found=TRUE;
+            }
+            else 
+              // for case where the actual arg is something like "unsigned int"
+              // the "int" part is in actArg->name.
+            {
+              result += actArg->type+" "+actArg->name+" "; 
+              found=TRUE;
             }
           }
-        } else if (formArg->name == n && actArg == 0 &&
-                   !formArg->defval.isEmpty() &&
-                   formArg->defval != name /* to prevent recursion */
-                   ) {
-          result += substituteTemplateArgumentsInString(
-                        formArg->defval, formalArgs, actualArgs) +
-                    " ";
-          found = TRUE;
         }
-      } else if (formArg->name == n && actArg == 0 &&
+        else if (formArg->name==n && 
+                 actArg==0 && 
                  !formArg->defval.isEmpty() &&
-                 formArg->defval != name /* to prevent recursion */
-                 ) {
-        result += substituteTemplateArgumentsInString(formArg->defval,
-                                                      formalArgs, actualArgs) +
-                  " ";
-        found = TRUE;
+                 formArg->defval!=name /* to prevent recursion */
+            )
+        {
+          result += substituteTemplateArgumentsInString(formArg->defval,formalArgs,actualArgs)+" ";
+          found=TRUE;
+        }
+      }
+      else if (formArg->name==n && 
+               actArg==0 && 
+               !formArg->defval.isEmpty() &&
+               formArg->defval!=name /* to prevent recursion */
+              )
+      {
+        result += substituteTemplateArgumentsInString(formArg->defval,formalArgs,actualArgs)+" ";
+        found=TRUE;
       }
     }
-    if (!found) {
+    if (!found) 
+    {
       result += n;
     }
-    p = i + l;
+    p=i+l;
   }
-  result += name.right(name.length() - p);
-  // printf("      Inheritance relation %s -> %s\n",
+  result+=name.right(name.length()-p);
+  //printf("      Inheritance relation %s -> %s\n",
   //    name.data(),result.data());
   return result.stripWhiteSpace();
 }
 
-/*! Makes a deep copy of the list of argument lists \a srcLists.
+/*! Makes a deep copy of the list of argument lists \a srcLists. 
  *  Will allocate memory, that is owned by the caller.
  */
-QList<ArgumentList> *copyArgumentLists(const QList<ArgumentList> *srcLists) {
-  ASSERT(srcLists != 0);
+QList<ArgumentList> *copyArgumentLists(const QList<ArgumentList> *srcLists)
+{
+  ASSERT(srcLists!=0);
   QList<ArgumentList> *dstLists = new QList<ArgumentList>;
   dstLists->setAutoDelete(TRUE);
   QListIterator<ArgumentList> sli(*srcLists);
   ArgumentList *sl;
-  for (; (sl = sli.current()); ++sli) {
+  for (;(sl=sli.current());++sli)
+  {
     dstLists->append(sl->deepCopy());
   }
   return dstLists;
 }
 
-/*! Strips template specifiers from scope \a fullName, except those
- *  that make up specialized classes. The switch \a parentOnly
- *  determines whether or not a template "at the end" of a scope
- *  should be considered, e.g. with \a parentOnly is \c TRUE, A<T>::B<S> will
- *  try to strip \<T\> and not \<S\>, while \a parentOnly is \c FALSE will
- *  strip both unless A<T> or B<S> are specialized template classes.
+/*! Strips template specifiers from scope \a fullName, except those 
+ *  that make up specialized classes. The switch \a parentOnly 
+ *  determines whether or not a template "at the end" of a scope 
+ *  should be considered, e.g. with \a parentOnly is \c TRUE, A<T>::B<S> will 
+ *  try to strip \<T\> and not \<S\>, while \a parentOnly is \c FALSE will 
+ *  strip both unless A<T> or B<S> are specialized template classes. 
  */
 QCString stripTemplateSpecifiersFromScope(const QCString &fullName,
-                                          bool parentOnly,
-                                          QCString *pLastScopeStripped) {
+    bool parentOnly,
+    QCString *pLastScopeStripped)
+{
   QCString result;
-  int p = 0;
-  int l = fullName.length();
-  int i = fullName.find('<');
-  while (i != -1) {
-    // printf("1:result+=%s\n",fullName.mid(p,i-p).data());
-    int e = i + 1;
-    bool done = FALSE;
-    int count = 1;
-    while (e < l && !done) {
-      char c = fullName.at(e++);
-      if (c == '<') {
+  int p=0;
+  int l=fullName.length();
+  int i=fullName.find('<');
+  while (i!=-1)
+  {
+    //printf("1:result+=%s\n",fullName.mid(p,i-p).data());
+    int e=i+1;
+    bool done=FALSE;
+    int count=1;
+    while (e<l && !done)
+    {
+      char c=fullName.at(e++);
+      if (c=='<') 
+      {
         count++;
-      } else if (c == '>') {
+      }
+      else if (c=='>') 
+      {
         count--;
-        done = count == 0;
+        done = count==0;
       }
     }
-    int si = fullName.find("::", e);
+    int si= fullName.find("::",e);
 
-    if (parentOnly && si == -1)
-      break;
+    if (parentOnly && si==-1) break; 
     // we only do the parent scope, so we stop here if needed
 
-    result += fullName.mid(p, i - p);
-    // printf("  trying %s\n",(result+fullName.mid(i,e-i)).data());
-    if (getClass(result + fullName.mid(i, e - i)) != 0) {
-      result += fullName.mid(i, e - i);
-      // printf("  2:result+=%s\n",fullName.mid(i,e-i-1).data());
-    } else if (pLastScopeStripped) {
-      // printf("  last stripped scope '%s'\n",fullName.mid(i,e-i).data());
-      *pLastScopeStripped = fullName.mid(i, e - i);
+    result+=fullName.mid(p,i-p);
+    //printf("  trying %s\n",(result+fullName.mid(i,e-i)).data());
+    if (getClass(result+fullName.mid(i,e-i))!=0)
+    {
+      result+=fullName.mid(i,e-i);
+      //printf("  2:result+=%s\n",fullName.mid(i,e-i-1).data());
+    }
+    else if (pLastScopeStripped)
+    {
+      //printf("  last stripped scope '%s'\n",fullName.mid(i,e-i).data());
+      *pLastScopeStripped=fullName.mid(i,e-i);
     }
-    p = e;
-    i = fullName.find('<', p);
+    p=e;
+    i=fullName.find('<',p);
   }
-  result += fullName.right(l - p);
-  // printf("3:result+=%s\n",fullName.right(l-p).data());
+  result+=fullName.right(l-p);
+  //printf("3:result+=%s\n",fullName.right(l-p).data());
   return result;
 }
 
@@ -6170,37 +6381,36 @@ QCString stripTemplateSpecifiersFromScope(const QCString &fullName,
  *  Example1: \c A::B and \c B::C will result in \c A::B::C <br>
  *  Example2: \c A and \c B will be \c A::B <br>
  *  Example3: \c A::B and B will be \c A::B
- *
+ *  
  *  @param leftScope the left hand part of the scope.
  *  @param rightScope the right hand part of the scope.
- *  @returns the merged scope.
+ *  @returns the merged scope. 
  */
-QCString mergeScopes(const QCString &leftScope, const QCString &rightScope) {
+QCString mergeScopes(const QCString &leftScope,const QCString &rightScope)
+{
   // case leftScope=="A" rightScope=="A::B" => result = "A::B"
-  if (leftScopeMatch(rightScope, leftScope))
-    return rightScope;
+  if (leftScopeMatch(rightScope,leftScope)) return rightScope;
   QCString result;
-  int i = 0, p = leftScope.length();
+  int i=0,p=leftScope.length();
 
   // case leftScope=="A::B" rightScope=="B::C" => result = "A::B::C"
   // case leftScope=="A::B" rightScope=="B" => result = "A::B"
-  bool found = FALSE;
-  while ((i = leftScope.findRev("::", p)) != -1) {
-    if (leftScopeMatch(rightScope,
-                       leftScope.right(leftScope.length() - i - 2))) {
-      result = leftScope.left(i + 2) + rightScope;
-      found = TRUE;
+  bool found=FALSE;
+  while ((i=leftScope.findRev("::",p))!=-1)
+  {
+    if (leftScopeMatch(rightScope,leftScope.right(leftScope.length()-i-2)))
+    {
+      result = leftScope.left(i+2)+rightScope;
+      found=TRUE;
     }
-    p = i - 1;
+    p=i-1;
   }
-  if (found)
-    return result;
+  if (found) return result;
 
   // case leftScope=="A" rightScope=="B" => result = "A::B"
-  result = leftScope.copy();
-  if (!result.isEmpty() && !rightScope.isEmpty())
-    result += "::";
-  result += rightScope;
+  result=leftScope.copy();
+  if (!result.isEmpty() && !rightScope.isEmpty()) result+="::";
+  result+=rightScope;
   return result;
 }
 
@@ -6211,129 +6421,132 @@ QCString mergeScopes(const QCString &leftScope, const QCString &rightScope) {
  *  @param l the resulting length of the fragment.
  *  @returns the location of the fragment, or -1 if non is found.
  */
-int getScopeFragment(const QCString &s, int p, int *l) {
-  int sl = s.length();
-  int sp = p;
-  int count = 0;
+int getScopeFragment(const QCString &s,int p,int *l)
+{
+  int sl=s.length();
+  int sp=p;
+  int count=0;
   bool done;
-  if (sp >= sl)
-    return -1;
-  while (sp < sl) {
-    char c = s.at(sp);
-    if (c == ':')
-      sp++, p++;
-    else
-      break;
-  }
-  while (sp < sl) {
-    char c = s.at(sp);
-    switch (c) {
-    case ':': // found next part
-      goto found;
-    case '<': // skip template specifier
-      count = 1;
-      sp++;
-      done = FALSE;
-      while (sp < sl && !done) {
-        // TODO: deal with << and >> operators!
-        char c = s.at(sp++);
-        switch (c) {
-        case '<':
-          count++;
-          break;
-        case '>':
-          count--;
-          if (count == 0)
-            done = TRUE;
-          break;
-        default:
-          break;
+  if (sp>=sl) return -1;
+  while (sp<sl)
+  {
+    char c=s.at(sp);
+    if (c==':') sp++,p++; else break;
+  }
+  while (sp<sl)
+  {
+    char c=s.at(sp);
+    switch (c)
+    {
+      case ':': // found next part
+        goto found;
+      case '<': // skip template specifier
+        count=1;sp++;
+        done=FALSE;
+        while (sp<sl && !done)
+        {
+          // TODO: deal with << and >> operators!
+          char c=s.at(sp++);
+          switch(c)
+          {
+            case '<': count++; break;
+            case '>': count--; if (count==0) done=TRUE; break;
+            default: break;
+          }
         }
-      }
-      break;
-    default:
-      sp++;
-      break;
+        break;
+      default:
+        sp++;
+        break;
     }
   }
 found:
-  *l = sp - p;
-  // printf("getScopeFragment(%s,%d)=%s\n",s.data(),p,s.mid(p,*l).data());
+  *l=sp-p;
+  //printf("getScopeFragment(%s,%d)=%s\n",s.data(),p,s.mid(p,*l).data());
   return p;
 }
 
 //----------------------------------------------------------------------------
 
-PageDef *addRelatedPage(const char *name, const QCString &ptitle,
-                        const QCString &doc, QList<SectionInfo> * /*anchors*/,
-                        const char *fileName, int startLine,
-                        const QList<ListItemInfo> *sli, GroupDef *gd,
-                        TagInfo *tagInfo, SrcLangExt lang) {
-  PageDef *pd = 0;
-  // printf("addRelatedPage(name=%s gd=%p)\n",name,gd);
-  if ((pd = Doxygen::pageSDict->find(name)) && !tagInfo) {
+PageDef *addRelatedPage(const char *name,const QCString &ptitle,
+    const QCString &doc,
+    QList<SectionInfo> * /*anchors*/,
+    const char *fileName,int startLine,
+    const QList<ListItemInfo> *sli,
+    GroupDef *gd,
+    TagInfo *tagInfo,
+    SrcLangExt lang
+    )
+{
+  PageDef *pd=0;
+  //printf("addRelatedPage(name=%s gd=%p)\n",name,gd);
+  if ((pd=Doxygen::pageSDict->find(name)) && !tagInfo)
+  {
     // append documentation block to the page.
-    pd->setDocumentation(doc, fileName, startLine);
-    // printf("Adding page docs `%s' pi=%p name=%s\n",doc.data(),pd,name);
-  } else // new page
+    pd->setDocumentation(doc,fileName,startLine);
+    //printf("Adding page docs `%s' pi=%p name=%s\n",doc.data(),pd,name);
+  }
+  else // new page
   {
-    QCString baseName = name;
-    if (baseName.right(4) == ".tex")
-      baseName = baseName.left(baseName.length() - 4);
-    else if (baseName.right(Doxygen::htmlFileExtension.length()) ==
-             Doxygen::htmlFileExtension)
-      baseName = baseName.left(baseName.length() -
-                               Doxygen::htmlFileExtension.length());
+    QCString baseName=name;
+    if (baseName.right(4)==".tex") 
+      baseName=baseName.left(baseName.length()-4);
+    else if (baseName.right(Doxygen::htmlFileExtension.length())==Doxygen::htmlFileExtension)
+      baseName=baseName.left(baseName.length()-Doxygen::htmlFileExtension.length());
 
-    QCString title = ptitle.stripWhiteSpace();
-    pd = new PageDef(fileName, startLine, baseName, doc, title);
+    QCString title=ptitle.stripWhiteSpace();
+    pd=new PageDef(fileName,startLine,baseName,doc,title);
 
     pd->setRefItems(sli);
     pd->setLanguage(lang);
 
-    if (tagInfo) {
+    if (tagInfo)
+    {
       pd->setReference(tagInfo->tagName);
       pd->setFileName(tagInfo->fileName);
     }
 
-    // printf("Appending page `%s'\n",baseName.data());
-    Doxygen::pageSDict->append(baseName, pd);
+    //printf("Appending page `%s'\n",baseName.data());
+    Doxygen::pageSDict->append(baseName,pd);
 
-    if (gd)
-      gd->addPage(pd);
+    if (gd) gd->addPage(pd);
 
-    if (!pd->title().isEmpty()) {
-      // outputList->writeTitle(pi->name,pi->title);
+    if (!pd->title().isEmpty())
+    {
+      //outputList->writeTitle(pi->name,pi->title);
 
       // a page name is a label as well!
       QCString file;
-      if (gd) {
-        file = gd->getOutputFileBase();
-      } else {
-        file = pd->getOutputFileBase();
+      if (gd)
+      {
+        file=gd->getOutputFileBase();
+      }
+      else 
+      {
+        file=pd->getOutputFileBase();
       }
       SectionInfo *si = Doxygen::sectionDict->find(pd->name());
-      if (si) {
-        if (si->lineNr != -1) {
-          warn(file, -1, "multiple use of section label '%s', (first "
-                         "occurrence: %s, line %d)",
-               pd->name().data(), si->fileName.data(), si->lineNr);
-        } else {
-          warn(file, -1,
-               "multiple use of section label '%s', (first occurrence: %s)",
-               pd->name().data(), si->fileName.data());
+      if (si)
+      {
+        if (si->lineNr != -1)
+        {
+          warn(file,-1,"multiple use of section label '%s', (first occurrence: %s, line %d)",pd->name().data(),si->fileName.data(),si->lineNr);
+        }
+        else
+        {
+          warn(file,-1,"multiple use of section label '%s', (first occurrence: %s)",pd->name().data(),si->fileName.data());
         }
-      } else {
-        si = new SectionInfo(file, -1, pd->name(), pd->title(),
-                             SectionInfo::Page, 0, pd->getReference());
-        // printf("si->label=`%s' si->definition=%s si->fileName=`%s'\n",
+      }
+      else
+      {
+        si=new SectionInfo(
+            file,-1,pd->name(),pd->title(),SectionInfo::Page,0,pd->getReference());
+        //printf("si->label=`%s' si->definition=%s si->fileName=`%s'\n",
         //      si->label.data(),si->definition?si->definition->name().data():"<none>",
         //      si->fileName.data());
-        // printf("  SectionInfo: sec=%p
-        // sec->fileName=%s\n",si,si->fileName.data());
-        // printf("Adding section key=%s
-        // si->fileName=%s\n",pageName.data(),si->fileName.data());
-        Doxygen::sectionDict->append(pd->name(), si);
+        //printf("  SectionInfo: sec=%p sec->fileName=%s\n",si,si->fileName.data());
+        //printf("Adding section key=%s si->fileName=%s\n",pageName.data(),si->fileName.data());
+        Doxygen::sectionDict->append(pd->name(),si);
       }
     }
   }
@@ -6342,64 +6555,70 @@ PageDef *addRelatedPage(const char *name, const QCString &ptitle,
 
 //----------------------------------------------------------------------------
 
-void addRefItem(const QList<ListItemInfo> *sli, const char *key,
-                const char *prefix, const char *name, const char *title,
-                const char *args, Definition *scope) {
-  // printf("addRefItem(sli=%p,key=%s,prefix=%s,name=%s,title=%s,args=%s)\n",sli,key,prefix,name,title,args);
-  if (sli && key &&
-      key[0] != '@') // check for @ to skip anonymous stuff (see bug427012)
+void addRefItem(const QList<ListItemInfo> *sli,
+    const char *key, 
+    const char *prefix, const char *name,const char *title,const char *args,Definition *scope)
+{
+  //printf("addRefItem(sli=%p,key=%s,prefix=%s,name=%s,title=%s,args=%s)\n",sli,key,prefix,name,title,args);
+  if (sli && key && key[0]!='@') // check for @ to skip anonymous stuff (see bug427012)
   {
     QListIterator<ListItemInfo> slii(*sli);
     ListItemInfo *lii;
-    for (slii.toFirst(); (lii = slii.current()); ++slii) {
+    for (slii.toFirst();(lii=slii.current());++slii)
+    {
       RefList *refList = Doxygen::xrefLists->find(lii->type);
-      if (refList &&
+      if (refList
+          &&
           (
-              // either not a built-in list or the list is enabled
-              (lii->type != "todo" || Config_getBool(GENERATE_TODOLIST)) &&
-              (lii->type != "test" || Config_getBool(GENERATE_TESTLIST)) &&
-              (lii->type != "bug" || Config_getBool(GENERATE_BUGLIST)) &&
-              (lii->type != "deprecated" ||
-               Config_getBool(GENERATE_DEPRECATEDLIST)))) {
+           // either not a built-in list or the list is enabled
+           (lii->type!="todo"       || Config_getBool(GENERATE_TODOLIST)) &&
+           (lii->type!="test"       || Config_getBool(GENERATE_TESTLIST)) &&
+           (lii->type!="bug"        || Config_getBool(GENERATE_BUGLIST))  &&
+           (lii->type!="deprecated" || Config_getBool(GENERATE_DEPRECATEDLIST))
+          )
+         )
+      {
         RefItem *item = refList->getRefItem(lii->itemId);
-        ASSERT(item != 0);
+        ASSERT(item!=0);
 
         item->prefix = prefix;
-        item->scope = scope;
-        item->name = name;
-        item->title = title;
-        item->args = args;
+        item->scope  = scope;
+        item->name   = name;
+        item->title  = title;
+        item->args   = args;
+
+        refList->insertIntoList(key,item);
 
-        refList->insertIntoList(key, item);
       }
     }
   }
 }
 
-bool recursivelyAddGroupListToTitle(OutputList &ol, Definition *d, bool root) {
+bool recursivelyAddGroupListToTitle(OutputList &ol,Definition *d,bool root)
+{
   GroupList *groups = d->partOfGroups();
   if (groups) // write list of group to which this definition belongs
   {
-    if (root) {
+    if (root)
+    {
       ol.pushGeneratorState();
       ol.disableAllBut(OutputGenerator::Html);
       ol.writeString("<div class=\"ingroups\">");
     }
     GroupListIterator gli(*groups);
     GroupDef *gd;
-    bool first = true;
-    for (gli.toFirst(); (gd = gli.current()); ++gli) {
-      if (recursivelyAddGroupListToTitle(ol, gd, FALSE)) {
+    bool first=true;
+    for (gli.toFirst();(gd=gli.current());++gli)
+    {
+      if (recursivelyAddGroupListToTitle(ol, gd, FALSE))
+      {
         ol.writeString(" &raquo; ");
       }
-      if (!first) {
-        ol.writeString(" &#124; ");
-      } else
-        first = FALSE;
-      ol.writeObjectLink(gd->getReference(), gd->getOutputFileBase(), 0,
-                         gd->groupTitle());
+      if (!first) { ol.writeString(" &#124; "); } else first=FALSE;
+      ol.writeObjectLink(gd->getReference(),gd->getOutputFileBase(),0,gd->groupTitle());
     }
-    if (root) {
+    if (root)
+    {
       ol.writeString("</div>");
       ol.popGeneratorState();
     }
@@ -6408,299 +6627,229 @@ bool recursivelyAddGroupListToTitle(OutputList &ol, Definition *d, bool root) {
   return false;
 }
 
-void addGroupListToTitle(OutputList &ol, Definition *d) {
-  recursivelyAddGroupListToTitle(ol, d, TRUE);
+void addGroupListToTitle(OutputList &ol,Definition *d)
+{
+  recursivelyAddGroupListToTitle(ol,d,TRUE);
 }
 
-void filterLatexString(FTextStream &t, const char *str, bool insideTabbing,
-                       bool insidePre, bool insideItem, bool keepSpaces) {
-  if (str == 0)
-    return;
-  // if (strlen(str)<2) stackTrace();
-  const unsigned char *p = (const unsigned char *)str;
+void filterLatexString(FTextStream &t,const char *str,
+    bool insideTabbing,bool insidePre,bool insideItem,bool keepSpaces)
+{
+  if (str==0) return;
+  //if (strlen(str)<2) stackTrace();
+  const unsigned char *p=(const unsigned char *)str;
   const unsigned char *q;
   int cnt;
   unsigned char c;
-  unsigned char pc = '\0';
-  while (*p) {
-    c = *p++;
-
-    if (insidePre) {
-      switch (c) {
-      case '\\':
-        t << "\\(\\backslash\\)";
-        break;
-      case '{':
-        t << "\\{";
-        break;
-      case '}':
-        t << "\\}";
-        break;
-      case '_':
-        t << "\\_";
-        break;
-      case ' ':
-        if (keepSpaces)
-          t << "~";
-        else
-          t << ' ';
-        break;
-      default:
-        t << (char)c;
-        break;
-      }
-    } else {
-      switch (c) {
-      case '#':
-        t << "\\#";
-        break;
-      case '$':
-        t << "\\$";
-        break;
-      case '%':
-        t << "\\%";
-        break;
-      case '^':
-        t << "$^\\wedge$";
-        break;
-      case '&': // possibility to have a special symbol
-        q = p;
-        cnt = 2; // we have to count & and ; as well
-        while ((*q >= 'a' && *q <= 'z') || (*q >= 'A' && *q <= 'Z') ||
-               (*q >= '0' && *q <= '9')) {
-          cnt++;
-          q++;
-        }
-        if (*q == ';') {
-          --p; // we need & as well
-          DocSymbol::SymType res = HtmlEntityMapper::instance()->name2sym(
-              QCString((char *)p).left(cnt));
-          if (res == DocSymbol::Sym_Unknown) {
-            p++;
-            t << "\\&";
-          } else {
-            t << HtmlEntityMapper::instance()->latex(res);
-            q++;
-            p = q;
-          }
-        } else {
-          t << "\\&";
-        }
-        break;
-      case '*':
-        t << "$\\ast$";
-        break;
-      case '_':
-        if (!insideTabbing)
-          t << "\\+";
-        t << "\\_";
-        if (!insideTabbing)
-          t << "\\+";
-        break;
-      case '{':
-        t << "\\{";
-        break;
-      case '}':
-        t << "\\}";
-        break;
-      case '<':
-        t << "$<$";
-        break;
-      case '>':
-        t << "$>$";
-        break;
-      case '|':
-        t << "$\\vert$";
-        break;
-      case '~':
-        t << "$\\sim$";
-        break;
-      case '[':
-        if (Config_getBool(PDF_HYPERLINKS) || insideItem)
-          t << "\\mbox{[}";
-        else
-          t << "[";
-        break;
-      case ']':
-        if (pc == '[')
-          t << "$\\,$";
-        if (Config_getBool(PDF_HYPERLINKS) || insideItem)
-          t << "\\mbox{]}";
-        else
-          t << "]";
-        break;
-      case '-':
-        t << "-\\/";
-        break;
-      case '\\':
-        t << "\\textbackslash{}";
-        break;
-      case '"':
-        t << "\\char`\\\"{}";
-        break;
-      case '\'':
-        t << "\\textquotesingle{}";
-        break;
-      case ' ':
-        if (keepSpaces) {
-          if (insideTabbing)
-            t << "\\>";
-          else
-            t << '~';
-        } else
-          t << ' ';
-        break;
+  unsigned char pc='\0';
+  while (*p)
+  {
+    c=*p++;
 
-      default:
-        // if (!insideTabbing && forceBreaks && c!=' ' && *p!=' ')
-        if (!insideTabbing &&
-            ((c >= 'A' && c <= 'Z' && pc != ' ' && pc != '\0' && *p) ||
-             (c == ':' && pc != ':') || (pc == '.' && isId(c)))) {
-          t << "\\+";
-        }
-        t << (char)c;
+    if (insidePre)
+    {
+      switch(c)
+      {
+        case '\\': t << "\\(\\backslash\\)"; break;
+        case '{':  t << "\\{"; break;
+        case '}':  t << "\\}"; break;
+        case '_':  t << "\\_"; break;
+        case ' ':  if (keepSpaces) t << "~"; else t << ' ';
+                   break;
+        default:
+                   t << (char)c;
+                   break;
+      }
+    }
+    else
+    {
+      switch(c)
+      {
+        case '#':  t << "\\#";           break;
+        case '$':  t << "\\$";           break;
+        case '%':  t << "\\%";           break;
+        case '^':  t << "$^\\wedge$";    break;
+        case '&':  // possibility to have a special symbol
+                   q = p;
+                   cnt = 2; // we have to count & and ; as well
+                   while ((*q >= 'a' && *q <= 'z') || (*q >= 'A' && *q <= 'Z') || (*q >= '0' && *q <= '9'))
+                   {
+                     cnt++;
+                     q++;
+                   }
+                   if (*q == ';')
+                   {
+                      --p; // we need & as well
+                      DocSymbol::SymType res = HtmlEntityMapper::instance()->name2sym(QCString((char *)p).left(cnt));
+                      if (res == DocSymbol::Sym_Unknown)
+                      {
+                        p++;
+                        t << "\\&";
+                      }
+                      else
+                      {
+                        t << HtmlEntityMapper::instance()->latex(res);
+                        q++;
+                        p = q;
+                      }
+                   }
+                   else
+                   {
+                     t << "\\&";
+                   }
+                   break;
+        case '*':  t << "$\\ast$";       break;
+        case '_':  if (!insideTabbing) t << "\\+";  
+                   t << "\\_"; 
+                   if (!insideTabbing) t << "\\+";  
+                   break;
+        case '{':  t << "\\{";           break;
+        case '}':  t << "\\}";           break;
+        case '<':  t << "$<$";           break;
+        case '>':  t << "$>$";           break;
+        case '|':  t << "$\\vert$";      break;
+        case '~':  t << "$\\sim$";       break;
+        case '[':  if (Config_getBool(PDF_HYPERLINKS) || insideItem) 
+                     t << "\\mbox{[}"; 
+                   else
+                     t << "[";
+                   break;
+        case ']':  if (pc=='[') t << "$\\,$";
+                     if (Config_getBool(PDF_HYPERLINKS) || insideItem)
+                       t << "\\mbox{]}";
+                     else
+                       t << "]";             
+                   break;
+        case '-':  t << "-\\/";
+                   break;
+        case '\\': t << "\\textbackslash{}";
+                   break;           
+        case '"':  t << "\\char`\\\"{}";
+                   break;
+        case '\'': t << "\\textquotesingle{}";
+                   break;
+        case ' ':  if (keepSpaces) { if (insideTabbing) t << "\\>"; else t << '~'; } else t << ' ';
+                   break;
+
+        default:   
+                   //if (!insideTabbing && forceBreaks && c!=' ' && *p!=' ')
+                   if (!insideTabbing && 
+                       ((c>='A' && c<='Z' && pc!=' ' && pc!='\0' && *p) || (c==':' && pc!=':') || (pc=='.' && isId(c)))
+                      )
+                   {
+                     t << "\\+";
+                   }
+                   t << (char)c;
       }
     }
     pc = c;
   }
 }
 
-QCString latexEscapeLabelName(const char *s, bool insideTabbing) {
+QCString latexEscapeLabelName(const char *s,bool insideTabbing)
+{
   QGString result;
-  QCString tmp(qstrlen(s) + 1);
+  QCString tmp(qstrlen(s)+1);
   FTextStream t(&result);
-  const char *p = s;
+  const char *p=s;
   char c;
   int i;
-  while ((c = *p++)) {
-    switch (c) {
-    case '|':
-      t << "\\texttt{\"|}";
-      break;
-    case '!':
-      t << "\"!";
-      break;
-    case '@':
-      t << "\"@";
-      break;
-    case '%':
-      t << "\\%";
-      break;
-    case '{':
-      t << "\\lcurly{}";
-      break;
-    case '}':
-      t << "\\rcurly{}";
-      break;
-    case '~':
-      t << "````~";
-      break; // to get it a bit better in index together with other special
-             // characters
-    // NOTE: adding a case here, means adding it to while below as well!
-    default:
-      i = 0;
-      // collect as long string as possible, before handing it to docify
-      tmp[i++] = c;
-      while ((c = *p) && c != '@' && c != '[' && c != ']' && c != '!' &&
-             c != '{' && c != '}' && c != '|') {
-        tmp[i++] = c;
-        p++;
-      }
-      tmp[i] = 0;
-      filterLatexString(t, tmp.data(), insideTabbing);
-      break;
+  while ((c=*p++))
+  {
+    switch (c)
+    {
+      case '|': t << "\\texttt{\"|}"; break;
+      case '!': t << "\"!"; break;
+      case '@': t << "\"@"; break;
+      case '%': t << "\\%";       break;
+      case '{': t << "\\lcurly{}"; break;
+      case '}': t << "\\rcurly{}"; break;
+      case '~': t << "````~"; break; // to get it a bit better in index together with other special characters
+      // NOTE: adding a case here, means adding it to while below as well!
+      default:  
+        i=0;
+        // collect as long string as possible, before handing it to docify
+        tmp[i++]=c;
+        while ((c=*p) && c!='@' && c!='[' && c!=']' && c!='!' && c!='{' && c!='}' && c!='|')
+        {
+          tmp[i++]=c;
+          p++;
+        }
+        tmp[i]=0;
+        filterLatexString(t,tmp.data(),insideTabbing);
+        break;
     }
   }
   return result.data();
 }
 
-QCString latexEscapeIndexChars(const char *s, bool insideTabbing) {
+QCString latexEscapeIndexChars(const char *s,bool insideTabbing)
+{
   QGString result;
-  QCString tmp(qstrlen(s) + 1);
+  QCString tmp(qstrlen(s)+1);
   FTextStream t(&result);
-  const char *p = s;
+  const char *p=s;
   char c;
   int i;
-  while ((c = *p++)) {
-    switch (c) {
-    case '!':
-      t << "\"!";
-      break;
-    case '"':
-      t << "\"\"";
-      break;
-    case '@':
-      t << "\"@";
-      break;
-    case '|':
-      t << "\\texttt{\"|}";
-      break;
-    case '[':
-      t << "[";
-      break;
-    case ']':
-      t << "]";
-      break;
-    case '{':
-      t << "\\lcurly{}";
-      break;
-    case '}':
-      t << "\\rcurly{}";
-      break;
-    // NOTE: adding a case here, means adding it to while below as well!
-    default:
-      i = 0;
-      // collect as long string as possible, before handing it to docify
-      tmp[i++] = c;
-      while ((c = *p) && c != '"' && c != '@' && c != '[' && c != ']' &&
-             c != '!' && c != '{' && c != '}' && c != '|') {
-        tmp[i++] = c;
-        p++;
-      }
-      tmp[i] = 0;
-      filterLatexString(t, tmp.data(), insideTabbing);
-      break;
+  while ((c=*p++))
+  {
+    switch (c)
+    {
+      case '!': t << "\"!"; break;
+      case '"': t << "\"\""; break;
+      case '@': t << "\"@"; break;
+      case '|': t << "\\texttt{\"|}"; break;
+      case '[': t << "["; break;
+      case ']': t << "]"; break;
+      case '{': t << "\\lcurly{}"; break;
+      case '}': t << "\\rcurly{}"; break;
+      // NOTE: adding a case here, means adding it to while below as well!
+      default:  
+        i=0;
+        // collect as long string as possible, before handing it to docify
+        tmp[i++]=c;
+        while ((c=*p) && c!='"' && c!='@' && c!='[' && c!=']' && c!='!' && c!='{' && c!='}' && c!='|')
+        {
+          tmp[i++]=c;
+          p++;
+        }
+        tmp[i]=0;
+        filterLatexString(t,tmp.data(),insideTabbing);
+        break;
     }
   }
   return result.data();
 }
 
-QCString latexEscapePDFString(const char *s) {
+QCString latexEscapePDFString(const char *s)
+{
   QGString result;
   FTextStream t(&result);
-  const char *p = s;
+  const char *p=s;
   char c;
-  while ((c = *p++)) {
-    switch (c) {
-    case '\\':
-      t << "\\textbackslash{}";
-      break;
-    case '{':
-      t << "\\{";
-      break;
-    case '}':
-      t << "\\}";
-      break;
-    case '_':
-      t << "\\_";
-      break;
-    case '%':
-      t << "\\%";
-      break;
-    case '&':
-      t << "\\&";
-      break;
-    default:
-      t << c;
-      break;
+  while ((c=*p++))
+  {
+    switch (c)
+    {
+      case '\\': t << "\\textbackslash{}"; break;
+      case '{':  t << "\\{"; break;
+      case '}':  t << "\\}"; break;
+      case '_':  t << "\\_"; break;
+      case '%':  t << "\\%"; break;
+      case '&':  t << "\\&"; break;
+      default:
+        t << c;
+        break;
     }
   }
   return result.data();
 }
 
-QCString rtfFormatBmkStr(const char *name) {
-  static QCString g_nextTag("AAAAAAAAAA");
-  static QDict<QCString> g_tagDict(5003);
+
+QCString rtfFormatBmkStr(const char *name)
+{
+  static QCString g_nextTag( "AAAAAAAAAA" );
+  static QDict<QCString> g_tagDict( 5003 );
 
   g_tagDict.setAutoDelete(TRUE);
 
@@ -6708,21 +6857,26 @@ QCString rtfFormatBmkStr(const char *name) {
   // substitute a short arbitrary string for the name
   // supplied, and keep track of the correspondence
   // between names and strings.
-  QCString key(name);
-  QCString *tag = g_tagDict.find(key);
-  if (!tag) {
+  QCString key( name );
+  QCString* tag = g_tagDict.find( key );
+  if ( !tag )
+  {
     // This particular name has not yet been added
     // to the list. Add it, associating it with the
     // next tag value, and increment the next tag.
-    tag = new QCString(g_nextTag.copy()); // Make sure to use a deep copy!
-    g_tagDict.insert(key, tag);
+    tag = new QCString( g_nextTag.copy() ); // Make sure to use a deep copy!
+    g_tagDict.insert( key, tag );
 
     // This is the increment part
-    char *nxtTag = g_nextTag.rawData() + g_nextTag.length() - 1;
-    for (unsigned int i = 0; i < g_nextTag.length(); ++i, --nxtTag) {
-      if ((++(*nxtTag)) > 'Z') {
+    char* nxtTag = g_nextTag.rawData() + g_nextTag.length() - 1;
+    for ( unsigned int i = 0; i < g_nextTag.length(); ++i, --nxtTag )
+    {
+      if ( ( ++(*nxtTag) ) > 'Z' )
+      {
         *nxtTag = 'A';
-      } else {
+      }
+      else
+      {
         // Since there was no carry, we can stop now
         break;
       }
@@ -6732,73 +6886,86 @@ QCString rtfFormatBmkStr(const char *name) {
   return *tag;
 }
 
-bool checkExtension(const char *fName, const char *ext) {
-  return (QCString(fName).right(QCString(ext).length()) == ext);
+bool checkExtension(const char *fName, const char *ext)
+{
+  return (QCString(fName).right(QCString(ext).length())==ext);
 }
 
-QCString stripExtensionGeneral(const char *fName, const char *ext) {
-  QCString result = fName;
-  if (result.right(QCString(ext).length()) == QCString(ext)) {
-    result = result.left(result.length() - QCString(ext).length());
+QCString stripExtensionGeneral(const char *fName, const char *ext)
+{
+  QCString result=fName;
+  if (result.right(QCString(ext).length())==QCString(ext))
+  {
+    result=result.left(result.length()-QCString(ext).length());
   }
   return result;
 }
 
-QCString stripExtension(const char *fName) {
+QCString stripExtension(const char *fName)
+{
   return stripExtensionGeneral(fName, Doxygen::htmlFileExtension);
 }
 
-void replaceNamespaceAliases(QCString &scope, int i) {
-  while (i > 0) {
+void replaceNamespaceAliases(QCString &scope,int i)
+{
+  while (i>0)
+  {
     QCString ns = scope.left(i);
     QCString *s = Doxygen::namespaceAliasDict[ns];
-    if (s) {
-      scope = *s + scope.right(scope.length() - i);
-      i = s->length();
+    if (s)
+    {
+      scope=*s+scope.right(scope.length()-i);
+      i=s->length();
     }
-    if (i > 0 && ns == scope.left(i))
-      break;
+    if (i>0 && ns==scope.left(i)) break;
   }
 }
 
-QCString stripPath(const char *s) {
-  QCString result = s;
-  int i = result.findRev('/');
-  if (i != -1) {
-    result = result.mid(i + 1);
+QCString stripPath(const char *s)
+{
+  QCString result=s;
+  int i=result.findRev('/');
+  if (i!=-1)
+  {
+    result=result.mid(i+1);
   }
-  i = result.findRev('\\');
-  if (i != -1) {
-    result = result.mid(i + 1);
+  i=result.findRev('\\');
+  if (i!=-1)
+  {
+    result=result.mid(i+1);
   }
   return result;
 }
 
 /** returns \c TRUE iff string \a s contains word \a w */
-bool containsWord(const QCString &s, const QCString &word) {
+bool containsWord(const QCString &s,const QCString &word)
+{
   static QRegExp wordExp("[a-z_A-Z\\x80-\\xFF]+");
-  int p = 0, i, l;
-  while ((i = wordExp.match(s, p, &l)) != -1) {
-    if (s.mid(i, l) == word)
-      return TRUE;
-    p = i + l;
+  int p=0,i,l;
+  while ((i=wordExp.match(s,p,&l))!=-1)
+  {
+    if (s.mid(i,l)==word) return TRUE;
+    p=i+l;
   }
   return FALSE;
 }
 
-bool findAndRemoveWord(QCString &s, const QCString &word) {
+bool findAndRemoveWord(QCString &s,const QCString &word)
+{
   static QRegExp wordExp("[a-z_A-Z\\x80-\\xFF]+");
-  int p = 0, i, l;
-  while ((i = wordExp.match(s, p, &l)) != -1) {
-    if (s.mid(i, l) == word) {
-      if (i > 0 && isspace((uchar)s.at(i - 1)))
-        i--, l++;
-      else if (i + l < (int)s.length() && isspace(s.at(i + l)))
+  int p=0,i,l;
+  while ((i=wordExp.match(s,p,&l))!=-1)
+  {
+    if (s.mid(i,l)==word) 
+    {
+      if (i>0 && isspace((uchar)s.at(i-1))) 
+        i--,l++;
+      else if (i+l<(int)s.length() && isspace(s.at(i+l))) 
         l++;
-      s = s.left(i) + s.mid(i + l); // remove word + spacing
+      s = s.left(i)+s.mid(i+l); // remove word + spacing
       return TRUE;
     }
-    p = i + l;
+    p=i+l;
   }
   return FALSE;
 }
@@ -6811,49 +6978,40 @@ bool findAndRemoveWord(QCString &s, const QCString &word) {
  *         from the start.
  *  @returns The stripped string.
  */
-QCString stripLeadingAndTrailingEmptyLines(const QCString &s, int &docLine) {
+QCString stripLeadingAndTrailingEmptyLines(const QCString &s,int &docLine)
+{
   const char *p = s.data();
-  if (p == 0)
-    return 0;
+  if (p==0) return 0;
 
   // search for leading empty lines
-  int i = 0, li = -1, l = s.length();
+  int i=0,li=-1,l=s.length();
   char c;
-  while ((c = *p++)) {
-    if (c == ' ' || c == '\t' || c == '\r')
-      i++;
-    else if (c == '\n')
-      i++, li = i, docLine++;
-    else
-      break;
+  while ((c=*p++))
+  {
+    if (c==' ' || c=='\t' || c=='\r') i++;
+    else if (c=='\n') i++,li=i,docLine++;
+    else break;
   }
 
   // search for trailing empty lines
-  int b = l - 1, bi = -1;
-  p = s.data() + b;
-  while (b >= 0) {
-    c = *p;
-    p--;
-    if (c == ' ' || c == '\t' || c == '\r')
-      b--;
-    else if (c == '\n')
-      bi = b, b--;
-    else
-      break;
+  int b=l-1,bi=-1;
+  p=s.data()+b;
+  while (b>=0)
+  {
+    c=*p; p--;
+    if (c==' ' || c=='\t' || c=='\r') b--;
+    else if (c=='\n') bi=b,b--;
+    else break;
   }
 
   // return whole string if no leading or trailing lines where found
-  if (li == -1 && bi == -1)
-    return s;
+  if (li==-1 && bi==-1) return s;
 
   // return substring
-  if (bi == -1)
-    bi = l;
-  if (li == -1)
-    li = 0;
-  if (bi <= li)
-    return 0; // only empty lines
-  return s.mid(li, bi - li);
+  if (bi==-1) bi=l;
+  if (li==-1) li=0;
+  if (bi<=li) return 0; // only empty lines
+  return s.mid(li,bi-li);
 }
 
 #if 0
@@ -6879,161 +7037,172 @@ void stringToSearchIndex(const QCString &docBaseUrl,const QCString &title,
 
 static QDict<int> g_extLookup;
 
-static struct Lang2ExtMap {
+static struct Lang2ExtMap
+{
   const char *langName;
   const char *parserName;
   SrcLangExt parserId;
-} g_lang2extMap[] = {
-    //  language       parser           parser option
-    {"idl", "c", SrcLangExt_IDL},
-    {"java", "c", SrcLangExt_Java},
-    {"javascript", "c", SrcLangExt_JS},
-    {"csharp", "c", SrcLangExt_CSharp},
-    {"d", "c", SrcLangExt_D},
-    {"php", "c", SrcLangExt_PHP},
-    {"objective-c", "c", SrcLangExt_ObjC},
-    {"c", "c", SrcLangExt_Cpp},
-    {"c++", "c", SrcLangExt_Cpp},
-    {"prolog", "prolog", SrcLangExt_Prolog},
-    {"python", "python", SrcLangExt_Python},
-    {"fortran", "fortran", SrcLangExt_Fortran},
-    {"fortranfree", "fortranfree", SrcLangExt_Fortran},
-    {"fortranfixed", "fortranfixed", SrcLangExt_Fortran},
-    {"vhdl", "vhdl", SrcLangExt_VHDL},
-    {"xml", "xml", SrcLangExt_XML},
-    {"tcl", "tcl", SrcLangExt_Tcl},
-    {"md", "md", SrcLangExt_Markdown},
-    {0, 0, (SrcLangExt)0}};
-
-bool updateLanguageMapping(const QCString &extension,
-                           const QCString &language) {
+} 
+g_lang2extMap[] =
+{
+//  language       parser           parser option
+  { "idl",         "c",             SrcLangExt_IDL      },
+  { "java",        "c",             SrcLangExt_Java     },
+  { "javascript",  "c",             SrcLangExt_JS       },
+  { "csharp",      "c",             SrcLangExt_CSharp   },
+  { "d",           "c",             SrcLangExt_D        },
+  { "php",         "c",             SrcLangExt_PHP      },
+  { "objective-c", "c",             SrcLangExt_ObjC     },
+  { "c",           "c",             SrcLangExt_Cpp      },
+  { "c++",         "c",             SrcLangExt_Cpp      },
+  { "python",      "python",        SrcLangExt_Python   },
+  { "fortran",     "fortran",       SrcLangExt_Fortran  },
+  { "fortranfree", "fortranfree",   SrcLangExt_Fortran  },
+  { "fortranfixed", "fortranfixed", SrcLangExt_Fortran  },
+  { "vhdl",        "vhdl",          SrcLangExt_VHDL     },
+  { "xml",         "xml",           SrcLangExt_XML      },
+  { "tcl",         "tcl",           SrcLangExt_Tcl      },
+  { "md",          "md",            SrcLangExt_Markdown },
+  { "prolog",      "prolog",        SrcLangExt_Prolog },
+  { 0,             0,              (SrcLangExt)0        }
+};
+
+bool updateLanguageMapping(const QCString &extension,const QCString &language)
+{
   const Lang2ExtMap *p = g_lang2extMap;
   QCString langName = language.lower();
-  while (p->langName) {
-    if (langName == p->langName)
-      break;
+  while (p->langName)
+  {
+    if (langName==p->langName) break;
     p++;
   }
-  if (!p->langName)
-    return FALSE;
+  if (!p->langName) return FALSE;
 
   // found the language
   SrcLangExt parserId = p->parserId;
   QCString extName = extension.lower();
-  if (extName.isEmpty())
-    return FALSE;
-  if (extName.at(0) != '.')
-    extName.prepend(".");
-  if (g_extLookup.find(extension) !=
-      0) // language was already register for this ext
+  if (extName.isEmpty()) return FALSE;
+  if (extName.at(0)!='.') extName.prepend(".");
+  if (g_extLookup.find(extension)!=0) // language was already register for this ext
   {
     g_extLookup.remove(extension);
   }
-  // printf("registering extension %s\n",extName.data());
-  g_extLookup.insert(extName, new int(parserId));
-  if (!Doxygen::parserManager->registerExtension(extName, p->parserName)) {
+  //printf("registering extension %s\n",extName.data());
+  g_extLookup.insert(extName,new int(parserId));
+  if (!Doxygen::parserManager->registerExtension(extName,p->parserName))
+  {
     err("Failed to assign extension %s to parser %s for language %s\n",
-        extName.data(), p->parserName, language.data());
-  } else {
-    // msg("Registered extension %s to language parser %s...\n",
+        extName.data(),p->parserName,language.data());
+  }
+  else
+  {
+    //msg("Registered extension %s to language parser %s...\n",
     //    extName.data(),language.data());
   }
   return TRUE;
 }
 
-void initDefaultExtensionMapping() {
+void initDefaultExtensionMapping()
+{
   // NOTE: when adding an extension, also add the extension in config.xml
   g_extLookup.setAutoDelete(TRUE);
   //                  extension      parser id
-  updateLanguageMapping(".dox", "c");
-  updateLanguageMapping(".txt", "c"); // see bug 760836
-  updateLanguageMapping(".doc", "c");
-  updateLanguageMapping(".c", "c");
-  updateLanguageMapping(".C", "c");
-  updateLanguageMapping(".cc", "c");
-  updateLanguageMapping(".CC", "c");
-  updateLanguageMapping(".cxx", "c");
-  updateLanguageMapping(".cpp", "c");
-  updateLanguageMapping(".c++", "c");
-  updateLanguageMapping(".ii", "c");
-  updateLanguageMapping(".ixx", "c");
-  updateLanguageMapping(".ipp", "c");
-  updateLanguageMapping(".i++", "c");
-  updateLanguageMapping(".inl", "c");
-  updateLanguageMapping(".h", "c");
-  updateLanguageMapping(".H", "c");
-  updateLanguageMapping(".hh", "c");
-  updateLanguageMapping(".HH", "c");
-  updateLanguageMapping(".hxx", "c");
-  updateLanguageMapping(".hpp", "c");
-  updateLanguageMapping(".h++", "c");
-  updateLanguageMapping(".idl", "idl");
-  updateLanguageMapping(".ddl", "idl");
-  updateLanguageMapping(".odl", "idl");
-  updateLanguageMapping(".java", "java");
-  // updateLanguageMapping(".as",       "javascript"); // not officially
-  // supported
-  // updateLanguageMapping(".js",       "javascript"); // not officially
-  // supported
-  updateLanguageMapping(".cs", "csharp");
-  updateLanguageMapping(".d", "d");
-  updateLanguageMapping(".php", "php");
-  updateLanguageMapping(".php4", "php");
-  updateLanguageMapping(".php5", "php");
-  updateLanguageMapping(".inc", "php");
-  updateLanguageMapping(".phtml", "php");
-  updateLanguageMapping(".m", "objective-c");
-  updateLanguageMapping(".M", "objective-c");
-  updateLanguageMapping(".mm", "c"); // see bug746361
-  updateLanguageMapping(".py", "python");
+  updateLanguageMapping(".dox",      "c");
+  updateLanguageMapping(".txt",      "c"); // see bug 760836
+  updateLanguageMapping(".doc",      "c");
+  updateLanguageMapping(".c",        "c");
+  updateLanguageMapping(".C",        "c");
+  updateLanguageMapping(".cc",       "c");
+  updateLanguageMapping(".CC",       "c");
+  updateLanguageMapping(".cxx",      "c");
+  updateLanguageMapping(".cpp",      "c");
+  updateLanguageMapping(".c++",      "c");
+  updateLanguageMapping(".ii",       "c");
+  updateLanguageMapping(".ixx",      "c");
+  updateLanguageMapping(".ipp",      "c");
+  updateLanguageMapping(".i++",      "c");
+  updateLanguageMapping(".inl",      "c");
+  updateLanguageMapping(".h",        "c");
+  updateLanguageMapping(".H",        "c");
+  updateLanguageMapping(".hh",       "c");
+  updateLanguageMapping(".HH",       "c");
+  updateLanguageMapping(".hxx",      "c");
+  updateLanguageMapping(".hpp",      "c");
+  updateLanguageMapping(".h++",      "c");
+  updateLanguageMapping(".idl",      "idl");
+  updateLanguageMapping(".ddl",      "idl");
+  updateLanguageMapping(".odl",      "idl");
+  updateLanguageMapping(".java",     "java");
+  //updateLanguageMapping(".as",       "javascript"); // not officially supported
+  //updateLanguageMapping(".js",       "javascript"); // not officially supported
+  updateLanguageMapping(".cs",       "csharp");
+  updateLanguageMapping(".d",        "d");
+  updateLanguageMapping(".php",      "php");
+  updateLanguageMapping(".php4",     "php");
+  updateLanguageMapping(".php5",     "php");
+  updateLanguageMapping(".inc",      "php");
+  updateLanguageMapping(".phtml",    "php");
+  updateLanguageMapping(".m",        "objective-c");
+  updateLanguageMapping(".M",        "objective-c");
+  updateLanguageMapping(".mm",       "c");  // see bug746361
+  updateLanguageMapping(".py",       "python");
+  updateLanguageMapping(".pyw",      "python");
+  updateLanguageMapping(".f",        "fortran");
+  updateLanguageMapping(".for",      "fortran");
+  updateLanguageMapping(".f90",      "fortran");
+  updateLanguageMapping(".f95",      "fortran");
+  updateLanguageMapping(".f03",      "fortran");
+  updateLanguageMapping(".f08",      "fortran");
+  updateLanguageMapping(".vhd",      "vhdl");
+  updateLanguageMapping(".vhdl",     "vhdl");
+  updateLanguageMapping(".tcl",      "tcl");
+  updateLanguageMapping(".ucf",      "vhdl");
+  updateLanguageMapping(".qsf",      "vhdl");
+  updateLanguageMapping(".md",       "md");
+  updateLanguageMapping(".markdown", "md");
+  updateLanguageMapping(".pl", "prolog");
   updateLanguageMapping(".yap", "prolog");
-  updateLanguageMapping(".prolog", "prolog");
   updateLanguageMapping(".ypp", "prolog");
-  updateLanguageMapping(".pl", "prolog");
-  updateLanguageMapping(".pyw", "python");
-  updateLanguageMapping(".f", "fortran");
-  updateLanguageMapping(".for", "fortran");
-  updateLanguageMapping(".f90", "fortran");
-  updateLanguageMapping(".f95", "fortran");
-  updateLanguageMapping(".f03", "fortran");
-  updateLanguageMapping(".f08", "fortran");
-  updateLanguageMapping(".vhd", "vhdl");
-  updateLanguageMapping(".vhdl", "vhdl");
-  updateLanguageMapping(".tcl", "tcl");
-  updateLanguageMapping(".ucf", "vhdl");
-  updateLanguageMapping(".qsf", "vhdl");
-  updateLanguageMapping(".md", "md");
-  updateLanguageMapping(".markdown", "md");
+  updateLanguageMapping(".prolog", "prolog");
 }
 
-void addCodeOnlyMappings() { updateLanguageMapping(".xml", "xml"); }
+void addCodeOnlyMappings()
+{
+  updateLanguageMapping(".xml",   "xml");
+}
 
-SrcLangExt getLanguageFromFileName(const QCString fileName) {
+SrcLangExt getLanguageFromFileName(const QCString fileName)
+{
   int i = fileName.findRev('.');
-  if (i != -1) // name has an extension
+  if (i!=-1) // name has an extension
   {
-    QCString extStr = fileName.right(fileName.length() - i).lower();
+    QCString extStr=fileName.right(fileName.length()-i).lower();
     if (!extStr.isEmpty()) // non-empty extension
     {
-      int *pVal = g_extLookup.find(extStr);
+      int *pVal=g_extLookup.find(extStr);
       if (pVal) // listed extension
       {
-        // printf("getLanguageFromFileName(%s)=%x\n",extStr.data(),*pVal);
-        return (SrcLangExt)*pVal;
+        //printf("getLanguageFromFileName(%s)=%x\n",extStr.data(),*pVal);
+        return (SrcLangExt)*pVal; 
       }
     }
   }
-  // printf("getLanguageFromFileName(%s) not found!\n",fileName.data());
+  //printf("getLanguageFromFileName(%s) not found!\n",fileName.data());
   return SrcLangExt_Cpp; // not listed => assume C-ish language.
 }
 
 //--------------------------------------------------------------------------
 
-MemberDef *getMemberFromSymbol(Definition *scope, FileDef *fileScope,
-                               const char *n) {
-  if (scope == 0 || (scope->definitionType() != Definition::TypeClass &&
-                     scope->definitionType() != Definition::TypeNamespace)) {
-    scope = Doxygen::globalScope;
+MemberDef *getMemberFromSymbol(Definition *scope,FileDef *fileScope, 
+                                const char *n)
+{
+  if (scope==0 ||
+      (scope->definitionType()!=Definition::TypeClass &&
+       scope->definitionType()!=Definition::TypeNamespace
+      )
+     )
+  {
+    scope=Doxygen::globalScope;
   }
 
   QCString name = n;
@@ -7041,59 +7210,64 @@ MemberDef *getMemberFromSymbol(Definition *scope, FileDef *fileScope,
     return 0; // no name was given
 
   DefinitionIntf *di = Doxygen::symbolMap->find(name);
-  if (di == 0)
+  if (di==0)
     return 0; // could not find any matching symbols
 
   // mostly copied from getResolvedClassRec()
   QCString explicitScopePart;
   int qualifierIndex = computeQualifiedIndex(name);
-  if (qualifierIndex != -1) {
+  if (qualifierIndex!=-1)
+  {
     explicitScopePart = name.left(qualifierIndex);
-    replaceNamespaceAliases(explicitScopePart, explicitScopePart.length());
-    name = name.mid(qualifierIndex + 2);
+    replaceNamespaceAliases(explicitScopePart,explicitScopePart.length());
+    name = name.mid(qualifierIndex+2);
   }
-  // printf("explicitScopePart=%s\n",explicitScopePart.data());
+  //printf("explicitScopePart=%s\n",explicitScopePart.data());
 
   int minDistance = 10000;
   MemberDef *bestMatch = 0;
 
-  if (di->definitionType() == DefinitionIntf::TypeSymbolList) {
-    // printf("multiple matches!\n");
+  if (di->definitionType()==DefinitionIntf::TypeSymbolList)
+  {
+    //printf("multiple matches!\n");
     // find the closest closest matching definition
-    DefinitionListIterator dli(*(DefinitionList *)di);
+    DefinitionListIterator dli(*(DefinitionList*)di);
     Definition *d;
-    for (dli.toFirst(); (d = dli.current()); ++dli) {
-      if (d->definitionType() == Definition::TypeMember) {
+    for (dli.toFirst();(d=dli.current());++dli)
+    {
+      if (d->definitionType()==Definition::TypeMember)
+      {
         g_visitedNamespaces.clear();
-        int distance = isAccessibleFromWithExpScope(scope, fileScope, d,
-                                                    explicitScopePart);
-        if (distance != -1 && distance < minDistance) {
+        int distance = isAccessibleFromWithExpScope(scope,fileScope,d,explicitScopePart);
+        if (distance!=-1 && distance<minDistance)
+        {
           minDistance = distance;
           bestMatch = (MemberDef *)d;
-          // printf("new best match %s
-          // distance=%d\n",bestMatch->qualifiedName().data(),distance);
+          //printf("new best match %s distance=%d\n",bestMatch->qualifiedName().data(),distance);
         }
       }
     }
-  } else if (di->definitionType() == Definition::TypeMember) {
-    // printf("unique match!\n");
+  }
+  else if (di->definitionType()==Definition::TypeMember)
+  {
+    //printf("unique match!\n");
     Definition *d = (Definition *)di;
     g_visitedNamespaces.clear();
-    int distance =
-        isAccessibleFromWithExpScope(scope, fileScope, d, explicitScopePart);
-    if (distance != -1 && distance < minDistance) {
+    int distance = isAccessibleFromWithExpScope(scope,fileScope,d,explicitScopePart);
+    if (distance!=-1 && distance<minDistance)
+    {
       minDistance = distance;
       bestMatch = (MemberDef *)d;
-      // printf("new best match %s
-      // distance=%d\n",bestMatch->qualifiedName().data(),distance);
+      //printf("new best match %s distance=%d\n",bestMatch->qualifiedName().data(),distance);
     }
   }
   return bestMatch;
 }
 
 /*! Returns true iff the given name string appears to be a typedef in scope. */
-bool checkIfTypedef(Definition *scope, FileDef *fileScope, const char *n) {
-  MemberDef *bestMatch = getMemberFromSymbol(scope, fileScope, n);
+bool checkIfTypedef(Definition *scope,FileDef *fileScope,const char *n)
+{
+  MemberDef *bestMatch = getMemberFromSymbol(scope,fileScope,n);
 
   if (bestMatch && bestMatch->isTypedef())
     return TRUE; // closest matching symbol is a typedef
@@ -7101,105 +7275,123 @@ bool checkIfTypedef(Definition *scope, FileDef *fileScope, const char *n) {
     return FALSE;
 }
 
-const char *writeUtf8Char(FTextStream &t, const char *s) {
-  char c = *s++;
+const char *writeUtf8Char(FTextStream &t,const char *s)
+{
+  char c=*s++;
   t << c;
-  if (c < 0) // multibyte character
+  if (c<0) // multibyte character
   {
-    if (((uchar)c & 0xE0) == 0xC0) {
+    if (((uchar)c&0xE0)==0xC0)
+    {
       t << *s++; // 11xx.xxxx: >=2 byte character
     }
-    if (((uchar)c & 0xF0) == 0xE0) {
+    if (((uchar)c&0xF0)==0xE0)
+    {
       t << *s++; // 111x.xxxx: >=3 byte character
     }
-    if (((uchar)c & 0xF8) == 0xF0) {
+    if (((uchar)c&0xF8)==0xF0)
+    {
       t << *s++; // 1111.xxxx: >=4 byte character
     }
-    if (((uchar)c & 0xFC) == 0xF8) {
+    if (((uchar)c&0xFC)==0xF8)
+    {
       t << *s++; // 1111.1xxx: >=5 byte character
     }
-    if (((uchar)c & 0xFE) == 0xFC) {
+    if (((uchar)c&0xFE)==0xFC)
+    {
       t << *s++; // 1111.1xxx: 6 byte character
     }
   }
   return s;
 }
 
-int nextUtf8CharPosition(const QCString &utf8Str, int len, int startPos) {
-  int bytes = 1;
-  if (startPos >= len)
-    return len;
+int nextUtf8CharPosition(const QCString &utf8Str,int len,int startPos)
+{
+  int bytes=1;
+  if (startPos>=len) return len;
   char c = utf8Str[startPos];
-  if (c < 0) // multibyte utf-8 character
+  if (c<0) // multibyte utf-8 character
   {
-    if (((uchar)c & 0xE0) == 0xC0) {
+    if (((uchar)c&0xE0)==0xC0)
+    {
       bytes++; // 11xx.xxxx: >=2 byte character
     }
-    if (((uchar)c & 0xF0) == 0xE0) {
+    if (((uchar)c&0xF0)==0xE0)
+    {
       bytes++; // 111x.xxxx: >=3 byte character
     }
-    if (((uchar)c & 0xF8) == 0xF0) {
+    if (((uchar)c&0xF8)==0xF0)
+    {
       bytes++; // 1111.xxxx: >=4 byte character
     }
-    if (((uchar)c & 0xFC) == 0xF8) {
+    if (((uchar)c&0xFC)==0xF8)
+    {
       bytes++; // 1111.1xxx: >=5 byte character
     }
-    if (((uchar)c & 0xFE) == 0xFC) {
+    if (((uchar)c&0xFE)==0xFC)
+    {
       bytes++; // 1111.1xxx: 6 byte character
     }
-  } else if (c == '&') // skip over character entities
+  }
+  else if (c=='&') // skip over character entities
   {
-    static QRegExp re1("&#[0-9]+;");    // numerical entity
-    static QRegExp re2("&[A-Z_a-z]+;"); // named entity
-    int l1, l2;
-    int i1 = re1.match(utf8Str, startPos, &l1);
-    int i2 = re2.match(utf8Str, startPos, &l2);
-    if (i1 != -1) {
-      bytes = l1;
-    } else if (i2 != -1) {
-      bytes = l2;
+    static QRegExp re1("&#[0-9]+;");     // numerical entity
+    static QRegExp re2("&[A-Z_a-z]+;");  // named entity
+    int l1,l2;
+    int i1 = re1.match(utf8Str,startPos,&l1);
+    int i2 = re2.match(utf8Str,startPos,&l2);
+    if (i1!=-1)
+    {
+      bytes=l1;
+    }
+    else if (i2!=-1)
+    {
+      bytes=l2;
     }
   }
-  return startPos + bytes;
+  return startPos+bytes;
 }
 
-QCString parseCommentAsText(const Definition *scope, const MemberDef *md,
-                            const QCString &doc, const QCString &fileName,
-                            int lineNr) {
+QCString parseCommentAsText(const Definition *scope,const MemberDef *md,
+    const QCString &doc,const QCString &fileName,int lineNr)
+{
   QGString s;
-  if (doc.isEmpty())
-    return s.data();
+  if (doc.isEmpty()) return s.data();
   FTextStream t(&s);
-  DocNode *root = validatingParseDoc(fileName, lineNr, (Definition *)scope,
-                                     (MemberDef *)md, doc, FALSE, FALSE);
+  DocNode *root = validatingParseDoc(fileName,lineNr,
+      (Definition*)scope,(MemberDef*)md,doc,FALSE,FALSE);
   TextDocVisitor *visitor = new TextDocVisitor(t);
   root->accept(visitor);
   delete visitor;
   delete root;
   QCString result = convertCharEntitiesToUTF8(s.data());
-  int i = 0;
-  int charCnt = 0;
-  int l = result.length();
-  bool addEllipsis = FALSE;
-  while ((i = nextUtf8CharPosition(result, l, i)) < l) {
+  int i=0;
+  int charCnt=0;
+  int l=result.length();
+  bool addEllipsis=FALSE;
+  while ((i=nextUtf8CharPosition(result,l,i))<l)
+  {
     charCnt++;
-    if (charCnt >= 80)
-      break;
+    if (charCnt>=80) break;
   }
-  if (charCnt >= 80) // try to truncate the string
+  if (charCnt>=80) // try to truncate the string
   {
-    while ((i = nextUtf8CharPosition(result, l, i)) < l && charCnt < 100) {
+    while ((i=nextUtf8CharPosition(result,l,i))<l && charCnt<100)
+    {
       charCnt++;
-      if (result.at(i) >= 0 && isspace(result.at(i))) {
-        addEllipsis = TRUE;
-      } else if (result.at(i) == ',' || result.at(i) == '.' ||
-                 result.at(i) == '?') {
+      if (result.at(i)>=0 && isspace(result.at(i)))
+      {
+        addEllipsis=TRUE;
+      }
+      else if (result.at(i)==',' || 
+               result.at(i)=='.' || 
+               result.at(i)=='?')
+      {
         break;
       }
     }
   }
-  if (addEllipsis || charCnt == 100)
-    result = result.left(i) + "...";
+  if (addEllipsis || charCnt==100) result=result.left(i)+"...";
   return result.data();
 }
 
@@ -7207,17 +7399,18 @@ QCString parseCommentAsText(const Definition *scope, const MemberDef *md,
 
 static QDict<void> aliasesProcessed;
 
-static QCString expandAliasRec(const QCString s, bool allowRecursion = FALSE);
+static QCString expandAliasRec(const QCString s,bool allowRecursion=FALSE);
 
-struct Marker {
-  Marker(int p, int n, int s) : pos(p), number(n), size(s) {}
-  int pos;    // position in the string
+struct Marker
+{
+  Marker(int p, int n,int s) : pos(p),number(n),size(s) {}
+  int pos; // position in the string
   int number; // argument number
-  int size;   // size of the marker
+  int size; // size of the marker
 };
 
-/** For a string \a s that starts with a command name, returns the character
- *  offset within that string representing the first character after the
+/** For a string \a s that starts with a command name, returns the character 
+ *  offset within that string representing the first character after the 
  *  command. For an alias with argument, this is the offset to the
  *  character just after the argument list.
  *
@@ -7226,278 +7419,298 @@ struct Marker {
  *  - s=="a{2,3} b" returns 6
  *  = s=="#"        returns 0
  */
-static int findEndOfCommand(const char *s) {
+static int findEndOfCommand(const char *s)
+{
   const char *p = s;
   char c;
-  int i = 0;
-  if (p) {
-    while ((c = *p) && isId(c))
-      p++;
-    if (c == '{') {
-      QCString args = extractAliasArgs(p, 0);
-      i += args.length();
+  int i=0;
+  if (p)
+  {
+    while ((c=*p) && isId(c)) p++;
+    if (c=='{')
+    {
+      QCString args = extractAliasArgs(p,0);
+      i+=args.length();
     }
-    i += p - s;
+    i+=p-s;
   }
   return i;
 }
 
-/** Replaces the markers in an alias definition \a aliasValue
- *  with the corresponding values found in the comma separated argument
+/** Replaces the markers in an alias definition \a aliasValue 
+ *  with the corresponding values found in the comma separated argument 
  *  list \a argList and the returns the result after recursive alias expansion.
  */
-static QCString replaceAliasArguments(const QCString &aliasValue,
-                                      const QCString &argList) {
-  // printf("-----
-  // replaceAliasArguments(val=[%s],args=[%s])\n",aliasValue.data(),argList.data());
+static QCString replaceAliasArguments(const QCString &aliasValue,const QCString &argList)
+{
+  //printf("----- replaceAliasArguments(val=[%s],args=[%s])\n",aliasValue.data(),argList.data());
 
   // first make a list of arguments from the comma separated argument list
   QList<QCString> args;
   args.setAutoDelete(TRUE);
-  int i, l = (int)argList.length();
-  int s = 0;
-  for (i = 0; i < l; i++) {
+  int i,l=(int)argList.length();
+  int s=0;
+  for (i=0;i<l;i++)
+  {
     char c = argList.at(i);
-    if (c == ',' && (i == 0 || argList.at(i - 1) != '\\')) {
-      args.append(new QCString(argList.mid(s, i - s)));
-      s = i + 1; // start of next argument
-    } else if (c == '@' || c == '\\') {
+    if (c==',' && (i==0 || argList.at(i-1)!='\\')) 
+    {
+      args.append(new QCString(argList.mid(s,i-s)));
+      s=i+1; // start of next argument
+    }
+    else if (c=='@' || c=='\\')
+    {
       // check if this is the start of another aliased command (see bug704172)
-      i += findEndOfCommand(argList.data() + i + 1);
+      i+=findEndOfCommand(argList.data()+i+1);
     }
   }
-  if (l > s)
-    args.append(new QCString(argList.right(l - s)));
-  // printf("found %d arguments\n",args.count());
+  if (l>s) args.append(new QCString(argList.right(l-s)));
+  //printf("found %d arguments\n",args.count());
 
   // next we look for the positions of the markers and add them to a list
   QList<Marker> markerList;
   markerList.setAutoDelete(TRUE);
   l = aliasValue.length();
-  int markerStart = 0;
-  int markerEnd = 0;
-  for (i = 0; i < l; i++) {
-    if (markerStart == 0 && aliasValue.at(i) == '\\') // start of a \xx marker
-    {
-      markerStart = i + 1;
-    } else if (markerStart > 0 && aliasValue.at(i) >= '0' &&
-               aliasValue.at(i) <= '9') {
+  int markerStart=0;
+  int markerEnd=0;
+  for (i=0;i<l;i++)
+  {
+    if (markerStart==0 && aliasValue.at(i)=='\\') // start of a \xx marker
+    {
+      markerStart=i+1;
+    }
+    else if (markerStart>0 && aliasValue.at(i)>='0' && aliasValue.at(i)<='9')
+    {
       // read digit that make up the marker number
-      markerEnd = i + 1;
-    } else {
-      if (markerStart > 0 && markerEnd > markerStart) // end of marker
-      {
-        int markerLen = markerEnd - markerStart;
-        markerList.append(new Marker(
-            markerStart - 1, // include backslash
-            atoi(aliasValue.mid(markerStart, markerLen)), markerLen + 1));
-        // printf("found marker at %d with len %d and number %d\n",
+      markerEnd=i+1;
+    }
+    else
+    {
+      if (markerStart>0 && markerEnd>markerStart) // end of marker
+      {
+        int markerLen = markerEnd-markerStart;
+        markerList.append(new Marker(markerStart-1, // include backslash
+                    atoi(aliasValue.mid(markerStart,markerLen)),markerLen+1));
+        //printf("found marker at %d with len %d and number %d\n",
         //    markerStart-1,markerLen+1,atoi(aliasValue.mid(markerStart,markerLen)));
       }
-      markerStart = 0; // outside marker
-      markerEnd = 0;
+      markerStart=0; // outside marker
+      markerEnd=0;
     }
   }
-  if (markerStart > 0) {
-    markerEnd = l;
+  if (markerStart>0)
+  {
+    markerEnd=l;
   }
-  if (markerStart > 0 && markerEnd > markerStart) {
-    int markerLen = markerEnd - markerStart;
-    markerList.append(new Marker(markerStart - 1, // include backslash
-                                 atoi(aliasValue.mid(markerStart, markerLen)),
-                                 markerLen + 1));
-    // printf("found marker at %d with len %d and number %d\n",
-    //    markerStart-1,markerLen+1,atoi(aliasValue.mid(markerStart,markerLen)));
+  if (markerStart>0 && markerEnd>markerStart)
+  {
+     int markerLen = markerEnd-markerStart;
+     markerList.append(new Marker(markerStart-1, // include backslash
+                 atoi(aliasValue.mid(markerStart,markerLen)),markerLen+1));
+     //printf("found marker at %d with len %d and number %d\n",
+     //    markerStart-1,markerLen+1,atoi(aliasValue.mid(markerStart,markerLen)));
   }
 
   // then we replace the markers with the corresponding arguments in one pass
   QCString result;
-  int p = 0;
-  for (i = 0; i < (int)markerList.count(); i++) {
+  int p=0;
+  for (i=0;i<(int)markerList.count();i++)
+  {
     Marker *m = markerList.at(i);
-    result += aliasValue.mid(p, m->pos - p);
-    // printf("part before marker %d:
-    // '%s'\n",i,aliasValue.mid(p,m->pos-p).data());
-    if (m->number > 0 && m->number <= (int)args.count()) // valid number
-    {
-      result += expandAliasRec(*args.at(m->number - 1), TRUE);
-      // printf("marker index=%d pos=%d number=%d size=%d replacement
-      // %s\n",i,m->pos,m->number,m->size,
+    result+=aliasValue.mid(p,m->pos-p);
+    //printf("part before marker %d: '%s'\n",i,aliasValue.mid(p,m->pos-p).data());
+    if (m->number>0 && m->number<=(int)args.count()) // valid number
+    {
+      result+=expandAliasRec(*args.at(m->number-1),TRUE);
+      //printf("marker index=%d pos=%d number=%d size=%d replacement %s\n",i,m->pos,m->number,m->size,
       //    args.at(m->number-1)->data());
     }
-    p = m->pos + m->size; // continue after the marker
+    p=m->pos+m->size; // continue after the marker
   }
-  result += aliasValue.right(l - p); // append remainder
-  // printf("string after replacement of markers: '%s'\n",result.data());
+  result+=aliasValue.right(l-p); // append remainder
+  //printf("string after replacement of markers: '%s'\n",result.data());
 
   // expand the result again
-  result = substitute(result, "\\{", "{");
-  result = substitute(result, "\\}", "}");
-  result = expandAliasRec(substitute(result, "\\,", ","));
+  result = substitute(result,"\\{","{");
+  result = substitute(result,"\\}","}");
+  result = expandAliasRec(substitute(result,"\\,",","));
 
   return result;
 }
 
-static QCString escapeCommas(const QCString &s) {
+static QCString escapeCommas(const QCString &s)
+{
   QGString result;
   const char *p = s.data();
-  char c, pc = 0;
-  while ((c = *p++)) {
-    if (c == ',' && pc != '\\') {
-      result += "\\,";
-    } else {
-      result += c;
+  char c,pc=0;
+  while ((c=*p++))
+  {
+    if (c==',' && pc!='\\')
+    {
+      result+="\\,";
     }
-    pc = c;
+    else
+    {
+      result+=c;
+    }
+    pc=c;
   }
-  result += '\0';
-  // printf("escapeCommas: '%s'->'%s'\n",s.data(),result.data());
+  result+='\0';
+  //printf("escapeCommas: '%s'->'%s'\n",s.data(),result.data());
   return result.data();
 }
 
-static QCString expandAliasRec(const QCString s, bool allowRecursion) {
+static QCString expandAliasRec(const QCString s,bool allowRecursion)
+{
   QCString result;
   static QRegExp cmdPat("[\\\\@][a-z_A-Z][a-z_A-Z0-9]*");
-  QCString value = s;
-  int i, p = 0, l;
-  while ((i = cmdPat.match(value, p, &l)) != -1) {
-    result += value.mid(p, i - p);
-    QCString args = extractAliasArgs(value, i + l);
-    bool hasArgs = !args.isEmpty(); // found directly after command
+  QCString value=s;
+  int i,p=0,l;
+  while ((i=cmdPat.match(value,p,&l))!=-1)
+  {
+    result+=value.mid(p,i-p);
+    QCString args = extractAliasArgs(value,i+l);
+    bool hasArgs = !args.isEmpty();            // found directly after command
     int argsLen = args.length();
-    QCString cmd = value.mid(i + 1, l - 1);
+    QCString cmd = value.mid(i+1,l-1);
     QCString cmdNoArgs = cmd;
-    int numArgs = 0;
-    if (hasArgs) {
+    int numArgs=0;
+    if (hasArgs)
+    {
       numArgs = countAliasArguments(args);
-      cmd += QCString().sprintf("{%d}", numArgs); // alias name + {n}
-    }
-    QCString *aliasText = Doxygen::aliasDict.find(cmd);
-    if (numArgs > 1 && aliasText == 0) { // in case there is no command with
-                                         // numArgs parameters, but there is a
-                                         // command with 1 parameter,
-      // we also accept all text as the argument of that command (so you don't
-      // have to escape commas)
-      aliasText = Doxygen::aliasDict.find(cmdNoArgs + "{1}");
-      if (aliasText) {
-        cmd = cmdNoArgs + "{1}";
-        args = escapeCommas(
-            args); // escape , so that everything is seen as one argument
-      }
-    }
-    // printf("Found command s='%s' cmd='%s' numArgs=%d args='%s'
-    // aliasText=%s\n",
+      cmd += QCString().sprintf("{%d}",numArgs);  // alias name + {n}
+    }
+    QCString *aliasText=Doxygen::aliasDict.find(cmd);
+    if (numArgs>1 && aliasText==0) 
+    { // in case there is no command with numArgs parameters, but there is a command with 1 parameter, 
+      // we also accept all text as the argument of that command (so you don't have to escape commas)
+      aliasText=Doxygen::aliasDict.find(cmdNoArgs+"{1}");
+      if (aliasText)
+      {
+        cmd = cmdNoArgs+"{1}";
+        args = escapeCommas(args); // escape , so that everything is seen as one argument
+      }
+    }
+    //printf("Found command s='%s' cmd='%s' numArgs=%d args='%s' aliasText=%s\n",
     //    s.data(),cmd.data(),numArgs,args.data(),aliasText?aliasText->data():"<none>");
-    if ((allowRecursion || aliasesProcessed.find(cmd) == 0) &&
-        aliasText) // expand the alias
+    if ((allowRecursion || aliasesProcessed.find(cmd)==0) && aliasText) // expand the alias
     {
-      // printf("is an alias!\n");
-      if (!allowRecursion)
-        aliasesProcessed.insert(cmd, (void *)0x8);
+      //printf("is an alias!\n");
+      if (!allowRecursion) aliasesProcessed.insert(cmd,(void *)0x8);
       QCString val = *aliasText;
-      if (hasArgs) {
-        val = replaceAliasArguments(val, args);
-        // printf("replace '%s'->'%s' args='%s'\n",
+      if (hasArgs)
+      {
+        val = replaceAliasArguments(val,args);
+        //printf("replace '%s'->'%s' args='%s'\n",
         //       aliasText->data(),val.data(),args.data());
       }
-      result += expandAliasRec(val);
-      if (!allowRecursion)
-        aliasesProcessed.remove(cmd);
-      p = i + l;
-      if (hasArgs)
-        p += argsLen + 2;
-    } else // command is not an alias
+      result+=expandAliasRec(val);
+      if (!allowRecursion) aliasesProcessed.remove(cmd);
+      p=i+l;
+      if (hasArgs) p+=argsLen+2;
+    }
+    else // command is not an alias
     {
-      // printf("not an alias!\n");
-      result += value.mid(i, l);
-      p = i + l;
+      //printf("not an alias!\n");
+      result+=value.mid(i,l);
+      p=i+l;
     }
   }
-  result += value.right(value.length() - p);
+  result+=value.right(value.length()-p);
 
-  // printf("expandAliases '%s'->'%s'\n",s.data(),result.data());
+  //printf("expandAliases '%s'->'%s'\n",s.data(),result.data());
   return result;
 }
 
-int countAliasArguments(const QCString argList) {
-  int count = 1;
+
+int countAliasArguments(const QCString argList)
+{
+  int count=1;
   int l = argList.length();
   int i;
-  for (i = 0; i < l; i++) {
+  for (i=0;i<l;i++) 
+  {
     char c = argList.at(i);
-    if (c == ',' && (i == 0 || argList.at(i - 1) != '\\'))
-      count++;
-    else if (c == '@' || c == '\\') {
+    if (c==',' && (i==0 || argList.at(i-1)!='\\')) count++;
+    else if (c=='@' || c=='\\')
+    {
       // check if this is the start of another aliased command (see bug704172)
-      i += findEndOfCommand(argList.data() + i + 1);
+      i+=findEndOfCommand(argList.data()+i+1);
     }
   }
-  // printf("countAliasArguments=%d\n",count);
+  //printf("countAliasArguments=%d\n",count);
   return count;
 }
 
-QCString extractAliasArgs(const QCString &args, int pos) {
+QCString extractAliasArgs(const QCString &args,int pos)
+{
   int i;
-  int bc = 0;
-  char prevChar = 0;
-  if (args.at(pos) == '{') // alias has argument
+  int bc=0;
+  char prevChar=0;
+  if (args.at(pos)=='{') // alias has argument
   {
-    for (i = pos; i < (int)args.length(); i++) {
-      if (prevChar != '\\') {
-        if (args.at(i) == '{')
-          bc++;
-        if (args.at(i) == '}')
-          bc--;
-        prevChar = args.at(i);
-      } else {
-        prevChar = 0;
+    for (i=pos;i<(int)args.length();i++)
+    {
+      if (prevChar!='\\')
+      {
+        if (args.at(i)=='{') bc++;
+        if (args.at(i)=='}') bc--;
+        prevChar=args.at(i);
+      }
+      else
+      {
+        prevChar=0;
       }
 
-      if (bc == 0) {
-        // printf("extractAliasArgs('%s')->'%s'\n",args.data(),args.mid(pos+1,i-pos-1).data());
-        return args.mid(pos + 1, i - pos - 1);
+      if (bc==0) 
+      {
+        //printf("extractAliasArgs('%s')->'%s'\n",args.data(),args.mid(pos+1,i-pos-1).data());
+        return args.mid(pos+1,i-pos-1);
       }
     }
   }
   return "";
 }
 
-QCString resolveAliasCmd(const QCString aliasCmd) {
+QCString resolveAliasCmd(const QCString aliasCmd)
+{
   QCString result;
   aliasesProcessed.clear();
-  // printf("Expanding: '%s'\n",aliasCmd.data());
+  //printf("Expanding: '%s'\n",aliasCmd.data());
   result = expandAliasRec(aliasCmd);
-  // printf("Expanding result: '%s'->'%s'\n",aliasCmd.data(),result.data());
+  //printf("Expanding result: '%s'->'%s'\n",aliasCmd.data(),result.data());
   return result;
 }
 
-QCString expandAlias(const QCString &aliasName, const QCString &aliasValue) {
+QCString expandAlias(const QCString &aliasName,const QCString &aliasValue)
+{
   QCString result;
   aliasesProcessed.clear();
   // avoid expanding this command recursively
-  aliasesProcessed.insert(aliasName, (void *)0x8);
+  aliasesProcessed.insert(aliasName,(void *)0x8);
   // expand embedded commands
-  // printf("Expanding: '%s'->'%s'\n",aliasName.data(),aliasValue.data());
+  //printf("Expanding: '%s'->'%s'\n",aliasName.data(),aliasValue.data());
   result = expandAliasRec(aliasValue);
-  // printf("Expanding result: '%s'->'%s'\n",aliasName.data(),result.data());
+  //printf("Expanding result: '%s'->'%s'\n",aliasName.data(),result.data());
   return result;
 }
 
-void writeTypeConstraints(OutputList &ol, Definition *d, ArgumentList *al) {
-  if (al == 0)
-    return;
-  ol.startConstraintList(theTranslator->trTypeConstraints());
+void writeTypeConstraints(OutputList &ol,Definition *d,ArgumentList *al)
+{
+  if (al==0) return;
+  ol.startConstraintList(theTranslator->trTypeConstraints()); 
   ArgumentListIterator ali(*al);
   Argument *a;
-  for (; (a = ali.current()); ++ali) {
+  for (;(a=ali.current());++ali)
+  {
     ol.startConstraintParam();
     ol.parseText(a->name);
     ol.endConstraintParam();
     ol.startConstraintType();
-    linkifyText(TextGeneratorOLImpl(ol), d, 0, 0, a->type);
+    linkifyText(TextGeneratorOLImpl(ol),d,0,0,a->type);
     ol.endConstraintType();
     ol.startConstraintDocs();
-    ol.generateDoc(d->docFile(), d->docLine(), d, 0, a->docs, TRUE, FALSE);
+    ol.generateDoc(d->docFile(),d->docLine(),d,0,a->docs,TRUE,FALSE);
     ol.endConstraintDocs();
   }
   ol.endConstraintList();
@@ -7505,60 +7718,64 @@ void writeTypeConstraints(OutputList &ol, Definition *d, ArgumentList *al) {
 
 //----------------------------------------------------------------------------
 
-void stackTrace() {
+void stackTrace()
+{
 #ifdef TRACINGSUPPORT
   void *backtraceFrames[128];
   int frameCount = backtrace(backtraceFrames, 128);
   static char cmd[40960];
   char *p = cmd;
-  p += sprintf(p, "/usr/bin/atos -p %d ", (int)getpid());
-  for (int x = 0; x < frameCount; x++) {
-    p += sprintf(p, "%p ", backtraceFrames[x]);
+  p += sprintf(p,"/usr/bin/atos -p %d ", (int)getpid());
+  for (int x = 0; x < frameCount; x++) 
+  {
+    p += sprintf(p,"%p ", backtraceFrames[x]);
   }
-  fprintf(stderr, "========== STACKTRACE START ==============\n");
-  if (FILE *fp = popen(cmd, "r")) {
+  fprintf(stderr,"========== STACKTRACE START ==============\n");
+  if (FILE *fp = popen(cmd, "r"))
+  {
     char resBuf[512];
-    while (size_t len = fread(resBuf, 1, sizeof(resBuf), fp)) {
+    while (size_t len = fread(resBuf, 1, sizeof(resBuf), fp))
+    {
       fwrite(resBuf, 1, len, stderr);
     }
     pclose(fp);
   }
-  fprintf(stderr, "============ STACKTRACE END ==============\n");
-// fprintf(stderr,"%s\n", frameStrings[x]);
+  fprintf(stderr,"============ STACKTRACE END ==============\n");
+  //fprintf(stderr,"%s\n", frameStrings[x]);
 #endif
 }
 
-static int transcodeCharacterBuffer(const char *fileName, BufStr &srcBuf,
-                                    int size, const char *inputEncoding,
-                                    const char *outputEncoding) {
-  if (inputEncoding == 0 || outputEncoding == 0)
-    return size;
-  if (qstricmp(inputEncoding, outputEncoding) == 0)
-    return size;
-  void *cd = portable_iconv_open(outputEncoding, inputEncoding);
-  if (cd == (void *)(-1)) {
+static int transcodeCharacterBuffer(const char *fileName,BufStr &srcBuf,int size,
+           const char *inputEncoding,const char *outputEncoding)
+{
+  if (inputEncoding==0 || outputEncoding==0) return size;
+  if (qstricmp(inputEncoding,outputEncoding)==0) return size;
+  void *cd = portable_iconv_open(outputEncoding,inputEncoding);
+  if (cd==(void *)(-1)) 
+  {
     err("unsupported character conversion: '%s'->'%s': %s\n"
         "Check the INPUT_ENCODING setting in the config file!\n",
-        inputEncoding, outputEncoding, strerror(errno));
+        inputEncoding,outputEncoding,strerror(errno));
     exit(1);
   }
-  int tmpBufSize = size * 4 + 1;
+  int tmpBufSize=size*4+1;
   BufStr tmpBuf(tmpBufSize);
-  size_t iLeft = size;
-  size_t oLeft = tmpBufSize;
+  size_t iLeft=size;
+  size_t oLeft=tmpBufSize;
   char *srcPtr = srcBuf.data();
   char *dstPtr = tmpBuf.data();
-  uint newSize = 0;
-  if (!portable_iconv(cd, &srcPtr, &iLeft, &dstPtr, &oLeft)) {
-    newSize = tmpBufSize - (int)oLeft;
+  uint newSize=0;
+  if (!portable_iconv(cd, &srcPtr, &iLeft, &dstPtr, &oLeft))
+  {
+    newSize = tmpBufSize-(int)oLeft;
     srcBuf.shrink(newSize);
-    strncpy(srcBuf.data(), tmpBuf.data(), newSize);
-    // printf("iconv: input size=%d output
-    // size=%d\n[%s]\n",size,newSize,srcBuf.data());
-  } else {
-    err("%s: failed to translate characters from %s to %s: check "
-        "INPUT_ENCODING\n",
-        fileName, inputEncoding, outputEncoding);
+    strncpy(srcBuf.data(),tmpBuf.data(),newSize);
+    //printf("iconv: input size=%d output size=%d\n[%s]\n",size,newSize,srcBuf.data());
+  }
+  else
+  {
+    err("%s: failed to translate characters from %s to %s: check INPUT_ENCODING\n",
+        fileName,inputEncoding,outputEncoding);
     exit(1);
   }
   portable_iconv_close(cd);
@@ -7566,99 +7783,110 @@ static int transcodeCharacterBuffer(const char *fileName, BufStr &srcBuf,
 }
 
 //! read a file name \a fileName and optionally filter and transcode it
-bool readInputFile(const char *fileName, BufStr &inBuf, bool filter,
-                   bool isSourceCode) {
+bool readInputFile(const char *fileName,BufStr &inBuf,bool filter,bool isSourceCode)
+{
   // try to open file
-  int size = 0;
-  // uint oldPos = dest.curPos();
-  // printf(".......oldPos=%d\n",oldPos);
+  int size=0;
+  //uint oldPos = dest.curPos();
+  //printf(".......oldPos=%d\n",oldPos);
 
   QFileInfo fi(fileName);
-  if (!fi.exists())
-    return FALSE;
-  QCString filterName = getFileFilter(fileName, isSourceCode);
-  if (filterName.isEmpty() || !filter) {
+  if (!fi.exists()) return FALSE;
+  QCString filterName = getFileFilter(fileName,isSourceCode);
+  if (filterName.isEmpty() || !filter)
+  {
     QFile f(fileName);
-    if (!f.open(IO_ReadOnly)) {
-      err("could not open file %s\n", fileName);
+    if (!f.open(IO_ReadOnly))
+    {
+      err("could not open file %s\n",fileName);
       return FALSE;
     }
-    size = fi.size();
+    size=fi.size();
     // read the file
     inBuf.skip(size);
-    if (f.readBlock(inBuf.data() /*+oldPos*/, size) != size) {
-      err("problems while reading file %s\n", fileName);
+    if (f.readBlock(inBuf.data()/*+oldPos*/,size)!=size)
+    {
+      err("problems while reading file %s\n",fileName);
       return FALSE;
     }
-  } else {
-    QCString cmd = filterName + " \"" + fileName + "\"";
-    Debug::print(Debug::ExtCmd, 0, "Executing popen(`%s`)\n", qPrint(cmd));
-    FILE *f = portable_popen(cmd, "r");
-    if (!f) {
-      err("could not execute filter %s\n", filterName.data());
+  }
+  else
+  {
+    QCString cmd=filterName+" \""+fileName+"\"";
+    Debug::print(Debug::ExtCmd,0,"Executing popen(`%s`)\n",qPrint(cmd));
+    FILE *f=portable_popen(cmd,"r");
+    if (!f)
+    {
+      err("could not execute filter %s\n",filterName.data());
       return FALSE;
     }
-    const int bufSize = 1024;
+    const int bufSize=1024;
     char buf[bufSize];
     int numRead;
-    while ((numRead = (int)fread(buf, 1, bufSize, f)) > 0) {
-      // printf(">>>>>>>>Reading %d bytes\n",numRead);
-      inBuf.addArray(buf, numRead), size += numRead;
+    while ((numRead=(int)fread(buf,1,bufSize,f))>0)
+    {
+      //printf(">>>>>>>>Reading %d bytes\n",numRead);
+      inBuf.addArray(buf,numRead),size+=numRead;
     }
     portable_pclose(f);
-    inBuf.at(inBuf.curPos()) = '\0';
+    inBuf.at(inBuf.curPos()) ='\0';
     Debug::print(Debug::FilterOutput, 0, "Filter output\n");
-    Debug::print(Debug::FilterOutput, 0, "-------------\n%s\n-------------\n",
-                 qPrint(inBuf));
+    Debug::print(Debug::FilterOutput,0,"-------------\n%s\n-------------\n",qPrint(inBuf));
   }
 
-  int start = 0;
-  if (size >= 2 &&
-      ((inBuf.at(0) == -1 && inBuf.at(1) == -2) || // Litte endian BOM
-       (inBuf.at(0) == -2 && inBuf.at(1) == -1)    // big endian BOM
-       ))                                          // UCS-2 encoded file
+  int start=0;
+  if (size>=2 &&
+      ((inBuf.at(0)==-1 && inBuf.at(1)==-2) || // Litte endian BOM
+       (inBuf.at(0)==-2 && inBuf.at(1)==-1)    // big endian BOM
+      )
+     ) // UCS-2 encoded file
   {
-    transcodeCharacterBuffer(fileName, inBuf, inBuf.curPos(), "UCS-2", "UTF-8");
-  } else if (size >= 3 && (uchar)inBuf.at(0) == 0xEF &&
-             (uchar)inBuf.at(1) == 0xBB &&
-             (uchar)inBuf.at(2) == 0xBF) // UTF-8 encoded file
+    transcodeCharacterBuffer(fileName,inBuf,inBuf.curPos(),
+        "UCS-2","UTF-8");
+  }
+  else if (size>=3 &&
+           (uchar)inBuf.at(0)==0xEF &&
+           (uchar)inBuf.at(1)==0xBB &&
+           (uchar)inBuf.at(2)==0xBF
+     ) // UTF-8 encoded file
   {
     inBuf.dropFromStart(3); // remove UTF-8 BOM: no translation needed
-  } else                    // transcode according to the INPUT_ENCODING setting
+  }
+  else // transcode according to the INPUT_ENCODING setting
   {
     // do character transcoding if needed.
-    transcodeCharacterBuffer(fileName, inBuf, inBuf.curPos(),
-                             Config_getString(INPUT_ENCODING), "UTF-8");
+    transcodeCharacterBuffer(fileName,inBuf,inBuf.curPos(),
+        Config_getString(INPUT_ENCODING),"UTF-8");
   }
 
-  // inBuf.addChar('\n'); /* to prevent problems under Windows ? */
+  //inBuf.addChar('\n'); /* to prevent problems under Windows ? */
 
   // and translate CR's
-  size = inBuf.curPos() - start;
-  int newSize = filterCRLF(inBuf.data() + start, size);
-  // printf("filter char at %p size=%d
-  // newSize=%d\n",dest.data()+oldPos,size,newSize);
-  if (newSize != size) // we removed chars
+  size=inBuf.curPos()-start;
+  int newSize=filterCRLF(inBuf.data()+start,size);
+  //printf("filter char at %p size=%d newSize=%d\n",dest.data()+oldPos,size,newSize);
+  if (newSize!=size) // we removed chars
   {
     inBuf.shrink(newSize); // resize the array
-    // printf(".......resizing from %d to %d
-    // result=[%s]\n",oldPos+size,oldPos+newSize,dest.data());
+    //printf(".......resizing from %d to %d result=[%s]\n",oldPos+size,oldPos+newSize,dest.data());
   }
   inBuf.addChar(0);
   return TRUE;
 }
 
 // Replace %word by word in title
-QCString filterTitle(const QCString &title) {
+QCString filterTitle(const QCString &title)
+{
   QCString tf;
   static QRegExp re("%[A-Z_a-z]");
-  int p = 0, i, l;
-  while ((i = re.match(title, p, &l)) != -1) {
-    tf += title.mid(p, i - p);
-    tf += title.mid(i + 1, l - 1); // skip %
-    p = i + l;
+  int p=0,i,l;
+  while ((i=re.match(title,p,&l))!=-1)
+  {
+    tf+=title.mid(p,i-p);
+    tf+=title.mid(i+1,l-1); // skip %
+    p=i+l;
   }
-  tf += title.right(title.length() - p);
+  tf+=title.right(title.length()-p);
   return tf;
 }
 
@@ -7666,32 +7894,35 @@ QCString filterTitle(const QCString &title) {
 // returns TRUE if the name of the file represented by `fi' matches
 // one of the file patterns in the `patList' list.
 
-bool patternMatch(const QFileInfo &fi, const QStrList *patList) {
-  bool found = FALSE;
-  if (patList) {
+bool patternMatch(const QFileInfo &fi,const QStrList *patList)
+{
+  bool found=FALSE;
+  if (patList)
+  { 
     QStrListIterator it(*patList);
     QCString pattern;
 
     QCString fn = fi.fileName().data();
     QCString fp = fi.filePath().data();
-    QCString afp = fi.absFilePath().data();
+    QCString afp= fi.absFilePath().data();
 
-    for (it.toFirst(); (pattern = it.current()); ++it) {
-      if (!pattern.isEmpty()) {
-        int i = pattern.find('=');
-        if (i != -1)
-          pattern =
-              pattern.left(i); // strip of the extension specific filter name
+    for (it.toFirst();(pattern=it.current());++it)
+    {
+      if (!pattern.isEmpty())
+      {
+        int i=pattern.find('=');
+        if (i!=-1) pattern=pattern.left(i); // strip of the extension specific filter name
 
 #if defined(_WIN32) || defined(__MACOSX__) // Windows or MacOSX
-        QRegExp re(pattern, FALSE, TRUE);  // case insensitive match
-#else // unix
-        QRegExp re(pattern, TRUE, TRUE); // case sensitive match
+        QRegExp re(pattern,FALSE,TRUE); // case insensitive match 
+#else                // unix
+        QRegExp re(pattern,TRUE,TRUE);  // case sensitive match
 #endif
-        found = re.match(fn) != -1 || re.match(fp) != -1 || re.match(afp) != -1;
-        if (found)
-          break;
-        // printf("Matching `%s' against pattern `%s' found=%d\n",
+        found = re.match(fn)!=-1 ||
+                re.match(fp)!=-1 ||
+                re.match(afp)!=-1;
+        if (found) break;
+        //printf("Matching `%s' against pattern `%s' found=%d\n",
         //    fi->fileName().data(),pattern.data(),found);
       }
     }
@@ -7729,58 +7960,64 @@ void writeSummaryLink(OutputList &ol,const char *label,const char *title,
 }
 #endif
 
-QCString externalLinkTarget() {
+QCString externalLinkTarget()
+{
   static bool extLinksInWindow = Config_getBool(EXT_LINKS_IN_WINDOW);
-  if (extLinksInWindow)
-    return "target=\"_blank\" ";
-  else
-    return "";
+  if (extLinksInWindow) return "target=\"_blank\" "; else return "";
 }
 
-QCString externalRef(const QCString &relPath, const QCString &ref, bool href) {
+QCString externalRef(const QCString &relPath,const QCString &ref,bool href)
+{
   QCString result;
-  if (!ref.isEmpty()) {
+  if (!ref.isEmpty())
+  {
     QCString *dest = Doxygen::tagDestinationDict[ref];
-    if (dest) {
+    if (dest)
+    {
       result = *dest;
       int l = result.length();
-      if (!relPath.isEmpty() && l > 0 &&
-          result.at(0) == '.') { // relative path -> prepend relPath.
+      if (!relPath.isEmpty() && l>0 && result.at(0)=='.')
+      { // relative path -> prepend relPath.
         result.prepend(relPath);
-        l += relPath.length();
+        l+=relPath.length();
       }
-      if (!href) {
-        result.prepend("doxygen=\"" + ref + ":");
-        l += 10 + ref.length();
+      if (!href){
+        result.prepend("doxygen=\""+ref+":");
+        l+=10+ref.length();
       }
-      if (l > 0 && result.at(l - 1) != '/')
-        result += '/';
-      if (!href)
-        result.append("\" ");
+      if (l>0 && result.at(l-1)!='/') result+='/';
+      if (!href) result.append("\" ");
     }
-  } else {
+  }
+  else
+  {
     result = relPath;
   }
   return result;
 }
 
-/** Writes the intensity only bitmap representated by \a data as an image to
+/** Writes the intensity only bitmap representated by \a data as an image to 
  *  directory \a dir using the colors defined by HTML_COLORSTYLE_*.
  */
-void writeColoredImgData(const char *dir, ColoredImgDataItem data[]) {
-  static int hue = Config_getInt(HTML_COLORSTYLE_HUE);
-  static int sat = Config_getInt(HTML_COLORSTYLE_SAT);
+void writeColoredImgData(const char *dir,ColoredImgDataItem data[])
+{
+  static int hue   = Config_getInt(HTML_COLORSTYLE_HUE);
+  static int sat   = Config_getInt(HTML_COLORSTYLE_SAT);
   static int gamma = Config_getInt(HTML_COLORSTYLE_GAMMA);
-  while (data->name) {
+  while (data->name)
+  {
     QCString fileName;
-    fileName = (QCString)dir + "/" + data->name;
+    fileName=(QCString)dir+"/"+data->name;
     QFile f(fileName);
-    if (f.open(IO_WriteOnly)) {
-      ColoredImage img(data->width, data->height, data->content, data->alpha,
-                       sat, hue, gamma);
+    if (f.open(IO_WriteOnly))
+    {
+      ColoredImage img(data->width,data->height,data->content,data->alpha,
+                       sat,hue,gamma);
       img.save(fileName);
-    } else {
-      fprintf(stderr, "Warning: Cannot open file %s for writing\n", data->name);
+    }
+    else
+    {
+      fprintf(stderr,"Warning: Cannot open file %s for writing\n",data->name);
     }
     Doxygen::indexList->addImageFile(data->name);
     data++;
@@ -7788,196 +8025,193 @@ void writeColoredImgData(const char *dir, ColoredImgDataItem data[]) {
 }
 
 /** Replaces any markers of the form \#\#AA in input string \a str
- *  by new markers of the form \#AABBCC, where \#AABBCC represents a
- *  valid color, based on the intensity represented by hex number AA
+ *  by new markers of the form \#AABBCC, where \#AABBCC represents a 
+ *  valid color, based on the intensity represented by hex number AA 
  *  and the current HTML_COLORSTYLE_* settings.
  */
-QCString replaceColorMarkers(const char *str) {
+QCString replaceColorMarkers(const char *str)
+{
   QCString result;
-  QCString s = str;
-  if (s.isEmpty())
-    return result;
+  QCString s=str;
+  if (s.isEmpty()) return result;
   static QRegExp re("##[0-9A-Fa-f][0-9A-Fa-f]");
   static const char hex[] = "0123456789ABCDEF";
-  static int hue = Config_getInt(HTML_COLORSTYLE_HUE);
-  static int sat = Config_getInt(HTML_COLORSTYLE_SAT);
+  static int hue   = Config_getInt(HTML_COLORSTYLE_HUE);
+  static int sat   = Config_getInt(HTML_COLORSTYLE_SAT);
   static int gamma = Config_getInt(HTML_COLORSTYLE_GAMMA);
-  int i, l, sl = s.length(), p = 0;
-  while ((i = re.match(s, p, &l)) != -1) {
-    result += s.mid(p, i - p);
-    QCString lumStr = s.mid(i + 2, l - 2);
-#define HEXTONUM(x)                                                            \
-  (((x) >= '0' && (x) <= '9')                                                  \
-       ? ((x) - '0')                                                           \
-       : ((x) >= 'a' && (x) <= 'f')                                            \
-             ? ((x) - 'a' + 10)                                                \
-             : ((x) >= 'A' && (x) <= 'F') ? ((x) - 'A' + 10) : 0)
-
-    double r, g, b;
-    int red, green, blue;
-    int level = HEXTONUM(lumStr[0]) * 16 + HEXTONUM(lumStr[1]);
-    ColoredImage::hsl2rgb(hue / 360.0, sat / 255.0,
-                          pow(level / 255.0, gamma / 100.0), &r, &g, &b);
-    red = (int)(r * 255.0);
-    green = (int)(g * 255.0);
-    blue = (int)(b * 255.0);
+  int i,l,sl=s.length(),p=0;
+  while ((i=re.match(s,p,&l))!=-1)
+  {
+    result+=s.mid(p,i-p);
+    QCString lumStr = s.mid(i+2,l-2);
+#define HEXTONUM(x) (((x)>='0' && (x)<='9') ? ((x)-'0') :       \
+                     ((x)>='a' && (x)<='f') ? ((x)-'a'+10) :    \
+                     ((x)>='A' && (x)<='F') ? ((x)-'A'+10) : 0)
+    
+    double r,g,b;
+    int red,green,blue;
+    int level = HEXTONUM(lumStr[0])*16+HEXTONUM(lumStr[1]);
+    ColoredImage::hsl2rgb(hue/360.0,sat/255.0,
+                          pow(level/255.0,gamma/100.0),&r,&g,&b);
+    red   = (int)(r*255.0);
+    green = (int)(g*255.0);
+    blue  = (int)(b*255.0);
     char colStr[8];
-    colStr[0] = '#';
-    colStr[1] = hex[red >> 4];
-    colStr[2] = hex[red & 0xf];
-    colStr[3] = hex[green >> 4];
-    colStr[4] = hex[green & 0xf];
-    colStr[5] = hex[blue >> 4];
-    colStr[6] = hex[blue & 0xf];
-    colStr[7] = 0;
-    // printf("replacing %s->%s (level=%d)\n",lumStr.data(),colStr,level);
-    result += colStr;
-    p = i + l;
-  }
-  result += s.right(sl - p);
+    colStr[0]='#';
+    colStr[1]=hex[red>>4];
+    colStr[2]=hex[red&0xf];
+    colStr[3]=hex[green>>4];
+    colStr[4]=hex[green&0xf];
+    colStr[5]=hex[blue>>4];
+    colStr[6]=hex[blue&0xf];
+    colStr[7]=0;
+    //printf("replacing %s->%s (level=%d)\n",lumStr.data(),colStr,level);
+    result+=colStr;
+    p=i+l;
+  }
+  result+=s.right(sl-p);
   return result;
 }
 
-/** Copies the contents of file with name \a src to the newly created
+/** Copies the contents of file with name \a src to the newly created 
  *  file with name \a dest. Returns TRUE if successful.
  */
-bool copyFile(const QCString &src, const QCString &dest) {
+bool copyFile(const QCString &src,const QCString &dest)
+{
   QFile sf(src);
-  if (sf.open(IO_ReadOnly)) {
+  if (sf.open(IO_ReadOnly))
+  {
     QFileInfo fi(src);
     QFile df(dest);
-    if (df.open(IO_WriteOnly)) {
+    if (df.open(IO_WriteOnly))
+    {
       char *buffer = new char[fi.size()];
-      sf.readBlock(buffer, fi.size());
-      df.writeBlock(buffer, fi.size());
+      sf.readBlock(buffer,fi.size());
+      df.writeBlock(buffer,fi.size());
       df.flush();
       delete[] buffer;
-    } else {
-      err("could not write to file %s\n", dest.data());
+    }
+    else
+    {
+      err("could not write to file %s\n",dest.data());
       return FALSE;
     }
-  } else {
-    err("could not open user specified file %s\n", src.data());
+  }
+  else
+  {
+    err("could not open user specified file %s\n",src.data());
     return FALSE;
   }
   return TRUE;
 }
 
-/** Returns the section of text, in between a pair of markers.
+/** Returns the section of text, in between a pair of markers. 
  *  Full lines are returned, excluding the lines on which the markers appear.
  *  \sa routine lineBlock
  */
-QCString extractBlock(const QCString text, const QCString marker) {
+QCString extractBlock(const QCString text,const QCString marker)
+{
   QCString result;
-  int p = 0, i;
-  bool found = FALSE;
+  int p=0,i;
+  bool found=FALSE;
 
   // find the character positions of the markers
   int m1 = text.find(marker);
-  if (m1 == -1)
-    return result;
-  int m2 = text.find(marker, m1 + marker.length());
-  if (m2 == -1)
-    return result;
+  if (m1==-1) return result;
+  int m2 = text.find(marker,m1+marker.length());
+  if (m2==-1) return result;
 
   // find start and end line positions for the markers
-  int l1 = -1, l2 = -1;
-  while (!found && (i = text.find('\n', p)) != -1) {
-    found = (p <= m1 && m1 < i); // found the line with the start marker
-    p = i + 1;
-  }
-  l1 = p;
-  int lp = i;
-  if (found) {
-    while ((i = text.find('\n', p)) != -1) {
-      if (p <= m2 && m2 < i) // found the line with the end marker
-      {
-        l2 = p;
+  int l1=-1,l2=-1;
+  while (!found && (i=text.find('\n',p))!=-1)
+  {
+    found = (p<=m1 && m1<i); // found the line with the start marker
+    p=i+1;
+  }
+  l1=p;
+  int lp=i;
+  if (found)
+  {
+    while ((i=text.find('\n',p))!=-1)
+    {
+      if (p<=m2 && m2<i) // found the line with the end marker
+      {
+        l2=p;
         break;
       }
-      p = i + 1;
-      lp = i;
+      p=i+1;
+      lp=i;
     }
   }
-  if (l2 == -1) // marker at last line without newline (see bug706874)
+  if (l2==-1) // marker at last line without newline (see bug706874)
   {
-    l2 = lp;
+    l2=lp;
   }
-  // printf("text=[%s]\n",text.mid(l1,l2-l1).data());
-  return l2 > l1 ? text.mid(l1, l2 - l1) : QCString();
+  //printf("text=[%s]\n",text.mid(l1,l2-l1).data());
+  return l2>l1 ? text.mid(l1,l2-l1) : QCString();
 }
 
 /** Returns the line number of the line following the line with the marker.
  *  \sa routine extractBlock
  */
-int lineBlock(const QCString text, const QCString marker) {
+int lineBlock(const QCString text,const QCString marker)
+{
   int result = 1;
-  int p = 0, i;
-  bool found = FALSE;
+  int p=0,i;
+  bool found=FALSE;
 
   // find the character positions of the first marker
   int m1 = text.find(marker);
-  if (m1 == -1)
-    return result;
+  if (m1==-1) return result;
 
   // find start line positions for the markers
-  while (!found && (i = text.find('\n', p)) != -1) {
-    found = (p <= m1 && m1 < i); // found the line with the start marker
-    p = i + 1;
+  while (!found && (i=text.find('\n',p))!=-1)
+  {
+    found = (p<=m1 && m1<i); // found the line with the start marker
+    p=i+1;
     result++;
   }
   return result;
 }
 
 /** Returns a string representation of \a lang. */
-QCString langToString(SrcLangExt lang) {
-  switch (lang) {
-  case SrcLangExt_Unknown:
-    return "Unknown";
-  case SrcLangExt_IDL:
-    return "IDL";
-  case SrcLangExt_Java:
-    return "Java";
-  case SrcLangExt_CSharp:
-    return "C#";
-  case SrcLangExt_D:
-    return "D";
-  case SrcLangExt_PHP:
-    return "PHP";
-  case SrcLangExt_ObjC:
-    return "Objective-C";
-  case SrcLangExt_Cpp:
-    return "C++";
-  case SrcLangExt_JS:
-    return "Javascript";
-  case SrcLangExt_Prolog:
-    return "Prolog";
-  case SrcLangExt_Python:
-    return "Python";
-  case SrcLangExt_Fortran:
-    return "Fortran";
-  case SrcLangExt_VHDL:
-    return "VHDL";
-  case SrcLangExt_XML:
-    return "XML";
-  case SrcLangExt_Tcl:
-    return "Tcl";
-  case SrcLangExt_Markdown:
-    return "Markdown";
+QCString langToString(SrcLangExt lang)
+{
+  switch(lang)
+  {
+    case SrcLangExt_Unknown:  return "Unknown";
+    case SrcLangExt_IDL:      return "IDL";
+    case SrcLangExt_Java:     return "Java";
+    case SrcLangExt_CSharp:   return "C#";
+    case SrcLangExt_D:        return "D";
+    case SrcLangExt_PHP:      return "PHP";
+    case SrcLangExt_ObjC:     return "Objective-C";
+    case SrcLangExt_Cpp:      return "C++";
+    case SrcLangExt_JS:       return "Javascript";
+    case SrcLangExt_Python:   return "Python";
+    case SrcLangExt_Prolog:   return "Prolog";
+    case SrcLangExt_Fortran:  return "Fortran";
+    case SrcLangExt_VHDL:     return "VHDL";
+    case SrcLangExt_XML:      return "XML";
+    case SrcLangExt_Tcl:      return "Tcl";
+    case SrcLangExt_Markdown: return "Markdown";
   }
   return "Unknown";
 }
 
 /** Returns the scope separator to use given the programming language \a lang */
-QCString getLanguageSpecificSeparator(SrcLangExt lang, bool classScope) {
-  if (lang == SrcLangExt_Java || lang == SrcLangExt_CSharp ||
-      lang == SrcLangExt_VHDL || lang == SrcLangExt_Python) {
+QCString getLanguageSpecificSeparator(SrcLangExt lang,bool classScope)
+{
+  if (lang==SrcLangExt_Java || lang==SrcLangExt_CSharp || lang==SrcLangExt_VHDL || lang==SrcLangExt_Python)
+  {
     return ".";
-  } else if (lang == SrcLangExt_Prolog) {
-    return ":";
-  } else if (lang == SrcLangExt_PHP && !classScope) {
+  }
+  else if (lang==SrcLangExt_PHP && !classScope)
+  {
     return "\\";
-  } else {
+  }
+  else
+  {
     return "::";
   }
 }
@@ -7985,10 +8219,13 @@ QCString getLanguageSpecificSeparator(SrcLangExt lang, bool classScope) {
 /** Corrects URL \a url according to the relative path \a relPath.
  *  Returns the corrected URL. For absolute URLs no correction will be done.
  */
-QCString correctURL(const QCString &url, const QCString &relPath) {
+QCString correctURL(const QCString &url,const QCString &relPath)
+{
   QCString result = url;
-  if (!relPath.isEmpty() && url.left(5) != "http:" && url.left(6) != "https:" &&
-      url.left(4) != "ftp:" && url.left(5) != "file:") {
+  if (!relPath.isEmpty() && 
+      url.left(5)!="http:" && url.left(6)!="https:" && 
+      url.left(4)!="ftp:"  && url.left(5)!="file:")
+  {
     result.prepend(relPath);
   }
   return result;
@@ -7996,118 +8233,133 @@ QCString correctURL(const QCString &url, const QCString &relPath) {
 
 //---------------------------------------------------------------------------
 
-bool protectionLevelVisible(Protection prot) {
+bool protectionLevelVisible(Protection prot)
+{
   static bool extractPrivate = Config_getBool(EXTRACT_PRIVATE);
   static bool extractPackage = Config_getBool(EXTRACT_PACKAGE);
 
-  return (prot != Private && prot != Package) ||
-         (prot == Private && extractPrivate) ||
-         (prot == Package && extractPackage);
+  return (prot!=Private && prot!=Package)  || 
+         (prot==Private && extractPrivate) || 
+         (prot==Package && extractPackage);
 }
 
 //---------------------------------------------------------------------------
 
-QCString stripIndentation(const QCString &s) {
-  if (s.isEmpty())
-    return s; // empty string -> we're done
+QCString stripIndentation(const QCString &s)
+{
+  if (s.isEmpty()) return s; // empty string -> we're done
 
-  // printf("stripIndentation:\n%s\n------\n",s.data());
+  //printf("stripIndentation:\n%s\n------\n",s.data());
   // compute minimum indentation over all lines
-  const char *p = s.data();
+  const char *p=s.data();
   char c;
-  int indent = 0;
-  int minIndent = 1000000; // "infinite"
-  bool searchIndent = TRUE;
-  static int tabSize = Config_getInt(TAB_SIZE);
-  while ((c = *p++)) {
-    if (c == '\t')
-      indent += tabSize - (indent % tabSize);
-    else if (c == '\n')
-      indent = 0, searchIndent = TRUE;
-    else if (c == ' ')
-      indent++;
-    else if (searchIndent) {
-      searchIndent = FALSE;
-      if (indent < minIndent)
-        minIndent = indent;
+  int indent=0;
+  int minIndent=1000000; // "infinite"
+  bool searchIndent=TRUE;
+  static int tabSize=Config_getInt(TAB_SIZE);
+  while ((c=*p++))
+  {
+    if      (c=='\t') indent+=tabSize - (indent%tabSize);
+    else if (c=='\n') indent=0,searchIndent=TRUE;
+    else if (c==' ')  indent++;
+    else if (searchIndent) 
+    {
+      searchIndent=FALSE;
+      if (indent<minIndent) minIndent=indent;
     }
   }
 
   // no indent to remove -> we're done
-  if (minIndent == 0)
-    return s;
+  if (minIndent==0) return s;
 
   // remove minimum indentation for each line
   QGString result;
-  p = s.data();
-  indent = 0;
-  while ((c = *p++)) {
-    if (c == '\n') // start of new line
-    {
-      indent = 0;
-      result += c;
-    } else if (indent < minIndent) // skip until we reach minIndent
-    {
-      if (c == '\t') {
-        int newIndent = indent + tabSize - (indent % tabSize);
-        int i = newIndent;
-        while (i > minIndent) // if a tab crosses the minIndent boundary fill
-                              // the rest with spaces
+  p=s.data();
+  indent=0;
+  while ((c=*p++))
+  {
+    if (c=='\n') // start of new line
+    {
+      indent=0;
+      result+=c;
+    }
+    else if (indent<minIndent) // skip until we reach minIndent
+    {
+      if (c=='\t')
+      {
+        int newIndent = indent+tabSize-(indent%tabSize);
+        int i=newIndent;
+        while (i>minIndent) // if a tab crosses the minIndent boundary fill the rest with spaces
         {
-          result += ' ';
+          result+=' ';
           i--;
         }
-        indent = newIndent;
-      } else // space
+        indent=newIndent;
+      }
+      else // space
       {
         indent++;
       }
-    } else // copy anything until the end of the line
+    }
+    else // copy anything until the end of the line
     {
-      result += c;
+      result+=c;
     }
   }
 
-  result += '\0';
+  result+='\0';
   return result.data();
 }
 
-bool fileVisibleInIndex(FileDef *fd, bool &genSourceFile) {
+
+bool fileVisibleInIndex(FileDef *fd,bool &genSourceFile)
+{
   static bool allExternals = Config_getBool(ALLEXTERNALS);
   bool isDocFile = fd->isDocumentationFile();
   genSourceFile = !isDocFile && fd->generateSourceFile();
-  return (((allExternals && fd->isLinkable()) || fd->isLinkableInProject()) &&
-          !isDocFile);
+  return ( ((allExternals && fd->isLinkable()) ||
+            fd->isLinkableInProject()
+           ) && 
+           !isDocFile
+         );
 }
 
-void addDocCrossReference(MemberDef *src, MemberDef *dst) {
+void addDocCrossReference(MemberDef *src,MemberDef *dst)
+{
   static bool referencedByRelation = Config_getBool(REFERENCED_BY_RELATION);
-  static bool referencesRelation = Config_getBool(REFERENCES_RELATION);
-
-  // printf("--> addDocCrossReference
-  // src=%s,dst=%s\n",src->name().data(),dst->name().data());
-  if (dst->isTypedef() || dst->isEnumerate())
-    return; // don't add types
-  if ((referencedByRelation || dst->hasCallerGraph()) &&
-      src->showInCallGraph()) {
+  static bool referencesRelation   = Config_getBool(REFERENCES_RELATION);
+
+  //printf("--> addDocCrossReference src=%s,dst=%s\n",src->name().data(),dst->name().data());
+  if (dst->isTypedef() || dst->isEnumerate()) return; // don't add types
+  if ((referencedByRelation || dst->hasCallerGraph()) && 
+      src->showInCallGraph()
+     )
+  {
     dst->addSourceReferencedBy(src);
     MemberDef *mdDef = dst->memberDefinition();
-    if (mdDef) {
+    if (mdDef)
+    {
       mdDef->addSourceReferencedBy(src);
     }
     MemberDef *mdDecl = dst->memberDeclaration();
-    if (mdDecl) {
+    if (mdDecl)
+    {
       mdDecl->addSourceReferencedBy(src);
     }
   }
-  if ((referencesRelation || src->hasCallGraph()) && src->showInCallGraph()) {
+  if ((referencesRelation || src->hasCallGraph()) && 
+      src->showInCallGraph()
+     )
+  {
     src->addSourceReferences(dst);
     MemberDef *mdDef = src->memberDefinition();
-    if (mdDef) {
+    if (mdDef)
+    {
       mdDef->addSourceReferences(dst);
     }
     MemberDef *mdDecl = src->memberDeclaration();
-    if (mdDecl) {
+    if (mdDecl)
+    {
       mdDecl->addSourceReferences(dst);
     }
   }
@@ -8123,41 +8375,35 @@ void addDocCrossReference(MemberDef *src, MemberDef *dst) {
  * @see getNextUtf8OrToLower()
  * @see getNextUtf8OrToUpper()
  */
-uint getUtf8Code(const QCString &s, int idx) {
+uint getUtf8Code( const QCString& s, int idx )
+{
   const int length = s.length();
-  if (idx >= length) {
-    return 0;
-  }
+  if (idx >= length) { return 0; }
   const uint c0 = (uchar)s.at(idx);
-  if (c0 < 0xC2 || c0 >= 0xF8) // 1 byte character
+  if ( c0 < 0xC2 || c0 >= 0xF8 ) // 1 byte character
   {
     return c0;
   }
-  if (idx + 1 >= length) {
-    return 0;
-  }
-  const uint c1 = ((uchar)s.at(idx + 1)) & 0x3f;
-  if (c0 < 0xE0) // 2 byte character
+  if (idx+1 >= length) { return 0; }
+  const uint c1 = ((uchar)s.at(idx+1)) & 0x3f;
+  if ( c0 < 0xE0 ) // 2 byte character
   {
     return ((c0 & 0x1f) << 6) | c1;
   }
-  if (idx + 2 >= length) {
-    return 0;
-  }
-  const uint c2 = ((uchar)s.at(idx + 2)) & 0x3f;
-  if (c0 < 0xF0) // 3 byte character
+  if (idx+2 >= length) { return 0; }
+  const uint c2 = ((uchar)s.at(idx+2)) & 0x3f;
+  if ( c0 < 0xF0 ) // 3 byte character
   {
     return ((c0 & 0x0f) << 12) | (c1 << 6) | c2;
   }
-  if (idx + 3 >= length) {
-    return 0;
-  }
+  if (idx+3 >= length) { return 0; }
   // 4 byte character
-  const uint c3 = ((uchar)s.at(idx + 3)) & 0x3f;
+  const uint c3 = ((uchar)s.at(idx+3)) & 0x3f;
   return ((c0 & 0x07) << 18) | (c1 << 12) | (c2 << 6) | c3;
 }
 
-/*! @brief Returns one unicode character as an unsigned integer
+
+/*! @brief Returns one unicode character as an unsigned integer 
  *  from utf-8 string, making the character lower case if it was upper case.
  *
  * @param s utf-8 encoded string
@@ -8165,12 +8411,14 @@ uint getUtf8Code(const QCString &s, int idx) {
  * @return the unicode codepoint, 0 - MAX_UNICODE_CODEPOINT, excludes 'A'-'Z'
  * @see getNextUtf8Code()
 */
-uint getUtf8CodeToLower(const QCString &s, int idx) {
-  const uint v = getUtf8Code(s, idx);
-  return v < 0x7f ? tolower(v) : v;
+uint getUtf8CodeToLower( const QCString& s, int idx )
+{
+  const uint v = getUtf8Code( s, idx );
+  return v < 0x7f ? tolower( v ) : v;
 }
 
-/*! @brief Returns one unicode character as ian unsigned interger
+
+/*! @brief Returns one unicode character as ian unsigned interger 
  *  from utf-8 string, making the character upper case if it was lower case.
  *
  * @param s utf-8 encoded string
@@ -8178,30 +8426,40 @@ uint getUtf8CodeToLower(const QCString &s, int idx) {
  * @return the unicode codepoint, 0 - MAX_UNICODE_CODEPOINT, excludes 'A'-'Z'
  * @see getNextUtf8Code()
  */
-uint getUtf8CodeToUpper(const QCString &s, int idx) {
-  const uint v = getUtf8Code(s, idx);
-  return v < 0x7f ? toupper(v) : v;
+uint getUtf8CodeToUpper( const QCString& s, int idx )
+{
+  const uint v = getUtf8Code( s, idx );
+  return v < 0x7f ? toupper( v ) : v;
 }
 
 //--------------------------------------------------------------------------------------
 
-bool namespaceHasVisibleChild(NamespaceDef *nd, bool includeClasses) {
-  if (nd->getNamespaceSDict()) {
+bool namespaceHasVisibleChild(NamespaceDef *nd,bool includeClasses)
+{
+  if (nd->getNamespaceSDict())
+  {
     NamespaceSDict::Iterator cnli(*nd->getNamespaceSDict());
     NamespaceDef *cnd;
-    for (cnli.toFirst(); (cnd = cnli.current()); ++cnli) {
-      if (cnd->isLinkableInProject() && cnd->localName().find('@') == -1) {
+    for (cnli.toFirst();(cnd=cnli.current());++cnli)
+    {
+      if (cnd->isLinkableInProject() && cnd->localName().find('@')==-1)
+      {
         return TRUE;
-      } else if (namespaceHasVisibleChild(cnd, includeClasses)) {
+      }
+      else if (namespaceHasVisibleChild(cnd,includeClasses))
+      {
         return TRUE;
       }
     }
   }
-  if (includeClasses && nd->getClassSDict()) {
+  if (includeClasses && nd->getClassSDict())
+  {
     ClassSDict::Iterator cli(*nd->getClassSDict());
     ClassDef *cd;
-    for (; (cd = cli.current()); ++cli) {
-      if (cd->isLinkableInProject() && cd->templateMaster() == 0) {
+    for (;(cd=cli.current());++cli)
+    {
+      if (cd->isLinkableInProject() && cd->templateMaster()==0) 
+      { 
         return TRUE;
       }
     }
@@ -8211,30 +8469,30 @@ bool namespaceHasVisibleChild(NamespaceDef *nd, bool includeClasses) {
 
 //----------------------------------------------------------------------------
 
-bool classVisibleInIndex(ClassDef *cd) {
+bool classVisibleInIndex(ClassDef *cd)
+{
   static bool allExternals = Config_getBool(ALLEXTERNALS);
   return (allExternals && cd->isLinkable()) || cd->isLinkableInProject();
 }
 
 //----------------------------------------------------------------------------
 
-QCString extractDirection(QCString &docs) {
+QCString extractDirection(QCString &docs)
+{
   QRegExp re("\\[[^\\]]+\\]"); // [...]
-  int l = 0;
-  if (re.match(docs, 0, &l) == 0) {
-    int inPos = docs.find("in", 1, FALSE);
-    int outPos = docs.find("out", 1, FALSE);
-    bool input = inPos != -1 && inPos < l;
-    bool output = outPos != -1 && outPos < l;
+  int l=0;
+  if (re.match(docs,0,&l)==0)
+  {
+    int  inPos  = docs.find("in", 1,FALSE);
+    int outPos  = docs.find("out",1,FALSE);
+    bool input  =  inPos!=-1 &&  inPos<l;
+    bool output = outPos!=-1 && outPos<l;
     if (input || output) // in,out attributes
     {
       docs = docs.mid(l); // strip attributes
-      if (input && output)
-        return "[in,out]";
-      else if (input)
-        return "[in]";
-      else if (output)
-        return "[out]";
+      if (input && output) return "[in,out]";
+      else if (input)      return "[in]";
+      else if (output)     return "[out]";
     }
   }
   return QCString();
@@ -8255,207 +8513,239 @@ QCString extractDirection(QCString &docs) {
  *  For private inheritance, both protected and public members of the
  *  base class should be joined in the private member section.
  */
-void convertProtectionLevel(MemberListType inListType, Protection inProt,
-                            int *outListType1, int *outListType2) {
+void convertProtectionLevel(
+                   MemberListType inListType,
+                   Protection inProt,
+                   int *outListType1,
+                   int *outListType2
+                  )
+{
   static bool extractPrivate = Config_getBool(EXTRACT_PRIVATE);
   // default representing 1-1 mapping
-  *outListType1 = inListType;
-  *outListType2 = -1;
-  if (inProt == Public) {
+  *outListType1=inListType;
+  *outListType2=-1;
+  if (inProt==Public)
+  {
     switch (inListType) // in the private section of the derived class,
                         // the private section of the base class should not
                         // be visible
     {
-    case MemberListType_priMethods:
-    case MemberListType_priStaticMethods:
-    case MemberListType_priSlots:
-    case MemberListType_priAttribs:
-    case MemberListType_priStaticAttribs:
-    case MemberListType_priTypes:
-      *outListType1 = -1;
-      *outListType2 = -1;
-      break;
-    default:
-      break;
+      case MemberListType_priMethods:
+      case MemberListType_priStaticMethods:
+      case MemberListType_priSlots:
+      case MemberListType_priAttribs:
+      case MemberListType_priStaticAttribs:
+      case MemberListType_priTypes:
+        *outListType1=-1;
+        *outListType2=-1;
+        break;
+      default:
+        break;
     }
-  } else if (inProt == Protected) // Protected inheritance
+  }
+  else if (inProt==Protected) // Protected inheritance
   {
     switch (inListType) // in the protected section of the derived class,
                         // both the public and protected members are shown
                         // as protected
     {
-    case MemberListType_pubMethods:
-    case MemberListType_pubStaticMethods:
-    case MemberListType_pubSlots:
-    case MemberListType_pubAttribs:
-    case MemberListType_pubStaticAttribs:
-    case MemberListType_pubTypes:
-    case MemberListType_priMethods:
-    case MemberListType_priStaticMethods:
-    case MemberListType_priSlots:
-    case MemberListType_priAttribs:
-    case MemberListType_priStaticAttribs:
-    case MemberListType_priTypes:
-      *outListType1 = -1;
-      *outListType2 = -1;
-      break;
-
-    case MemberListType_proMethods:
-      *outListType2 = MemberListType_pubMethods;
-      break;
-    case MemberListType_proStaticMethods:
-      *outListType2 = MemberListType_pubStaticMethods;
-      break;
-    case MemberListType_proSlots:
-      *outListType2 = MemberListType_pubSlots;
-      break;
-    case MemberListType_proAttribs:
-      *outListType2 = MemberListType_pubAttribs;
-      break;
-    case MemberListType_proStaticAttribs:
-      *outListType2 = MemberListType_pubStaticAttribs;
-      break;
-    case MemberListType_proTypes:
-      *outListType2 = MemberListType_pubTypes;
-      break;
-    default:
-      break;
-    }
-  } else if (inProt == Private) {
+      case MemberListType_pubMethods:
+      case MemberListType_pubStaticMethods:
+      case MemberListType_pubSlots:
+      case MemberListType_pubAttribs:
+      case MemberListType_pubStaticAttribs:
+      case MemberListType_pubTypes:
+      case MemberListType_priMethods:
+      case MemberListType_priStaticMethods:
+      case MemberListType_priSlots:
+      case MemberListType_priAttribs:
+      case MemberListType_priStaticAttribs:
+      case MemberListType_priTypes:
+        *outListType1=-1;
+        *outListType2=-1;
+        break;
+
+      case MemberListType_proMethods:
+        *outListType2=MemberListType_pubMethods;
+        break;
+      case MemberListType_proStaticMethods:
+        *outListType2=MemberListType_pubStaticMethods;
+        break;
+      case MemberListType_proSlots:
+        *outListType2=MemberListType_pubSlots;
+        break;
+      case MemberListType_proAttribs:
+        *outListType2=MemberListType_pubAttribs;
+        break;
+      case MemberListType_proStaticAttribs:
+        *outListType2=MemberListType_pubStaticAttribs;
+        break;
+      case MemberListType_proTypes:
+        *outListType2=MemberListType_pubTypes;
+        break;
+      default:
+        break;
+    }
+  }
+  else if (inProt==Private)
+  {
     switch (inListType) // in the private section of the derived class,
                         // both the public and protected members are shown
                         // as private
     {
-    case MemberListType_pubMethods:
-    case MemberListType_pubStaticMethods:
-    case MemberListType_pubSlots:
-    case MemberListType_pubAttribs:
-    case MemberListType_pubStaticAttribs:
-    case MemberListType_pubTypes:
-    case MemberListType_proMethods:
-    case MemberListType_proStaticMethods:
-    case MemberListType_proSlots:
-    case MemberListType_proAttribs:
-    case MemberListType_proStaticAttribs:
-    case MemberListType_proTypes:
-      *outListType1 = -1;
-      *outListType2 = -1;
-      break;
-
-    case MemberListType_priMethods:
-      if (extractPrivate) {
-        *outListType1 = MemberListType_pubMethods;
-        *outListType2 = MemberListType_proMethods;
-      } else {
-        *outListType1 = -1;
-        *outListType2 = -1;
-      }
-      break;
-    case MemberListType_priStaticMethods:
-      if (extractPrivate) {
-        *outListType1 = MemberListType_pubStaticMethods;
-        *outListType2 = MemberListType_proStaticMethods;
-      } else {
-        *outListType1 = -1;
-        *outListType2 = -1;
-      }
-      break;
-    case MemberListType_priSlots:
-      if (extractPrivate) {
-        *outListType1 = MemberListType_pubSlots;
-        *outListType2 = MemberListType_proSlots;
-      } else {
-        *outListType1 = -1;
-        *outListType2 = -1;
-      }
-      break;
-    case MemberListType_priAttribs:
-      if (extractPrivate) {
-        *outListType1 = MemberListType_pubAttribs;
-        *outListType2 = MemberListType_proAttribs;
-      } else {
-        *outListType1 = -1;
-        *outListType2 = -1;
-      }
-      break;
-    case MemberListType_priStaticAttribs:
-      if (extractPrivate) {
-        *outListType1 = MemberListType_pubStaticAttribs;
-        *outListType2 = MemberListType_proStaticAttribs;
-      } else {
-        *outListType1 = -1;
-        *outListType2 = -1;
-      }
-      break;
-    case MemberListType_priTypes:
-      if (extractPrivate) {
-        *outListType1 = MemberListType_pubTypes;
-        *outListType2 = MemberListType_proTypes;
-      } else {
-        *outListType1 = -1;
-        *outListType2 = -1;
-      }
-      break;
-    default:
-      break;
-    }
-  }
-  // printf("convertProtectionLevel(type=%d prot=%d): %d,%d\n",
+      case MemberListType_pubMethods:
+      case MemberListType_pubStaticMethods:
+      case MemberListType_pubSlots:
+      case MemberListType_pubAttribs:
+      case MemberListType_pubStaticAttribs:
+      case MemberListType_pubTypes:
+      case MemberListType_proMethods:
+      case MemberListType_proStaticMethods:
+      case MemberListType_proSlots:
+      case MemberListType_proAttribs:
+      case MemberListType_proStaticAttribs:
+      case MemberListType_proTypes:
+        *outListType1=-1;
+        *outListType2=-1;
+        break;
+
+      case MemberListType_priMethods:
+        if (extractPrivate)
+        {
+          *outListType1=MemberListType_pubMethods;
+          *outListType2=MemberListType_proMethods;
+        }
+        else
+        {
+          *outListType1=-1;
+          *outListType2=-1;
+        }
+        break;
+      case MemberListType_priStaticMethods:
+        if (extractPrivate)
+        {
+          *outListType1=MemberListType_pubStaticMethods;
+          *outListType2=MemberListType_proStaticMethods;
+        }
+        else
+        {
+          *outListType1=-1;
+          *outListType2=-1;
+        }
+        break;
+      case MemberListType_priSlots:
+        if (extractPrivate)
+        {
+          *outListType1=MemberListType_pubSlots;
+          *outListType2=MemberListType_proSlots;
+        }
+        else
+        {
+          *outListType1=-1;
+          *outListType2=-1;
+        }
+        break;
+      case MemberListType_priAttribs:
+        if (extractPrivate)
+        {
+          *outListType1=MemberListType_pubAttribs;
+          *outListType2=MemberListType_proAttribs;
+        }
+        else
+        {
+          *outListType1=-1;
+          *outListType2=-1;
+        }
+        break;
+      case MemberListType_priStaticAttribs:
+        if (extractPrivate)
+        {
+          *outListType1=MemberListType_pubStaticAttribs;
+          *outListType2=MemberListType_proStaticAttribs;
+        }
+        else
+        {
+          *outListType1=-1;
+          *outListType2=-1;
+        }
+        break;
+      case MemberListType_priTypes:
+        if (extractPrivate)
+        {
+          *outListType1=MemberListType_pubTypes;
+          *outListType2=MemberListType_proTypes;
+        }
+        else
+        {
+          *outListType1=-1;
+          *outListType2=-1;
+        }
+        break;
+      default:
+        break;
+    }
+  }
+  //printf("convertProtectionLevel(type=%d prot=%d): %d,%d\n",
   //    inListType,inProt,*outListType1,*outListType2);
 }
 
-bool mainPageHasTitle() {
-  if (Doxygen::mainPage == 0)
-    return FALSE;
-  if (Doxygen::mainPage->title().isEmpty())
-    return FALSE;
-  if (Doxygen::mainPage->title().lower() == "notitle")
-    return FALSE;
+bool mainPageHasTitle()
+{
+  if (Doxygen::mainPage==0) return FALSE;
+  if (Doxygen::mainPage->title().isEmpty()) return FALSE;
+  if (Doxygen::mainPage->title().lower()=="notitle") return FALSE;
   return TRUE;
 }
 
-QCString getDotImageExtension(void) {
-  QCString imgExt = Config_getEnum(DOT_IMAGE_FORMAT);
-  imgExt = imgExt.replace(QRegExp(":.*"), "");
+QCString getDotImageExtension(void)
+{
+  QCString imgExt      = Config_getEnum(DOT_IMAGE_FORMAT);
+  imgExt = imgExt.replace( QRegExp(":.*"), "" );
   return imgExt;
 }
 
-bool openOutputFile(const char *outFile, QFile &f) {
-  bool fileOpened = FALSE;
-  bool writeToStdout = (outFile[0] == '-' && outFile[1] == '\0');
+bool openOutputFile(const char *outFile,QFile &f)
+{
+  bool fileOpened=FALSE;
+  bool writeToStdout=(outFile[0]=='-' && outFile[1]=='\0');
   if (writeToStdout) // write to stdout
   {
-    fileOpened = f.open(IO_WriteOnly, stdout);
-  } else // write to file
+    fileOpened = f.open(IO_WriteOnly,stdout);
+  }
+  else // write to file
   {
     QFileInfo fi(outFile);
     if (fi.exists()) // create a backup
     {
-      QDir dir = fi.dir();
-      QFileInfo backup(fi.fileName() + ".bak");
+      QDir dir=fi.dir();
+      QFileInfo backup(fi.fileName()+".bak");
       if (backup.exists()) // remove existing backup
         dir.remove(backup.fileName());
-      dir.rename(fi.fileName(), fi.fileName() + ".bak");
-    }
+      dir.rename(fi.fileName(),fi.fileName()+".bak");
+    } 
     f.setName(outFile);
-    fileOpened = f.open(IO_WriteOnly | IO_Translate);
+    fileOpened = f.open(IO_WriteOnly|IO_Translate);
   }
   return fileOpened;
 }
 
-void writeExtraLatexPackages(FTextStream &t) {
+void writeExtraLatexPackages(FTextStream &t)
+{
   // User-specified packages
   QStrList &extraPackages = Config_getList(EXTRA_PACKAGES);
-  if (!extraPackages.isEmpty()) {
+  if (!extraPackages.isEmpty()) 
+  {
     t << "% Packages requested by user\n";
-    const char *pkgName = extraPackages.first();
-    while (pkgName) {
+    const char *pkgName=extraPackages.first();
+    while (pkgName)
+    {
       if ((pkgName[0] == '[') || (pkgName[0] == '{'))
         t << "\\usepackage" << pkgName << "\n";
       else
         t << "\\usepackage{" << pkgName << "}\n";
-      pkgName = extraPackages.next();
+      pkgName=extraPackages.next();
     }
     t << "\n";
   }
 }
+
diff --git a/src/xmlgen.cpp b/src/xmlgen.cpp
index 6c43173e..94281a8b 100644
--- a/src/xmlgen.cpp
+++ b/src/xmlgen.cpp
@@ -3,8 +3,8 @@
  * Copyright (C) 1997-2015 by Dimitri van Heesch.
  *
  * Permission to use, copy, modify, and distribute this software and its
- * documentation under the terms of the GNU General Public License is hereby 
- * granted. No representations are made about the suitability of this software 
+ * documentation under the terms of the GNU General Public License is hereby
+ * granted. No representations are made about the suitability of this software
  * for any purpose. It is provided "as is" without express or implied warranty.
  * See the GNU General Public License for more details.
  *
@@ -17,39 +17,41 @@
 
 #include <qdir.h>
 #include <qfile.h>
-#include <qtextstream.h>
 #include <qintdict.h>
+#include <qtextstream.h>
 
-#include "xmlgen.h"
-#include "doxygen.h"
-#include "message.h"
-#include "config.h"
+#include "arguments.h"
 #include "classlist.h"
-#include "util.h"
+#include "config.h"
 #include "defargs.h"
-#include "outputgen.h"
+#include "dirdef.h"
+#include "docparser.h"
 #include "dot.h"
-#include "pagedef.h"
+#include "doxygen.h"
 #include "filename.h"
-#include "version.h"
-#include "xmldocvisitor.h"
-#include "docparser.h"
-#include "language.h"
-#include "parserintf.h"
-#include "arguments.h"
-#include "memberlist.h"
 #include "groupdef.h"
+#include "htmlentity.h"
+#include "language.h"
 #include "memberdef.h"
-#include "namespacedef.h"
-#include "membername.h"
 #include "membergroup.h"
-#include "dirdef.h"
-#include "section.h"
-#include "htmlentity.h"
+#include "memberlist.h"
+#include "membername.h"
+#include "message.h"
+#include "namespacedef.h"
+#include "outputgen.h"
+#include "pagedef.h"
+#include "parserintf.h"
 #include "resourcemgr.h"
+#include "section.h"
+#include "util.h"
+#include "version.h"
+#include "xmldocvisitor.h"
+#include "xmlgen.h"
 
 // no debug info
-#define XML_DB(x) do {} while(0)
+#define XML_DB(x)                                                              \
+  do {                                                                         \
+  } while (0)
 // debug to stdout
 //#define XML_DB(x) printf x
 // debug inside output
@@ -58,346 +60,351 @@
 //------------------
 
 /** Helper class mapping MemberList::ListType to a string representing */
-class XmlSectionMapper : public QIntDict<char>
-{
-  public:
-    XmlSectionMapper() : QIntDict<char>(47)
-    {
-      insert(MemberListType_pubTypes,"public-type");
-      insert(MemberListType_pubMethods,"public-func");
-      insert(MemberListType_pubAttribs,"public-attrib");
-      insert(MemberListType_pubSlots,"public-slot");
-      insert(MemberListType_signals,"signal");
-      insert(MemberListType_dcopMethods,"dcop-func");
-      insert(MemberListType_properties,"property");
-      insert(MemberListType_events,"event");
-      insert(MemberListType_interfaces,"interfaces");
-      insert(MemberListType_services,"services");
-      insert(MemberListType_pubStaticMethods,"public-static-func");
-      insert(MemberListType_pubStaticAttribs,"public-static-attrib");
-      insert(MemberListType_proTypes,"protected-type");
-      insert(MemberListType_proMethods,"protected-func");
-      insert(MemberListType_proAttribs,"protected-attrib");
-      insert(MemberListType_proSlots,"protected-slot");
-      insert(MemberListType_proStaticMethods,"protected-static-func");
-      insert(MemberListType_proStaticAttribs,"protected-static-attrib");
-      insert(MemberListType_pacTypes,"package-type");
-      insert(MemberListType_pacMethods,"package-func");
-      insert(MemberListType_pacAttribs,"package-attrib");
-      insert(MemberListType_pacStaticMethods,"package-static-func");
-      insert(MemberListType_pacStaticAttribs,"package-static-attrib");
-      insert(MemberListType_priTypes,"private-type");
-      insert(MemberListType_priMethods,"private-func");
-      insert(MemberListType_priAttribs,"private-attrib");
-      insert(MemberListType_priSlots,"private-slot");
-      insert(MemberListType_priStaticMethods,"private-static-func");
-      insert(MemberListType_priStaticAttribs,"private-static-attrib");
-      insert(MemberListType_friends,"friend");
-      insert(MemberListType_related,"related");
-      insert(MemberListType_decDefineMembers,"define");
-      insert(MemberListType_decProtoMembers,"prototype");
-      insert(MemberListType_decTypedefMembers,"typedef");
-      insert(MemberListType_decEnumMembers,"enum");
-      insert(MemberListType_decFuncMembers,"func");
-      insert(MemberListType_decVarMembers,"var");
-    }
+class XmlSectionMapper : public QIntDict<char> {
+public:
+  XmlSectionMapper() : QIntDict<char>(47) {
+    insert(MemberListType_pubTypes, "public-type");
+    insert(MemberListType_pubMethods, "public-func");
+    insert(MemberListType_pubAttribs, "public-attrib");
+    insert(MemberListType_pubSlots, "public-slot");
+    insert(MemberListType_signals, "signal");
+    insert(MemberListType_dcopMethods, "dcop-func");
+    insert(MemberListType_properties, "property");
+    insert(MemberListType_events, "event");
+    insert(MemberListType_interfaces, "interfaces");
+    insert(MemberListType_services, "services");
+    insert(MemberListType_pubStaticMethods, "public-static-func");
+    insert(MemberListType_pubStaticAttribs, "public-static-attrib");
+    insert(MemberListType_proTypes, "protected-type");
+    insert(MemberListType_proMethods, "protected-func");
+    insert(MemberListType_proAttribs, "protected-attrib");
+    insert(MemberListType_proSlots, "protected-slot");
+    insert(MemberListType_proStaticMethods, "protected-static-func");
+    insert(MemberListType_proStaticAttribs, "protected-static-attrib");
+    insert(MemberListType_pacTypes, "package-type");
+    insert(MemberListType_pacMethods, "package-func");
+    insert(MemberListType_pacAttribs, "package-attrib");
+    insert(MemberListType_pacStaticMethods, "package-static-func");
+    insert(MemberListType_pacStaticAttribs, "package-static-attrib");
+    insert(MemberListType_priTypes, "private-type");
+    insert(MemberListType_priMethods, "private-func");
+    insert(MemberListType_priAttribs, "private-attrib");
+    insert(MemberListType_priSlots, "private-slot");
+    insert(MemberListType_priStaticMethods, "private-static-func");
+    insert(MemberListType_priStaticAttribs, "private-static-attrib");
+    insert(MemberListType_friends, "friend");
+    insert(MemberListType_related, "related");
+    insert(MemberListType_decDefineMembers, "define");
+    insert(MemberListType_decProtoMembers, "prototype");
+    insert(MemberListType_decTypedefMembers, "typedef");
+    insert(MemberListType_decEnumMembers, "enum");
+    insert(MemberListType_decFuncMembers, "func");
+    insert(MemberListType_decVarMembers, "var");
+  }
 };
 
 static XmlSectionMapper g_xmlSectionMapper;
 
-
-inline void writeXMLString(FTextStream &t,const char *s)
-{
+inline void writeXMLString(FTextStream &t, const char *s) {
   t << convertToXML(s);
 }
 
-inline void writeXMLCodeString(FTextStream &t,const char *s, int &col)
-{
+inline void writeXMLCodeString(FTextStream &t, const char *s, int &col) {
   char c;
-  while ((c=*s++))
-  {
-    switch(c)
-    {
-      case '\t':
-      {
-        static int tabSize = Config_getInt(TAB_SIZE);
-	int spacesToNextTabStop = tabSize - (col%tabSize);
-	col+=spacesToNextTabStop;
-	while (spacesToNextTabStop--) t << "<sp/>";
-	break;
-	}
-      case ' ':  t << "<sp/>"; col++;  break;
-      case '<':  t << "&lt;"; col++;   break;
-      case '>':  t << "&gt;"; col++;   break;
-      case '&':  t << "&amp;"; col++;  break;
-      case '\'': t << "&apos;"; col++; break;
-      case '"':  t << "&quot;"; col++; break;
-      case  1: case  2: case  3: case  4: case  5: case  6: case  7: case  8:
-      case 11: case 12: case 13: case 14: case 15: case 16: case 17: case 18:
-      case 19: case 20: case 21: case 22: case 23: case 24: case 25: case 26:
-      case 27: case 28: case 29: case 30: case 31:
-        break; // skip invalid XML characters (see http://www.w3.org/TR/2000/REC-xml-20001006#NT-Char)
-      default:   s=writeUtf8Char(t,s-1); col++; break;
+  while ((c = *s++)) {
+    switch (c) {
+    case '\t': {
+      static int tabSize = Config_getInt(TAB_SIZE);
+      int spacesToNextTabStop = tabSize - (col % tabSize);
+      col += spacesToNextTabStop;
+      while (spacesToNextTabStop--)
+        t << "<sp/>";
+      break;
+    }
+    case ' ':
+      t << "<sp/>";
+      col++;
+      break;
+    case '<':
+      t << "&lt;";
+      col++;
+      break;
+    case '>':
+      t << "&gt;";
+      col++;
+      break;
+    case '&':
+      t << "&amp;";
+      col++;
+      break;
+    case '\'':
+      t << "&apos;";
+      col++;
+      break;
+    case '"':
+      t << "&quot;";
+      col++;
+      break;
+    case 1:
+    case 2:
+    case 3:
+    case 4:
+    case 5:
+    case 6:
+    case 7:
+    case 8:
+    case 11:
+    case 12:
+    case 13:
+    case 14:
+    case 15:
+    case 16:
+    case 17:
+    case 18:
+    case 19:
+    case 20:
+    case 21:
+    case 22:
+    case 23:
+    case 24:
+    case 25:
+    case 26:
+    case 27:
+    case 28:
+    case 29:
+    case 30:
+    case 31:
+      break; // skip invalid XML characters (see
+             // http://www.w3.org/TR/2000/REC-xml-20001006#NT-Char)
+    default:
+      s = writeUtf8Char(t, s - 1);
+      col++;
+      break;
     }
   }
 }
 
-
-static void writeXMLHeader(FTextStream &t)
-{
-  t << "<?xml version='1.0' encoding='UTF-8' standalone='no'?>" << endl;;
+static void writeXMLHeader(FTextStream &t) {
+  t << "<?xml version='1.0' encoding='UTF-8' standalone='no'?>" << endl;
+  ;
   t << "<doxygen xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" ";
   t << "xsi:noNamespaceSchemaLocation=\"compound.xsd\" ";
   t << "version=\"" << versionString << "\">" << endl;
 }
 
-static void writeCombineScript()
-{
+static void writeCombineScript() {
   QCString outputDirectory = Config_getString(XML_OUTPUT);
-  QCString fileName=outputDirectory+"/combine.xslt";
+  QCString fileName = outputDirectory + "/combine.xslt";
   QFile f(fileName);
-  if (!f.open(IO_WriteOnly))
-  {
-    err("Cannot open file %s for writing!\n",fileName.data());
+  if (!f.open(IO_WriteOnly)) {
+    err("Cannot open file %s for writing!\n", fileName.data());
     return;
   }
   FTextStream t(&f);
-  //t.setEncoding(FTextStream::UnicodeUTF8);
-
-  t <<
-  "<!-- XSLT script to combine the generated output into a single file. \n"
-  "     If you have xsltproc you could use:\n"
-  "     xsltproc combine.xslt index.xml >all.xml\n"
-  "-->\n"
-  "<xsl:stylesheet xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\" version=\"1.0\">\n"
-  "  <xsl:output method=\"xml\" version=\"1.0\" indent=\"no\" standalone=\"yes\" />\n"
-  "  <xsl:template match=\"/\">\n"
-  "    <doxygen version=\"{doxygenindex/@version}\">\n"
-  "      <!-- Load all doxgen generated xml files -->\n"
-  "      <xsl:for-each select=\"doxygenindex/compound\">\n"
-  "        <xsl:copy-of select=\"document( concat( @refid, '.xml' ) )/doxygen/*\" />\n"
-  "      </xsl:for-each>\n"
-  "    </doxygen>\n"
-  "  </xsl:template>\n"
-  "</xsl:stylesheet>\n";
-
+  // t.setEncoding(FTextStream::UnicodeUTF8);
+
+  t << "<!-- XSLT script to combine the generated output into a single file. \n"
+       "     If you have xsltproc you could use:\n"
+       "     xsltproc combine.xslt index.xml >all.xml\n"
+       "-->\n"
+       "<xsl:stylesheet xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\" "
+       "version=\"1.0\">\n"
+       "  <xsl:output method=\"xml\" version=\"1.0\" indent=\"no\" "
+       "standalone=\"yes\" />\n"
+       "  <xsl:template match=\"/\">\n"
+       "    <doxygen version=\"{doxygenindex/@version}\">\n"
+       "      <!-- Load all doxgen generated xml files -->\n"
+       "      <xsl:for-each select=\"doxygenindex/compound\">\n"
+       "        <xsl:copy-of select=\"document( concat( @refid, '.xml' ) "
+       ")/doxygen/*\" />\n"
+       "      </xsl:for-each>\n"
+       "    </doxygen>\n"
+       "  </xsl:template>\n"
+       "</xsl:stylesheet>\n";
 }
 
-void writeXMLLink(FTextStream &t,const char *extRef,const char *compoundId,
-                  const char *anchorId,const char *text,const char *tooltip)
-{
+void writeXMLLink(FTextStream &t, const char *extRef, const char *compoundId,
+                  const char *anchorId, const char *text, const char *tooltip) {
   t << "<ref refid=\"" << compoundId;
-  if (anchorId) t << "_1" << anchorId;
+  if (anchorId)
+    t << "_1" << anchorId;
   t << "\" kindref=\"";
-  if (anchorId) t << "member"; else t << "compound"; 
+  if (anchorId)
+    t << "member";
+  else
+    t << "compound";
   t << "\"";
-  if (extRef) t << " external=\"" << extRef << "\"";
-  if (tooltip) t << " tooltip=\"" << convertToXML(tooltip) << "\"";
+  if (extRef)
+    t << " external=\"" << extRef << "\"";
+  if (tooltip)
+    t << " tooltip=\"" << convertToXML(tooltip) << "\"";
   t << ">";
-  writeXMLString(t,text);
+  writeXMLString(t, text);
   t << "</ref>";
 }
 
 /** Implements TextGeneratorIntf for an XML stream. */
-class TextGeneratorXMLImpl : public TextGeneratorIntf
-{
-  public:
-    TextGeneratorXMLImpl(FTextStream &t): m_t(t) {}
-    void writeString(const char *s,bool /*keepSpaces*/) const
-    {
-      writeXMLString(m_t,s); 
-    }
-    void writeBreak(int) const {}
-    void writeLink(const char *extRef,const char *file,
-                   const char *anchor,const char *text
-                  ) const
-    {
-      writeXMLLink(m_t,extRef,file,anchor,text,0);
-    }
-  private:
-    FTextStream &m_t;
-};
+class TextGeneratorXMLImpl : public TextGeneratorIntf {
+public:
+  TextGeneratorXMLImpl(FTextStream &t) : m_t(t) {}
+  void writeString(const char *s, bool /*keepSpaces*/) const {
+    writeXMLString(m_t, s);
+  }
+  void writeBreak(int) const {}
+  void writeLink(const char *extRef, const char *file, const char *anchor,
+                 const char *text) const {
+    writeXMLLink(m_t, extRef, file, anchor, text, 0);
+  }
 
+private:
+  FTextStream &m_t;
+};
 
 /** Generator for producing XML formatted source code. */
-class XMLCodeGenerator : public CodeOutputInterface
-{
-  public:
-
-    XMLCodeGenerator(FTextStream &t) : m_t(t), m_lineNumber(-1), m_isMemberRef(FALSE), m_col(0),
-      m_insideCodeLine(FALSE), m_normalHLNeedStartTag(TRUE), m_insideSpecialHL(FALSE) {}
-    virtual ~XMLCodeGenerator() { }
-
-    void codify(const char *text)
-    {
-      XML_DB(("(codify \"%s\")\n",text));
-      if (m_insideCodeLine && !m_insideSpecialHL && m_normalHLNeedStartTag)
-      {
-        m_t << "<highlight class=\"normal\">";
-        m_normalHLNeedStartTag=FALSE;
-      }
-      writeXMLCodeString(m_t,text,m_col);
-    }
-    void writeCodeLink(const char *ref,const char *file,
-                       const char *anchor,const char *name,
-                       const char *tooltip)
-    {
-      XML_DB(("(writeCodeLink)\n"));
-      if (m_insideCodeLine && !m_insideSpecialHL && m_normalHLNeedStartTag)
-      {
-        m_t << "<highlight class=\"normal\">";
-        m_normalHLNeedStartTag=FALSE;
-      }
-      writeXMLLink(m_t,ref,file,anchor,name,tooltip);
-      m_col+=qstrlen(name);
-    }
-    void writeTooltip(const char *, const DocLinkInfo &, const char *,
-                      const char *, const SourceLinkInfo &, const SourceLinkInfo &
-                     )
-    {
-      XML_DB(("(writeToolTip)\n"));
-    }
-    void startCodeLine(bool)
-    {
-      XML_DB(("(startCodeLine)\n"));
-      m_t << "<codeline";
-      if (m_lineNumber!=-1)
-      {
-        m_t << " lineno=\"" << m_lineNumber << "\"";
-        if (!m_refId.isEmpty())
-        {
-          m_t << " refid=\"" << m_refId << "\"";
-          if (m_isMemberRef)
-          {
-            m_t << " refkind=\"member\"";
-          }
-          else
-          {
-            m_t << " refkind=\"compound\"";
-          }
+class XMLCodeGenerator : public CodeOutputInterface {
+public:
+  XMLCodeGenerator(FTextStream &t)
+      : m_t(t), m_lineNumber(-1), m_isMemberRef(FALSE), m_col(0),
+        m_insideCodeLine(FALSE), m_normalHLNeedStartTag(TRUE),
+        m_insideSpecialHL(FALSE) {}
+  virtual ~XMLCodeGenerator() {}
+
+  void codify(const char *text) {
+    XML_DB(("(codify \"%s\")\n", text));
+    if (m_insideCodeLine && !m_insideSpecialHL && m_normalHLNeedStartTag) {
+      m_t << "<highlight class=\"normal\">";
+      m_normalHLNeedStartTag = FALSE;
+    }
+    writeXMLCodeString(m_t, text, m_col);
+  }
+  void writeCodeLink(const char *ref, const char *file, const char *anchor,
+                     const char *name, const char *tooltip) {
+    XML_DB(("(writeCodeLink)\n"));
+    if (m_insideCodeLine && !m_insideSpecialHL && m_normalHLNeedStartTag) {
+      m_t << "<highlight class=\"normal\">";
+      m_normalHLNeedStartTag = FALSE;
+    }
+    writeXMLLink(m_t, ref, file, anchor, name, tooltip);
+    m_col += qstrlen(name);
+  }
+  void writeTooltip(const char *, const DocLinkInfo &, const char *,
+                    const char *, const SourceLinkInfo &,
+                    const SourceLinkInfo &) {
+    XML_DB(("(writeToolTip)\n"));
+  }
+  void startCodeLine(bool) {
+    XML_DB(("(startCodeLine)\n"));
+    m_t << "<codeline";
+    if (m_lineNumber != -1) {
+      m_t << " lineno=\"" << m_lineNumber << "\"";
+      if (!m_refId.isEmpty()) {
+        m_t << " refid=\"" << m_refId << "\"";
+        if (m_isMemberRef) {
+          m_t << " refkind=\"member\"";
+        } else {
+          m_t << " refkind=\"compound\"";
         }
-        if (!m_external.isEmpty())
-        {
-          m_t << " external=\"" << m_external << "\"";
-        }
-      }
-      m_t << ">";
-      m_insideCodeLine=TRUE;
-      m_col=0;
-    }
-    void endCodeLine()
-    {
-      XML_DB(("(endCodeLine)\n"));
-      if (!m_insideSpecialHL && !m_normalHLNeedStartTag)
-      {
-        m_t << "</highlight>";
-        m_normalHLNeedStartTag=TRUE;
       }
-      m_t << "</codeline>" << endl; // non DocBook
-      m_lineNumber = -1;
-      m_refId.resize(0);
-      m_external.resize(0);
-      m_insideCodeLine=FALSE;
-    }
-    void startFontClass(const char *colorClass)
-    {
-      XML_DB(("(startFontClass)\n"));
-      if (m_insideCodeLine && !m_insideSpecialHL && !m_normalHLNeedStartTag)
-      {
-        m_t << "</highlight>";
-        m_normalHLNeedStartTag=TRUE;
+      if (!m_external.isEmpty()) {
+        m_t << " external=\"" << m_external << "\"";
       }
-      m_t << "<highlight class=\"" << colorClass << "\">"; // non DocBook
-      m_insideSpecialHL=TRUE;
-    }
-    void endFontClass()
-    {
-      XML_DB(("(endFontClass)\n"));
-      m_t << "</highlight>"; // non DocBook
-      m_insideSpecialHL=FALSE;
     }
-    void writeCodeAnchor(const char *)
-    {
-      XML_DB(("(writeCodeAnchor)\n"));
-    }
-    void writeLineNumber(const char *extRef,const char *compId,
-                         const char *anchorId,int l)
-    {
-      XML_DB(("(writeLineNumber)\n"));
-      // we remember the information provided here to use it
-      // at the <codeline> start tag.
-      m_lineNumber = l;
-      if (compId)
-      {
-        m_refId=compId;
-        if (anchorId) m_refId+=(QCString)"_1"+anchorId;
-        m_isMemberRef = anchorId!=0;
-        if (extRef) m_external=extRef;
-      }
-    }
-    void setCurrentDoc(Definition *,const char *,bool)
-    {
-    }
-    void addWord(const char *,bool)
-    {
-    }
-
-    void finish()
-    {
-      if (m_insideCodeLine) endCodeLine();
-    }
-
-  private:
-    FTextStream &m_t;
-    QCString m_refId;
-    QCString m_external;
-    int m_lineNumber;
-    bool m_isMemberRef;
-    int m_col;
-
-    bool m_insideCodeLine;
-    bool m_normalHLNeedStartTag;
-    bool m_insideSpecialHL;
+    m_t << ">";
+    m_insideCodeLine = TRUE;
+    m_col = 0;
+  }
+  void endCodeLine() {
+    XML_DB(("(endCodeLine)\n"));
+    if (!m_insideSpecialHL && !m_normalHLNeedStartTag) {
+      m_t << "</highlight>";
+      m_normalHLNeedStartTag = TRUE;
+    }
+    m_t << "</codeline>" << endl; // non DocBook
+    m_lineNumber = -1;
+    m_refId.resize(0);
+    m_external.resize(0);
+    m_insideCodeLine = FALSE;
+  }
+  void startFontClass(const char *colorClass) {
+    XML_DB(("(startFontClass)\n"));
+    if (m_insideCodeLine && !m_insideSpecialHL && !m_normalHLNeedStartTag) {
+      m_t << "</highlight>";
+      m_normalHLNeedStartTag = TRUE;
+    }
+    m_t << "<highlight class=\"" << colorClass << "\">"; // non DocBook
+    m_insideSpecialHL = TRUE;
+  }
+  void endFontClass() {
+    XML_DB(("(endFontClass)\n"));
+    m_t << "</highlight>"; // non DocBook
+    m_insideSpecialHL = FALSE;
+  }
+  void writeCodeAnchor(const char *) { XML_DB(("(writeCodeAnchor)\n")); }
+  void writeLineNumber(const char *extRef, const char *compId,
+                       const char *anchorId, int l) {
+    XML_DB(("(writeLineNumber)\n"));
+    // we remember the information provided here to use it
+    // at the <codeline> start tag.
+    m_lineNumber = l;
+    if (compId) {
+      m_refId = compId;
+      if (anchorId)
+        m_refId += (QCString) "_1" + anchorId;
+      m_isMemberRef = anchorId != 0;
+      if (extRef)
+        m_external = extRef;
+    }
+  }
+  void setCurrentDoc(Definition *, const char *, bool) {}
+  void addWord(const char *, bool) {}
+
+  void finish() {
+    if (m_insideCodeLine)
+      endCodeLine();
+  }
+
+private:
+  FTextStream &m_t;
+  QCString m_refId;
+  QCString m_external;
+  int m_lineNumber;
+  bool m_isMemberRef;
+  int m_col;
+
+  bool m_insideCodeLine;
+  bool m_normalHLNeedStartTag;
+  bool m_insideSpecialHL;
 };
 
-
-static void writeTemplateArgumentList(ArgumentList *al,
-                                      FTextStream &t,
-                                      Definition *scope,
-                                      FileDef *fileScope,
-                                      int indent)
-{
+static void writeTemplateArgumentList(ArgumentList *al, FTextStream &t,
+                                      Definition *scope, FileDef *fileScope,
+                                      int indent) {
   QCString indentStr;
-  indentStr.fill(' ',indent);
-  if (al)
-  {
+  indentStr.fill(' ', indent);
+  if (al) {
     t << indentStr << "<templateparamlist>" << endl;
     ArgumentListIterator ali(*al);
     Argument *a;
-    for (ali.toFirst();(a=ali.current());++ali)
-    {
+    for (ali.toFirst(); (a = ali.current()); ++ali) {
       t << indentStr << "  <param>" << endl;
-      if (!a->type.isEmpty())
-      {
-        t << indentStr <<  "    <type>";
-        linkifyText(TextGeneratorXMLImpl(t),scope,fileScope,0,a->type);
+      if (!a->type.isEmpty()) {
+        t << indentStr << "    <type>";
+        linkifyText(TextGeneratorXMLImpl(t), scope, fileScope, 0, a->type);
         t << "</type>" << endl;
       }
-      if (!a->name.isEmpty())
-      {
-        t << indentStr <<  "    <declname>" << a->name << "</declname>" << endl;
-        t << indentStr <<  "    <defname>" << a->name << "</defname>" << endl;
+      if (!a->name.isEmpty()) {
+        t << indentStr << "    <declname>" << a->name << "</declname>" << endl;
+        t << indentStr << "    <defname>" << a->name << "</defname>" << endl;
       }
-      if (!a->defval.isEmpty())
-      {
+      if (!a->defval.isEmpty()) {
         t << indentStr << "    <defval>";
-        linkifyText(TextGeneratorXMLImpl(t),scope,fileScope,0,a->defval);
+        linkifyText(TextGeneratorXMLImpl(t), scope, fileScope, 0, a->defval);
         t << "</defval>" << endl;
       }
-      if (!a->typeConstraint.isEmpty())
-      {
+      if (!a->typeConstraint.isEmpty()) {
         t << indentStr << "    <typeconstraint>";
-        linkifyText(TextGeneratorXMLImpl(t),scope,fileScope,0,a->typeConstraint);
+        linkifyText(TextGeneratorXMLImpl(t), scope, fileScope, 0,
+                    a->typeConstraint);
         t << "</typeconstraint>" << endl;
       }
       t << indentStr << "  </param>" << endl;
@@ -406,125 +413,119 @@ static void writeTemplateArgumentList(ArgumentList *al,
   }
 }
 
-static void writeMemberTemplateLists(MemberDef *md,FTextStream &t)
-{
+static void writeMemberTemplateLists(MemberDef *md, FTextStream &t) {
   ArgumentList *templMd = md->templateArguments();
   if (templMd) // function template prefix
   {
-    writeTemplateArgumentList(templMd,t,md->getClassDef(),md->getFileDef(),8);
+    writeTemplateArgumentList(templMd, t, md->getClassDef(), md->getFileDef(),
+                              8);
   }
 }
 
-static void writeTemplateList(ClassDef *cd,FTextStream &t)
-{
-  writeTemplateArgumentList(cd->templateArguments(),t,cd,0,4);
+static void writeTemplateList(ClassDef *cd, FTextStream &t) {
+  writeTemplateArgumentList(cd->templateArguments(), t, cd, 0, 4);
 }
 
-static void writeXMLDocBlock(FTextStream &t,
-                      const QCString &fileName,
-                      int lineNr,
-                      Definition *scope,
-                      MemberDef * md,
-                      const QCString &text)
-{
+static void writeXMLDocBlock(FTextStream &t, const QCString &fileName,
+                             int lineNr, Definition *scope, MemberDef *md,
+                             const QCString &text) {
   QCString stext = text.stripWhiteSpace();
-  if (stext.isEmpty()) return;
+  if (stext.isEmpty())
+    return;
   // convert the documentation string into an abstract syntax tree
-  DocNode *root = validatingParseDoc(fileName,lineNr,scope,md,text,FALSE,FALSE);
+  DocNode *root =
+      validatingParseDoc(fileName, lineNr, scope, md, text, FALSE, FALSE);
   // create a code generator
   XMLCodeGenerator *xmlCodeGen = new XMLCodeGenerator(t);
   // create a parse tree visitor for XML
-  XmlDocVisitor *visitor = new XmlDocVisitor(t,*xmlCodeGen);
+  XmlDocVisitor *visitor = new XmlDocVisitor(t, *xmlCodeGen);
   // visit all nodes
   root->accept(visitor);
   // clean up
   delete visitor;
   delete xmlCodeGen;
   delete root;
-  
 }
 
-void writeXMLCodeBlock(FTextStream &t,FileDef *fd)
-{
-  ParserInterface *pIntf=Doxygen::parserManager->getParser(fd->getDefFileExtension());
+void writeXMLCodeBlock(FTextStream &t, FileDef *fd) {
+  ParserInterface *pIntf =
+      Doxygen::parserManager->getParser(fd->getDefFileExtension());
   SrcLangExt langExt = getLanguageFromFileName(fd->getDefFileExtension());
   pIntf->resetCodeParserState();
   XMLCodeGenerator *xmlGen = new XMLCodeGenerator(t);
-  pIntf->parseCode(*xmlGen,  // codeOutIntf
-                0,           // scopeName
-                fileToString(fd->absFilePath(),Config_getBool(FILTER_SOURCE_FILES)),
-                langExt,     // lang
-                FALSE,       // isExampleBlock
-                0,           // exampleName
-                fd,          // fileDef
-                -1,          // startLine
-                -1,          // endLine
-                FALSE,       // inlineFragement
-                0,           // memberDef
-                TRUE         // showLineNumbers
-                );
+  pIntf->parseCode(
+      *xmlGen, // codeOutIntf
+      0,       // scopeName
+      fileToString(fd->absFilePath(), Config_getBool(FILTER_SOURCE_FILES)),
+      langExt, // lang
+      FALSE,   // isExampleBlock
+      0,       // exampleName
+      fd,      // fileDef
+      -1,      // startLine
+      -1,      // endLine
+      FALSE,   // inlineFragement
+      0,       // memberDef
+      TRUE     // showLineNumbers
+      );
   xmlGen->finish();
   delete xmlGen;
 }
 
-static void writeMemberReference(FTextStream &t,Definition *def,MemberDef *rmd,const char *tagName)
-{
+static void writeMemberReference(FTextStream &t, Definition *def,
+                                 MemberDef *rmd, const char *tagName) {
   QCString scope = rmd->getScopeString();
   QCString name = rmd->name();
-  if (!scope.isEmpty() && scope!=def->name())
-  {
-    name.prepend(scope+getLanguageSpecificSeparator(rmd->getLanguage()));
+  if (!scope.isEmpty() && scope != def->name()) {
+    name.prepend(scope + getLanguageSpecificSeparator(rmd->getLanguage()));
   }
   t << "        <" << tagName << " refid=\"";
   t << rmd->getOutputFileBase() << "_1" << rmd->anchor() << "\"";
-  if (rmd->getStartBodyLine()!=-1 && rmd->getBodyDef()) 
-  {
+  if (rmd->getStartBodyLine() != -1 && rmd->getBodyDef()) {
     t << " compoundref=\"" << rmd->getBodyDef()->getOutputFileBase() << "\"";
     t << " startline=\"" << rmd->getStartBodyLine() << "\"";
-    if (rmd->getEndBodyLine()!=-1)
-    {
+    if (rmd->getEndBodyLine() != -1) {
       t << " endline=\"" << rmd->getEndBodyLine() << "\"";
     }
   }
   t << ">" << convertToXML(name) << "</" << tagName << ">" << endl;
-  
 }
 
-static void stripQualifiers(QCString &typeStr)
-{
-  bool done=FALSE;
-  while (!done)
-  {
-    if (typeStr.stripPrefix("static "));
-    else if (typeStr.stripPrefix("virtual "));
-    else if (typeStr.stripPrefix("volatile "));
-    else if (typeStr=="virtual") typeStr="";
-    else done=TRUE;
+static void stripQualifiers(QCString &typeStr) {
+  bool done = FALSE;
+  while (!done) {
+    if (typeStr.stripPrefix("static "))
+      ;
+    else if (typeStr.stripPrefix("virtual "))
+      ;
+    else if (typeStr.stripPrefix("volatile "))
+      ;
+    else if (typeStr == "virtual")
+      typeStr = "";
+    else
+      done = TRUE;
   }
 }
 
-static QCString classOutputFileBase(ClassDef *cd)
-{
-  //static bool inlineGroupedClasses = Config_getBool(INLINE_GROUPED_CLASSES);
-  //if (inlineGroupedClasses && cd->partOfGroups()!=0) 
+static QCString classOutputFileBase(ClassDef *cd) {
+  // static bool inlineGroupedClasses = Config_getBool(INLINE_GROUPED_CLASSES);
+  // if (inlineGroupedClasses && cd->partOfGroups()!=0)
   return cd->getOutputFileBase();
-  //else 
+  // else
   //  return cd->getOutputFileBase();
 }
 
-static QCString memberOutputFileBase(MemberDef *md)
-{
-  //static bool inlineGroupedClasses = Config_getBool(INLINE_GROUPED_CLASSES);
-  //if (inlineGroupedClasses && md->getClassDef() && md->getClassDef()->partOfGroups()!=0) 
+static QCString memberOutputFileBase(MemberDef *md) {
+  // static bool inlineGroupedClasses = Config_getBool(INLINE_GROUPED_CLASSES);
+  // if (inlineGroupedClasses && md->getClassDef() &&
+  // md->getClassDef()->partOfGroups()!=0)
   //  return md->getClassDef()->getXmlOutputFileBase();
-  //else 
+  // else
   //  return md->getOutputFileBase();
   return md->getOutputFileBase();
 }
 
-
-static void generateXMLForMember(MemberDef *md,FTextStream &ti,FTextStream &t,Definition *def)
-{
+static void generateXMLForMember(MemberDef *md, FTextStream &ti, FTextStream &t,
+                                 Definition *def) {
 
   // + declaration/definition arg lists
   // + reimplements
@@ -535,582 +536,661 @@ static void generateXMLForMember(MemberDef *md,FTextStream &ti,FTextStream &t,De
   // + source definition
   // + source references
   // + source referenced by
-  // - body code 
-  // + template arguments 
+  // - body code
+  // + template arguments
   //     (templateArguments(), definitionTemplateParameterLists())
   // - call graph
-  
+
   // enum values are written as part of the enum
-  if (md->memberType()==MemberType_EnumValue) return;
-  if (md->isHidden()) return;
-  //if (md->name().at(0)=='@') return; // anonymous member
+  if (md->memberType() == MemberType_EnumValue)
+    return;
+  if (md->isHidden())
+    return;
+  // if (md->name().at(0)=='@') return; // anonymous member
 
   // group members are only visible in their group
-  //if (def->definitionType()!=Definition::TypeGroup && md->getGroupDef()) return;
+  // if (def->definitionType()!=Definition::TypeGroup && md->getGroupDef())
+  // return;
 
   QCString memType;
-  bool isFunc=FALSE;
-  switch (md->memberType())
-  {
-    case MemberType_Define:      memType="define";    break;
-    case MemberType_Function:    memType="function";  isFunc=TRUE; break;
-    case MemberType_Variable:    memType="variable";  break;
-    case MemberType_Typedef:     memType="typedef";   break;
-    case MemberType_Enumeration: memType="enum";      break;
-    case MemberType_EnumValue:   ASSERT(0);           break;
-    case MemberType_Signal:      memType="signal";    isFunc=TRUE; break;
-    case MemberType_Slot:        memType="slot";      isFunc=TRUE; break;
-    case MemberType_Friend:      memType="friend";    isFunc=TRUE; break;
-    case MemberType_DCOP:        memType="dcop";      isFunc=TRUE; break;
-    case MemberType_Property:    memType="property";  break;
-    case MemberType_Event:       memType="event";     break;
-    case MemberType_Interface:   memType="interface"; break;
-    case MemberType_Service:     memType="service";   break;
-    case MemberType_Clause:      memType="clause";    break;
-  }
-
-  ti << "    <member refid=\"" << memberOutputFileBase(md) 
-     << "_1" << md->anchor() << "\" kind=\"" << memType << "\"><name>" 
+  bool isFunc = FALSE;
+  switch (md->memberType()) {
+  case MemberType_Define:
+    memType = "define";
+    break;
+  case MemberType_Function:
+    memType = "function";
+    isFunc = TRUE;
+    break;
+  case MemberType_Variable:
+    memType = "variable";
+    break;
+  case MemberType_Typedef:
+    memType = "typedef";
+    break;
+  case MemberType_Enumeration:
+    memType = "enum";
+    break;
+  case MemberType_EnumValue:
+    ASSERT(0);
+    break;
+  case MemberType_Signal:
+    memType = "signal";
+    isFunc = TRUE;
+    break;
+  case MemberType_Slot:
+    memType = "slot";
+    isFunc = TRUE;
+    break;
+  case MemberType_Friend:
+    memType = "friend";
+    isFunc = TRUE;
+    break;
+  case MemberType_DCOP:
+    memType = "dcop";
+    isFunc = TRUE;
+    break;
+  case MemberType_Property:
+    memType = "property";
+    break;
+  case MemberType_Event:
+    memType = "event";
+    break;
+  case MemberType_Interface:
+    memType = "interface";
+    break;
+  case MemberType_Service:
+    memType = "service";
+    break;
+  case MemberType_Clause:
+    memType = "clause";
+    break;
+  default:
+    return;
+  }
+
+  ti << "    <member refid=\"" << memberOutputFileBase(md) << "_1"
+     << md->anchor() << "\" kind=\"" << memType << "\"><name>"
      << convertToXML(md->name()) << "</name></member>" << endl;
-  
+
   QCString scopeName;
-  if (md->getClassDef()) 
-    scopeName=md->getClassDef()->name();
-  else if (md->getNamespaceDef()) 
-    scopeName=md->getNamespaceDef()->name();
-    
+  if (md->getClassDef())
+    scopeName = md->getClassDef()->name();
+  else if (md->getNamespaceDef())
+    scopeName = md->getNamespaceDef()->name();
+
   t << "      <memberdef kind=\"";
-  //enum { define_t,variable_t,typedef_t,enum_t,function_t } xmlType = function_t;
+  // enum { define_t,variable_t,typedef_t,enum_t,function_t } xmlType =
+  // function_t;
   t << memType << "\" id=\"";
-  if (md->getGroupDef() && def->definitionType()==Definition::TypeGroup)
-  {
+  if (md->getGroupDef() && def->definitionType() == Definition::TypeGroup) {
     t << md->getGroupDef()->getOutputFileBase();
-  }
-  else
-  {
+  } else {
     t << memberOutputFileBase(md);
   }
-  t << "_1"      // encoded `:' character (see util.cpp:convertNameToFile)
+  t << "_1" // encoded `:' character (see util.cpp:convertNameToFile)
     << md->anchor();
   t << "\" prot=\"";
-  switch(md->protection())
-  {
-    case Public:    t << "public";     break;
-    case Protected: t << "protected";  break;
-    case Private:   t << "private";    break;
-    case Package:   t << "package";    break;
+  switch (md->protection()) {
+  case Public:
+    t << "public";
+    break;
+  case Protected:
+    t << "protected";
+    break;
+  case Private:
+    t << "private";
+    break;
+  case Package:
+    t << "package";
+    break;
   }
   t << "\"";
 
   t << " static=\"";
-  if (md->isStatic()) t << "yes"; else t << "no";
+  if (md->isStatic())
+    t << "yes";
+  else
+    t << "no";
   t << "\"";
 
-  if (isFunc)
-  {
+  if (isFunc) {
     ArgumentList *al = md->argumentList();
     t << " const=\"";
-    if (al!=0 && al->constSpecifier)    t << "yes"; else t << "no"; 
+    if (al != 0 && al->constSpecifier)
+      t << "yes";
+    else
+      t << "no";
     t << "\"";
 
     t << " explicit=\"";
-    if (md->isExplicit()) t << "yes"; else t << "no";
+    if (md->isExplicit())
+      t << "yes";
+    else
+      t << "no";
     t << "\"";
 
     t << " inline=\"";
-    if (md->isInline()) t << "yes"; else t << "no";
+    if (md->isInline())
+      t << "yes";
+    else
+      t << "no";
     t << "\"";
 
-    if (al->refQualifier!=RefQualifierNone)
-    {
+    if (al && al->refQualifier != RefQualifierNone) {
       t << " refqual=\"";
-      if (al->refQualifier==RefQualifierLValue) t << "lvalue"; else t << "rvalue";
+      if (al && al->refQualifier == RefQualifierLValue)
+        t << "lvalue";
+      else
+        t << "rvalue";
       t << "\"";
     }
 
-    if (md->isFinal())
-    {
+    if (md->isFinal()) {
       t << " final=\"yes\"";
     }
 
-    if (md->isSealed())
-    {
+    if (md->isSealed()) {
       t << " sealed=\"yes\"";
     }
 
-    if (md->isNew())
-    {
+    if (md->isNew()) {
       t << " new=\"yes\"";
     }
 
-    if (md->isOptional())
-    {
+    if (md->isOptional()) {
       t << " optional=\"yes\"";
     }
 
-    if (md->isRequired())
-    {
+    if (md->isRequired()) {
       t << " required=\"yes\"";
     }
 
-    if (al && al->volatileSpecifier)
-    {
+    if (al && al->volatileSpecifier) {
       t << " volatile=\"yes\"";
     }
 
     t << " virt=\"";
-    switch (md->virtualness())
-    {
-      case Normal:  t << "non-virtual";  break;
-      case Virtual: t << "virtual";      break;
-      case Pure:    t << "pure-virtual"; break;
-      default: ASSERT(0);
+    switch (md->virtualness()) {
+    case Normal:
+      t << "non-virtual";
+      break;
+    case Virtual:
+      t << "virtual";
+      break;
+    case Pure:
+      t << "pure-virtual";
+      break;
+    default:
+      ASSERT(0);
     }
     t << "\"";
   }
 
-  if (md->memberType() == MemberType_Variable)
-  {
-    //ArgumentList *al = md->argumentList();
-    //t << " volatile=\"";
-    //if (al && al->volatileSpecifier) t << "yes"; else t << "no"; 
+  if (md->memberType() == MemberType_Variable) {
+    // ArgumentList *al = md->argumentList();
+    // t << " volatile=\"";
+    // if (al && al->volatileSpecifier) t << "yes"; else t << "no";
 
     t << " mutable=\"";
-    if (md->isMutable()) t << "yes"; else t << "no";
+    if (md->isMutable())
+      t << "yes";
+    else
+      t << "no";
     t << "\"";
-    
-    if (md->isInitonly())
-    {
+
+    if (md->isInitonly()) {
       t << " initonly=\"yes\"";
     }
-    if (md->isAttribute())
-    {
+    if (md->isAttribute()) {
       t << " attribute=\"yes\"";
     }
-    if (md->isUNOProperty())
-    {
+    if (md->isUNOProperty()) {
       t << " property=\"yes\"";
     }
-    if (md->isReadonly())
-    {
+    if (md->isReadonly()) {
       t << " readonly=\"yes\"";
     }
-    if (md->isBound())
-    {
+    if (md->isBound()) {
       t << " bound=\"yes\"";
     }
-    if (md->isRemovable())
-    {
+    if (md->isRemovable()) {
       t << " removable=\"yes\"";
     }
-    if (md->isConstrained())
-    {
+    if (md->isConstrained()) {
       t << " constrained=\"yes\"";
     }
-    if (md->isTransient())
-    {
+    if (md->isTransient()) {
       t << " transient=\"yes\"";
     }
-    if (md->isMaybeVoid())
-    {
+    if (md->isMaybeVoid()) {
       t << " maybevoid=\"yes\"";
     }
-    if (md->isMaybeDefault())
-    {
+    if (md->isMaybeDefault()) {
       t << " maybedefault=\"yes\"";
     }
-    if (md->isMaybeAmbiguous())
-    {
+    if (md->isMaybeAmbiguous()) {
       t << " maybeambiguous=\"yes\"";
     }
-  }
-  else if (md->memberType() == MemberType_Property)
-  {
+  } else if (md->memberType() == MemberType_Property) {
     t << " readable=\"";
-    if (md->isReadable()) t << "yes"; else t << "no";
+    if (md->isReadable())
+      t << "yes";
+    else
+      t << "no";
     t << "\"";
 
     t << " writable=\"";
-    if (md->isWritable()) t << "yes"; else t << "no";
+    if (md->isWritable())
+      t << "yes";
+    else
+      t << "no";
     t << "\"";
 
     t << " gettable=\"";
-    if (md->isGettable()) t << "yes"; else t << "no";
+    if (md->isGettable())
+      t << "yes";
+    else
+      t << "no";
     t << "\"";
 
     t << " privategettable=\"";
-    if (md->isPrivateGettable()) t << "yes"; else t << "no";
+    if (md->isPrivateGettable())
+      t << "yes";
+    else
+      t << "no";
     t << "\"";
 
     t << " protectedgettable=\"";
-    if (md->isProtectedGettable()) t << "yes"; else t << "no";
+    if (md->isProtectedGettable())
+      t << "yes";
+    else
+      t << "no";
     t << "\"";
 
     t << " settable=\"";
-    if (md->isSettable()) t << "yes"; else t << "no";
+    if (md->isSettable())
+      t << "yes";
+    else
+      t << "no";
     t << "\"";
 
     t << " privatesettable=\"";
-    if (md->isPrivateSettable()) t << "yes"; else t << "no";
+    if (md->isPrivateSettable())
+      t << "yes";
+    else
+      t << "no";
     t << "\"";
 
     t << " protectedsettable=\"";
-    if (md->isProtectedSettable()) t << "yes"; else t << "no";
+    if (md->isProtectedSettable())
+      t << "yes";
+    else
+      t << "no";
     t << "\"";
 
-    if (md->isAssign() || md->isCopy() || md->isRetain() || md->isStrong() || md->isWeak())
-    {
+    if (md->isAssign() || md->isCopy() || md->isRetain() || md->isStrong() ||
+        md->isWeak()) {
       t << " accessor=\"";
-      if (md->isAssign())      t << "assign";
-      else if (md->isCopy())   t << "copy";
-      else if (md->isRetain()) t << "retain";
-      else if (md->isStrong()) t << "strong";
-      else if (md->isWeak())   t << "weak";
+      if (md->isAssign())
+        t << "assign";
+      else if (md->isCopy())
+        t << "copy";
+      else if (md->isRetain())
+        t << "retain";
+      else if (md->isStrong())
+        t << "strong";
+      else if (md->isWeak())
+        t << "weak";
       t << "\"";
     }
-  }
-  else if (md->memberType() == MemberType_Event)
-  {
+  } else if (md->memberType() == MemberType_Event) {
     t << " add=\"";
-    if (md->isAddable()) t << "yes"; else t << "no";
+    if (md->isAddable())
+      t << "yes";
+    else
+      t << "no";
     t << "\"";
 
     t << " remove=\"";
-    if (md->isRemovable()) t << "yes"; else t << "no";
+    if (md->isRemovable())
+      t << "yes";
+    else
+      t << "no";
     t << "\"";
 
     t << " raise=\"";
-    if (md->isRaisable()) t << "yes"; else t << "no";
+    if (md->isRaisable())
+      t << "yes";
+    else
+      t << "no";
     t << "\"";
   }
 
   t << ">" << endl;
 
-  if (md->memberType()!=MemberType_Define &&
-      md->memberType()!=MemberType_Enumeration
-     )
-  {
-    if (md->memberType()!=MemberType_Typedef)
-    {
-      writeMemberTemplateLists(md,t);
+  if (md->memberType() != MemberType_Define &&
+      md->memberType() != MemberType_Enumeration) {
+    if (md->memberType() != MemberType_Typedef) {
+      writeMemberTemplateLists(md, t);
     }
-    QCString typeStr = md->typeString(); //replaceAnonymousScopes(md->typeString());
+    QCString typeStr =
+        md->typeString(); // replaceAnonymousScopes(md->typeString());
     stripQualifiers(typeStr);
     t << "        <type>";
-    linkifyText(TextGeneratorXMLImpl(t),def,md->getBodyDef(),md,typeStr);
+    linkifyText(TextGeneratorXMLImpl(t), def, md->getBodyDef(), md, typeStr);
     t << "</type>" << endl;
-    t << "        <definition>" << convertToXML(md->definition()) << "</definition>" << endl;
-    t << "        <argsstring>" << convertToXML(md->argsString()) << "</argsstring>" << endl;
+    t << "        <definition>" << convertToXML(md->definition())
+      << "</definition>" << endl;
+    t << "        <argsstring>" << convertToXML(md->argsString())
+      << "</argsstring>" << endl;
   }
 
   t << "        <name>" << convertToXML(md->name()) << "</name>" << endl;
-  
-  if (md->memberType() == MemberType_Property)
-  {
+
+  if (md->memberType() == MemberType_Property) {
     if (md->isReadable())
-      t << "        <read>" << convertToXML(md->getReadAccessor()) << "</read>" << endl;
+      t << "        <read>" << convertToXML(md->getReadAccessor()) << "</read>"
+        << endl;
     if (md->isWritable())
-      t << "        <write>" << convertToXML(md->getWriteAccessor()) << "</write>" << endl;
+      t << "        <write>" << convertToXML(md->getWriteAccessor())
+        << "</write>" << endl;
   }
 
-  if (md->memberType()==MemberType_Variable && md->bitfieldString())
-  {
+  if (md->memberType() == MemberType_Variable && md->bitfieldString()) {
     QCString bitfield = md->bitfieldString();
-    if (bitfield.at(0)==':') bitfield=bitfield.mid(1);
-    t << "        <bitfield>" << convertToXML(bitfield) << "</bitfield>" << endl;
+    if (bitfield.at(0) == ':')
+      bitfield = bitfield.mid(1);
+    t << "        <bitfield>" << convertToXML(bitfield) << "</bitfield>"
+      << endl;
   }
-  
+
   MemberDef *rmd = md->reimplements();
-  if (rmd)
-  {
-    t << "        <reimplements refid=\"" 
-      << memberOutputFileBase(rmd) << "_1" << rmd->anchor() << "\">"
-      << convertToXML(rmd->name()) << "</reimplements>" << endl;
+  if (rmd) {
+    t << "        <reimplements refid=\"" << memberOutputFileBase(rmd) << "_1"
+      << rmd->anchor() << "\">" << convertToXML(rmd->name())
+      << "</reimplements>" << endl;
   }
   MemberList *rbml = md->reimplementedBy();
-  if (rbml)
-  {
+  if (rbml) {
     MemberListIterator mli(*rbml);
-    for (mli.toFirst();(rmd=mli.current());++mli)
-    {
-      t << "        <reimplementedby refid=\"" 
-        << memberOutputFileBase(rmd) << "_1" << rmd->anchor() << "\">"
-        << convertToXML(rmd->name()) << "</reimplementedby>" << endl;
+    for (mli.toFirst(); (rmd = mli.current()); ++mli) {
+      t << "        <reimplementedby refid=\"" << memberOutputFileBase(rmd)
+        << "_1" << rmd->anchor() << "\">" << convertToXML(rmd->name())
+        << "</reimplementedby>" << endl;
     }
   }
 
-  if (isFunc) //function
+  if (isFunc) // function
   {
     ArgumentList *declAl = md->declArgumentList();
     ArgumentList *defAl = md->argumentList();
-    if (declAl && declAl->count()>0)
-    {
+    if (declAl && declAl->count() > 0) {
       ArgumentListIterator declAli(*declAl);
       ArgumentListIterator defAli(*defAl);
       Argument *a;
-      for (declAli.toFirst();(a=declAli.current());++declAli)
-      {
+      for (declAli.toFirst(); (a = declAli.current()); ++declAli) {
         Argument *defArg = defAli.current();
         t << "        <param>" << endl;
-        if (!a->attrib.isEmpty())
-        {
+        if (!a->attrib.isEmpty()) {
           t << "          <attributes>";
-          writeXMLString(t,a->attrib);
+          writeXMLString(t, a->attrib);
           t << "</attributes>" << endl;
         }
-        if (!a->type.isEmpty())
-        {
+        if (!a->type.isEmpty()) {
           t << "          <type>";
-          linkifyText(TextGeneratorXMLImpl(t),def,md->getBodyDef(),md,a->type);
+          linkifyText(TextGeneratorXMLImpl(t), def, md->getBodyDef(), md,
+                      a->type);
           t << "</type>" << endl;
         }
-        if (!a->name.isEmpty())
-        {
+        if (!a->name.isEmpty()) {
           t << "          <declname>";
-          writeXMLString(t,a->name); 
+          writeXMLString(t, a->name);
           t << "</declname>" << endl;
         }
-        if (defArg && !defArg->name.isEmpty() && defArg->name!=a->name)
-        {
+        if (defArg && !defArg->name.isEmpty() && defArg->name != a->name) {
           t << "          <defname>";
-          writeXMLString(t,defArg->name);
+          writeXMLString(t, defArg->name);
           t << "</defname>" << endl;
         }
-        if (!a->array.isEmpty())
-        {
-          t << "          <array>"; 
-          writeXMLString(t,a->array); 
+        if (!a->array.isEmpty()) {
+          t << "          <array>";
+          writeXMLString(t, a->array);
           t << "</array>" << endl;
         }
-        if (!a->defval.isEmpty())
-        {
+        if (!a->defval.isEmpty()) {
           t << "          <defval>";
-          linkifyText(TextGeneratorXMLImpl(t),def,md->getBodyDef(),md,a->defval);
+          linkifyText(TextGeneratorXMLImpl(t), def, md->getBodyDef(), md,
+                      a->defval);
           t << "</defval>" << endl;
         }
-        if (defArg && defArg->hasDocumentation())
-        {
+        if (defArg && defArg->hasDocumentation()) {
           t << "          <briefdescription>";
-          writeXMLDocBlock(t,md->getDefFileName(),md->getDefLine(),
-                           md->getOuterScope(),md,defArg->docs);
+          writeXMLDocBlock(t, md->getDefFileName(), md->getDefLine(),
+                           md->getOuterScope(), md, defArg->docs);
           t << "</briefdescription>" << endl;
         }
         t << "        </param>" << endl;
-        if (defArg) ++defAli;
+        if (defArg)
+          ++defAli;
       }
     }
-  }
-  else if (md->memberType()==MemberType_Define && 
-          md->argsString()) // define
+  } else if (md->memberType() == MemberType_Define &&
+             md->argsString()) // define
   {
-    if (md->argumentList()->count()==0) // special case for "foo()" to
-                                        // disguish it from "foo".
+    if (md->argumentList()->count() == 0) // special case for "foo()" to
+                                          // disguish it from "foo".
     {
       t << "        <param></param>" << endl;
-    }
-    else
-    {
+    } else {
       ArgumentListIterator ali(*md->argumentList());
       Argument *a;
-      for (ali.toFirst();(a=ali.current());++ali)
-      {
-        t << "        <param><defname>" << a->type << "</defname></param>" << endl;
+      for (ali.toFirst(); (a = ali.current()); ++ali) {
+        t << "        <param><defname>" << a->type << "</defname></param>"
+          << endl;
       }
     }
   }
 
-  if (md->hasOneLineInitializer() || md->hasMultiLineInitializer())
-  {
+  if (md->hasOneLineInitializer() || md->hasMultiLineInitializer()) {
     t << "        <initializer>";
-    linkifyText(TextGeneratorXMLImpl(t),def,md->getBodyDef(),md,md->initializer());
+    linkifyText(TextGeneratorXMLImpl(t), def, md->getBodyDef(), md,
+                md->initializer());
     t << "</initializer>" << endl;
   }
 
-  if (md->excpString())
-  {
+  if (md->excpString()) {
     t << "        <exceptions>";
-    linkifyText(TextGeneratorXMLImpl(t),def,md->getBodyDef(),md,md->excpString());
+    linkifyText(TextGeneratorXMLImpl(t), def, md->getBodyDef(), md,
+                md->excpString());
     t << "</exceptions>" << endl;
   }
-  
-  if (md->memberType()==MemberType_Enumeration) // enum
+
+  if (md->memberType() == MemberType_Enumeration) // enum
   {
     MemberList *enumFields = md->enumFieldList();
-    if (enumFields)
-    {
+    if (enumFields) {
       MemberListIterator emli(*enumFields);
       MemberDef *emd;
-      for (emli.toFirst();(emd=emli.current());++emli)
-      {
-        ti << "    <member refid=\"" << memberOutputFileBase(emd) 
-           << "_1" << emd->anchor() << "\" kind=\"enumvalue\"><name>" 
+      for (emli.toFirst(); (emd = emli.current()); ++emli) {
+        ti << "    <member refid=\"" << memberOutputFileBase(emd) << "_1"
+           << emd->anchor() << "\" kind=\"enumvalue\"><name>"
            << convertToXML(emd->name()) << "</name></member>" << endl;
 
-        t << "        <enumvalue id=\"" << memberOutputFileBase(emd) << "_1" 
+        t << "        <enumvalue id=\"" << memberOutputFileBase(emd) << "_1"
           << emd->anchor() << "\" prot=\"";
-        switch (emd->protection())
-        {
-          case Public:    t << "public";    break;
-          case Protected: t << "protected"; break;
-          case Private:   t << "private";   break;
-          case Package:   t << "package";   break;
+        switch (emd->protection()) {
+        case Public:
+          t << "public";
+          break;
+        case Protected:
+          t << "protected";
+          break;
+        case Private:
+          t << "private";
+          break;
+        case Package:
+          t << "package";
+          break;
         }
         t << "\">" << endl;
         t << "          <name>";
-        writeXMLString(t,emd->name());
+        writeXMLString(t, emd->name());
         t << "</name>" << endl;
-        if (!emd->initializer().isEmpty())
-        {
+        if (!emd->initializer().isEmpty()) {
           t << "          <initializer>";
-          writeXMLString(t,emd->initializer());
+          writeXMLString(t, emd->initializer());
           t << "</initializer>" << endl;
         }
         t << "          <briefdescription>" << endl;
-        writeXMLDocBlock(t,emd->briefFile(),emd->briefLine(),emd->getOuterScope(),emd,emd->briefDescription());
+        writeXMLDocBlock(t, emd->briefFile(), emd->briefLine(),
+                         emd->getOuterScope(), emd, emd->briefDescription());
         t << "          </briefdescription>" << endl;
         t << "          <detaileddescription>" << endl;
-        writeXMLDocBlock(t,emd->docFile(),emd->docLine(),emd->getOuterScope(),emd,emd->documentation());
+        writeXMLDocBlock(t, emd->docFile(), emd->docLine(),
+                         emd->getOuterScope(), emd, emd->documentation());
         t << "          </detaileddescription>" << endl;
         t << "        </enumvalue>" << endl;
       }
     }
   }
   t << "        <briefdescription>" << endl;
-  writeXMLDocBlock(t,md->briefFile(),md->briefLine(),md->getOuterScope(),md,md->briefDescription());
+  writeXMLDocBlock(t, md->briefFile(), md->briefLine(), md->getOuterScope(), md,
+                   md->briefDescription());
   t << "        </briefdescription>" << endl;
   t << "        <detaileddescription>" << endl;
-  writeXMLDocBlock(t,md->docFile(),md->docLine(),md->getOuterScope(),md,md->documentation());
+  writeXMLDocBlock(t, md->docFile(), md->docLine(), md->getOuterScope(), md,
+                   md->documentation());
   t << "        </detaileddescription>" << endl;
   t << "        <inbodydescription>" << endl;
-  writeXMLDocBlock(t,md->docFile(),md->inbodyLine(),md->getOuterScope(),md,md->inbodyDocumentation());
+  writeXMLDocBlock(t, md->docFile(), md->inbodyLine(), md->getOuterScope(), md,
+                   md->inbodyDocumentation());
   t << "        </inbodydescription>" << endl;
-  if (md->getDefLine()!=-1)
-  {
-    t << "        <location file=\"" 
-      << stripFromPath(md->getDefFileName()) << "\" line=\""
-      << md->getDefLine() << "\"" << " column=\"" 
-      << md->getDefColumn() << "\"" ;
-    if (md->getStartBodyLine()!=-1)
-    {
+  if (md->getDefLine() != -1) {
+    t << "        <location file=\"" << stripFromPath(md->getDefFileName())
+      << "\" line=\"" << md->getDefLine() << "\""
+      << " column=\"" << md->getDefColumn() << "\"";
+    if (md->getStartBodyLine() != -1) {
       FileDef *bodyDef = md->getBodyDef();
-      if (bodyDef)
-      {
+      if (bodyDef) {
         t << " bodyfile=\"" << stripFromPath(bodyDef->absFilePath()) << "\"";
       }
-      t << " bodystart=\"" << md->getStartBodyLine() << "\" bodyend=\"" 
+      t << " bodystart=\"" << md->getStartBodyLine() << "\" bodyend=\""
         << md->getEndBodyLine() << "\"";
     }
     t << "/>" << endl;
   }
 
-  //printf("md->getReferencesMembers()=%p\n",md->getReferencesMembers());
+  // printf("md->getReferencesMembers()=%p\n",md->getReferencesMembers());
   MemberSDict *mdict = md->getReferencesMembers();
-  if (mdict)
-  {
+  if (mdict) {
     MemberSDict::Iterator mdi(*mdict);
     MemberDef *rmd;
-    for (mdi.toFirst();(rmd=mdi.current());++mdi)
-    {
-      writeMemberReference(t,def,rmd,"references");
+    for (mdi.toFirst(); (rmd = mdi.current()); ++mdi) {
+      writeMemberReference(t, def, rmd, "references");
     }
   }
   mdict = md->getReferencedByMembers();
-  if (mdict)
-  {
+  if (mdict) {
     MemberSDict::Iterator mdi(*mdict);
     MemberDef *rmd;
-    for (mdi.toFirst();(rmd=mdi.current());++mdi)
-    {
-      writeMemberReference(t,def,rmd,"referencedby");
+    for (mdi.toFirst(); (rmd = mdi.current()); ++mdi) {
+      writeMemberReference(t, def, rmd, "referencedby");
     }
   }
-  
+
   t << "      </memberdef>" << endl;
 }
 
-static void generateXMLSection(Definition *d,FTextStream &ti,FTextStream &t,
-                      MemberList *ml,const char *kind,const char *header=0,
-                      const char *documentation=0)
-{
-  if (ml==0) return;
+static void generateXMLSection(Definition *d, FTextStream &ti, FTextStream &t,
+                               MemberList *ml, const char *kind,
+                               const char *header = 0,
+                               const char *documentation = 0) {
+  if (ml == 0)
+    return;
   MemberListIterator mli(*ml);
   MemberDef *md;
-  int count=0;
-  for (mli.toFirst();(md=mli.current());++mli)
-  {
-    // namespace members are also inserted in the file scope, but 
+  int count = 0;
+  for (mli.toFirst(); (md = mli.current()); ++mli) {
+    // namespace members are also inserted in the file scope, but
     // to prevent this duplication in the XML output, we filter those here.
-    if (d->definitionType()!=Definition::TypeFile || md->getNamespaceDef()==0)
-    {
+    if (d->definitionType() != Definition::TypeFile ||
+        md->getNamespaceDef() == 0) {
       count++;
     }
   }
-  if (count==0) return; // empty list
+  if (count == 0)
+    return; // empty list
 
   t << "      <sectiondef kind=\"" << kind << "\">" << endl;
-  if (header)
-  {
+  if (header) {
     t << "      <header>" << convertToXML(header) << "</header>" << endl;
   }
-  if (documentation)
-  {
+  if (documentation) {
     t << "      <description>";
-    writeXMLDocBlock(t,d->docFile(),d->docLine(),d,0,documentation);
+    writeXMLDocBlock(t, d->docFile(), d->docLine(), d, 0, documentation);
     t << "</description>" << endl;
   }
-  for (mli.toFirst();(md=mli.current());++mli)
-  {
-    // namespace members are also inserted in the file scope, but 
+  for (mli.toFirst(); (md = mli.current()); ++mli) {
+    // namespace members are also inserted in the file scope, but
     // to prevent this duplication in the XML output, we filter those here.
-    if (d->definitionType()!=Definition::TypeFile || md->getNamespaceDef()==0)
-    {
-      generateXMLForMember(md,ti,t,d);
+    if (d->definitionType() != Definition::TypeFile ||
+        md->getNamespaceDef() == 0) {
+      generateXMLForMember(md, ti, t, d);
     }
   }
   t << "      </sectiondef>" << endl;
 }
 
-static void writeListOfAllMembers(ClassDef *cd,FTextStream &t)
-{
+static void writeListOfAllMembers(ClassDef *cd, FTextStream &t) {
   t << "    <listofallmembers>" << endl;
-  if (cd->memberNameInfoSDict())
-  {
+  if (cd->memberNameInfoSDict()) {
     MemberNameInfoSDict::Iterator mnii(*cd->memberNameInfoSDict());
     MemberNameInfo *mni;
-    for (mnii.toFirst();(mni=mnii.current());++mnii)
-    {
+    for (mnii.toFirst(); (mni = mnii.current()); ++mnii) {
       MemberNameInfoIterator mii(*mni);
       MemberInfo *mi;
-      for (mii.toFirst();(mi=mii.current());++mii)
-      {
-        MemberDef *md=mi->memberDef;
-        if (md->name().at(0)!='@') // skip anonymous members
+      for (mii.toFirst(); (mi = mii.current()); ++mii) {
+        MemberDef *md = mi->memberDef;
+        if (md->name().at(0) != '@') // skip anonymous members
         {
           Protection prot = mi->prot;
-          Specifier virt=md->virtualness();
-          t << "      <member refid=\"" << memberOutputFileBase(md) << "_1" <<
-            md->anchor() << "\" prot=\"";
-          switch (prot)
-          {
-            case Public:    t << "public";    break;
-            case Protected: t << "protected"; break;
-            case Private:   t << "private";   break;
-            case Package:   t << "package";   break;
+          Specifier virt = md->virtualness();
+          t << "      <member refid=\"" << memberOutputFileBase(md) << "_1"
+            << md->anchor() << "\" prot=\"";
+          switch (prot) {
+          case Public:
+            t << "public";
+            break;
+          case Protected:
+            t << "protected";
+            break;
+          case Private:
+            t << "private";
+            break;
+          case Package:
+            t << "package";
+            break;
           }
           t << "\" virt=\"";
-          switch(virt)
-          {
-            case Normal:  t << "non-virtual";  break;
-            case Virtual: t << "virtual";      break;
-            case Pure:    t << "pure-virtual"; break;
+          switch (virt) {
+          case Normal:
+            t << "non-virtual";
+            break;
+          case Virtual:
+            t << "virtual";
+            break;
+          case Pure:
+            t << "pure-virtual";
+            break;
           }
           t << "\"";
-          if (!mi->ambiguityResolutionScope.isEmpty())
-          {
-            t << " ambiguityscope=\"" << convertToXML(mi->ambiguityResolutionScope) << "\"";
+          if (!mi->ambiguityResolutionScope.isEmpty()) {
+            t << " ambiguityscope=\""
+              << convertToXML(mi->ambiguityResolutionScope) << "\"";
           }
-          t << "><scope>" << convertToXML(cd->name()) << "</scope><name>" << 
-            convertToXML(md->name()) << "</name></member>" << endl;
+          t << "><scope>" << convertToXML(cd->name()) << "</scope><name>"
+            << convertToXML(md->name()) << "</name></member>" << endl;
         }
       }
     }
@@ -1118,24 +1198,29 @@ static void writeListOfAllMembers(ClassDef *cd,FTextStream &t)
   t << "    </listofallmembers>" << endl;
 }
 
-static void writeInnerClasses(const ClassSDict *cl,FTextStream &t)
-{
-  if (cl)
-  {
+static void writeInnerClasses(const ClassSDict *cl, FTextStream &t) {
+  if (cl) {
     ClassSDict::Iterator cli(*cl);
     ClassDef *cd;
-    for (cli.toFirst();(cd=cli.current());++cli)
-    {
-      if (!cd->isHidden() && cd->name().find('@')==-1) // skip anonymous scopes
+    for (cli.toFirst(); (cd = cli.current()); ++cli) {
+      if (!cd->isHidden() &&
+          cd->name().find('@') == -1) // skip anonymous scopes
       {
         t << "    <innerclass refid=\"" << classOutputFileBase(cd)
           << "\" prot=\"";
-        switch(cd->protection())
-        {
-           case Public:    t << "public";     break;
-           case Protected: t << "protected";  break;
-           case Private:   t << "private";    break;
-           case Package:   t << "package";    break;
+        switch (cd->protection()) {
+        case Public:
+          t << "public";
+          break;
+        case Protected:
+          t << "protected";
+          break;
+        case Private:
+          t << "private";
+          break;
+        case Package:
+          t << "package";
+          break;
         }
         t << "\">" << convertToXML(cd->name()) << "</innerclass>" << endl;
       }
@@ -1143,48 +1228,39 @@ static void writeInnerClasses(const ClassSDict *cl,FTextStream &t)
   }
 }
 
-static void writeInnerNamespaces(const NamespaceSDict *nl,FTextStream &t)
-{
-  if (nl)
-  {
+static void writeInnerNamespaces(const NamespaceSDict *nl, FTextStream &t) {
+  if (nl) {
     NamespaceSDict::Iterator nli(*nl);
     NamespaceDef *nd;
-    for (nli.toFirst();(nd=nli.current());++nli)
-    {
-      if (!nd->isHidden() && nd->name().find('@')==-1) // skip anonymouse scopes
+    for (nli.toFirst(); (nd = nli.current()); ++nli) {
+      if (!nd->isHidden() &&
+          nd->name().find('@') == -1) // skip anonymouse scopes
       {
-        t << "    <innernamespace refid=\"" << nd->getOutputFileBase()
-          << "\">" << convertToXML(nd->name()) << "</innernamespace>" << endl;
+        t << "    <innernamespace refid=\"" << nd->getOutputFileBase() << "\">"
+          << convertToXML(nd->name()) << "</innernamespace>" << endl;
       }
     }
   }
 }
 
-static void writeInnerFiles(const FileList *fl,FTextStream &t)
-{
-  if (fl)
-  {
+static void writeInnerFiles(const FileList *fl, FTextStream &t) {
+  if (fl) {
     QListIterator<FileDef> fli(*fl);
     FileDef *fd;
-    for (fli.toFirst();(fd=fli.current());++fli)
-    {
-      t << "    <innerfile refid=\"" << fd->getOutputFileBase() 
-        << "\">" << convertToXML(fd->name()) << "</innerfile>" << endl;
+    for (fli.toFirst(); (fd = fli.current()); ++fli) {
+      t << "    <innerfile refid=\"" << fd->getOutputFileBase() << "\">"
+        << convertToXML(fd->name()) << "</innerfile>" << endl;
     }
   }
 }
 
-static void writeInnerPages(const PageSDict *pl,FTextStream &t)
-{
-  if (pl)
-  {
+static void writeInnerPages(const PageSDict *pl, FTextStream &t) {
+  if (pl) {
     PageSDict::Iterator pli(*pl);
     PageDef *pd;
-    for (pli.toFirst();(pd=pli.current());++pli)
-    {
+    for (pli.toFirst(); (pd = pli.current()); ++pli) {
       t << "    <innerpage refid=\"" << pd->getOutputFileBase();
-      if (pd->getGroupDef())
-      {
+      if (pd->getGroupDef()) {
         t << "_" << pd->name();
       }
       t << "\">" << convertToXML(pd->title()) << "</innerpage>" << endl;
@@ -1192,37 +1268,29 @@ static void writeInnerPages(const PageSDict *pl,FTextStream &t)
   }
 }
 
-static void writeInnerGroups(const GroupList *gl,FTextStream &t)
-{
-  if (gl)
-  {
+static void writeInnerGroups(const GroupList *gl, FTextStream &t) {
+  if (gl) {
     GroupListIterator gli(*gl);
     GroupDef *sgd;
-    for (gli.toFirst();(sgd=gli.current());++gli)
-    {
-      t << "    <innergroup refid=\"" << sgd->getOutputFileBase()
-        << "\">" << convertToXML(sgd->groupTitle()) 
-        << "</innergroup>" << endl;
+    for (gli.toFirst(); (sgd = gli.current()); ++gli) {
+      t << "    <innergroup refid=\"" << sgd->getOutputFileBase() << "\">"
+        << convertToXML(sgd->groupTitle()) << "</innergroup>" << endl;
     }
   }
 }
 
-static void writeInnerDirs(const DirList *dl,FTextStream &t)
-{
-  if (dl)
-  {
+static void writeInnerDirs(const DirList *dl, FTextStream &t) {
+  if (dl) {
     QListIterator<DirDef> subdirs(*dl);
     DirDef *subdir;
-    for (subdirs.toFirst();(subdir=subdirs.current());++subdirs)
-    {
-      t << "    <innerdir refid=\"" << subdir->getOutputFileBase() 
-        << "\">" << convertToXML(subdir->displayName()) << "</innerdir>" << endl;
+    for (subdirs.toFirst(); (subdir = subdirs.current()); ++subdirs) {
+      t << "    <innerdir refid=\"" << subdir->getOutputFileBase() << "\">"
+        << convertToXML(subdir->displayName()) << "</innerdir>" << endl;
     }
   }
 }
-  
-static void generateXMLForClass(ClassDef *cd,FTextStream &ti)
-{
+
+static void generateXMLForClass(ClassDef *cd, FTextStream &ti) {
   // + brief description
   // + detailed description
   // + template argument list(s)
@@ -1239,126 +1307,152 @@ static void generateXMLForClass(ClassDef *cd,FTextStream &ti)
   // + detailed member documentation
   // - examples using the class
 
-  if (cd->isReference())        return; // skip external references.
-  if (cd->isHidden())           return; // skip hidden classes.
-  if (cd->name().find('@')!=-1) return; // skip anonymous compounds.
-  if (cd->templateMaster()!=0)  return; // skip generated template instances.
-  if (cd->isArtificial())       return; // skip artificially created classes
-
-  msg("Generating XML output for class %s\n",cd->name().data());
+  if (cd->isReference())
+    return; // skip external references.
+  if (cd->isHidden())
+    return; // skip hidden classes.
+  if (cd->name().find('@') != -1)
+    return; // skip anonymous compounds.
+  if (cd->templateMaster() != 0)
+    return; // skip generated template instances.
+  if (cd->isArtificial())
+    return; // skip artificially created classes
+
+  msg("Generating XML output for class %s\n", cd->name().data());
+
+  ti << "  <compound refid=\"" << classOutputFileBase(cd) << "\" kind=\""
+     << cd->compoundTypeString() << "\"><name>" << convertToXML(cd->name())
+     << "</name>" << endl;
 
-  ti << "  <compound refid=\"" << classOutputFileBase(cd) 
-     << "\" kind=\"" << cd->compoundTypeString()
-     << "\"><name>" << convertToXML(cd->name()) << "</name>" << endl;
-  
   QCString outputDirectory = Config_getString(XML_OUTPUT);
-  QCString fileName=outputDirectory+"/"+ classOutputFileBase(cd)+".xml";
+  QCString fileName = outputDirectory + "/" + classOutputFileBase(cd) + ".xml";
   QFile f(fileName);
-  if (!f.open(IO_WriteOnly))
-  {
-    err("Cannot open file %s for writing!\n",fileName.data());
+  if (!f.open(IO_WriteOnly)) {
+    err("Cannot open file %s for writing!\n", fileName.data());
     return;
   }
   FTextStream t(&f);
-  //t.setEncoding(FTextStream::UnicodeUTF8);
+  // t.setEncoding(FTextStream::UnicodeUTF8);
 
   writeXMLHeader(t);
-  t << "  <compounddef id=\"" 
-    << classOutputFileBase(cd) << "\" kind=\"" 
+  t << "  <compounddef id=\"" << classOutputFileBase(cd) << "\" kind=\""
     << cd->compoundTypeString() << "\" language=\""
     << langToString(cd->getLanguage()) << "\" prot=\"";
-  switch (cd->protection())
-  {
-    case Public:    t << "public";    break;
-    case Protected: t << "protected"; break;
-    case Private:   t << "private";   break;
-    case Package:   t << "package";   break;
-  }
-  if (cd->isFinal()) t << "\" final=\"yes";
-  if (cd->isSealed()) t << "\" sealed=\"yes";
-  if (cd->isAbstract()) t << "\" abstract=\"yes";
+  switch (cd->protection()) {
+  case Public:
+    t << "public";
+    break;
+  case Protected:
+    t << "protected";
+    break;
+  case Private:
+    t << "private";
+    break;
+  case Package:
+    t << "package";
+    break;
+  }
+  if (cd->isFinal())
+    t << "\" final=\"yes";
+  if (cd->isSealed())
+    t << "\" sealed=\"yes";
+  if (cd->isAbstract())
+    t << "\" abstract=\"yes";
   t << "\">" << endl;
-  t << "    <compoundname>"; 
-  writeXMLString(t,cd->name()); 
+  t << "    <compoundname>";
+  writeXMLString(t, cd->name());
   t << "</compoundname>" << endl;
-  if (cd->baseClasses())
-  {
+  if (cd->baseClasses()) {
     BaseClassListIterator bcli(*cd->baseClasses());
     BaseClassDef *bcd;
-    for (bcli.toFirst();(bcd=bcli.current());++bcli)
-    {
+    for (bcli.toFirst(); (bcd = bcli.current()); ++bcli) {
       t << "    <basecompoundref ";
-      if (bcd->classDef->isLinkable())
-      {
+      if (bcd->classDef->isLinkable()) {
         t << "refid=\"" << classOutputFileBase(bcd->classDef) << "\" ";
       }
       t << "prot=\"";
-      switch (bcd->prot)
-      {
-        case Public:    t << "public";    break;
-        case Protected: t << "protected"; break;
-        case Private:   t << "private";   break;
-        case Package: ASSERT(0); break;
+      switch (bcd->prot) {
+      case Public:
+        t << "public";
+        break;
+      case Protected:
+        t << "protected";
+        break;
+      case Private:
+        t << "private";
+        break;
+      case Package:
+        ASSERT(0);
+        break;
       }
       t << "\" virt=\"";
-      switch(bcd->virt)
-      {
-        case Normal:  t << "non-virtual";  break;
-        case Virtual: t << "virtual";      break;
-        case Pure:    t <<"pure-virtual"; break;
+      switch (bcd->virt) {
+      case Normal:
+        t << "non-virtual";
+        break;
+      case Virtual:
+        t << "virtual";
+        break;
+      case Pure:
+        t << "pure-virtual";
+        break;
       }
       t << "\">";
-      if (!bcd->templSpecifiers.isEmpty())
-      {
-        t << convertToXML(
-              insertTemplateSpecifierInScope(
-              bcd->classDef->name(),bcd->templSpecifiers)
-           );
-      }
-      else
-      {
+      if (!bcd->templSpecifiers.isEmpty()) {
+        t << convertToXML(insertTemplateSpecifierInScope(bcd->classDef->name(),
+                                                         bcd->templSpecifiers));
+      } else {
         t << convertToXML(bcd->classDef->displayName());
       }
-      t  << "</basecompoundref>" << endl;
+      t << "</basecompoundref>" << endl;
     }
   }
-  if (cd->subClasses())
-  {
+  if (cd->subClasses()) {
     BaseClassListIterator bcli(*cd->subClasses());
     BaseClassDef *bcd;
-    for (bcli.toFirst();(bcd=bcli.current());++bcli)
-    {
-      t << "    <derivedcompoundref refid=\"" 
-        << classOutputFileBase(bcd->classDef)
-        << "\" prot=\"";
-      switch (bcd->prot)
-      {
-        case Public:    t << "public";    break;
-        case Protected: t << "protected"; break;
-        case Private:   t << "private";   break;
-        case Package: ASSERT(0); break;
+    for (bcli.toFirst(); (bcd = bcli.current()); ++bcli) {
+      t << "    <derivedcompoundref refid=\""
+        << classOutputFileBase(bcd->classDef) << "\" prot=\"";
+      switch (bcd->prot) {
+      case Public:
+        t << "public";
+        break;
+      case Protected:
+        t << "protected";
+        break;
+      case Private:
+        t << "private";
+        break;
+      case Package:
+        ASSERT(0);
+        break;
       }
       t << "\" virt=\"";
-      switch(bcd->virt)
-      {
-        case Normal:  t << "non-virtual";  break;
-        case Virtual: t << "virtual";      break;
-        case Pure:    t << "pure-virtual"; break;
+      switch (bcd->virt) {
+      case Normal:
+        t << "non-virtual";
+        break;
+      case Virtual:
+        t << "virtual";
+        break;
+      case Pure:
+        t << "pure-virtual";
+        break;
       }
-      t << "\">" << convertToXML(bcd->classDef->displayName()) 
+      t << "\">" << convertToXML(bcd->classDef->displayName())
         << "</derivedcompoundref>" << endl;
     }
   }
 
-  IncludeInfo *ii=cd->includeInfo();
-  if (ii)
-  {
+  IncludeInfo *ii = cd->includeInfo();
+  if (ii) {
     QCString nm = ii->includeName;
-    if (nm.isEmpty() && ii->fileDef) nm = ii->fileDef->docName();
-    if (!nm.isEmpty())
-    {
+    if (nm.isEmpty() && ii->fileDef)
+      nm = ii->fileDef->docName();
+    if (!nm.isEmpty()) {
       t << "    <includes";
-      if (ii->fileDef && !ii->fileDef->isReference()) // TODO: support external references
+      if (ii->fileDef &&
+          !ii->fileDef->isReference()) // TODO: support external references
       {
         t << " refid=\"" << ii->fileDef->getOutputFileBase() << "\"";
       }
@@ -1368,74 +1462,66 @@ static void generateXMLForClass(ClassDef *cd,FTextStream &ti)
     }
   }
 
-  writeInnerClasses(cd->getClassSDict(),t);
+  writeInnerClasses(cd->getClassSDict(), t);
 
-  writeTemplateList(cd,t);
-  if (cd->getMemberGroupSDict())
-  {
+  writeTemplateList(cd, t);
+  if (cd->getMemberGroupSDict()) {
     MemberGroupSDict::Iterator mgli(*cd->getMemberGroupSDict());
     MemberGroup *mg;
-    for (;(mg=mgli.current());++mgli)
-    {
-      generateXMLSection(cd,ti,t,mg->members(),"user-defined",mg->header(),
-          mg->documentation());
+    for (; (mg = mgli.current()); ++mgli) {
+      generateXMLSection(cd, ti, t, mg->members(), "user-defined", mg->header(),
+                         mg->documentation());
     }
   }
 
   QListIterator<MemberList> mli(cd->getMemberLists());
   MemberList *ml;
-  for (mli.toFirst();(ml=mli.current());++mli)
-  {
-    if ((ml->listType()&MemberListType_detailedLists)==0)
-    {
-      generateXMLSection(cd,ti,t,ml,g_xmlSectionMapper.find(ml->listType()));
+  for (mli.toFirst(); (ml = mli.current()); ++mli) {
+    if ((ml->listType() & MemberListType_detailedLists) == 0) {
+      generateXMLSection(cd, ti, t, ml,
+                         g_xmlSectionMapper.find(ml->listType()));
     }
   }
 
   t << "    <briefdescription>" << endl;
-  writeXMLDocBlock(t,cd->briefFile(),cd->briefLine(),cd,0,cd->briefDescription());
+  writeXMLDocBlock(t, cd->briefFile(), cd->briefLine(), cd, 0,
+                   cd->briefDescription());
   t << "    </briefdescription>" << endl;
   t << "    <detaileddescription>" << endl;
-  writeXMLDocBlock(t,cd->docFile(),cd->docLine(),cd,0,cd->documentation());
+  writeXMLDocBlock(t, cd->docFile(), cd->docLine(), cd, 0, cd->documentation());
   t << "    </detaileddescription>" << endl;
-  DotClassGraph inheritanceGraph(cd,DotNode::Inheritance);
-  if (!inheritanceGraph.isTrivial())
-  {
+  DotClassGraph inheritanceGraph(cd, DotNode::Inheritance);
+  if (!inheritanceGraph.isTrivial()) {
     t << "    <inheritancegraph>" << endl;
     inheritanceGraph.writeXML(t);
     t << "    </inheritancegraph>" << endl;
   }
-  DotClassGraph collaborationGraph(cd,DotNode::Collaboration);
-  if (!collaborationGraph.isTrivial())
-  {
+  DotClassGraph collaborationGraph(cd, DotNode::Collaboration);
+  if (!collaborationGraph.isTrivial()) {
     t << "    <collaborationgraph>" << endl;
     collaborationGraph.writeXML(t);
     t << "    </collaborationgraph>" << endl;
   }
-  t << "    <location file=\"" 
-    << stripFromPath(cd->getDefFileName()) << "\" line=\""
-    << cd->getDefLine() << "\"" << " column=\"" 
-    << cd->getDefColumn() << "\"" ;
-    if (cd->getStartBodyLine()!=-1)
-    {
-      FileDef *bodyDef = cd->getBodyDef();
-      if (bodyDef)
-      {
-        t << " bodyfile=\"" << stripFromPath(bodyDef->absFilePath()) << "\"";
-      }
-      t << " bodystart=\"" << cd->getStartBodyLine() << "\" bodyend=\"" 
-        << cd->getEndBodyLine() << "\"";
+  t << "    <location file=\"" << stripFromPath(cd->getDefFileName())
+    << "\" line=\"" << cd->getDefLine() << "\""
+    << " column=\"" << cd->getDefColumn() << "\"";
+  if (cd->getStartBodyLine() != -1) {
+    FileDef *bodyDef = cd->getBodyDef();
+    if (bodyDef) {
+      t << " bodyfile=\"" << stripFromPath(bodyDef->absFilePath()) << "\"";
     }
+    t << " bodystart=\"" << cd->getStartBodyLine() << "\" bodyend=\""
+      << cd->getEndBodyLine() << "\"";
+  }
   t << "/>" << endl;
-  writeListOfAllMembers(cd,t);
+  writeListOfAllMembers(cd, t);
   t << "  </compounddef>" << endl;
   t << "</doxygen>" << endl;
 
   ti << "  </compound>" << endl;
 }
 
-static void generateXMLForNamespace(NamespaceDef *nd,FTextStream &ti)
-{
+static void generateXMLForNamespace(NamespaceDef *nd, FTextStream &ti) {
   // + contained class definitions
   // + contained namespace definitions
   // + member groups
@@ -1445,73 +1531,69 @@ static void generateXMLForNamespace(NamespaceDef *nd,FTextStream &ti)
   // + location
   // - files containing (parts of) the namespace definition
 
-  if (nd->isReference() || nd->isHidden()) return; // skip external references
+  if (nd->isReference() || nd->isHidden())
+    return; // skip external references
+
+  ti << "  <compound refid=\"" << nd->getOutputFileBase()
+     << "\" kind=\"namespace\""
+     << "><name>" << convertToXML(nd->name()) << "</name>" << endl;
 
-  ti << "  <compound refid=\"" << nd->getOutputFileBase() 
-     << "\" kind=\"namespace\"" << "><name>" 
-     << convertToXML(nd->name()) << "</name>" << endl;
-  
   QCString outputDirectory = Config_getString(XML_OUTPUT);
-  QCString fileName=outputDirectory+"/"+nd->getOutputFileBase()+".xml";
+  QCString fileName = outputDirectory + "/" + nd->getOutputFileBase() + ".xml";
   QFile f(fileName);
-  if (!f.open(IO_WriteOnly))
-  {
-    err("Cannot open file %s for writing!\n",fileName.data());
+  if (!f.open(IO_WriteOnly)) {
+    err("Cannot open file %s for writing!\n", fileName.data());
     return;
   }
   FTextStream t(&f);
-  //t.setEncoding(FTextStream::UnicodeUTF8);
-  
+  // t.setEncoding(FTextStream::UnicodeUTF8);
+
   writeXMLHeader(t);
-  t << "  <compounddef id=\"" << nd->getOutputFileBase() 
-    << "\" kind=\"namespace\" language=\"" 
-    << langToString(nd->getLanguage()) << "\">" << endl;
+  t << "  <compounddef id=\"" << nd->getOutputFileBase()
+    << "\" kind=\"namespace\" language=\"" << langToString(nd->getLanguage())
+    << "\">" << endl;
   t << "    <compoundname>";
-  writeXMLString(t,nd->name());
+  writeXMLString(t, nd->name());
   t << "</compoundname>" << endl;
 
-  writeInnerClasses(nd->getClassSDict(),t);
-  writeInnerNamespaces(nd->getNamespaceSDict(),t);
+  writeInnerClasses(nd->getClassSDict(), t);
+  writeInnerNamespaces(nd->getNamespaceSDict(), t);
 
-  if (nd->getMemberGroupSDict())
-  {
+  if (nd->getMemberGroupSDict()) {
     MemberGroupSDict::Iterator mgli(*nd->getMemberGroupSDict());
     MemberGroup *mg;
-    for (;(mg=mgli.current());++mgli)
-    {
-      generateXMLSection(nd,ti,t,mg->members(),"user-defined",mg->header(),
-          mg->documentation());
+    for (; (mg = mgli.current()); ++mgli) {
+      generateXMLSection(nd, ti, t, mg->members(), "user-defined", mg->header(),
+                         mg->documentation());
     }
   }
 
   QListIterator<MemberList> mli(nd->getMemberLists());
   MemberList *ml;
-  for (mli.toFirst();(ml=mli.current());++mli)
-  {
-    if ((ml->listType()&MemberListType_declarationLists)!=0)
-    {
-      generateXMLSection(nd,ti,t,ml,g_xmlSectionMapper.find(ml->listType()));
+  for (mli.toFirst(); (ml = mli.current()); ++mli) {
+    if ((ml->listType() & MemberListType_declarationLists) != 0) {
+      generateXMLSection(nd, ti, t, ml,
+                         g_xmlSectionMapper.find(ml->listType()));
     }
   }
 
   t << "    <briefdescription>" << endl;
-  writeXMLDocBlock(t,nd->briefFile(),nd->briefLine(),nd,0,nd->briefDescription());
+  writeXMLDocBlock(t, nd->briefFile(), nd->briefLine(), nd, 0,
+                   nd->briefDescription());
   t << "    </briefdescription>" << endl;
   t << "    <detaileddescription>" << endl;
-  writeXMLDocBlock(t,nd->docFile(),nd->docLine(),nd,0,nd->documentation());
+  writeXMLDocBlock(t, nd->docFile(), nd->docLine(), nd, 0, nd->documentation());
   t << "    </detaileddescription>" << endl;
-  t << "    <location file=\""
-    << stripFromPath(nd->getDefFileName()) << "\" line=\""
-    << nd->getDefLine() << "\"" << " column=\""
-    << nd->getDefColumn() << "\"/>" << endl ;
+  t << "    <location file=\"" << stripFromPath(nd->getDefFileName())
+    << "\" line=\"" << nd->getDefLine() << "\""
+    << " column=\"" << nd->getDefColumn() << "\"/>" << endl;
   t << "  </compounddef>" << endl;
   t << "</doxygen>" << endl;
 
   ti << "  </compound>" << endl;
 }
 
-static void generateXMLForFile(FileDef *fd,FTextStream &ti)
-{
+static void generateXMLForFile(FileDef *fd, FTextStream &ti) {
   // + includes files
   // + includedby files
   // + include graph
@@ -1525,41 +1607,40 @@ static void generateXMLForFile(FileDef *fd,FTextStream &ti)
   // + source code
   // + location
   // - number of lines
-  
-  if (fd->isReference()) return; // skip external references
-  
-  ti << "  <compound refid=\"" << fd->getOutputFileBase() 
-     << "\" kind=\"file\"><name>" << convertToXML(fd->name()) 
-     << "</name>" << endl;
-  
+
+  if (fd->isReference())
+    return; // skip external references
+
+  ti << "  <compound refid=\"" << fd->getOutputFileBase()
+     << "\" kind=\"file\"><name>" << convertToXML(fd->name()) << "</name>"
+     << endl;
+
   QCString outputDirectory = Config_getString(XML_OUTPUT);
-  QCString fileName=outputDirectory+"/"+fd->getOutputFileBase()+".xml";
+  QCString fileName = outputDirectory + "/" + fd->getOutputFileBase() + ".xml";
   QFile f(fileName);
-  if (!f.open(IO_WriteOnly))
-  {
-    err("Cannot open file %s for writing!\n",fileName.data());
+  if (!f.open(IO_WriteOnly)) {
+    err("Cannot open file %s for writing!\n", fileName.data());
     return;
   }
   FTextStream t(&f);
-  //t.setEncoding(FTextStream::UnicodeUTF8);
+  // t.setEncoding(FTextStream::UnicodeUTF8);
 
   writeXMLHeader(t);
   t << "  <compounddef id=\"" << fd->getOutputFileBase()
-    << "\" kind=\"file\" language=\"" 
-    << langToString(fd->getLanguage()) << "\">" << endl;
+    << "\" kind=\"file\" language=\"" << langToString(fd->getLanguage())
+    << "\">" << endl;
   t << "    <compoundname>";
-  writeXMLString(t,fd->name());
+  writeXMLString(t, fd->name());
   t << "</compoundname>" << endl;
 
   IncludeInfo *inc;
 
-  if (fd->includeFileList())
-  {
+  if (fd->includeFileList()) {
     QListIterator<IncludeInfo> ili1(*fd->includeFileList());
-    for (ili1.toFirst();(inc=ili1.current());++ili1)
-    {
+    for (ili1.toFirst(); (inc = ili1.current()); ++ili1) {
       t << "    <includes";
-      if (inc->fileDef && !inc->fileDef->isReference()) // TODO: support external references
+      if (inc->fileDef &&
+          !inc->fileDef->isReference()) // TODO: support external references
       {
         t << " refid=\"" << inc->fileDef->getOutputFileBase() << "\"";
       }
@@ -1569,13 +1650,12 @@ static void generateXMLForFile(FileDef *fd,FTextStream &ti)
     }
   }
 
-  if (fd->includedByFileList())
-  {
+  if (fd->includedByFileList()) {
     QListIterator<IncludeInfo> ili2(*fd->includedByFileList());
-    for (ili2.toFirst();(inc=ili2.current());++ili2)
-    {
+    for (ili2.toFirst(); (inc = ili2.current()); ++ili2) {
       t << "    <includedby";
-      if (inc->fileDef && !inc->fileDef->isReference()) // TODO: support external references
+      if (inc->fileDef &&
+          !inc->fileDef->isReference()) // TODO: support external references
       {
         t << " refid=\"" << inc->fileDef->getOutputFileBase() << "\"";
       }
@@ -1585,73 +1665,66 @@ static void generateXMLForFile(FileDef *fd,FTextStream &ti)
     }
   }
 
-  DotInclDepGraph incDepGraph(fd,FALSE);
-  if (!incDepGraph.isTrivial())
-  {
+  DotInclDepGraph incDepGraph(fd, FALSE);
+  if (!incDepGraph.isTrivial()) {
     t << "    <incdepgraph>" << endl;
     incDepGraph.writeXML(t);
     t << "    </incdepgraph>" << endl;
   }
 
-  DotInclDepGraph invIncDepGraph(fd,TRUE);
-  if (!invIncDepGraph.isTrivial())
-  {
+  DotInclDepGraph invIncDepGraph(fd, TRUE);
+  if (!invIncDepGraph.isTrivial()) {
     t << "    <invincdepgraph>" << endl;
     invIncDepGraph.writeXML(t);
     t << "    </invincdepgraph>" << endl;
   }
 
-  if (fd->getClassSDict())
-  {
-    writeInnerClasses(fd->getClassSDict(),t);
+  if (fd->getClassSDict()) {
+    writeInnerClasses(fd->getClassSDict(), t);
   }
-  if (fd->getNamespaceSDict())
-  {
-    writeInnerNamespaces(fd->getNamespaceSDict(),t);
+  if (fd->getNamespaceSDict()) {
+    writeInnerNamespaces(fd->getNamespaceSDict(), t);
   }
 
-  if (fd->getMemberGroupSDict())
-  {
+  if (fd->getMemberGroupSDict()) {
     MemberGroupSDict::Iterator mgli(*fd->getMemberGroupSDict());
     MemberGroup *mg;
-    for (;(mg=mgli.current());++mgli)
-    {
-      generateXMLSection(fd,ti,t,mg->members(),"user-defined",mg->header(),
-          mg->documentation());
+    for (; (mg = mgli.current()); ++mgli) {
+      generateXMLSection(fd, ti, t, mg->members(), "user-defined", mg->header(),
+                         mg->documentation());
     }
   }
 
   QListIterator<MemberList> mli(fd->getMemberLists());
   MemberList *ml;
-  for (mli.toFirst();(ml=mli.current());++mli)
-  {
-    if ((ml->listType()&MemberListType_declarationLists)!=0)
-    {
-      generateXMLSection(fd,ti,t,ml,g_xmlSectionMapper.find(ml->listType()));
+  for (mli.toFirst(); (ml = mli.current()); ++mli) {
+    if ((ml->listType() & MemberListType_declarationLists) != 0) {
+      generateXMLSection(fd, ti, t, ml,
+                         g_xmlSectionMapper.find(ml->listType()));
     }
   }
 
   t << "    <briefdescription>" << endl;
-  writeXMLDocBlock(t,fd->briefFile(),fd->briefLine(),fd,0,fd->briefDescription());
+  writeXMLDocBlock(t, fd->briefFile(), fd->briefLine(), fd, 0,
+                   fd->briefDescription());
   t << "    </briefdescription>" << endl;
   t << "    <detaileddescription>" << endl;
-  writeXMLDocBlock(t,fd->docFile(),fd->docLine(),fd,0,fd->documentation());
+  writeXMLDocBlock(t, fd->docFile(), fd->docLine(), fd, 0, fd->documentation());
   t << "    </detaileddescription>" << endl;
-  if (Config_getBool(XML_PROGRAMLISTING))
-  {
+  if (Config_getBool(XML_PROGRAMLISTING)) {
     t << "    <programlisting>" << endl;
-    writeXMLCodeBlock(t,fd);
+    writeXMLCodeBlock(t, fd);
     t << "    </programlisting>" << endl;
   }
-  t << "    <location file=\"" << stripFromPath(fd->getDefFileName()) << "\"/>" << endl;
+  t << "    <location file=\"" << stripFromPath(fd->getDefFileName()) << "\"/>"
+    << endl;
   t << "  </compounddef>" << endl;
   t << "</doxygen>" << endl;
 
   ti << "  </compound>" << endl;
 }
 
-static void generateXMLForGroup(GroupDef *gd,FTextStream &ti)
-{
+static void generateXMLForGroup(GroupDef *gd, FTextStream &ti) {
   // + members
   // + member groups
   // + files
@@ -1664,60 +1737,60 @@ static void generateXMLForGroup(GroupDef *gd,FTextStream &ti)
   // + brief description
   // + detailed description
 
-  if (gd->isReference()) return; // skip external references
+  if (gd->isReference())
+    return; // skip external references
+
+  ti << "  <compound refid=\"" << gd->getOutputFileBase()
+     << "\" kind=\"group\"><name>" << convertToXML(gd->name()) << "</name>"
+     << endl;
 
-  ti << "  <compound refid=\"" << gd->getOutputFileBase() 
-     << "\" kind=\"group\"><name>" << convertToXML(gd->name()) << "</name>" << endl;
-  
   QCString outputDirectory = Config_getString(XML_OUTPUT);
-  QCString fileName=outputDirectory+"/"+gd->getOutputFileBase()+".xml";
+  QCString fileName = outputDirectory + "/" + gd->getOutputFileBase() + ".xml";
   QFile f(fileName);
-  if (!f.open(IO_WriteOnly))
-  {
-    err("Cannot open file %s for writing!\n",fileName.data());
+  if (!f.open(IO_WriteOnly)) {
+    err("Cannot open file %s for writing!\n", fileName.data());
     return;
   }
 
   FTextStream t(&f);
-  //t.setEncoding(FTextStream::UnicodeUTF8);
+  // t.setEncoding(FTextStream::UnicodeUTF8);
   writeXMLHeader(t);
-  t << "  <compounddef id=\"" 
-    << gd->getOutputFileBase() << "\" kind=\"group\">" << endl;
-  t << "    <compoundname>" << convertToXML(gd->name()) << "</compoundname>" << endl;
+  t << "  <compounddef id=\"" << gd->getOutputFileBase() << "\" kind=\"group\">"
+    << endl;
+  t << "    <compoundname>" << convertToXML(gd->name()) << "</compoundname>"
+    << endl;
   t << "    <title>" << convertToXML(gd->groupTitle()) << "</title>" << endl;
 
-  writeInnerFiles(gd->getFiles(),t);
-  writeInnerClasses(gd->getClasses(),t);
-  writeInnerNamespaces(gd->getNamespaces(),t);
-  writeInnerPages(gd->getPages(),t);
-  writeInnerGroups(gd->getSubGroups(),t);
+  writeInnerFiles(gd->getFiles(), t);
+  writeInnerClasses(gd->getClasses(), t);
+  writeInnerNamespaces(gd->getNamespaces(), t);
+  writeInnerPages(gd->getPages(), t);
+  writeInnerGroups(gd->getSubGroups(), t);
 
-  if (gd->getMemberGroupSDict())
-  {
+  if (gd->getMemberGroupSDict()) {
     MemberGroupSDict::Iterator mgli(*gd->getMemberGroupSDict());
     MemberGroup *mg;
-    for (;(mg=mgli.current());++mgli)
-    {
-      generateXMLSection(gd,ti,t,mg->members(),"user-defined",mg->header(),
-          mg->documentation());
+    for (; (mg = mgli.current()); ++mgli) {
+      generateXMLSection(gd, ti, t, mg->members(), "user-defined", mg->header(),
+                         mg->documentation());
     }
   }
 
   QListIterator<MemberList> mli(gd->getMemberLists());
   MemberList *ml;
-  for (mli.toFirst();(ml=mli.current());++mli)
-  {
-    if ((ml->listType()&MemberListType_declarationLists)!=0)
-    {
-      generateXMLSection(gd,ti,t,ml,g_xmlSectionMapper.find(ml->listType()));
+  for (mli.toFirst(); (ml = mli.current()); ++mli) {
+    if ((ml->listType() & MemberListType_declarationLists) != 0) {
+      generateXMLSection(gd, ti, t, ml,
+                         g_xmlSectionMapper.find(ml->listType()));
     }
   }
 
   t << "    <briefdescription>" << endl;
-  writeXMLDocBlock(t,gd->briefFile(),gd->briefLine(),gd,0,gd->briefDescription());
+  writeXMLDocBlock(t, gd->briefFile(), gd->briefLine(), gd, 0,
+                   gd->briefDescription());
   t << "    </briefdescription>" << endl;
   t << "    <detaileddescription>" << endl;
-  writeXMLDocBlock(t,gd->docFile(),gd->docLine(),gd,0,gd->documentation());
+  writeXMLDocBlock(t, gd->docFile(), gd->docLine(), gd, 0, gd->documentation());
   t << "    </detaileddescription>" << endl;
   t << "  </compounddef>" << endl;
   t << "</doxygen>" << endl;
@@ -1725,37 +1798,38 @@ static void generateXMLForGroup(GroupDef *gd,FTextStream &ti)
   ti << "  </compound>" << endl;
 }
 
-static void generateXMLForDir(DirDef *dd,FTextStream &ti)
-{
-  if (dd->isReference()) return; // skip external references
-  ti << "  <compound refid=\"" << dd->getOutputFileBase() 
-     << "\" kind=\"dir\"><name>" << convertToXML(dd->displayName()) 
-     << "</name>" << endl;
+static void generateXMLForDir(DirDef *dd, FTextStream &ti) {
+  if (dd->isReference())
+    return; // skip external references
+  ti << "  <compound refid=\"" << dd->getOutputFileBase()
+     << "\" kind=\"dir\"><name>" << convertToXML(dd->displayName()) << "</name>"
+     << endl;
 
   QCString outputDirectory = Config_getString(XML_OUTPUT);
-  QCString fileName=outputDirectory+"/"+dd->getOutputFileBase()+".xml";
+  QCString fileName = outputDirectory + "/" + dd->getOutputFileBase() + ".xml";
   QFile f(fileName);
-  if (!f.open(IO_WriteOnly))
-  {
-    err("Cannot open file %s for writing!\n",fileName.data());
+  if (!f.open(IO_WriteOnly)) {
+    err("Cannot open file %s for writing!\n", fileName.data());
     return;
   }
 
   FTextStream t(&f);
-  //t.setEncoding(FTextStream::UnicodeUTF8);
+  // t.setEncoding(FTextStream::UnicodeUTF8);
   writeXMLHeader(t);
-  t << "  <compounddef id=\"" 
-    << dd->getOutputFileBase() << "\" kind=\"dir\">" << endl;
-  t << "    <compoundname>" << convertToXML(dd->displayName()) << "</compoundname>" << endl;
+  t << "  <compounddef id=\"" << dd->getOutputFileBase() << "\" kind=\"dir\">"
+    << endl;
+  t << "    <compoundname>" << convertToXML(dd->displayName())
+    << "</compoundname>" << endl;
 
-  writeInnerDirs(&dd->subDirs(),t);
-  writeInnerFiles(dd->getFiles(),t);
+  writeInnerDirs(&dd->subDirs(), t);
+  writeInnerFiles(dd->getFiles(), t);
 
   t << "    <briefdescription>" << endl;
-  writeXMLDocBlock(t,dd->briefFile(),dd->briefLine(),dd,0,dd->briefDescription());
+  writeXMLDocBlock(t, dd->briefFile(), dd->briefLine(), dd, 0,
+                   dd->briefDescription());
   t << "    </briefdescription>" << endl;
   t << "    <detaileddescription>" << endl;
-  writeXMLDocBlock(t,dd->docFile(),dd->docLine(),dd,0,dd->documentation());
+  writeXMLDocBlock(t, dd->docFile(), dd->docLine(), dd, 0, dd->documentation());
   t << "    </detaileddescription>" << endl;
   t << "    <location file=\"" << stripFromPath(dd->name()) << "\"/>" << endl;
   t << "  </compounddef>" << endl;
@@ -1764,78 +1838,69 @@ static void generateXMLForDir(DirDef *dd,FTextStream &ti)
   ti << "  </compound>" << endl;
 }
 
-static void generateXMLForPage(PageDef *pd,FTextStream &ti,bool isExample)
-{
+static void generateXMLForPage(PageDef *pd, FTextStream &ti, bool isExample) {
   // + name
   // + title
   // + documentation
 
   const char *kindName = isExample ? "example" : "page";
 
-  if (pd->isReference()) return;
-  
+  if (pd->isReference())
+    return;
+
   QCString pageName = pd->getOutputFileBase();
-  if (pd->getGroupDef())
-  {
-    pageName+=(QCString)"_"+pd->name();
+  if (pd->getGroupDef()) {
+    pageName += (QCString) "_" + pd->name();
   }
-  if (pageName=="index") pageName="indexpage"; // to prevent overwriting the generated index page.
-  
-  ti << "  <compound refid=\"" << pageName
-     << "\" kind=\"" << kindName << "\"><name>" << convertToXML(pd->name()) 
-     << "</name>" << endl;
-  
+  if (pageName == "index")
+    pageName = "indexpage"; // to prevent overwriting the generated index page.
+
+  ti << "  <compound refid=\"" << pageName << "\" kind=\"" << kindName
+     << "\"><name>" << convertToXML(pd->name()) << "</name>" << endl;
+
   QCString outputDirectory = Config_getString(XML_OUTPUT);
-  QCString fileName=outputDirectory+"/"+pageName+".xml";
+  QCString fileName = outputDirectory + "/" + pageName + ".xml";
   QFile f(fileName);
-  if (!f.open(IO_WriteOnly))
-  {
-    err("Cannot open file %s for writing!\n",fileName.data());
+  if (!f.open(IO_WriteOnly)) {
+    err("Cannot open file %s for writing!\n", fileName.data());
     return;
   }
 
   FTextStream t(&f);
-  //t.setEncoding(FTextStream::UnicodeUTF8);
+  // t.setEncoding(FTextStream::UnicodeUTF8);
   writeXMLHeader(t);
   t << "  <compounddef id=\"" << pageName;
   t << "\" kind=\"" << kindName << "\">" << endl;
-  t << "    <compoundname>" << convertToXML(pd->name()) 
-    << "</compoundname>" << endl;
+  t << "    <compoundname>" << convertToXML(pd->name()) << "</compoundname>"
+    << endl;
 
-  if (pd==Doxygen::mainPage) // main page is special
+  if (pd == Doxygen::mainPage) // main page is special
   {
     QCString title;
-    if (!pd->title().isEmpty() && pd->title().lower()!="notitle")
-    {
-      title = filterTitle(convertCharEntitiesToUTF8(Doxygen::mainPage->title()));
-    }
-    else 
-    {
+    if (!pd->title().isEmpty() && pd->title().lower() != "notitle") {
+      title =
+          filterTitle(convertCharEntitiesToUTF8(Doxygen::mainPage->title()));
+    } else {
       title = Config_getString(PROJECT_NAME);
     }
-    t << "    <title>" << convertToXML(convertCharEntitiesToUTF8(title)) 
+    t << "    <title>" << convertToXML(convertCharEntitiesToUTF8(title))
       << "</title>" << endl;
-  }
-  else
-  {
+  } else {
     SectionInfo *si = Doxygen::sectionDict->find(pd->name());
-    if (si)
-    {
-      t << "    <title>" << convertToXML(convertCharEntitiesToUTF8(filterTitle(si->title))) 
+    if (si) {
+      t << "    <title>"
+        << convertToXML(convertCharEntitiesToUTF8(filterTitle(si->title)))
         << "</title>" << endl;
     }
   }
-  writeInnerPages(pd->getSubPages(),t);
+  writeInnerPages(pd->getSubPages(), t);
   t << "    <detaileddescription>" << endl;
-  if (isExample)
-  {
-    writeXMLDocBlock(t,pd->docFile(),pd->docLine(),pd,0,
-        pd->documentation()+"\n\\include "+pd->name());
-  }
-  else
-  {
-    writeXMLDocBlock(t,pd->docFile(),pd->docLine(),pd,0,
-        pd->documentation());
+  if (isExample) {
+    writeXMLDocBlock(t, pd->docFile(), pd->docLine(), pd, 0,
+                     pd->documentation() + "\n\\include " + pd->name());
+  } else {
+    writeXMLDocBlock(t, pd->docFile(), pd->docLine(), pd, 0,
+                     pd->documentation());
   }
   t << "    </detaileddescription>" << endl;
 
@@ -1845,69 +1910,64 @@ static void generateXMLForPage(PageDef *pd,FTextStream &ti,bool isExample)
   ti << "  </compound>" << endl;
 }
 
-void generateXML()
-{
+void generateXML() {
   // + classes
   // + namespaces
   // + files
   // + groups
   // + related pages
   // - examples
-  
+
   QCString outputDirectory = Config_getString(XML_OUTPUT);
   QDir xmlDir(outputDirectory);
   createSubDirs(xmlDir);
 
-  ResourceMgr::instance().copyResource("index.xsd",outputDirectory);
+  ResourceMgr::instance().copyResource("index.xsd", outputDirectory);
 
-  QCString fileName=outputDirectory+"/compound.xsd";
+  QCString fileName = outputDirectory + "/compound.xsd";
   QFile f(fileName);
-  if (!f.open(IO_WriteOnly))
-  {
-    err("Cannot open file %s for writing!\n",fileName.data());
+  if (!f.open(IO_WriteOnly)) {
+    err("Cannot open file %s for writing!\n", fileName.data());
     return;
   }
 
   // write compound.xsd, but replace special marker with the entities
   QCString compound_xsd = ResourceMgr::instance().getAsString("compound.xsd");
   const char *startLine = compound_xsd.data();
-  while (*startLine)
-  {
+  while (*startLine) {
     // find end of the line
-    const char *endLine = startLine+1;
-    while (*endLine && *(endLine-1)!='\n') endLine++; // skip to end of the line including \n
-    int len=endLine-startLine;
-    if (len>0)
-    {
-      QCString s(len+1);
-      qstrncpy(s.rawData(),startLine,len);
-      s[len]='\0';
-      if (s.find("<!-- Automatically insert here the HTML entities -->")!=-1)
-      {
+    const char *endLine = startLine + 1;
+    while (*endLine && *(endLine - 1) != '\n')
+      endLine++; // skip to end of the line including \n
+    int len = endLine - startLine;
+    if (len > 0) {
+      QCString s(len + 1);
+      qstrncpy(s.rawData(), startLine, len);
+      s[len] = '\0';
+      if (s.find("<!-- Automatically insert here the HTML entities -->") !=
+          -1) {
         FTextStream t(&f);
         HtmlEntityMapper::instance()->writeXMLSchema(t);
-      }
-      else
-      {
-        f.writeBlock(startLine,len);
+      } else {
+        f.writeBlock(startLine, len);
       }
     }
-    startLine=endLine;
+    startLine = endLine;
   }
   f.close();
 
-  fileName=outputDirectory+"/index.xml";
+  fileName = outputDirectory + "/index.xml";
   f.setName(fileName);
-  if (!f.open(IO_WriteOnly))
-  {
-    err("Cannot open file %s for writing!\n",fileName.data());
+  if (!f.open(IO_WriteOnly)) {
+    err("Cannot open file %s for writing!\n", fileName.data());
     return;
   }
   FTextStream t(&f);
-  //t.setEncoding(FTextStream::UnicodeUTF8);
+  // t.setEncoding(FTextStream::UnicodeUTF8);
 
   // write index header
-  t << "<?xml version='1.0' encoding='UTF-8' standalone='no'?>" << endl;;
+  t << "<?xml version='1.0' encoding='UTF-8' standalone='no'?>" << endl;
+  ;
   t << "<doxygenindex xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" ";
   t << "xsi:noNamespaceSchemaLocation=\"index.xsd\" ";
   t << "version=\"" << versionString << "\">" << endl;
@@ -1915,9 +1975,8 @@ void generateXML()
   {
     ClassSDict::Iterator cli(*Doxygen::classSDict);
     ClassDef *cd;
-    for (cli.toFirst();(cd=cli.current());++cli)
-    {
-      generateXMLForClass(cd,t);
+    for (cli.toFirst(); (cd = cli.current()); ++cli) {
+      generateXMLForClass(cd, t);
     }
   }
   //{
@@ -1931,67 +1990,57 @@ void generateXML()
   //}
   NamespaceSDict::Iterator nli(*Doxygen::namespaceSDict);
   NamespaceDef *nd;
-  for (nli.toFirst();(nd=nli.current());++nli)
-  {
-    msg("Generating XML output for namespace %s\n",nd->name().data());
-    generateXMLForNamespace(nd,t);
+  for (nli.toFirst(); (nd = nli.current()); ++nli) {
+    msg("Generating XML output for namespace %s\n", nd->name().data());
+    generateXMLForNamespace(nd, t);
   }
   FileNameListIterator fnli(*Doxygen::inputNameList);
   FileName *fn;
-  for (;(fn=fnli.current());++fnli)
-  {
+  for (; (fn = fnli.current()); ++fnli) {
     FileNameIterator fni(*fn);
     FileDef *fd;
-    for (;(fd=fni.current());++fni)
-    {
-      msg("Generating XML output for file %s\n",fd->name().data());
-      generateXMLForFile(fd,t);
+    for (; (fd = fni.current()); ++fni) {
+      msg("Generating XML output for file %s\n", fd->name().data());
+      generateXMLForFile(fd, t);
     }
   }
   GroupSDict::Iterator gli(*Doxygen::groupSDict);
   GroupDef *gd;
-  for (;(gd=gli.current());++gli)
-  {
-    msg("Generating XML output for group %s\n",gd->name().data());
-    generateXMLForGroup(gd,t);
+  for (; (gd = gli.current()); ++gli) {
+    msg("Generating XML output for group %s\n", gd->name().data());
+    generateXMLForGroup(gd, t);
   }
   {
     PageSDict::Iterator pdi(*Doxygen::pageSDict);
-    PageDef *pd=0;
-    for (pdi.toFirst();(pd=pdi.current());++pdi)
-    {
-      msg("Generating XML output for page %s\n",pd->name().data());
-      generateXMLForPage(pd,t,FALSE);
+    PageDef *pd = 0;
+    for (pdi.toFirst(); (pd = pdi.current()); ++pdi) {
+      msg("Generating XML output for page %s\n", pd->name().data());
+      generateXMLForPage(pd, t, FALSE);
     }
   }
   {
     DirDef *dir;
     DirSDict::Iterator sdi(*Doxygen::directories);
-    for (sdi.toFirst();(dir=sdi.current());++sdi)
-    {
-      msg("Generate XML output for dir %s\n",dir->name().data());
-      generateXMLForDir(dir,t);
+    for (sdi.toFirst(); (dir = sdi.current()); ++sdi) {
+      msg("Generate XML output for dir %s\n", dir->name().data());
+      generateXMLForDir(dir, t);
     }
   }
   {
     PageSDict::Iterator pdi(*Doxygen::exampleSDict);
-    PageDef *pd=0;
-    for (pdi.toFirst();(pd=pdi.current());++pdi)
-    {
-      msg("Generating XML output for example %s\n",pd->name().data());
-      generateXMLForPage(pd,t,TRUE);
+    PageDef *pd = 0;
+    for (pdi.toFirst(); (pd = pdi.current()); ++pdi) {
+      msg("Generating XML output for example %s\n", pd->name().data());
+      generateXMLForPage(pd, t, TRUE);
     }
   }
-  if (Doxygen::mainPage)
-  {
+  if (Doxygen::mainPage) {
     msg("Generating XML output for the main page\n");
-    generateXMLForPage(Doxygen::mainPage,t,FALSE);
+    generateXMLForPage(Doxygen::mainPage, t, FALSE);
   }
 
-  //t << "  </compoundlist>" << endl;
+  // t << "  </compoundlist>" << endl;
   t << "</doxygenindex>" << endl;
 
   writeCombineScript();
 }
-
-
diff --git a/vhdlparser/Makefile b/vhdlparser/Makefile
index 4725470a..0f2af426 100644
--- a/vhdlparser/Makefile
+++ b/vhdlparser/Makefile
@@ -1,22 +1,432 @@
-#
-# Copyright (C) 1997-2015 by Dimitri van Heesch.
-#
-# Permission to use, copy, modify, and distribute this software and its
-# documentation under the terms of the GNU General Public License is hereby
-# granted. No representations are made about the suitability of this software
-# for any purpose. It is provided "as is" without express or implied warranty.
-# See the GNU General Public License for more details.
-#
-# Documents produced by Doxygen are derivative works derived from the
-# input used in their production; they are not affected by this license.
-#
-
-regenerate:
-	rm -f CharStream.cc CharStream.h ErrorHandler.h ParseException.cc ParseException.h \
-	      Token.cc Token.h TokenManager.h TokenMgrError.cc TokenMgrError.h VhdlParser.cc VhdlParser.h \
-	      VhdlParserConstants.h VhdlParserTokenManager.cc VhdlParserTokenManager.h \
-              JavaCC.h
-	javacc vhdlparser.jj
-	cp JavaCC.h.in JavaCC.h
-
-FORCE:
+# CMAKE generated file: DO NOT EDIT!
+# Generated by "Unix Makefiles" Generator, CMake Version 3.7
+
+# Default target executed when no arguments are given to make.
+default_target: all
+
+.PHONY : default_target
+
+# Allow only one "make -f Makefile2" at a time, but pass parallelism.
+.NOTPARALLEL:
+
+
+#=============================================================================
+# Special targets provided by cmake.
+
+# Disable implicit rules so canonical targets will work.
+.SUFFIXES:
+
+
+# Remove some rules from gmake that .SUFFIXES does not remove.
+SUFFIXES =
+
+.SUFFIXES: .hpux_make_needs_suffix_list
+
+
+# Suppress display of executed commands.
+$(VERBOSE).SILENT:
+
+
+# A target that is always out of date.
+cmake_force:
+
+.PHONY : cmake_force
+
+#=============================================================================
+# Set environment variables for the build.
+
+# The shell in which to execute make rules.
+SHELL = /bin/sh
+
+# The CMake executable.
+CMAKE_COMMAND = /usr/local/Cellar/cmake/3.7.0/bin/cmake
+
+# The command to remove a file.
+RM = /usr/local/Cellar/cmake/3.7.0/bin/cmake -E remove -f
+
+# Escaping for special characters.
+EQUALS = =
+
+# The top-level source directory on which CMake was run.
+CMAKE_SOURCE_DIR = /Users/vsc/github/doxygen-yap
+
+# The top-level build directory on which CMake was run.
+CMAKE_BINARY_DIR = /Users/vsc/github/doxygen-yap
+
+#=============================================================================
+# Targets provided globally by CMake.
+
+# Special rule for the target install
+install: preinstall
+	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --cyan "Install the project..."
+	/usr/local/Cellar/cmake/3.7.0/bin/cmake -P cmake_install.cmake
+.PHONY : install
+
+# Special rule for the target install
+install/fast: preinstall/fast
+	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --cyan "Install the project..."
+	/usr/local/Cellar/cmake/3.7.0/bin/cmake -P cmake_install.cmake
+.PHONY : install/fast
+
+# Special rule for the target install/local
+install/local: preinstall
+	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --cyan "Installing only the local directory..."
+	/usr/local/Cellar/cmake/3.7.0/bin/cmake -DCMAKE_INSTALL_LOCAL_ONLY=1 -P cmake_install.cmake
+.PHONY : install/local
+
+# Special rule for the target install/local
+install/local/fast: install/local
+
+.PHONY : install/local/fast
+
+# Special rule for the target test
+test:
+	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --cyan "Running tests..."
+	/usr/local/Cellar/cmake/3.7.0/bin/ctest --force-new-ctest-process $(ARGS)
+.PHONY : test
+
+# Special rule for the target test
+test/fast: test
+
+.PHONY : test/fast
+
+# Special rule for the target edit_cache
+edit_cache:
+	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --cyan "Running CMake cache editor..."
+	/usr/local/Cellar/cmake/3.7.0/bin/ccmake -H$(CMAKE_SOURCE_DIR) -B$(CMAKE_BINARY_DIR)
+.PHONY : edit_cache
+
+# Special rule for the target edit_cache
+edit_cache/fast: edit_cache
+
+.PHONY : edit_cache/fast
+
+# Special rule for the target rebuild_cache
+rebuild_cache:
+	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --cyan "Running CMake to regenerate build system..."
+	/usr/local/Cellar/cmake/3.7.0/bin/cmake -H$(CMAKE_SOURCE_DIR) -B$(CMAKE_BINARY_DIR)
+.PHONY : rebuild_cache
+
+# Special rule for the target rebuild_cache
+rebuild_cache/fast: rebuild_cache
+
+.PHONY : rebuild_cache/fast
+
+# Special rule for the target package_source
+package_source:
+	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --cyan "Run CPack packaging tool for source..."
+	cd /Users/vsc/github/doxygen-yap && /usr/local/Cellar/cmake/3.7.0/bin/cpack --config ./CPackSourceConfig.cmake /Users/vsc/github/doxygen-yap/CPackSourceConfig.cmake
+.PHONY : package_source
+
+# Special rule for the target package_source
+package_source/fast: package_source
+
+.PHONY : package_source/fast
+
+# Special rule for the target package
+package: preinstall
+	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --cyan "Run CPack packaging tool..."
+	cd /Users/vsc/github/doxygen-yap && /usr/local/Cellar/cmake/3.7.0/bin/cpack --config ./CPackConfig.cmake
+.PHONY : package
+
+# Special rule for the target package
+package/fast: package
+
+.PHONY : package/fast
+
+# Special rule for the target list_install_components
+list_install_components:
+	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --cyan "Available install components are: \"Unspecified\""
+.PHONY : list_install_components
+
+# Special rule for the target list_install_components
+list_install_components/fast: list_install_components
+
+.PHONY : list_install_components/fast
+
+# The main all target
+all: cmake_check_build_system
+	cd /Users/vsc/github/doxygen-yap && $(CMAKE_COMMAND) -E cmake_progress_start /Users/vsc/github/doxygen-yap/CMakeFiles /Users/vsc/github/doxygen-yap/vhdlparser/CMakeFiles/progress.marks
+	cd /Users/vsc/github/doxygen-yap && $(MAKE) -f CMakeFiles/Makefile2 vhdlparser/all
+	$(CMAKE_COMMAND) -E cmake_progress_start /Users/vsc/github/doxygen-yap/CMakeFiles 0
+.PHONY : all
+
+# The main clean target
+clean:
+	cd /Users/vsc/github/doxygen-yap && $(MAKE) -f CMakeFiles/Makefile2 vhdlparser/clean
+.PHONY : clean
+
+# The main clean target
+clean/fast: clean
+
+.PHONY : clean/fast
+
+# Prepare targets for installation.
+preinstall: all
+	cd /Users/vsc/github/doxygen-yap && $(MAKE) -f CMakeFiles/Makefile2 vhdlparser/preinstall
+.PHONY : preinstall
+
+# Prepare targets for installation.
+preinstall/fast:
+	cd /Users/vsc/github/doxygen-yap && $(MAKE) -f CMakeFiles/Makefile2 vhdlparser/preinstall
+.PHONY : preinstall/fast
+
+# clear depends
+depend:
+	cd /Users/vsc/github/doxygen-yap && $(CMAKE_COMMAND) -H$(CMAKE_SOURCE_DIR) -B$(CMAKE_BINARY_DIR) --check-build-system CMakeFiles/Makefile.cmake 1
+.PHONY : depend
+
+# Convenience name for target.
+vhdlparser/CMakeFiles/vhdlparser.dir/rule:
+	cd /Users/vsc/github/doxygen-yap && $(MAKE) -f CMakeFiles/Makefile2 vhdlparser/CMakeFiles/vhdlparser.dir/rule
+.PHONY : vhdlparser/CMakeFiles/vhdlparser.dir/rule
+
+# Convenience name for target.
+vhdlparser: vhdlparser/CMakeFiles/vhdlparser.dir/rule
+
+.PHONY : vhdlparser
+
+# fast build rule for target.
+vhdlparser/fast:
+	cd /Users/vsc/github/doxygen-yap && $(MAKE) -f vhdlparser/CMakeFiles/vhdlparser.dir/build.make vhdlparser/CMakeFiles/vhdlparser.dir/build
+.PHONY : vhdlparser/fast
+
+CharStream.o: CharStream.cc.o
+
+.PHONY : CharStream.o
+
+# target to build an object file
+CharStream.cc.o:
+	cd /Users/vsc/github/doxygen-yap && $(MAKE) -f vhdlparser/CMakeFiles/vhdlparser.dir/build.make vhdlparser/CMakeFiles/vhdlparser.dir/CharStream.cc.o
+.PHONY : CharStream.cc.o
+
+CharStream.i: CharStream.cc.i
+
+.PHONY : CharStream.i
+
+# target to preprocess a source file
+CharStream.cc.i:
+	cd /Users/vsc/github/doxygen-yap && $(MAKE) -f vhdlparser/CMakeFiles/vhdlparser.dir/build.make vhdlparser/CMakeFiles/vhdlparser.dir/CharStream.cc.i
+.PHONY : CharStream.cc.i
+
+CharStream.s: CharStream.cc.s
+
+.PHONY : CharStream.s
+
+# target to generate assembly for a file
+CharStream.cc.s:
+	cd /Users/vsc/github/doxygen-yap && $(MAKE) -f vhdlparser/CMakeFiles/vhdlparser.dir/build.make vhdlparser/CMakeFiles/vhdlparser.dir/CharStream.cc.s
+.PHONY : CharStream.cc.s
+
+ParseException.o: ParseException.cc.o
+
+.PHONY : ParseException.o
+
+# target to build an object file
+ParseException.cc.o:
+	cd /Users/vsc/github/doxygen-yap && $(MAKE) -f vhdlparser/CMakeFiles/vhdlparser.dir/build.make vhdlparser/CMakeFiles/vhdlparser.dir/ParseException.cc.o
+.PHONY : ParseException.cc.o
+
+ParseException.i: ParseException.cc.i
+
+.PHONY : ParseException.i
+
+# target to preprocess a source file
+ParseException.cc.i:
+	cd /Users/vsc/github/doxygen-yap && $(MAKE) -f vhdlparser/CMakeFiles/vhdlparser.dir/build.make vhdlparser/CMakeFiles/vhdlparser.dir/ParseException.cc.i
+.PHONY : ParseException.cc.i
+
+ParseException.s: ParseException.cc.s
+
+.PHONY : ParseException.s
+
+# target to generate assembly for a file
+ParseException.cc.s:
+	cd /Users/vsc/github/doxygen-yap && $(MAKE) -f vhdlparser/CMakeFiles/vhdlparser.dir/build.make vhdlparser/CMakeFiles/vhdlparser.dir/ParseException.cc.s
+.PHONY : ParseException.cc.s
+
+Token.o: Token.cc.o
+
+.PHONY : Token.o
+
+# target to build an object file
+Token.cc.o:
+	cd /Users/vsc/github/doxygen-yap && $(MAKE) -f vhdlparser/CMakeFiles/vhdlparser.dir/build.make vhdlparser/CMakeFiles/vhdlparser.dir/Token.cc.o
+.PHONY : Token.cc.o
+
+Token.i: Token.cc.i
+
+.PHONY : Token.i
+
+# target to preprocess a source file
+Token.cc.i:
+	cd /Users/vsc/github/doxygen-yap && $(MAKE) -f vhdlparser/CMakeFiles/vhdlparser.dir/build.make vhdlparser/CMakeFiles/vhdlparser.dir/Token.cc.i
+.PHONY : Token.cc.i
+
+Token.s: Token.cc.s
+
+.PHONY : Token.s
+
+# target to generate assembly for a file
+Token.cc.s:
+	cd /Users/vsc/github/doxygen-yap && $(MAKE) -f vhdlparser/CMakeFiles/vhdlparser.dir/build.make vhdlparser/CMakeFiles/vhdlparser.dir/Token.cc.s
+.PHONY : Token.cc.s
+
+TokenMgrError.o: TokenMgrError.cc.o
+
+.PHONY : TokenMgrError.o
+
+# target to build an object file
+TokenMgrError.cc.o:
+	cd /Users/vsc/github/doxygen-yap && $(MAKE) -f vhdlparser/CMakeFiles/vhdlparser.dir/build.make vhdlparser/CMakeFiles/vhdlparser.dir/TokenMgrError.cc.o
+.PHONY : TokenMgrError.cc.o
+
+TokenMgrError.i: TokenMgrError.cc.i
+
+.PHONY : TokenMgrError.i
+
+# target to preprocess a source file
+TokenMgrError.cc.i:
+	cd /Users/vsc/github/doxygen-yap && $(MAKE) -f vhdlparser/CMakeFiles/vhdlparser.dir/build.make vhdlparser/CMakeFiles/vhdlparser.dir/TokenMgrError.cc.i
+.PHONY : TokenMgrError.cc.i
+
+TokenMgrError.s: TokenMgrError.cc.s
+
+.PHONY : TokenMgrError.s
+
+# target to generate assembly for a file
+TokenMgrError.cc.s:
+	cd /Users/vsc/github/doxygen-yap && $(MAKE) -f vhdlparser/CMakeFiles/vhdlparser.dir/build.make vhdlparser/CMakeFiles/vhdlparser.dir/TokenMgrError.cc.s
+.PHONY : TokenMgrError.cc.s
+
+VhdlParser.o: VhdlParser.cc.o
+
+.PHONY : VhdlParser.o
+
+# target to build an object file
+VhdlParser.cc.o:
+	cd /Users/vsc/github/doxygen-yap && $(MAKE) -f vhdlparser/CMakeFiles/vhdlparser.dir/build.make vhdlparser/CMakeFiles/vhdlparser.dir/VhdlParser.cc.o
+.PHONY : VhdlParser.cc.o
+
+VhdlParser.i: VhdlParser.cc.i
+
+.PHONY : VhdlParser.i
+
+# target to preprocess a source file
+VhdlParser.cc.i:
+	cd /Users/vsc/github/doxygen-yap && $(MAKE) -f vhdlparser/CMakeFiles/vhdlparser.dir/build.make vhdlparser/CMakeFiles/vhdlparser.dir/VhdlParser.cc.i
+.PHONY : VhdlParser.cc.i
+
+VhdlParser.s: VhdlParser.cc.s
+
+.PHONY : VhdlParser.s
+
+# target to generate assembly for a file
+VhdlParser.cc.s:
+	cd /Users/vsc/github/doxygen-yap && $(MAKE) -f vhdlparser/CMakeFiles/vhdlparser.dir/build.make vhdlparser/CMakeFiles/vhdlparser.dir/VhdlParser.cc.s
+.PHONY : VhdlParser.cc.s
+
+VhdlParserIF.o: VhdlParserIF.cpp.o
+
+.PHONY : VhdlParserIF.o
+
+# target to build an object file
+VhdlParserIF.cpp.o:
+	cd /Users/vsc/github/doxygen-yap && $(MAKE) -f vhdlparser/CMakeFiles/vhdlparser.dir/build.make vhdlparser/CMakeFiles/vhdlparser.dir/VhdlParserIF.cpp.o
+.PHONY : VhdlParserIF.cpp.o
+
+VhdlParserIF.i: VhdlParserIF.cpp.i
+
+.PHONY : VhdlParserIF.i
+
+# target to preprocess a source file
+VhdlParserIF.cpp.i:
+	cd /Users/vsc/github/doxygen-yap && $(MAKE) -f vhdlparser/CMakeFiles/vhdlparser.dir/build.make vhdlparser/CMakeFiles/vhdlparser.dir/VhdlParserIF.cpp.i
+.PHONY : VhdlParserIF.cpp.i
+
+VhdlParserIF.s: VhdlParserIF.cpp.s
+
+.PHONY : VhdlParserIF.s
+
+# target to generate assembly for a file
+VhdlParserIF.cpp.s:
+	cd /Users/vsc/github/doxygen-yap && $(MAKE) -f vhdlparser/CMakeFiles/vhdlparser.dir/build.make vhdlparser/CMakeFiles/vhdlparser.dir/VhdlParserIF.cpp.s
+.PHONY : VhdlParserIF.cpp.s
+
+VhdlParserTokenManager.o: VhdlParserTokenManager.cc.o
+
+.PHONY : VhdlParserTokenManager.o
+
+# target to build an object file
+VhdlParserTokenManager.cc.o:
+	cd /Users/vsc/github/doxygen-yap && $(MAKE) -f vhdlparser/CMakeFiles/vhdlparser.dir/build.make vhdlparser/CMakeFiles/vhdlparser.dir/VhdlParserTokenManager.cc.o
+.PHONY : VhdlParserTokenManager.cc.o
+
+VhdlParserTokenManager.i: VhdlParserTokenManager.cc.i
+
+.PHONY : VhdlParserTokenManager.i
+
+# target to preprocess a source file
+VhdlParserTokenManager.cc.i:
+	cd /Users/vsc/github/doxygen-yap && $(MAKE) -f vhdlparser/CMakeFiles/vhdlparser.dir/build.make vhdlparser/CMakeFiles/vhdlparser.dir/VhdlParserTokenManager.cc.i
+.PHONY : VhdlParserTokenManager.cc.i
+
+VhdlParserTokenManager.s: VhdlParserTokenManager.cc.s
+
+.PHONY : VhdlParserTokenManager.s
+
+# target to generate assembly for a file
+VhdlParserTokenManager.cc.s:
+	cd /Users/vsc/github/doxygen-yap && $(MAKE) -f vhdlparser/CMakeFiles/vhdlparser.dir/build.make vhdlparser/CMakeFiles/vhdlparser.dir/VhdlParserTokenManager.cc.s
+.PHONY : VhdlParserTokenManager.cc.s
+
+# Help Target
+help:
+	@echo "The following are some of the valid targets for this Makefile:"
+	@echo "... all (the default if no target is provided)"
+	@echo "... clean"
+	@echo "... depend"
+	@echo "... install"
+	@echo "... install/local"
+	@echo "... test"
+	@echo "... edit_cache"
+	@echo "... rebuild_cache"
+	@echo "... package_source"
+	@echo "... package"
+	@echo "... list_install_components"
+	@echo "... vhdlparser"
+	@echo "... CharStream.o"
+	@echo "... CharStream.i"
+	@echo "... CharStream.s"
+	@echo "... ParseException.o"
+	@echo "... ParseException.i"
+	@echo "... ParseException.s"
+	@echo "... Token.o"
+	@echo "... Token.i"
+	@echo "... Token.s"
+	@echo "... TokenMgrError.o"
+	@echo "... TokenMgrError.i"
+	@echo "... TokenMgrError.s"
+	@echo "... VhdlParser.o"
+	@echo "... VhdlParser.i"
+	@echo "... VhdlParser.s"
+	@echo "... VhdlParserIF.o"
+	@echo "... VhdlParserIF.i"
+	@echo "... VhdlParserIF.s"
+	@echo "... VhdlParserTokenManager.o"
+	@echo "... VhdlParserTokenManager.i"
+	@echo "... VhdlParserTokenManager.s"
+.PHONY : help
+
+
+
+#=============================================================================
+# Special targets to cleanup operation of make.
+
+# Special rule to run CMake to check the build system integrity.
+# No rule that depends on this can have commands that come from listfiles
+# because they might be regenerated.
+cmake_check_build_system:
+	cd /Users/vsc/github/doxygen-yap && $(CMAKE_COMMAND) -H$(CMAKE_SOURCE_DIR) -B$(CMAKE_BINARY_DIR) --check-build-system CMakeFiles/Makefile.cmake 0
+.PHONY : cmake_check_build_system
+
diff --git a/vhdlparser/VhdlParser.cc b/vhdlparser/VhdlParser.cc
index 71f1ca74..e1999195 100644
--- a/vhdlparser/VhdlParser.cc
+++ b/vhdlparser/VhdlParser.cc
@@ -24,36 +24,36 @@ namespace parser {
 QCString VhdlParser::abstract_literal() {Token *tok;
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case DECIMAL_LITERAL:{if (!hasError) {
-      
+
       tok = jj_consume_token(DECIMAL_LITERAL);
       }
       if (!hasError) {
-      
+
 return tok->image.c_str();
       }
-      
+
       break;
       }
     case INTEGER:{if (!hasError) {
-      
+
       tok = jj_consume_token(INTEGER);
       }
       if (!hasError) {
-      
+
 return tok->image.c_str();
       }
-      
+
       break;
       }
     case BASED_LITERAL:{if (!hasError) {
-      
+
       tok = jj_consume_token(BASED_LITERAL);
       }
       if (!hasError) {
-      
+
 return tok->image.c_str();
       }
-      
+
       break;
       }
     default:
@@ -66,14 +66,14 @@ assert(false);
 
 
 QCString VhdlParser::access_type_definition() {Token *tok=0;QCString str,str1;if (!hasError) {
-    
+
     tok = jj_consume_token(ACCESS_T);
     }
     if (!hasError) {
-    
+
     str1 = subtype_indication();
     }
-    
+
 str=tok->image.c_str(); return str+str1;
 assert(false);
 }
@@ -82,36 +82,36 @@ assert(false);
 QCString VhdlParser::actual_designator() {QCString str;Token *t=0;
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case OPEN_T:{if (!hasError) {
-      
+
       t = jj_consume_token(OPEN_T);
       }
       if (!hasError) {
-      
+
 return t->image.c_str();
       }
-      
+
       break;
       }
     default:
       jj_la1[1] = jj_gen;
       if (jj_2_1(2147483647)) {if (!hasError) {
-        
+
         str = expression();
         }
         if (!hasError) {
-        
+
 return str;
         }
-        
+
       } else if (jj_2_2(2147483647)) {if (!hasError) {
-        
+
         str = name();
         }
         if (!hasError) {
-        
+
 return str;
         }
-        
+
       } else {
         jj_consume_token(-1);
         errorHandler->handleParseError(token, getToken(1), __FUNCTION__, this), hasError = true;
@@ -122,10 +122,10 @@ assert(false);
 
 
 QCString VhdlParser::actual_parameter_part() {QCString s;if (!hasError) {
-    
+
     s = association_list();
     }
-    
+
 return s;
 assert(false);
 }
@@ -133,51 +133,51 @@ assert(false);
 
 QCString VhdlParser::actual_part() {QCString s,s1;
     if (jj_2_3(2147483647)) {if (!hasError) {
-      
+
       s = actual_designator();
       }
       if (!hasError) {
-      
+
 return s;
       }
-      
+
     } else {
       switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
       case BOX_T:{if (!hasError) {
-        
+
         jj_consume_token(BOX_T);
         }
         if (!hasError) {
-        
+
 return "<>";
         }
-        
+
         break;
         }
       case SLSL_T:
       case STRINGLITERAL:
       case BASIC_IDENTIFIER:
       case EXTENDED_CHARACTER:{if (!hasError) {
-        
+
         s = name();
         }
         if (!hasError) {
-        
+
         jj_consume_token(LPAREN_T);
         }
         if (!hasError) {
-        
+
         s1 = actual_designator();
         }
         if (!hasError) {
-        
+
         jj_consume_token(RPAREN_T);
         }
         if (!hasError) {
-        
+
 s+="(";s+=s1+")";return s;
         }
-        
+
         break;
         }
       default:
@@ -193,36 +193,36 @@ assert(false);
 QCString VhdlParser::adding_operator() {
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case PLUS_T:{if (!hasError) {
-      
+
       jj_consume_token(PLUS_T);
       }
       if (!hasError) {
-      
+
 return "+";
       }
-      
+
       break;
       }
     case MINUS_T:{if (!hasError) {
-      
+
       jj_consume_token(MINUS_T);
       }
       if (!hasError) {
-      
+
 return "-";
       }
-      
+
       break;
       }
     case AMPERSAND_T:{if (!hasError) {
-      
+
       jj_consume_token(AMPERSAND_T);
       }
       if (!hasError) {
-      
+
 return "&";
       }
-      
+
       break;
       }
     default:
@@ -235,15 +235,15 @@ assert(false);
 
 
 QCString VhdlParser::aggregate() {QCString s,s1,s2;if (!hasError) {
-    
+
     jj_consume_token(LPAREN_T);
     }
     if (!hasError) {
-    
+
     s = element_association();
     }
     if (!hasError) {
-    
+
     while (!hasError) {
       switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
       case COMMA_T:{
@@ -254,59 +254,59 @@ QCString VhdlParser::aggregate() {QCString s,s1,s2;if (!hasError) {
         jj_la1[4] = jj_gen;
         goto end_label_1;
       }if (!hasError) {
-      
+
       jj_consume_token(COMMA_T);
       }
       if (!hasError) {
-      
+
       s1 = element_association();
       }
       if (!hasError) {
-      
+
 s+=","+s1;
       }
-      
+
     }
     end_label_1: ;
     }
     if (!hasError) {
-    
+
     jj_consume_token(RPAREN_T);
     }
-    
+
 return "("+s+")";
 assert(false);
 }
 
 
 QCString VhdlParser::alias_declaration() {QCString s,s1,s2;if (!hasError) {
-    
+
     jj_consume_token(ALIAS_T);
     }
     if (!hasError) {
-    
+
     s2 = alias_designator();
     }
     if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case COLON_T:{if (!hasError) {
-      
+
       jj_consume_token(COLON_T);
       }
       if (!hasError) {
-      
+
 s+=":";
       }
       if (!hasError) {
-      
+
       s1 = subtype_indication();
       }
       if (!hasError) {
-      
+
 s+=s1;
       }
-      
+
       break;
       }
     default:
@@ -315,33 +315,33 @@ s+=s1;
     }
     }
     if (!hasError) {
-    
+
     jj_consume_token(IS_T);
     }
     if (!hasError) {
-    
+
 s+=" is ";
     }
     if (!hasError) {
-    
+
     s1 = name();
     }
     if (!hasError) {
-    
+
 s+=s1;
     }
     if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case LBRACKET_T:{if (!hasError) {
-      
+
       s1 = signature();
       }
       if (!hasError) {
-      
+
 s+=s1;
       }
-      
+
       break;
       }
     default:
@@ -350,10 +350,10 @@ s+=s1;
     }
     }
     if (!hasError) {
-    
+
     jj_consume_token(SEMI_T);
     }
-    
+
 addVhdlType(s2.data(),getLine(ALIAS_T),Entry::VARIABLE_SEC,VhdlDocGen::ALIAS,0,s.data(),Public);
 
  return s2+" "+s+";";
@@ -365,36 +365,36 @@ QCString VhdlParser::alias_designator() {Token *tok=0;QCString s;
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case BASIC_IDENTIFIER:
     case EXTENDED_CHARACTER:{if (!hasError) {
-      
+
       s = identifier();
       }
       if (!hasError) {
-      
+
 return s;
       }
-      
+
       break;
       }
     case CHARACTER_LITERAL:{if (!hasError) {
-      
+
       tok = jj_consume_token(CHARACTER_LITERAL);
       }
       if (!hasError) {
-      
+
 return tok->image.c_str();
       }
-      
+
       break;
       }
     case STRINGLITERAL:{if (!hasError) {
-      
+
       s = operator_symbol();
       }
       if (!hasError) {
-      
+
 return s;
       }
-      
+
       break;
       }
     default:
@@ -408,25 +408,25 @@ assert(false);
 
 void VhdlParser::allocator() {
     if (jj_2_4(3)) {if (!hasError) {
-      
+
       jj_consume_token(NEW_T);
       }
       if (!hasError) {
-      
+
       qualified_expression();
       }
-      
+
     } else {
       switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
       case NEW_T:{if (!hasError) {
-        
+
         jj_consume_token(NEW_T);
         }
         if (!hasError) {
-        
+
         subtype_indication();
         }
-        
+
         break;
         }
       default:
@@ -439,27 +439,27 @@ void VhdlParser::allocator() {
 
 
 void VhdlParser::architecture_body() {QCString s,s1;if (!hasError) {
-    
+
     jj_consume_token(ARCHITECTURE_T);
     }
     if (!hasError) {
-    
+
     s = identifier();
     }
     if (!hasError) {
-    
+
     jj_consume_token(OF_T);
     }
     if (!hasError) {
-    
+
     s1 = name();
     }
     if (!hasError) {
-    
+
     jj_consume_token(IS_T);
     }
     if (!hasError) {
-    
+
 QCString t=s1+"::"+s;
                   genLabels.resize(0);
                   pushLabel(genLabels,s1);
@@ -467,36 +467,36 @@ QCString t=s1+"::"+s;
                   addVhdlType(t,getLine(ARCHITECTURE_T),Entry::CLASS_SEC,VhdlDocGen::ARCHITECTURE,0,0,Private);
     }
     if (!hasError) {
-    
+
     try {if (!hasError) {
-      
+
       architecture_declarative_part();
       }
-      
+
     } catch ( ...) {
 error_skipto(BEGIN_T);
     }
     }
     if (!hasError) {
-    
+
     jj_consume_token(BEGIN_T);
     }
     if (!hasError) {
-    
+
     architecture_statement_part();
     }
     if (!hasError) {
-    
+
     jj_consume_token(END_T);
     }
     if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case ARCHITECTURE_T:{if (!hasError) {
-      
+
       jj_consume_token(ARCHITECTURE_T);
       }
-      
+
       break;
       }
     default:
@@ -505,16 +505,16 @@ error_skipto(BEGIN_T);
     }
     }
     if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case SLSL_T:
     case STRINGLITERAL:
     case BASIC_IDENTIFIER:
     case EXTENDED_CHARACTER:{if (!hasError) {
-      
+
       name();
       }
-      
+
       break;
       }
     default:
@@ -523,16 +523,16 @@ error_skipto(BEGIN_T);
     }
     }
     if (!hasError) {
-    
+
     jj_consume_token(SEMI_T);
     }
-    
+
 lastEntity=0;lastCompound=0; genLabels.resize(0);
 }
 
 
 void VhdlParser::architecture_declarative_part() {if (!hasError) {
-    
+
     while (!hasError) {
       switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
       case ALIAS_T:
@@ -560,19 +560,19 @@ void VhdlParser::architecture_declarative_part() {if (!hasError) {
         jj_la1[11] = jj_gen;
         goto end_label_2;
       }if (!hasError) {
-      
+
       block_declarative_item();
       }
-      
+
     }
     end_label_2: ;
     }
-    
+
 }
 
 
 void VhdlParser::architecture_statement_part() {if (!hasError) {
-    
+
     while (!hasError) {
       switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
       case ASSERT_T:
@@ -593,38 +593,38 @@ void VhdlParser::architecture_statement_part() {if (!hasError) {
         jj_la1[12] = jj_gen;
         goto end_label_3;
       }if (!hasError) {
-      
+
       concurrent_statement();
       }
-      
+
     }
     end_label_3: ;
     }
-    
+
 }
 
 
 QCString VhdlParser::array_type_definition() {QCString s;
     if (jj_2_5(2147483647)) {if (!hasError) {
-      
+
       s = unconstraint_array_definition();
       }
       if (!hasError) {
-      
+
 return s;
       }
-      
+
     } else {
       switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
       case ARRAY_T:{if (!hasError) {
-        
+
         s = constraint_array_definition();
         }
         if (!hasError) {
-        
+
 return s;
         }
-        
+
         break;
         }
       default:
@@ -638,25 +638,25 @@ assert(false);
 
 
 QCString VhdlParser::assertion() {QCString s,s1,s2;Token *t=0;Token *t1=0;if (!hasError) {
-    
+
     jj_consume_token(ASSERT_T);
     }
     if (!hasError) {
-    
+
     s = condition();
     }
     if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case REPORT_T:{if (!hasError) {
-      
+
       t = jj_consume_token(REPORT_T);
       }
       if (!hasError) {
-      
+
       s1 = expression();
       }
-      
+
       break;
       }
     default:
@@ -665,17 +665,17 @@ QCString VhdlParser::assertion() {QCString s,s1,s2;Token *t=0;Token *t1=0;if (!h
     }
     }
     if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case SEVERITY_T:{if (!hasError) {
-      
+
       t1 = jj_consume_token(SEVERITY_T);
       }
       if (!hasError) {
-      
+
       s2 = expression();
       }
-      
+
       break;
       }
     default:
@@ -683,7 +683,7 @@ QCString VhdlParser::assertion() {QCString s,s1,s2;Token *t=0;Token *t1=0;if (!h
       ;
     }
     }
-    
+
 s.prepend("assert ");
    if(t) s1.prepend(" report ");
    if(t1) s2.prepend(" report ");
@@ -693,18 +693,18 @@ assert(false);
 
 
 QCString VhdlParser::assertion_statement() {QCString s,s1,s2;Token *t=0;if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case BASIC_IDENTIFIER:
     case EXTENDED_CHARACTER:{if (!hasError) {
-      
+
       s = label();
       }
       if (!hasError) {
-      
+
       t = jj_consume_token(COLON_T);
       }
-      
+
       break;
       }
     default:
@@ -713,14 +713,14 @@ QCString VhdlParser::assertion_statement() {QCString s,s1,s2;Token *t=0;if (!has
     }
     }
     if (!hasError) {
-    
+
     s1 = assertion();
     }
     if (!hasError) {
-    
+
     jj_consume_token(SEMI_T);
     }
-    
+
 if(t) s+=":";
     return s+s1+";";
 assert(false);
@@ -728,36 +728,36 @@ assert(false);
 
 
 QCString VhdlParser::association_element() {QCString s,s1;if (!hasError) {
-    
+
     if (jj_2_6(2147483647)) {if (!hasError) {
-      
+
       s = formal_part();
       }
       if (!hasError) {
-      
+
       jj_consume_token(ARROW_T);
       }
-      
+
     } else {
       ;
     }
     }
     if (!hasError) {
-    
+
     s1 = actual_part();
     }
-    
+
 return s+" => "+s1;
 assert(false);
 }
 
 
 QCString VhdlParser::association_list() {QCString s,s1;if (!hasError) {
-    
+
     s = association_element();
     }
     if (!hasError) {
-    
+
     while (!hasError) {
       switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
       case COMMA_T:{
@@ -768,48 +768,48 @@ QCString VhdlParser::association_list() {QCString s,s1;if (!hasError) {
         jj_la1[17] = jj_gen;
         goto end_label_4;
       }if (!hasError) {
-      
+
       jj_consume_token(COMMA_T);
       }
       if (!hasError) {
-      
+
       s1 = association_element();
       }
       if (!hasError) {
-      
+
 s+=","+s1;
       }
-      
+
     }
     end_label_4: ;
     }
-    
+
 return s;
 assert(false);
 }
 
 
 QCString VhdlParser::attribute_declaration() {QCString s,s1;if (!hasError) {
-    
+
     jj_consume_token(ATTRIBUTE_T);
     }
     if (!hasError) {
-    
+
     s = identifier();
     }
     if (!hasError) {
-    
+
     jj_consume_token(COLON_T);
     }
     if (!hasError) {
-    
+
     s1 = type_mark();
     }
     if (!hasError) {
-    
+
     jj_consume_token(SEMI_T);
     }
-    
+
 addVhdlType(s.data(),getLine(ATTRIBUTE_T),Entry::VARIABLE_SEC,VhdlDocGen::ATTRIBUTE,0,s1.data(),Public);
     return " attribute "+s+":"+s1+";";
 assert(false);
@@ -820,25 +820,25 @@ QCString VhdlParser::attribute_designator() {QCString s;Token *tok=0;
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case BASIC_IDENTIFIER:
     case EXTENDED_CHARACTER:{if (!hasError) {
-      
+
       s = identifier();
       }
       if (!hasError) {
-      
+
 return s;
       }
-      
+
       break;
       }
     case RANGE_T:{if (!hasError) {
-      
+
       tok = jj_consume_token(RANGE_T);
       }
       if (!hasError) {
-      
+
 return tok->image.c_str();
       }
-      
+
       break;
       }
     default:
@@ -851,41 +851,41 @@ assert(false);
 
 
 QCString VhdlParser::attribute_name() {QCString s,s1;if (!hasError) {
-    
+
     s = identifier();
     }
     if (!hasError) {
-    
+
     jj_consume_token(APOSTROPHE_T);
     }
     if (!hasError) {
-    
+
     s1 = name();
     }
     if (!hasError) {
-    
+
 s+="'"+s1;
     }
     if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case LPAREN_T:{if (!hasError) {
-      
+
       jj_consume_token(LPAREN_T);
       }
       if (!hasError) {
-      
+
       s1 = expression();
       }
       if (!hasError) {
-      
+
       jj_consume_token(RPAREN_T);
       }
       if (!hasError) {
-      
+
 s+"("+s1+")";
       }
-      
+
       break;
       }
     default:
@@ -893,41 +893,41 @@ s+"("+s1+")";
       ;
     }
     }
-    
+
 return s;
 assert(false);
 }
 
 
 QCString VhdlParser::attribute_specification() {QCString s,s1,s2;if (!hasError) {
-    
+
     jj_consume_token(ATTRIBUTE_T);
     }
     if (!hasError) {
-    
+
     s = attribute_designator();
     }
     if (!hasError) {
-    
+
     jj_consume_token(OF_T);
     }
     if (!hasError) {
-    
+
     s1 = entity_specification();
     }
     if (!hasError) {
-    
+
     jj_consume_token(IS_T);
     }
     if (!hasError) {
-    
+
     s2 = expression();
     }
     if (!hasError) {
-    
+
     jj_consume_token(SEMI_T);
     }
-    
+
 QCString t= s1+" is "+s2;
    addVhdlType(s.data(),getLine(ATTRIBUTE_T),Entry::VARIABLE_SEC,VhdlDocGen::ATTRIBUTE,0,t.data(),Public);
    return " attribute "+s+" of "+s1+ " is "+s2+";";
@@ -936,77 +936,77 @@ assert(false);
 
 
 QCString VhdlParser::base() {Token *tok=0;if (!hasError) {
-    
+
     tok = jj_consume_token(INTEGER);
     }
-    
+
 return tok->image.c_str();
 assert(false);
 }
 
 
 QCString VhdlParser::base_specifier() {Token *tok=0;if (!hasError) {
-    
+
     tok = jj_consume_token(BASIC_IDENTIFIER);
     }
-    
+
 return tok->image.c_str();
 assert(false);
 }
 
 
 QCString VhdlParser::base_unit_declaration() {QCString s;if (!hasError) {
-    
+
     s = identifier();
     }
-    
+
 return s;
 assert(false);
 }
 
 
 QCString VhdlParser::based_integer() {Token *tok=0;if (!hasError) {
-    
+
     tok = jj_consume_token(BASIC_IDENTIFIER);
     }
-    
+
 return tok->image.c_str();
 assert(false);
 }
 
 
 QCString VhdlParser::based_literal() {Token *tok=0;if (!hasError) {
-    
+
     tok = jj_consume_token(BASED_LITERAL);
     }
-    
+
 return tok->image.c_str();
 assert(false);
 }
 
 
 QCString VhdlParser::basic_identifier() {Token *tok=0;if (!hasError) {
-    
+
     tok = jj_consume_token(BASIC_IDENTIFIER);
     }
-    
+
 return tok->image.c_str();
 assert(false);
 }
 
 
 void VhdlParser::binding_indication() {if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case USE_T:{if (!hasError) {
-      
+
       jj_consume_token(USE_T);
       }
       if (!hasError) {
-      
+
       entity_aspect();
       }
-      
+
       break;
       }
     default:
@@ -1015,13 +1015,13 @@ void VhdlParser::binding_indication() {if (!hasError) {
     }
     }
     if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case GENERIC_T:{if (!hasError) {
-      
+
       generic_map_aspect();
       }
-      
+
       break;
       }
     default:
@@ -1030,13 +1030,13 @@ void VhdlParser::binding_indication() {if (!hasError) {
     }
     }
     if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case PORT_T:{if (!hasError) {
-      
+
       port_map_aspect();
       }
-      
+
       break;
       }
     default:
@@ -1044,40 +1044,40 @@ void VhdlParser::binding_indication() {if (!hasError) {
       ;
     }
     }
-    
+
 }
 
 
 QCString VhdlParser::bit_string_literal() {Token *tok=0;if (!hasError) {
-    
+
     tok = jj_consume_token(BIT_STRING_LITERAL);
     }
-    
+
 return tok->image.c_str();
 assert(false);
 }
 
 
 QCString VhdlParser::bit_value() {Token *tok=0;if (!hasError) {
-    
+
     tok = jj_consume_token(BASIC_IDENTIFIER);
     }
-    
+
 return tok->image.c_str();
 assert(false);
 }
 
 
 void VhdlParser::block_configuration() {if (!hasError) {
-    
+
     jj_consume_token(FOR_T);
     }
     if (!hasError) {
-    
+
     block_specification();
     }
     if (!hasError) {
-    
+
     while (!hasError) {
       switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
       case USE_T:{
@@ -1088,15 +1088,15 @@ void VhdlParser::block_configuration() {if (!hasError) {
         jj_la1[23] = jj_gen;
         goto end_label_5;
       }if (!hasError) {
-      
+
       use_clause();
       }
-      
+
     }
     end_label_5: ;
     }
     if (!hasError) {
-    
+
     while (!hasError) {
       switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
       case FOR_T:{
@@ -1107,26 +1107,26 @@ void VhdlParser::block_configuration() {if (!hasError) {
         jj_la1[24] = jj_gen;
         goto end_label_6;
       }if (!hasError) {
-      
+
       configuration_item();
       }
-      
+
     }
     end_label_6: ;
     }
     if (!hasError) {
-    
+
     jj_consume_token(END_T);
     }
     if (!hasError) {
-    
+
     jj_consume_token(FOR_T);
     }
     if (!hasError) {
-    
+
     jj_consume_token(SEMI_T);
     }
-    
+
 }
 
 
@@ -1136,120 +1136,120 @@ void VhdlParser::block_declarative_item() {
     case IMPURE_T:
     case PROCEDURE_T:
     case PURE_T:{if (!hasError) {
-      
+
       subprogram_declaration();
       }
-      
+
       break;
       }
     case TYPE_T:{if (!hasError) {
-      
+
       type_declaration();
       }
-      
+
       break;
       }
     case SUBTYPE_T:{if (!hasError) {
-      
+
       subtype_declaration();
       }
-      
+
       break;
       }
     case CONSTANT_T:{if (!hasError) {
-      
+
       constant_declaration();
       }
-      
+
       break;
       }
     case SIGNAL_T:{if (!hasError) {
-      
+
       signal_declaration();
       }
-      
+
       break;
       }
     case SHARED_T:
     case VARIABLE_T:{if (!hasError) {
-      
+
       variable_declaration();
       }
-      
+
       break;
       }
     case FILE_T:{if (!hasError) {
-      
+
       file_declaration();
       }
-      
+
       break;
       }
     case ALIAS_T:{if (!hasError) {
-      
+
       alias_declaration();
       }
-      
+
       break;
       }
     case COMPONENT_T:{if (!hasError) {
-      
+
       component_declaration();
       }
-      
+
       break;
       }
     default:
       jj_la1[25] = jj_gen;
       if (jj_2_7(2147483647)) {if (!hasError) {
-        
+
         attribute_declaration();
         }
-        
+
       } else {
         switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
         case ATTRIBUTE_T:{if (!hasError) {
-          
+
           attribute_specification();
           }
-          
+
           break;
           }
         case FOR_T:{if (!hasError) {
-          
+
           configuration_specification();
           }
-          
+
           break;
           }
         case DISCONNECT_T:{if (!hasError) {
-          
+
           disconnection_specification();
           }
-          
+
           break;
           }
         case USE_T:{if (!hasError) {
-          
+
           use_clause();
           }
-          
+
           break;
           }
         default:
           jj_la1[26] = jj_gen;
           if (jj_2_8(3)) {if (!hasError) {
-            
+
             group_template_declaration();
             }
-            
+
           } else {
             switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
             case GROUP_T:{if (!hasError) {
-              
+
               group_declaration();
               }
-              
+
               break;
               }
             default:
@@ -1265,7 +1265,7 @@ void VhdlParser::block_declarative_item() {
 
 
 void VhdlParser::block_declarative_part() {if (!hasError) {
-    
+
     while (!hasError) {
       switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
       case ALIAS_T:
@@ -1293,35 +1293,35 @@ void VhdlParser::block_declarative_part() {if (!hasError) {
         jj_la1[28] = jj_gen;
         goto end_label_7;
       }if (!hasError) {
-      
+
       block_declarative_item();
       }
-      
+
     }
     end_label_7: ;
     }
-    
+
 }
 
 
 void VhdlParser::block_header() {if (!hasError) {
-    
+
     if (jj_2_9(2147483647)) {if (!hasError) {
-      
+
       generic_clause();
       }
       if (!hasError) {
-      
+
       switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
       case GENERIC_T:{if (!hasError) {
-        
+
         generic_map_aspect();
         }
         if (!hasError) {
-        
+
         jj_consume_token(SEMI_T);
         }
-        
+
         break;
         }
       default:
@@ -1329,30 +1329,30 @@ void VhdlParser::block_header() {if (!hasError) {
         ;
       }
       }
-      
+
     } else {
       ;
     }
     }
     if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case PORT_T:{if (!hasError) {
-      
+
       port_clause();
       }
       if (!hasError) {
-      
+
       switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
       case PORT_T:{if (!hasError) {
-        
+
         port_map_aspect();
         }
         if (!hasError) {
-        
+
         jj_consume_token(SEMI_T);
         }
-        
+
         break;
         }
       default:
@@ -1360,7 +1360,7 @@ void VhdlParser::block_header() {if (!hasError) {
         ;
       }
       }
-      
+
       break;
       }
     default:
@@ -1368,30 +1368,30 @@ void VhdlParser::block_header() {if (!hasError) {
       ;
     }
     }
-    
+
 }
 
 
 void VhdlParser::block_specification() {if (!hasError) {
-    
+
     name();
     }
     if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case LPAREN_T:{if (!hasError) {
-      
+
       jj_consume_token(LPAREN_T);
       }
       if (!hasError) {
-      
+
       index_specification();
       }
       if (!hasError) {
-      
+
       jj_consume_token(RPAREN_T);
       }
-      
+
       break;
       }
     default:
@@ -1399,42 +1399,42 @@ void VhdlParser::block_specification() {if (!hasError) {
       ;
     }
     }
-    
+
 }
 
 
 void VhdlParser::block_statement() {QCString s;if (!hasError) {
-    
+
     s = identifier();
     }
     if (!hasError) {
-    
+
     jj_consume_token(COLON_T);
     }
     if (!hasError) {
-    
+
     jj_consume_token(BLOCK_T);
     }
     if (!hasError) {
-    
+
 pushLabel(genLabels,s);
     }
     if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case LPAREN_T:{if (!hasError) {
-      
+
       jj_consume_token(LPAREN_T);
       }
       if (!hasError) {
-      
+
       expression();
       }
       if (!hasError) {
-      
+
       jj_consume_token(RPAREN_T);
       }
-      
+
       break;
       }
     default:
@@ -1443,13 +1443,13 @@ pushLabel(genLabels,s);
     }
     }
     if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case IS_T:{if (!hasError) {
-      
+
       jj_consume_token(IS_T);
       }
-      
+
       break;
       }
     default:
@@ -1458,38 +1458,38 @@ pushLabel(genLabels,s);
     }
     }
     if (!hasError) {
-    
+
     block_header();
     }
     if (!hasError) {
-    
+
     block_declarative_part();
     }
     if (!hasError) {
-    
+
     jj_consume_token(BEGIN_T);
     }
     if (!hasError) {
-    
+
     block_statement_part();
     }
     if (!hasError) {
-    
+
     jj_consume_token(END_T);
     }
     if (!hasError) {
-    
+
     jj_consume_token(BLOCK_T);
     }
     if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case BASIC_IDENTIFIER:
     case EXTENDED_CHARACTER:{if (!hasError) {
-      
+
       identifier();
       }
-      
+
       break;
       }
     default:
@@ -1498,16 +1498,16 @@ pushLabel(genLabels,s);
     }
     }
     if (!hasError) {
-    
+
     jj_consume_token(SEMI_T);
     }
-    
+
 genLabels=popLabel(genLabels);
 }
 
 
 void VhdlParser::block_statement_part() {if (!hasError) {
-    
+
     while (!hasError) {
       switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
       case ASSERT_T:
@@ -1528,30 +1528,30 @@ void VhdlParser::block_statement_part() {if (!hasError) {
         jj_la1[36] = jj_gen;
         goto end_label_8;
       }if (!hasError) {
-      
+
       concurrent_statement();
       }
-      
+
     }
     end_label_8: ;
     }
-    
+
 }
 
 
 void VhdlParser::case_statement() {QCString s;if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case BASIC_IDENTIFIER:
     case EXTENDED_CHARACTER:{if (!hasError) {
-      
+
       identifier();
       }
       if (!hasError) {
-      
+
       jj_consume_token(COLON_T);
       }
-      
+
       break;
       }
     default:
@@ -1560,28 +1560,28 @@ void VhdlParser::case_statement() {QCString s;if (!hasError) {
     }
     }
     if (!hasError) {
-    
+
     jj_consume_token(CASE_T);
     }
     if (!hasError) {
-    
+
     s = expression();
     }
     if (!hasError) {
-    
+
 QCString ca="case "+s;
      FlowChart::addFlowChart(FlowChart::CASE_NO,0,ca);
     }
     if (!hasError) {
-    
+
     jj_consume_token(IS_T);
     }
     if (!hasError) {
-    
+
     case_statement_alternative();
     }
     if (!hasError) {
-    
+
     while (!hasError) {
       switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
       case WHEN_T:{
@@ -1592,30 +1592,30 @@ QCString ca="case "+s;
         jj_la1[38] = jj_gen;
         goto end_label_9;
       }if (!hasError) {
-      
+
       case_statement_alternative();
       }
-      
+
     }
     end_label_9: ;
     }
     if (!hasError) {
-    
+
     jj_consume_token(END_T);
     }
     if (!hasError) {
-    
+
     jj_consume_token(CASE_T);
     }
     if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case BASIC_IDENTIFIER:
     case EXTENDED_CHARACTER:{if (!hasError) {
-      
+
       identifier();
       }
-      
+
       break;
       }
     default:
@@ -1624,47 +1624,47 @@ QCString ca="case "+s;
     }
     }
     if (!hasError) {
-    
+
     jj_consume_token(SEMI_T);
     }
-    
+
 FlowChart::moveToPrevLevel();
          FlowChart::addFlowChart(FlowChart::END_CASE,"end case",0);
 }
 
 
 void VhdlParser::case_statement_alternative() {QCString s;if (!hasError) {
-    
+
     jj_consume_token(WHEN_T);
     }
     if (!hasError) {
-    
+
     s = choices();
     }
     if (!hasError) {
-    
+
     jj_consume_token(ARROW_T);
     }
     if (!hasError) {
-    
+
 QCString t="when ";
     t+=s+"=> ";
     FlowChart::addFlowChart(FlowChart::WHEN_NO,s.data(),t);
     }
     if (!hasError) {
-    
+
     sequence_of_statement();
     }
-    
+
 FlowChart::moveToPrevLevel();
 }
 
 
 QCString VhdlParser::character_literal() {Token *tok=0;if (!hasError) {
-    
+
     tok = jj_consume_token(CHARACTER_LITERAL);
     }
-    
+
 return tok->image.c_str();
 assert(false);
 }
@@ -1672,43 +1672,43 @@ assert(false);
 
 QCString VhdlParser::choice() {QCString s;
     if (jj_2_10(2147483647)) {if (!hasError) {
-      
+
       s = discrete_range();
       }
       if (!hasError) {
-      
+
 return s;
       }
-      
+
     } else if (jj_2_11(2147483647)) {if (!hasError) {
-      
+
       s = simple_expression();
       }
       if (!hasError) {
-      
+
 return s;
       }
-      
+
     } else if (jj_2_12(2147483647)) {if (!hasError) {
-      
+
       s = identifier();
       }
       if (!hasError) {
-      
+
 return s;
       }
-      
+
     } else {
       switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
       case OTHER_T:{if (!hasError) {
-        
+
         jj_consume_token(OTHER_T);
         }
         if (!hasError) {
-        
+
 return " others ";
         }
-        
+
         break;
         }
       default:
@@ -1722,11 +1722,11 @@ assert(false);
 
 
 QCString VhdlParser::choices() {QCString s,s1;if (!hasError) {
-    
+
     s = choice();
     }
     if (!hasError) {
-    
+
     while (!hasError) {
       switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
       case BAR_T:{
@@ -1737,50 +1737,50 @@ QCString VhdlParser::choices() {QCString s,s1;if (!hasError) {
         jj_la1[41] = jj_gen;
         goto end_label_10;
       }if (!hasError) {
-      
+
       jj_consume_token(BAR_T);
       }
       if (!hasError) {
-      
+
       s1 = choice();
       }
       if (!hasError) {
-      
+
 s+="|";s+=s1;
       }
-      
+
     }
     end_label_10: ;
     }
-    
+
 return s;
 assert(false);
 }
 
 
 void VhdlParser::component_configuration() {if (!hasError) {
-    
+
     jj_consume_token(FOR_T);
     }
     if (!hasError) {
-    
+
     component_specification();
     }
     if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case GENERIC_T:
     case PORT_T:
     case USE_T:
     case SEMI_T:{if (!hasError) {
-      
+
       binding_indication();
       }
       if (!hasError) {
-      
+
       jj_consume_token(SEMI_T);
       }
-      
+
       break;
       }
     default:
@@ -1789,13 +1789,13 @@ void VhdlParser::component_configuration() {if (!hasError) {
     }
     }
     if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case FOR_T:{if (!hasError) {
-      
+
       block_configuration();
       }
-      
+
       break;
       }
     default:
@@ -1804,37 +1804,37 @@ void VhdlParser::component_configuration() {if (!hasError) {
     }
     }
     if (!hasError) {
-    
+
     jj_consume_token(END_T);
     }
     if (!hasError) {
-    
+
     jj_consume_token(FOR_T);
     }
     if (!hasError) {
-    
+
     jj_consume_token(SEMI_T);
     }
-    
+
 }
 
 
 void VhdlParser::component_declaration() {QCString s;if (!hasError) {
-    
+
     jj_consume_token(COMPONENT_T);
     }
     if (!hasError) {
-    
+
     s = identifier();
     }
     if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case IS_T:{if (!hasError) {
-      
+
       jj_consume_token(IS_T);
       }
-      
+
       break;
       }
     default:
@@ -1843,17 +1843,17 @@ void VhdlParser::component_declaration() {QCString s;if (!hasError) {
     }
     }
     if (!hasError) {
-    
+
 currP=VhdlDocGen::COMPONENT;
     }
     if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case GENERIC_T:{if (!hasError) {
-      
+
       generic_clause();
       }
-      
+
       break;
       }
     default:
@@ -1862,13 +1862,13 @@ currP=VhdlDocGen::COMPONENT;
     }
     }
     if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case PORT_T:{if (!hasError) {
-      
+
       port_clause();
       }
-      
+
       break;
       }
     default:
@@ -1877,27 +1877,27 @@ currP=VhdlDocGen::COMPONENT;
     }
     }
     if (!hasError) {
-    
+
 addVhdlType(s.data(),getLine(COMPONENT_T),Entry::VARIABLE_SEC,VhdlDocGen::COMPONENT,0,0,Public);
      currP=0;
     }
     if (!hasError) {
-    
+
     jj_consume_token(END_T);
     }
     if (!hasError) {
-    
+
     jj_consume_token(COMPONENT_T);
     }
     if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case BASIC_IDENTIFIER:
     case EXTENDED_CHARACTER:{if (!hasError) {
-      
+
       identifier();
       }
-      
+
       break;
       }
     default:
@@ -1906,27 +1906,27 @@ addVhdlType(s.data(),getLine(COMPONENT_T),Entry::VARIABLE_SEC,VhdlDocGen::COMPON
     }
     }
     if (!hasError) {
-    
+
     jj_consume_token(SEMI_T);
     }
-    
+
 }
 
 
 void VhdlParser::component_instantiation_statement() {QCString s,s1;if (!hasError) {
-    
+
     s = identifier();
     }
     if (!hasError) {
-    
+
     jj_consume_token(COLON_T);
     }
     if (!hasError) {
-    
+
     s1 = instantiation_unit();
     }
     if (!hasError) {
-    
+
 QCString s3;
        if (s1.contains("|")) {
          s3=VhdlDocGen::getIndexWord(s1.data(),0);
@@ -1936,24 +1936,24 @@ QCString s3;
        addCompInst(s.lower().data(),s1.lower().data(),s3.data(),getLine());
     }
     if (!hasError) {
-    
+
     if (jj_2_13(2147483647)) {if (!hasError) {
-      
+
       generic_map_aspect();
       }
-      
+
     } else {
       ;
     }
     }
     if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case PORT_T:{if (!hasError) {
-      
+
       port_map_aspect();
       }
-      
+
       break;
       }
     default:
@@ -1962,51 +1962,51 @@ QCString s3;
     }
     }
     if (!hasError) {
-    
+
     jj_consume_token(SEMI_T);
     }
-    
+
 }
 
 
 void VhdlParser::component_specification() {if (!hasError) {
-    
+
     instantiation_list();
     }
     if (!hasError) {
-    
+
     jj_consume_token(COLON_T);
     }
     if (!hasError) {
-    
+
     name();
     }
-    
+
 }
 
 
 QCString VhdlParser::composite_type_definition() {QCString s,s1;
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case ARRAY_T:{if (!hasError) {
-      
+
       s = array_type_definition();
       }
       if (!hasError) {
-      
+
 return s;
       }
-      
+
       break;
       }
     case RECORD_T:{if (!hasError) {
-      
+
       record_type_definition();
       }
       if (!hasError) {
-      
+
 return s+"#";
       }
-      
+
       break;
       }
     default:
@@ -2019,28 +2019,28 @@ assert(false);
 
 
 void VhdlParser::concurrent_assertion_statement() {if (!hasError) {
-    
+
     if (jj_2_14(2)) {if (!hasError) {
-      
+
       identifier();
       }
       if (!hasError) {
-      
+
       jj_consume_token(COLON_T);
       }
-      
+
     } else {
       ;
     }
     }
     if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case POSTPONED_T:{if (!hasError) {
-      
+
       jj_consume_token(POSTPONED_T);
       }
-      
+
       break;
       }
     default:
@@ -2049,40 +2049,40 @@ void VhdlParser::concurrent_assertion_statement() {if (!hasError) {
     }
     }
     if (!hasError) {
-    
+
     assertion();
     }
     if (!hasError) {
-    
+
     jj_consume_token(SEMI_T);
     }
-    
+
 }
 
 
 void VhdlParser::concurrent_procedure_call_statement() {if (!hasError) {
-    
+
     if (jj_2_15(2)) {if (!hasError) {
-      
+
       identifier();
       }
       if (!hasError) {
-      
+
       jj_consume_token(COLON_T);
       }
-      
+
     } else {
       ;
     }
     }
     if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case POSTPONED_T:{if (!hasError) {
-      
+
       jj_consume_token(POSTPONED_T);
       }
-      
+
       break;
       }
     default:
@@ -2091,40 +2091,40 @@ void VhdlParser::concurrent_procedure_call_statement() {if (!hasError) {
     }
     }
     if (!hasError) {
-    
+
     procedure_call();
     }
     if (!hasError) {
-    
+
     jj_consume_token(SEMI_T);
     }
-    
+
 }
 
 
 void VhdlParser::concurrent_signal_assignment_statement() {if (!hasError) {
-    
+
     if (jj_2_16(2)) {if (!hasError) {
-      
+
       identifier();
       }
       if (!hasError) {
-      
+
       jj_consume_token(COLON_T);
       }
-      
+
     } else {
       ;
     }
     }
     if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case POSTPONED_T:{if (!hasError) {
-      
+
       jj_consume_token(POSTPONED_T);
       }
-      
+
       break;
       }
     default:
@@ -2133,19 +2133,19 @@ void VhdlParser::concurrent_signal_assignment_statement() {if (!hasError) {
     }
     }
     if (!hasError) {
-    
+
     if (jj_2_17(2147483647)) {if (!hasError) {
-      
+
       conditional_signal_assignment();
       }
-      
+
     } else {
       switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
       case WITH_T:{if (!hasError) {
-        
+
         selected_signal_assignment();
         }
-        
+
         break;
         }
       default:
@@ -2155,64 +2155,64 @@ void VhdlParser::concurrent_signal_assignment_statement() {if (!hasError) {
       }
     }
     }
-    
+
 }
 
 
 void VhdlParser::concurrent_statement() {
     if (jj_2_18(2147483647)) {if (!hasError) {
-      
+
       block_statement();
       }
-      
+
     } else if (jj_2_19(2147483647)) {if (!hasError) {
-      
+
       process_statement();
       }
-      
+
     } else if (jj_2_20(2147483647)) {if (!hasError) {
-      
+
       generate_statement();
       }
-      
+
     } else {
       switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
       case CASE_T:{if (!hasError) {
-        
+
         case_scheme();
         }
-        
+
         break;
         }
       default:
         jj_la1[54] = jj_gen;
         if (jj_2_21(2147483647)) {if (!hasError) {
-          
+
           concurrent_assertion_statement();
           }
-          
+
         } else if (jj_2_22(2147483647)) {if (!hasError) {
-          
+
           concurrent_signal_assignment_statement();
           }
-          
+
         } else if (jj_2_23(2147483647)) {if (!hasError) {
-          
+
           component_instantiation_statement();
           }
-          
+
         } else if (jj_2_24(2147483647)) {if (!hasError) {
-          
+
           concurrent_procedure_call_statement();
           }
-          
+
         } else {
           switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
           case VHDL2008TOOLDIR:{if (!hasError) {
-            
+
             jj_consume_token(VHDL2008TOOLDIR);
             }
-            
+
             break;
             }
           default:
@@ -2227,96 +2227,96 @@ void VhdlParser::concurrent_statement() {
 
 
 QCString VhdlParser::condition() {QCString s;if (!hasError) {
-    
+
     s = expression();
     }
-    
+
 return s;
 assert(false);
 }
 
 
 QCString VhdlParser::condition_clause() {QCString s;if (!hasError) {
-    
+
     jj_consume_token(UNTIL_T);
     }
     if (!hasError) {
-    
+
     s = condition();
     }
-    
+
 return " until "+s;
 assert(false);
 }
 
 
 void VhdlParser::conditional_signal_assignment() {if (!hasError) {
-    
+
     target();
     }
     if (!hasError) {
-    
+
     jj_consume_token(LESSTHAN_T);
     }
     if (!hasError) {
-    
+
     options();
     }
     if (!hasError) {
-    
+
     conditional_waveforms();
     }
     if (!hasError) {
-    
+
     jj_consume_token(SEMI_T);
     }
-    
+
 }
 
 
 void VhdlParser::conditional_waveforms() {if (!hasError) {
-    
+
     waveform();
     }
     if (!hasError) {
-    
+
     while (!hasError) {
       if (jj_2_25(2147483647)) {
         ;
       } else {
         goto end_label_11;
       }if (!hasError) {
-      
+
       jj_consume_token(WHEN_T);
       }
       if (!hasError) {
-      
+
       condition();
       }
       if (!hasError) {
-      
+
       jj_consume_token(ELSE_T);
       }
       if (!hasError) {
-      
+
       waveform();
       }
-      
+
     }
     end_label_11: ;
     }
     if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case WHEN_T:{if (!hasError) {
-      
+
       jj_consume_token(WHEN_T);
       }
       if (!hasError) {
-      
+
       condition();
       }
-      
+
       break;
       }
     default:
@@ -2324,55 +2324,55 @@ void VhdlParser::conditional_waveforms() {if (!hasError) {
       ;
     }
     }
-    
+
 }
 
 
 void VhdlParser::configuration_declaration() {QCString s,s1;if (!hasError) {
-    
+
     jj_consume_token(CONFIGURATION_T);
     }
     if (!hasError) {
-    
+
     s = identifier();
     }
     if (!hasError) {
-    
+
     jj_consume_token(OF_T);
     }
     if (!hasError) {
-    
+
     s1 = name();
     }
     if (!hasError) {
-    
+
     jj_consume_token(IS_T);
     }
     if (!hasError) {
-    
+
 confName=s+"::"+s1;
   addVhdlType(s.data(),getLine(CONFIGURATION_T),Entry::VARIABLE_SEC,VhdlDocGen::CONFIG,"configuration",s1.data(),Public);
     }
     if (!hasError) {
-    
+
     configuration_declarative_part();
     }
     if (!hasError) {
-    
+
     block_configuration();
     }
     if (!hasError) {
-    
+
     jj_consume_token(END_T);
     }
     if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case CONFIGURATION_T:{if (!hasError) {
-      
+
       jj_consume_token(CONFIGURATION_T);
       }
-      
+
       break;
       }
     default:
@@ -2381,16 +2381,16 @@ confName=s+"::"+s1;
     }
     }
     if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case SLSL_T:
     case STRINGLITERAL:
     case BASIC_IDENTIFIER:
     case EXTENDED_CHARACTER:{if (!hasError) {
-      
+
       name();
       }
-      
+
       break;
       }
     default:
@@ -2399,10 +2399,10 @@ confName=s+"::"+s1;
     }
     }
     if (!hasError) {
-    
+
     jj_consume_token(SEMI_T);
     }
-    
+
 genLabels.resize(0); confName="";
 }
 
@@ -2410,24 +2410,24 @@ genLabels.resize(0); confName="";
 void VhdlParser::configuration_declarative_item() {
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case USE_T:{if (!hasError) {
-      
+
       use_clause();
       }
-      
+
       break;
       }
     case ATTRIBUTE_T:{if (!hasError) {
-      
+
       attribute_specification();
       }
-      
+
       break;
       }
     case GROUP_T:{if (!hasError) {
-      
+
       group_declaration();
       }
-      
+
       break;
       }
     default:
@@ -2439,7 +2439,7 @@ void VhdlParser::configuration_declarative_item() {
 
 
 void VhdlParser::configuration_declarative_part() {if (!hasError) {
-    
+
     while (!hasError) {
       switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
       case ATTRIBUTE_T:
@@ -2452,30 +2452,30 @@ void VhdlParser::configuration_declarative_part() {if (!hasError) {
         jj_la1[60] = jj_gen;
         goto end_label_12;
       }if (!hasError) {
-      
+
       configuration_declarative_item();
       }
-      
+
     }
     end_label_12: ;
     }
-    
+
 }
 
 
 void VhdlParser::configuration_item() {
     if (jj_2_26(2147483647)) {if (!hasError) {
-      
+
       component_configuration();
       }
-      
+
     } else {
       switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
       case FOR_T:{if (!hasError) {
-        
+
         block_configuration();
         }
-        
+
         break;
         }
       default:
@@ -2488,53 +2488,53 @@ void VhdlParser::configuration_item() {
 
 
 void VhdlParser::configuration_specification() {if (!hasError) {
-    
+
     jj_consume_token(FOR_T);
     }
     if (!hasError) {
-    
+
     component_specification();
     }
     if (!hasError) {
-    
+
     binding_indication();
     }
     if (!hasError) {
-    
+
     jj_consume_token(SEMI_T);
     }
-    
+
 }
 
 
 QCString VhdlParser::constant_declaration() {QCString s,s1,s2;Token *t=0;if (!hasError) {
-    
+
     jj_consume_token(CONSTANT_T);
     }
     if (!hasError) {
-    
+
     s = identifier_list();
     }
     if (!hasError) {
-    
+
     jj_consume_token(COLON_T);
     }
     if (!hasError) {
-    
+
     s1 = subtype_indication();
     }
     if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case VARASSIGN_T:{if (!hasError) {
-      
+
       t = jj_consume_token(VARASSIGN_T);
       }
       if (!hasError) {
-      
+
       s2 = expression();
       }
-      
+
       break;
       }
     default:
@@ -2543,10 +2543,10 @@ QCString VhdlParser::constant_declaration() {QCString s,s1,s2;Token *t=0;if (!ha
     }
     }
     if (!hasError) {
-    
+
     jj_consume_token(SEMI_T);
     }
-    
+
 if(t)
       s2.prepend(":=");
      QCString it=s1+s2;
@@ -2558,29 +2558,29 @@ assert(false);
 
 
 QCString VhdlParser::constraint_array_definition() {QCString s,s1;if (!hasError) {
-    
+
     jj_consume_token(ARRAY_T);
     }
     if (!hasError) {
-    
+
     s = index_constraint();
     }
     if (!hasError) {
-    
+
     jj_consume_token(OF_T);
     }
     if (!hasError) {
-    
+
     s1 = subtype_indication();
     }
-    
+
 return s+" "+s1;
 assert(false);
 }
 
 
 void VhdlParser::context_clause() {if (!hasError) {
-    
+
     while (!hasError) {
       switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
       case LIBRARY_T:
@@ -2592,36 +2592,36 @@ void VhdlParser::context_clause() {if (!hasError) {
         jj_la1[63] = jj_gen;
         goto end_label_13;
       }if (!hasError) {
-      
+
       context_item();
       }
-      
+
     }
     end_label_13: ;
     }
-    
+
 }
 
 
 QCString VhdlParser::constraint() {QCString s;
     if (jj_2_27(2147483647)) {if (!hasError) {
-      
+
       s = range_constraint();
       }
       if (!hasError) {
-      
+
 return s;
       }
-      
+
     } else if (jj_2_28(2147483647)) {if (!hasError) {
-      
+
       s = index_constraint();
       }
       if (!hasError) {
-      
+
 return s;
       }
-      
+
     } else {
       jj_consume_token(-1);
       errorHandler->handleParseError(token, getToken(1), __FUNCTION__, this), hasError = true;
@@ -2633,17 +2633,17 @@ assert(false);
 void VhdlParser::context_item() {
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case LIBRARY_T:{if (!hasError) {
-      
+
       library_clause();
       }
-      
+
       break;
       }
     case USE_T:{if (!hasError) {
-      
+
       use_clause();
       }
-      
+
       break;
       }
     default:
@@ -2655,10 +2655,10 @@ void VhdlParser::context_item() {
 
 
 QCString VhdlParser::decimal_literal() {Token *tok=0;if (!hasError) {
-    
+
     tok = jj_consume_token(DECIMAL_LITERAL);
     }
-    
+
 return tok->image.c_str();
 assert(false);
 }
@@ -2667,33 +2667,33 @@ assert(false);
 QCString VhdlParser::delay_mechanism() {QCString s;
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case TRANSPORT_T:{if (!hasError) {
-      
+
       jj_consume_token(TRANSPORT_T);
       }
       if (!hasError) {
-      
+
 return " transport ";
       }
-      
+
       break;
       }
     case INERTIAL_T:
     case REJECT_T:{if (!hasError) {
-      
+
       switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
       case REJECT_T:{if (!hasError) {
-        
+
         jj_consume_token(REJECT_T);
         }
         if (!hasError) {
-        
+
         s = expression();
         }
         if (!hasError) {
-        
+
 s.prepend(" reject ");
         }
-        
+
         break;
         }
       default:
@@ -2702,14 +2702,14 @@ s.prepend(" reject ");
       }
       }
       if (!hasError) {
-      
+
       jj_consume_token(INERTIAL_T);
       }
       if (!hasError) {
-      
+
 return s+" inertial ";
       }
-      
+
       break;
       }
     default:
@@ -2730,12 +2730,12 @@ void VhdlParser::design_file() {
     case LIBRARY_T:
     case PACKAGE_T:
     case USE_T:{if (!hasError) {
-      
+
       while (!hasError) {if (!hasError) {
-        
+
         design_unit();
         }
-        
+
         switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
         case ARCHITECTURE_T:
         case CONFIGURATION_T:
@@ -2755,17 +2755,17 @@ void VhdlParser::design_file() {
       end_label_14: ;
       }
       if (!hasError) {
-      
+
 
       }
-      
+
       break;
       }
     case 0:{if (!hasError) {
-      
+
       jj_consume_token(0);
       }
-      
+
       break;
       }
     default:
@@ -2777,14 +2777,14 @@ void VhdlParser::design_file() {
 
 
 void VhdlParser::design_unit() {if (!hasError) {
-    
+
     context_clause();
     }
     if (!hasError) {
-    
+
     library_unit();
     }
-    
+
 }
 
 
@@ -2792,25 +2792,25 @@ QCString VhdlParser::designator() {QCString s;
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case BASIC_IDENTIFIER:
     case EXTENDED_CHARACTER:{if (!hasError) {
-      
+
       s = identifier();
       }
       if (!hasError) {
-      
+
 return s;
       }
-      
+
       break;
       }
     case STRINGLITERAL:{if (!hasError) {
-      
+
       s = operator_symbol();
       }
       if (!hasError) {
-      
+
 return s;
       }
-      
+
       break;
       }
     default:
@@ -2825,25 +2825,25 @@ assert(false);
 QCString VhdlParser::direction() {Token *tok=0;
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case TO_T:{if (!hasError) {
-      
+
       tok = jj_consume_token(TO_T);
       }
       if (!hasError) {
-      
+
 return tok->image.c_str();
       }
-      
+
       break;
       }
     case DOWNTO_T:{if (!hasError) {
-      
+
       tok = jj_consume_token(DOWNTO_T);
       }
       if (!hasError) {
-      
+
 return tok->image.c_str();
       }
-      
+
       break;
       }
     default:
@@ -2856,64 +2856,64 @@ assert(false);
 
 
 void VhdlParser::disconnection_specification() {if (!hasError) {
-    
+
     jj_consume_token(DISCONNECT_T);
     }
     if (!hasError) {
-    
+
     guarded_signal_specificatio();
     }
     if (!hasError) {
-    
+
     jj_consume_token(AFTER_T);
     }
     if (!hasError) {
-    
+
     expression();
     }
     if (!hasError) {
-    
+
     jj_consume_token(SEMI_T);
     }
-    
+
 }
 
 
 void VhdlParser::guarded_signal_specificatio() {if (!hasError) {
-    
+
     signal_list();
     }
     if (!hasError) {
-    
+
     jj_consume_token(COLON_T);
     }
     if (!hasError) {
-    
+
     name();
     }
-    
+
 }
 
 
 QCString VhdlParser::discrete_range() {QCString s;
     if (jj_2_29(2147483647)) {if (!hasError) {
-      
+
       s = range();
       }
       if (!hasError) {
-      
+
 return s;
       }
-      
+
     } else if (jj_2_30(2147483647)) {if (!hasError) {
-      
+
       s = subtype_indication();
       }
       if (!hasError) {
-      
+
 return s;
       }
-      
+
     } else {
       jj_consume_token(-1);
       errorHandler->handleParseError(token, getToken(1), __FUNCTION__, this), hasError = true;
@@ -2923,25 +2923,25 @@ assert(false);
 
 
 QCString VhdlParser::element_association() {QCString s,s1;if (!hasError) {
-    
+
     if (jj_2_31(2147483647)) {if (!hasError) {
-      
+
       s = choices();
       }
       if (!hasError) {
-      
+
       jj_consume_token(ARROW_T);
       }
-      
+
     } else {
       ;
     }
     }
     if (!hasError) {
-    
+
     s1 = expression();
     }
-    
+
 if(!s.isEmpty())
  return s+"=>"+s1;
 return s1;
@@ -2950,22 +2950,22 @@ assert(false);
 
 
 QCString VhdlParser::element_declaration() {QCString s,s1;if (!hasError) {
-    
+
     s = identifier_list();
     }
     if (!hasError) {
-    
+
     jj_consume_token(COLON_T);
     }
     if (!hasError) {
-    
+
     s1 = subtype_indication();
     }
     if (!hasError) {
-    
+
     jj_consume_token(SEMI_T);
     }
-    
+
 addVhdlType(s.data(),getLine(),Entry::VARIABLE_SEC,VhdlDocGen::RECORD,0,s1.data(),Public);
   //addVhdlType(s.data(),getLine(),Entry::VARIABLE_SEC,VhdlDocGen::VFILE,0,s1.data(),Public);
   return s+":"+s1;
@@ -2976,33 +2976,33 @@ assert(false);
 QCString VhdlParser::entity_aspect() {Token *tok=0;QCString s,s1;
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case ENTITY_T:{if (!hasError) {
-      
+
       tok = jj_consume_token(ENTITY_T);
       }
       if (!hasError) {
-      
+
       s = name();
       }
       if (!hasError) {
-      
+
       switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
       case LPAREN_T:{if (!hasError) {
-        
+
         jj_consume_token(LPAREN_T);
         }
         if (!hasError) {
-        
+
         s1 = identifier();
         }
         if (!hasError) {
-        
+
         jj_consume_token(RPAREN_T);
         }
         if (!hasError) {
-        
+
 s+="("+s1+")";
         }
-        
+
         break;
         }
       default:
@@ -3011,36 +3011,36 @@ s+="("+s1+")";
       }
       }
       if (!hasError) {
-      
+
 return s;
       }
-      
+
       break;
       }
     case CONFIGURATION_T:{if (!hasError) {
-      
+
       tok = jj_consume_token(CONFIGURATION_T);
       }
       if (!hasError) {
-      
+
       s = name();
       }
       if (!hasError) {
-      
+
 return tok->image.c_str()+s;
       }
-      
+
       break;
       }
     case OPEN_T:{if (!hasError) {
-      
+
       tok = jj_consume_token(OPEN_T);
       }
       if (!hasError) {
-      
+
 return tok->image.c_str();
       }
-      
+
       break;
       }
     default:
@@ -3055,190 +3055,190 @@ assert(false);
 QCString VhdlParser::entity_class() {
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case ENTITY_T:{if (!hasError) {
-      
+
       jj_consume_token(ENTITY_T);
       }
       if (!hasError) {
-      
+
 return "entity";
       }
-      
+
       break;
       }
     case ARCHITECTURE_T:{if (!hasError) {
-      
+
       jj_consume_token(ARCHITECTURE_T);
       }
       if (!hasError) {
-      
+
 return "architecture";
       }
-      
+
       break;
       }
     case CONFIGURATION_T:{if (!hasError) {
-      
+
       jj_consume_token(CONFIGURATION_T);
       }
       if (!hasError) {
-      
+
 return "configuration";
       }
-      
+
       break;
       }
     case PROCEDURE_T:{if (!hasError) {
-      
+
       jj_consume_token(PROCEDURE_T);
       }
       if (!hasError) {
-      
+
 return "procedure";
       }
-      
+
       break;
       }
     case FUNCTION_T:{if (!hasError) {
-      
+
       jj_consume_token(FUNCTION_T);
       }
       if (!hasError) {
-      
+
 return "function";
       }
-      
+
       break;
       }
     case PACKAGE_T:{if (!hasError) {
-      
+
       jj_consume_token(PACKAGE_T);
       }
       if (!hasError) {
-      
+
 return "package";
       }
-      
+
       break;
       }
     case TYPE_T:{if (!hasError) {
-      
+
       jj_consume_token(TYPE_T);
       }
       if (!hasError) {
-      
+
 return "type";
       }
-      
+
       break;
       }
     case SUBTYPE_T:{if (!hasError) {
-      
+
       jj_consume_token(SUBTYPE_T);
       }
       if (!hasError) {
-      
+
 return "subtype";
       }
-      
+
       break;
       }
     case CONSTANT_T:{if (!hasError) {
-      
+
       jj_consume_token(CONSTANT_T);
       }
       if (!hasError) {
-      
+
 return "constant";
       }
-      
+
       break;
       }
     case SIGNAL_T:{if (!hasError) {
-      
+
       jj_consume_token(SIGNAL_T);
       }
       if (!hasError) {
-      
+
 return "signal";
       }
-      
+
       break;
       }
     case VARIABLE_T:{if (!hasError) {
-      
+
       jj_consume_token(VARIABLE_T);
       }
       if (!hasError) {
-      
+
 return "variable";
       }
-      
+
       break;
       }
     case COMPONENT_T:{if (!hasError) {
-      
+
       jj_consume_token(COMPONENT_T);
       }
       if (!hasError) {
-      
+
 return "component";
       }
-      
+
       break;
       }
     case LABEL_T:{if (!hasError) {
-      
+
       jj_consume_token(LABEL_T);
       }
       if (!hasError) {
-      
+
 return "label";
       }
-      
+
       break;
       }
     case LITERAL_T:{if (!hasError) {
-      
+
       jj_consume_token(LITERAL_T);
       }
       if (!hasError) {
-      
+
 return "literal";
       }
-      
+
       break;
       }
     case UNITS_T:{if (!hasError) {
-      
+
       jj_consume_token(UNITS_T);
       }
       if (!hasError) {
-      
+
 return "units";
       }
-      
+
       break;
       }
     case GROUP_T:{if (!hasError) {
-      
+
       jj_consume_token(GROUP_T);
       }
       if (!hasError) {
-      
+
 return "group";
       }
-      
+
       break;
       }
     case FILE_T:{if (!hasError) {
-      
+
       jj_consume_token(FILE_T);
       }
       if (!hasError) {
-      
+
 return "file";
       }
-      
+
       break;
       }
     default:
@@ -3251,21 +3251,21 @@ assert(false);
 
 
 QCString VhdlParser::entity_class_entry() {QCString s;if (!hasError) {
-    
+
     s = entity_class();
     }
     if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case BOX_T:{if (!hasError) {
-      
+
       jj_consume_token(BOX_T);
       }
       if (!hasError) {
-      
+
 s+="<>";
       }
-      
+
       break;
       }
     default:
@@ -3273,7 +3273,7 @@ s+="<>";
       ;
     }
     }
-    
+
 return s;
 assert(false);
 }
@@ -3281,17 +3281,17 @@ assert(false);
 
 QCString VhdlParser::entity_class_entry_list() {QCString s,s1,s2;if (!hasError) {
     if (!hasError) {
-    
+
     s1 = entity_class_entry();
     }
     if (!hasError) {
-    
+
 s+=s1;
     }
-    
+
     }
     if (!hasError) {
-    
+
     while (!hasError) {
       switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
       case COMMA_T:{
@@ -3302,65 +3302,65 @@ s+=s1;
         jj_la1[75] = jj_gen;
         goto end_label_15;
       }if (!hasError) {
-      
+
       jj_consume_token(COMMA_T);
       }
       if (!hasError) {
-      
+
       s = entity_class_entry();
       }
       if (!hasError) {
-      
+
 s2+=",";s2+=s;
       }
-      
+
     }
     end_label_15: ;
     }
-    
+
 return s1+s2;
 assert(false);
 }
 
 
 void VhdlParser::entity_declaration() {QCString s;if (!hasError) {
-    
+
     jj_consume_token(ENTITY_T);
     }
     if (!hasError) {
-    
+
     s = identifier();
     }
     if (!hasError) {
-    
+
     jj_consume_token(IS_T);
     }
     if (!hasError) {
-    
+
 lastEntity=current;
                 lastCompound=0;
                 addVhdlType(s.data(),getLine(ENTITY_T),Entry::CLASS_SEC,VhdlDocGen::ENTITY,0,0,Public);
     }
     if (!hasError) {
-    
+
     entity_header();
     }
     if (!hasError) {
-    
+
     entity_declarative_part();
     }
     if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case BEGIN_T:{if (!hasError) {
-      
+
       jj_consume_token(BEGIN_T);
       }
       if (!hasError) {
-      
+
       entity_statement_part();
       }
-      
+
       break;
       }
     default:
@@ -3369,17 +3369,17 @@ lastEntity=current;
     }
     }
     if (!hasError) {
-    
+
     jj_consume_token(END_T);
     }
     if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case ENTITY_T:{if (!hasError) {
-      
+
       jj_consume_token(ENTITY_T);
       }
-      
+
       break;
       }
     default:
@@ -3388,16 +3388,16 @@ lastEntity=current;
     }
     }
     if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case SLSL_T:
     case STRINGLITERAL:
     case BASIC_IDENTIFIER:
     case EXTENDED_CHARACTER:{if (!hasError) {
-      
+
       name();
       }
-      
+
       break;
       }
     default:
@@ -3406,10 +3406,10 @@ lastEntity=current;
     }
     }
     if (!hasError) {
-    
+
     jj_consume_token(SEMI_T);
     }
-    
+
 lastEntity=0;lastCompound=0; genLabels.resize(0);
 }
 
@@ -3420,129 +3420,129 @@ void VhdlParser::entity_declarative_item() {
     case IMPURE_T:
     case PROCEDURE_T:
     case PURE_T:{if (!hasError) {
-      
+
       subprogram_declaration();
       }
-      
+
       break;
       }
     case TYPE_T:{if (!hasError) {
-      
+
       type_declaration();
       }
-      
+
       break;
       }
     case SUBTYPE_T:{if (!hasError) {
-      
+
       subtype_declaration();
       }
-      
+
       break;
       }
     case CONSTANT_T:{if (!hasError) {
-      
+
       constant_declaration();
       }
-      
+
       break;
       }
     case SIGNAL_T:{if (!hasError) {
-      
+
       signal_declaration();
       }
-      
+
       break;
       }
     case SHARED_T:
     case VARIABLE_T:{if (!hasError) {
-      
+
       variable_declaration();
       }
-      
+
       break;
       }
     case FILE_T:{if (!hasError) {
-      
+
       file_declaration();
       }
-      
+
       break;
       }
     case ALIAS_T:{if (!hasError) {
-      
+
       alias_declaration();
       }
-      
+
       break;
       }
     default:
       jj_la1[79] = jj_gen;
       if (jj_2_32(2147483647)) {if (!hasError) {
-        
+
         attribute_declaration();
         }
-        
+
       } else {
         switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
         case ATTRIBUTE_T:{if (!hasError) {
-          
+
           attribute_specification();
           }
-          
+
           break;
           }
         case DISCONNECT_T:{if (!hasError) {
-          
+
           disconnection_specification();
           }
-          
+
           break;
           }
         case USE_T:{if (!hasError) {
-          
+
           use_clause();
           }
-          
+
           break;
           }
         default:
           jj_la1[80] = jj_gen;
           if (jj_2_33(3)) {if (!hasError) {
-            
+
             group_template_declaration();
             }
-            
+
           } else {
             switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
             case GROUP_T:{if (!hasError) {
-              
+
               group_declaration();
               }
-              
+
               break;
               }
             default:
               jj_la1[81] = jj_gen;
               if (jj_2_34(5)) {if (!hasError) {
-                
+
                 package_instantiation_declaration();
                 }
-                
+
               } else {
                 switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
                 case PACKAGE_T:{if (!hasError) {
-                  
+
                   package_declaration();
                   }
-                  
+
                   break;
                   }
                 case VHDL2008TOOLDIR:{if (!hasError) {
-                  
+
                   jj_consume_token(VHDL2008TOOLDIR);
                   }
-                  
+
                   break;
                   }
                 default:
@@ -3560,7 +3560,7 @@ void VhdlParser::entity_declarative_item() {
 
 
 void VhdlParser::entity_declarative_part() {if (!hasError) {
-    
+
     while (!hasError) {
       switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
       case ALIAS_T:
@@ -3588,29 +3588,29 @@ void VhdlParser::entity_declarative_part() {if (!hasError) {
         jj_la1[83] = jj_gen;
         goto end_label_16;
       }if (!hasError) {
-      
+
       entity_declarative_item();
       }
-      
+
     }
     end_label_16: ;
     }
-    
+
 }
 
 
 QCString VhdlParser::entity_designator() {QCString s,s1;if (!hasError) {
-    
+
     s = entity_tag();
     }
     if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case LBRACKET_T:{if (!hasError) {
-      
+
       s1 = signature();
       }
-      
+
       break;
       }
     default:
@@ -3618,24 +3618,24 @@ QCString VhdlParser::entity_designator() {QCString s,s1;if (!hasError) {
       ;
     }
     }
-    
+
 return s+s1;
 assert(false);
 }
 
 
 void VhdlParser::entity_header() {if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case GENERIC_T:{if (!hasError) {
-      
+
 currP=VhdlDocGen::GENERIC;parse_sec=GEN_SEC;
       }
       if (!hasError) {
-      
+
       generic_clause();
       }
-      
+
       break;
       }
     default:
@@ -3644,17 +3644,17 @@ currP=VhdlDocGen::GENERIC;parse_sec=GEN_SEC;
     }
     }
     if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case PORT_T:{if (!hasError) {
-      
+
 currP=VhdlDocGen::PORT;
       }
       if (!hasError) {
-      
+
       port_clause();
       }
-      
+
       break;
       }
     default:
@@ -3662,7 +3662,7 @@ currP=VhdlDocGen::PORT;
       ;
     }
     }
-    
+
 }
 
 
@@ -3673,16 +3673,16 @@ QCString VhdlParser::entity_name_list() {QCString s,s1;
     case BASIC_IDENTIFIER:
     case EXTENDED_CHARACTER:
     case CHARACTER_LITERAL:{if (!hasError) {
-      
+
       while (!hasError) {if (!hasError) {
-        
+
         s1 = entity_designator();
         }
         if (!hasError) {
-        
+
 s+=s1;
         }
-        
+
         switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
         case SLSL_T:
         case STRINGLITERAL:
@@ -3700,32 +3700,32 @@ s+=s1;
       end_label_17: ;
       }
       if (!hasError) {
-      
+
 return s;
       }
-      
+
       break;
       }
     case OTHER_T:{if (!hasError) {
-      
+
       jj_consume_token(OTHER_T);
       }
       if (!hasError) {
-      
+
 return "other";
       }
-      
+
       break;
       }
     case ALL_T:{if (!hasError) {
-      
+
       jj_consume_token(ALL_T);
       }
       if (!hasError) {
-      
+
 return "all";
       }
-      
+
       break;
       }
     default:
@@ -3738,18 +3738,18 @@ assert(false);
 
 
 QCString VhdlParser::entity_specification() {QCString s,s1;if (!hasError) {
-    
+
     s = entity_name_list();
     }
     if (!hasError) {
-    
+
     jj_consume_token(COLON_T);
     }
     if (!hasError) {
-    
+
     s1 = entity_class();
     }
-    
+
 return s+":"+s1;
 assert(false);
 }
@@ -3757,15 +3757,15 @@ assert(false);
 
 void VhdlParser::entity_statement() {
     if (jj_2_35(2147483647)) {if (!hasError) {
-      
+
       concurrent_assertion_statement();
       }
-      
+
     } else if (jj_2_36(2147483647)) {if (!hasError) {
-      
+
       process_statement();
       }
-      
+
     } else {
       switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
       case POSTPONED_T:
@@ -3773,10 +3773,10 @@ void VhdlParser::entity_statement() {
       case STRINGLITERAL:
       case BASIC_IDENTIFIER:
       case EXTENDED_CHARACTER:{if (!hasError) {
-        
+
         concurrent_procedure_call_statement();
         }
-        
+
         break;
         }
       default:
@@ -3789,7 +3789,7 @@ void VhdlParser::entity_statement() {
 
 
 void VhdlParser::entity_statement_part() {if (!hasError) {
-    
+
     while (!hasError) {
       switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
       case ASSERT_T:
@@ -3806,14 +3806,14 @@ void VhdlParser::entity_statement_part() {if (!hasError) {
         jj_la1[90] = jj_gen;
         goto end_label_18;
       }if (!hasError) {
-      
+
       entity_statement();
       }
-      
+
     }
     end_label_18: ;
     }
-    
+
 }
 
 
@@ -3823,25 +3823,25 @@ QCString VhdlParser::entity_tag() {QCString s;
     case STRINGLITERAL:
     case BASIC_IDENTIFIER:
     case EXTENDED_CHARACTER:{if (!hasError) {
-      
+
       s = name();
       }
       if (!hasError) {
-      
+
 return s;
       }
-      
+
       break;
       }
     case CHARACTER_LITERAL:{if (!hasError) {
-      
+
       s = character_literal();
       }
       if (!hasError) {
-      
+
 return s;
       }
-      
+
       break;
       }
     default:
@@ -3857,25 +3857,25 @@ QCString VhdlParser::enumeration_literal() {QCString s;
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case BASIC_IDENTIFIER:
     case EXTENDED_CHARACTER:{if (!hasError) {
-      
+
       s = identifier();
       }
       if (!hasError) {
-      
+
 return s;
       }
-      
+
       break;
       }
     case CHARACTER_LITERAL:{if (!hasError) {
-      
+
       s = character_literal();
       }
       if (!hasError) {
-      
+
 return s;
       }
-      
+
       break;
       }
     default:
@@ -3888,15 +3888,15 @@ assert(false);
 
 
 QCString VhdlParser::enumeration_type_definition() {QCString s,s1;if (!hasError) {
-    
+
     jj_consume_token(LPAREN_T);
     }
     if (!hasError) {
-    
+
     s = enumeration_literal();
     }
     if (!hasError) {
-    
+
     while (!hasError) {
       switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
       case COMMA_T:{
@@ -3907,44 +3907,44 @@ QCString VhdlParser::enumeration_type_definition() {QCString s,s1;if (!hasError)
         jj_la1[93] = jj_gen;
         goto end_label_19;
       }if (!hasError) {
-      
+
       jj_consume_token(COMMA_T);
       }
       if (!hasError) {
-      
+
       s1 = enumeration_literal();
       }
       if (!hasError) {
-      
+
 s+=",";s+=s1;
       }
-      
+
     }
     end_label_19: ;
     }
     if (!hasError) {
-    
+
     jj_consume_token(RPAREN_T);
     }
-    
+
 return "("+s+")";
 assert(false);
 }
 
 
 QCString VhdlParser::exit_statement() {QCString s,s1,s2;Token *t=0;Token *t1=0;if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case BASIC_IDENTIFIER:
     case EXTENDED_CHARACTER:{if (!hasError) {
-      
+
       s = identifier();
       }
       if (!hasError) {
-      
+
       t = jj_consume_token(COLON_T);
       }
-      
+
       break;
       }
     default:
@@ -3953,18 +3953,18 @@ QCString VhdlParser::exit_statement() {QCString s,s1,s2;Token *t=0;Token *t1=0;i
     }
     }
     if (!hasError) {
-    
+
     jj_consume_token(EXIT_T);
     }
     if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case BASIC_IDENTIFIER:
     case EXTENDED_CHARACTER:{if (!hasError) {
-      
+
       s1 = identifier();
       }
-      
+
       break;
       }
     default:
@@ -3973,17 +3973,17 @@ QCString VhdlParser::exit_statement() {QCString s,s1,s2;Token *t=0;Token *t1=0;i
     }
     }
     if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case WHEN_T:{if (!hasError) {
-      
+
       t1 = jj_consume_token(WHEN_T);
       }
       if (!hasError) {
-      
+
       s2 = condition();
       }
-      
+
       break;
       }
     default:
@@ -3992,10 +3992,10 @@ QCString VhdlParser::exit_statement() {QCString s,s1,s2;Token *t=0;Token *t1=0;i
     }
     }
     if (!hasError) {
-    
+
     jj_consume_token(SEMI_T);
     }
-    
+
 lab.resize(0);
   if(t) s+=":";
   if(t1) s2.prepend(" when ");
@@ -4007,11 +4007,11 @@ assert(false);
 
 
 QCString VhdlParser::expression() {QCString s,s1,s2;if (!hasError) {
-    
+
     s = relation();
     }
     if (!hasError) {
-    
+
     while (!hasError) {
       switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
       case AND_T:
@@ -4027,22 +4027,22 @@ QCString VhdlParser::expression() {QCString s,s1,s2;if (!hasError) {
         jj_la1[97] = jj_gen;
         goto end_label_20;
       }if (!hasError) {
-      
+
       s1 = logop();
       }
       if (!hasError) {
-      
+
       s2 = relation();
       }
       if (!hasError) {
-      
+
 s+=s1;s+=s2;
       }
-      
+
     }
     end_label_20: ;
     }
-    
+
 return s;
 assert(false);
 }
@@ -4051,69 +4051,69 @@ assert(false);
 QCString VhdlParser::logop() {
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case AND_T:{if (!hasError) {
-      
+
       jj_consume_token(AND_T);
       }
       if (!hasError) {
-      
+
 return "and" ;
       }
-      
+
       break;
       }
     case NAND_T:{if (!hasError) {
-      
+
       jj_consume_token(NAND_T);
       }
       if (!hasError) {
-      
+
 return "nand" ;
       }
-      
+
       break;
       }
     case NOR_T:{if (!hasError) {
-      
+
       jj_consume_token(NOR_T);
       }
       if (!hasError) {
-      
+
 return "nor" ;
       }
-      
+
       break;
       }
     case XNOR_T:{if (!hasError) {
-      
+
       jj_consume_token(XNOR_T);
       }
       if (!hasError) {
-      
+
 return "xnor" ;
       }
-      
+
       break;
       }
     case XOR_T:{if (!hasError) {
-      
+
       jj_consume_token(XOR_T);
       }
       if (!hasError) {
-      
+
 return "xor" ;
       }
-      
+
       break;
       }
     case OR_T:{if (!hasError) {
-      
+
       jj_consume_token(OR_T);
       }
       if (!hasError) {
-      
+
 return "or" ;
       }
-      
+
       break;
       }
     default:
@@ -4126,10 +4126,10 @@ assert(false);
 
 
 QCString VhdlParser::extended_identifier() {Token *t;if (!hasError) {
-    
+
     t = jj_consume_token(EXTENDED_CHARACTER);
     }
-    
+
 return t->image.c_str();
 assert(false);
 }
@@ -4149,25 +4149,25 @@ QCString VhdlParser::factor() {QCString s,s1;
     case DECIMAL_LITERAL:
     case BASED_LITERAL:
     case BIT_STRING_LITERAL:{if (!hasError) {
-      
+
       s = primary();
       }
       if (!hasError) {
-      
+
       switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
       case DOUBLEMULT_T:{if (!hasError) {
-        
+
         jj_consume_token(DOUBLEMULT_T);
         }
         if (!hasError) {
-        
+
         s1 = primary();
         }
         if (!hasError) {
-        
+
 s+="**";s+=s1;
         }
-        
+
         break;
         }
       default:
@@ -4176,40 +4176,40 @@ s+="**";s+=s1;
       }
       }
       if (!hasError) {
-      
+
 return s;
       }
-      
+
       break;
       }
     case ABS_T:{if (!hasError) {
-      
+
       jj_consume_token(ABS_T);
       }
       if (!hasError) {
-      
+
       s = primary();
       }
       if (!hasError) {
-      
+
 s1 = "abs "; return s1+s;
       }
-      
+
       break;
       }
     case NOT_T:{if (!hasError) {
-      
+
       jj_consume_token(NOT_T);
       }
       if (!hasError) {
-      
+
       s = primary();
       }
       if (!hasError) {
-      
+
 s1="not ";return s1+s;
       }
-      
+
       break;
       }
     default:
@@ -4222,30 +4222,30 @@ assert(false);
 
 
 QCString VhdlParser::file_declaration() {QCString s,s1,s2,s3;if (!hasError) {
-    
+
     jj_consume_token(FILE_T);
     }
     if (!hasError) {
-    
+
     s = identifier_list();
     }
     if (!hasError) {
-    
+
     jj_consume_token(COLON_T);
     }
     if (!hasError) {
-    
+
     s2 = subtype_indication();
     }
     if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case IS_T:
     case OPEN_T:{if (!hasError) {
-      
+
       s3 = file_open_information();
       }
-      
+
       break;
       }
     default:
@@ -4254,10 +4254,10 @@ QCString VhdlParser::file_declaration() {QCString s,s1,s2,s3;if (!hasError) {
     }
     }
     if (!hasError) {
-    
+
     jj_consume_token(SEMI_T);
     }
-    
+
 QCString t1=s2+" "+s3;
    addVhdlType(s.data(),getLine(),Entry::VARIABLE_SEC,VhdlDocGen::VFILE,0,t1.data(),Public);
    return " file "+s+":"+s2+" "+s3+";";
@@ -4266,27 +4266,27 @@ assert(false);
 
 
 QCString VhdlParser::file_logical_name() {QCString s;if (!hasError) {
-    
+
     s = expression();
     }
-    
+
 return s;
 assert(false);
 }
 
 
 QCString VhdlParser::file_open_information() {QCString s,s1,s2;if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case OPEN_T:{if (!hasError) {
-      
+
       jj_consume_token(OPEN_T);
       }
       if (!hasError) {
-      
+
       s = expression();
       }
-      
+
       break;
       }
     default:
@@ -4295,42 +4295,42 @@ QCString VhdlParser::file_open_information() {QCString s,s1,s2;if (!hasError) {
     }
     }
     if (!hasError) {
-    
+
     jj_consume_token(IS_T);
     }
     if (!hasError) {
-    
+
     s1 = file_logical_name();
     }
-    
+
 s2="open "+s+" is "+s1;  return s2;
 assert(false);
 }
 
 
 QCString VhdlParser::file_type_definition() {QCString s,s1;if (!hasError) {
-    
+
     jj_consume_token(FILE_T);
     }
     if (!hasError) {
-    
+
     jj_consume_token(OF_T);
     }
     if (!hasError) {
-    
+
     s = type_mark();
     }
-    
+
 s1=" file of "+s; return s1;
 assert(false);
 }
 
 
 QCString VhdlParser::floating_type_definition() {QCString s;if (!hasError) {
-    
+
     s = range_constraint();
     }
-    
+
 return s;
 assert(false);
 }
@@ -4342,25 +4342,25 @@ QCString VhdlParser::formal_designator() {QCString s;Token *tok=0;
     case STRINGLITERAL:
     case BASIC_IDENTIFIER:
     case EXTENDED_CHARACTER:{if (!hasError) {
-      
+
       s = name();
       }
       if (!hasError) {
-      
+
 return s;
       }
-      
+
       break;
       }
     case INTEGER:{if (!hasError) {
-      
+
       tok = jj_consume_token(INTEGER);
       }
       if (!hasError) {
-      
+
 return tok->image.c_str();
       }
-      
+
       break;
       }
     default:
@@ -4373,39 +4373,39 @@ assert(false);
 
 
 QCString VhdlParser::formal_parameter_list() {QCString s;if (!hasError) {
-    
+
     s = interface_list();
     }
-    
+
 return s;
 assert(false);
 }
 
 
 QCString VhdlParser::formal_part() {QCString s,s1;if (!hasError) {
-    
+
     s = name();
     }
     if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case LPAREN_T:{if (!hasError) {
-      
+
       jj_consume_token(LPAREN_T);
       }
       if (!hasError) {
-      
+
       formal_designator();
       }
       if (!hasError) {
-      
+
       jj_consume_token(RPAREN_T);
       }
       if (!hasError) {
-      
+
 s+"("+s1+")";
       }
-      
+
       break;
       }
     default:
@@ -4413,45 +4413,45 @@ s+"("+s1+")";
       ;
     }
     }
-    
+
 return s;
 assert(false);
 }
 
 
 QCString VhdlParser::full_type_declaration() {Entry *tmpEntry;QCString s,s1,s2;if (!hasError) {
-    
+
     jj_consume_token(TYPE_T);
     }
     if (!hasError) {
-    
+
     s = identifier();
     }
     if (!hasError) {
-    
+
     jj_consume_token(IS_T);
     }
     if (!hasError) {
-    
+
 tmpEntry=current;
   addVhdlType(s.data(),getLine(),Entry::VARIABLE_SEC,VhdlDocGen::RECORD,0,0,Public);
     }
     if (!hasError) {
 
     try {if (!hasError) {
-      
+
       s2 = type_definition();
       }
-      
+
     } catch ( ...) {
 error_skipto(SEMI_T);
     }
     }
     if (!hasError) {
-    
+
     jj_consume_token(SEMI_T);
     }
-    
+
 if (s2.contains("#")) {
         VhdlDocGen::deleteAllChars(s2,'#');
         tmpEntry->spec=VhdlDocGen::RECORD;
@@ -4476,75 +4476,75 @@ assert(false);
 
 
 QCString VhdlParser::function_call() {QCString s,s1;if (!hasError) {
-    
+
     s = name();
     }
     if (!hasError) {
-    
+
     jj_consume_token(LPAREN_T);
     }
     if (!hasError) {
-    
+
     s1 = actual_parameter_part();
     }
     if (!hasError) {
-    
+
     jj_consume_token(RPAREN_T);
     }
-    
+
 return s+"("+s1+")";
 assert(false);
 }
 
 
 void VhdlParser::generate_statement() {QCString s;if (!hasError) {
-    
+
     s = identifier();
     }
     if (!hasError) {
-    
+
     jj_consume_token(COLON_T);
     }
     if (!hasError) {
-    
+
     try {if (!hasError) {
-      
+
       generate_scheme();
       }
       if (!hasError) {
-      
+
       jj_consume_token(GENERATE_T);
       }
       if (!hasError) {
-      
+
 pushLabel(genLabels,s);
       }
       if (!hasError) {
-      
+
       generate_statement_body1();
       }
       if (!hasError) {
-      
+
       jj_consume_token(END_T);
       }
-      
+
     } catch ( ...) {
 error_skipto(GENERATE_T);
     }
     }
     if (!hasError) {
-    
+
     jj_consume_token(GENERATE_T);
     }
     if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case BASIC_IDENTIFIER:
     case EXTENDED_CHARACTER:{if (!hasError) {
-      
+
       identifier();
       }
-      
+
       break;
       }
     default:
@@ -4553,10 +4553,10 @@ error_skipto(GENERATE_T);
     }
     }
     if (!hasError) {
-    
+
     jj_consume_token(SEMI_T);
     }
-    
+
 genLabels=popLabel(genLabels);
 }
 
@@ -4564,25 +4564,25 @@ genLabels=popLabel(genLabels);
 void VhdlParser::generate_scheme() {
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case FOR_T:{if (!hasError) {
-      
+
       jj_consume_token(FOR_T);
       }
       if (!hasError) {
-      
+
       parameter_specification();
       }
-      
+
       break;
       }
     case IF_T:{if (!hasError) {
-      
+
       jj_consume_token(IF_T);
       }
       if (!hasError) {
-      
+
       condition();
       }
-      
+
       break;
       }
     default:
@@ -4594,65 +4594,65 @@ void VhdlParser::generate_scheme() {
 
 
 void VhdlParser::generic_clause() {QCString s;if (!hasError) {
-    
+
     jj_consume_token(GENERIC_T);
     }
     if (!hasError) {
-    
+
     jj_consume_token(LPAREN_T);
     }
     if (!hasError) {
-    
+
 parse_sec=GEN_SEC;
     }
     if (!hasError) {
-    
+
     s = generic_list();
     }
     if (!hasError) {
-    
+
     jj_consume_token(RPAREN_T);
     }
     if (!hasError) {
-    
+
     jj_consume_token(SEMI_T);
     }
-    
+
 parse_sec=0;
 }
 
 
 QCString VhdlParser::generic_list() {QCString s;if (!hasError) {
-    
+
     s = interface_list();
     }
-    
+
 return s;
 assert(false);
 }
 
 
 void VhdlParser::generic_map_aspect() {if (!hasError) {
-    
+
     jj_consume_token(GENERIC_T);
     }
     if (!hasError) {
-    
+
     jj_consume_token(MAP_T);
     }
     if (!hasError) {
-    
+
     jj_consume_token(LPAREN_T);
     }
     if (!hasError) {
-    
+
     association_list();
     }
     if (!hasError) {
-    
+
     jj_consume_token(RPAREN_T);
     }
-    
+
 }
 
 
@@ -4662,25 +4662,25 @@ QCString VhdlParser::group_constituent() {QCString s;
     case STRINGLITERAL:
     case BASIC_IDENTIFIER:
     case EXTENDED_CHARACTER:{if (!hasError) {
-      
+
       s = name();
       }
       if (!hasError) {
-      
+
 return s;
       }
-      
+
       break;
       }
     case CHARACTER_LITERAL:{if (!hasError) {
-      
+
       s = character_literal();
       }
       if (!hasError) {
-      
+
 return s;
       }
-      
+
       break;
       }
     default:
@@ -4694,13 +4694,13 @@ assert(false);
 
 QCString VhdlParser::group_constituent_list() {QCString s,s1,s2;if (!hasError) {
     if (!hasError) {
-    
+
     s1 = group_constituent();
     }
-    
+
     }
     if (!hasError) {
-    
+
     while (!hasError) {
       switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
       case COMMA_T:{
@@ -4711,137 +4711,137 @@ QCString VhdlParser::group_constituent_list() {QCString s,s1,s2;if (!hasError) {
         jj_la1[108] = jj_gen;
         goto end_label_21;
       }if (!hasError) {
-      
+
       jj_consume_token(COMMA_T);
       }
       if (!hasError) {
-      
+
       s = group_constituent();
       }
       if (!hasError) {
-      
+
 s2+=",";s2+=s1;
       }
-      
+
     }
     end_label_21: ;
     }
-    
+
 return s+s2;
 assert(false);
 }
 
 
 QCString VhdlParser::group_declaration() {QCString s,s1,s2;if (!hasError) {
-    
+
     jj_consume_token(GROUP_T);
     }
     if (!hasError) {
-    
+
     s = identifier();
     }
     if (!hasError) {
-    
+
     jj_consume_token(COLON_T);
     }
     if (!hasError) {
-    
+
     s1 = identifier();
     }
     if (!hasError) {
-    
+
     jj_consume_token(LPAREN_T);
     }
     if (!hasError) {
-    
+
     s2 = group_constituent_list();
     }
     if (!hasError) {
-    
+
     jj_consume_token(RPAREN_T);
     }
     if (!hasError) {
-    
+
     jj_consume_token(SEMI_T);
     }
-    
+
 return "group "+s+":"+s1+"("+s2+");";
 assert(false);
 }
 
 
 QCString VhdlParser::group_template_declaration() {QCString s,s1;if (!hasError) {
-    
+
     jj_consume_token(GROUP_T);
     }
     if (!hasError) {
-    
+
     s = identifier();
     }
     if (!hasError) {
-    
+
     jj_consume_token(IS_T);
     }
     if (!hasError) {
-    
+
     jj_consume_token(LPAREN_T);
     }
     if (!hasError) {
-    
+
     s1 = entity_class_entry_list();
     }
     if (!hasError) {
-    
+
     jj_consume_token(RPAREN_T);
     }
     if (!hasError) {
-    
+
     jj_consume_token(SEMI_T);
     }
-    
+
 return "group "+s+ "is ("+s1+");";
 assert(false);
 }
 
 
 void VhdlParser::guarded_signal_specification() {if (!hasError) {
-    
+
     signal_list();
     }
     if (!hasError) {
-    
+
     jj_consume_token(COLON_T);
     }
     if (!hasError) {
-    
+
     type_mark();
     }
-    
+
 }
 
 
 QCString VhdlParser::identifier() {Token *tok=0;
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case EXTENDED_CHARACTER:{if (!hasError) {
-      
+
       tok = jj_consume_token(EXTENDED_CHARACTER);
       }
       if (!hasError) {
-      
+
 return tok->image.c_str();
       }
-      
+
       break;
       }
     case BASIC_IDENTIFIER:{if (!hasError) {
-      
+
       tok = jj_consume_token(BASIC_IDENTIFIER);
       }
       if (!hasError) {
-      
+
 return tok->image.c_str();
       }
-      
+
       break;
       }
     default:
@@ -4854,11 +4854,11 @@ assert(false);
 
 
 QCString VhdlParser::identifier_list() {QCString str,str1;if (!hasError) {
-    
+
     str = identifier();
     }
     if (!hasError) {
-    
+
     while (!hasError) {
       switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
       case COMMA_T:{
@@ -4869,40 +4869,40 @@ QCString VhdlParser::identifier_list() {QCString str,str1;if (!hasError) {
         jj_la1[110] = jj_gen;
         goto end_label_22;
       }if (!hasError) {
-      
+
       jj_consume_token(COMMA_T);
       }
       if (!hasError) {
-      
+
       str1 = identifier();
       }
       if (!hasError) {
-      
+
 str+=",";str+=str1;
       }
-      
+
     }
     end_label_22: ;
     }
-    
+
 return str;
 assert(false);
 }
 
 
 void VhdlParser::if_statement() {QCString s,s1;if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case BASIC_IDENTIFIER:
     case EXTENDED_CHARACTER:{if (!hasError) {
-      
+
       identifier();
       }
       if (!hasError) {
-      
+
       jj_consume_token(COLON_T);
       }
-      
+
       break;
       }
     default:
@@ -4911,28 +4911,28 @@ void VhdlParser::if_statement() {QCString s,s1;if (!hasError) {
     }
     }
     if (!hasError) {
-    
+
     jj_consume_token(IF_T);
     }
     if (!hasError) {
-    
+
     s = condition();
     }
     if (!hasError) {
-    
+
     jj_consume_token(THEN_T);
     }
     if (!hasError) {
-    
+
 s.prepend("if ");
     FlowChart::addFlowChart(FlowChart::IF_NO,0,s);
     }
     if (!hasError) {
-    
+
     sequence_of_statement();
     }
     if (!hasError) {
-    
+
     while (!hasError) {
       switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
       case ELSIF_T:{
@@ -4943,46 +4943,46 @@ s.prepend("if ");
         jj_la1[112] = jj_gen;
         goto end_label_23;
       }if (!hasError) {
-      
+
       jj_consume_token(ELSIF_T);
       }
       if (!hasError) {
-      
+
       s1 = condition();
       }
       if (!hasError) {
-      
+
       jj_consume_token(THEN_T);
       }
       if (!hasError) {
-      
+
 s1.prepend("elsif ");
            FlowChart::addFlowChart(FlowChart::ELSIF_NO,0,s1.data());
       }
       if (!hasError) {
-      
+
       sequence_of_statement();
       }
-      
+
     }
     end_label_23: ;
     }
     if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case ELSE_T:{if (!hasError) {
-      
+
       jj_consume_token(ELSE_T);
       }
       if (!hasError) {
-      
+
 FlowChart::addFlowChart(FlowChart::ELSE_NO,0,0);
       }
       if (!hasError) {
-      
+
       sequence_of_statement();
       }
-      
+
       break;
       }
     default:
@@ -4991,22 +4991,22 @@ FlowChart::addFlowChart(FlowChart::ELSE_NO,0,0);
     }
     }
     if (!hasError) {
-    
+
     jj_consume_token(END_T);
     }
     if (!hasError) {
-    
+
     jj_consume_token(IF_T);
     }
     if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case BASIC_IDENTIFIER:
     case EXTENDED_CHARACTER:{if (!hasError) {
-      
+
       identifier();
       }
-      
+
       break;
       }
     default:
@@ -5015,47 +5015,47 @@ FlowChart::addFlowChart(FlowChart::ELSE_NO,0,0);
     }
     }
     if (!hasError) {
-    
+
     jj_consume_token(SEMI_T);
     }
-    
+
 FlowChart::moveToPrevLevel();
           FlowChart::addFlowChart(FlowChart::ENDIF_NO,0,0);
 }
 
 
 QCString VhdlParser::incomplete_type_declaration() {QCString s;if (!hasError) {
-    
+
     jj_consume_token(TYPE_T);
     }
     if (!hasError) {
-    
+
     s = identifier();
     }
     if (!hasError) {
-    
+
     jj_consume_token(SEMI_T);
     }
-    
+
 return "type "+s+";";
 assert(false);
 }
 
 
 QCString VhdlParser::index_constraint() {QCString s="("; QCString s1,s2;if (!hasError) {
-    
+
     jj_consume_token(LPAREN_T);
     }
     if (!hasError) {
-    
+
     s2 = discrete_range();
     }
     if (!hasError) {
-    
+
 s+=s2;
     }
     if (!hasError) {
-    
+
     while (!hasError) {
       switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
       case COMMA_T:{
@@ -5066,26 +5066,26 @@ s+=s2;
         jj_la1[115] = jj_gen;
         goto end_label_24;
       }if (!hasError) {
-      
+
       jj_consume_token(COMMA_T);
       }
       if (!hasError) {
-      
+
       s1 = discrete_range();
       }
       if (!hasError) {
-      
+
 s+=",";s+=s1;
       }
-      
+
     }
     end_label_24: ;
     }
     if (!hasError) {
-    
+
     jj_consume_token(RPAREN_T);
     }
-    
+
 return s+")";
 assert(false);
 }
@@ -5093,14 +5093,14 @@ assert(false);
 
 QCString VhdlParser::index_specification() {QCString s;
     if (jj_2_37(2147483647)) {if (!hasError) {
-      
+
       s = discrete_range();
       }
       if (!hasError) {
-      
+
 return s;
       }
-      
+
     } else {
       switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
       case ABS_T:
@@ -5119,14 +5119,14 @@ return s;
       case DECIMAL_LITERAL:
       case BASED_LITERAL:
       case BIT_STRING_LITERAL:{if (!hasError) {
-        
+
         s = expression();
         }
         if (!hasError) {
-        
+
 return s;
         }
-        
+
         break;
         }
       default:
@@ -5140,18 +5140,18 @@ assert(false);
 
 
 QCString VhdlParser::index_subtype_definition() {QCString s;if (!hasError) {
-    
+
     s = type_mark();
     }
     if (!hasError) {
-    
+
     jj_consume_token(RANGE_T);
     }
     if (!hasError) {
-    
+
     jj_consume_token(BOX_T);
     }
-    
+
 return s+" range <> ";
 assert(false);
 }
@@ -5162,13 +5162,13 @@ QCString VhdlParser::instantiation_unit() {QCString s,s1,s2;Token *tok;
     case COMPONENT_T:
     case BASIC_IDENTIFIER:
     case EXTENDED_CHARACTER:{if (!hasError) {
-      
+
       switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
       case COMPONENT_T:{if (!hasError) {
-        
+
         jj_consume_token(COMPONENT_T);
         }
-        
+
         break;
         }
       default:
@@ -5177,63 +5177,63 @@ QCString VhdlParser::instantiation_unit() {QCString s,s1,s2;Token *tok;
       }
       }
       if (!hasError) {
-      
+
       s = identifier();
       }
       if (!hasError) {
-      
+
 s1="component "; return s;
       }
-      
+
       break;
       }
     case ENTITY_T:{if (!hasError) {
-      
+
       jj_consume_token(ENTITY_T);
       }
       if (!hasError) {
-      
+
       if (jj_2_38(2)) {if (!hasError) {
-        
+
         jj_consume_token(BASIC_IDENTIFIER);
         }
         if (!hasError) {
-        
+
         jj_consume_token(DOT_T);
         }
-        
+
       } else {
         ;
       }
       }
       if (!hasError) {
-      
+
       s2 = name();
       }
       if (!hasError) {
-      
+
 s="entity|"+s2;
       }
       if (!hasError) {
-      
+
       switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
       case LPAREN_T:{if (!hasError) {
-        
+
         jj_consume_token(LPAREN_T);
         }
         if (!hasError) {
-        
+
         s1 = identifier();
         }
         if (!hasError) {
-        
+
         jj_consume_token(RPAREN_T);
         }
         if (!hasError) {
-        
+
 s+="(";s+=s1;s+=")" ;
         }
-        
+
         break;
         }
       default:
@@ -5242,25 +5242,25 @@ s+="(";s+=s1;s+=")" ;
       }
       }
       if (!hasError) {
-      
+
 return s;
       }
-      
+
       break;
       }
     case CONFIGURATION_T:{if (!hasError) {
-      
+
       jj_consume_token(CONFIGURATION_T);
       }
       if (!hasError) {
-      
+
       s = name();
       }
       if (!hasError) {
-      
+
 s1="configuration ";return s;
       }
-      
+
       break;
       }
     default:
@@ -5276,36 +5276,36 @@ QCString VhdlParser::instantiation_list() {QCString s;Token *tok=0;
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case BASIC_IDENTIFIER:
     case EXTENDED_CHARACTER:{if (!hasError) {
-      
+
       s = identifier_list();
       }
       if (!hasError) {
-      
+
 return s;
       }
-      
+
       break;
       }
     case OTHER_T:{if (!hasError) {
-      
+
       tok = jj_consume_token(OTHER_T);
       }
       if (!hasError) {
-      
+
 return tok->image.c_str();
       }
-      
+
       break;
       }
     case ALL_T:{if (!hasError) {
-      
+
       tok = jj_consume_token(ALL_T);
       }
       if (!hasError) {
-      
+
 return tok->image.c_str();
       }
-      
+
       break;
       }
     default:
@@ -5318,20 +5318,20 @@ assert(false);
 
 
 QCString VhdlParser::integer() {Token *t;if (!hasError) {
-    
+
     t = jj_consume_token(INTEGER);
     }
-    
+
 return t->image.c_str();
 assert(false);
 }
 
 
 QCString VhdlParser::integer_type_definition() {QCString s;if (!hasError) {
-    
+
     s = range_constraint();
     }
-    
+
 return s;
 assert(false);
 }
@@ -5339,56 +5339,56 @@ assert(false);
 
 QCString VhdlParser::interface_declaration() {QCString s,s1;
     if (jj_2_39(5)) {if (!hasError) {
-      
+
       s = interface_subprogram_declaration();
       }
       if (!hasError) {
-      
+
 return s;
       }
-      
+
     } else {
       switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
       case PACKAGE_T:{if (!hasError) {
-        
+
         interface_package_declaration();
         }
         if (!hasError) {
-        
+
 return s;
         }
-        
+
         break;
         }
       default:
         jj_la1[121] = jj_gen;
         if (jj_2_40(5)) {if (!hasError) {
-          
+
           s = interface_variable_declaration();
           }
           if (!hasError) {
-          
+
 return s;
           }
-          
+
         } else if (jj_2_41(5)) {if (!hasError) {
-          
+
           interface_file_declaration();
           }
           if (!hasError) {
-          
+
 return s;
           }
-          
+
         } else if (jj_2_42(2147483647)) {if (!hasError) {
-          
+
           subprogram_declaration();
           }
           if (!hasError) {
-          
+
 return s;
           }
-          
+
         } else {
           switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
           case CONSTANT_T:
@@ -5397,21 +5397,21 @@ return s;
           case SHARED_T:
           case TYPE_T:
           case VARIABLE_T:{if (!hasError) {
-            
+
             s = object_class();
             }
             if (!hasError) {
-            
+
             s1 = identifier();
             }
             if (!hasError) {
-            
+
 if (parse_sec==GEN_SEC)
 
     addVhdlType(s.data(),getLine(),Entry::VARIABLE_SEC,currP,s1.data(),0,Public);
     return s;
             }
-            
+
             break;
             }
           default:
@@ -5427,32 +5427,32 @@ assert(false);
 
 
 QCString VhdlParser::interface_element() {QCString s;if (!hasError) {
-    
+
     s = interface_declaration();
     }
-    
+
 return s;
 assert(false);
 }
 
 
 QCString VhdlParser::interface_file_declaration() {QCString s,s1;if (!hasError) {
-    
+
     jj_consume_token(FILE_T);
     }
     if (!hasError) {
-    
+
     s = identifier_list();
     }
     if (!hasError) {
-    
+
     jj_consume_token(COLON_T);
     }
     if (!hasError) {
-    
+
     s1 = subtype_indication();
     }
-    
+
 addVhdlType(s.data(),getLine(),Entry::VARIABLE_SEC,VhdlDocGen::VFILE,0,s1.data(),Public);
    return " file "+s+":"+s1;
 assert(false);
@@ -5460,11 +5460,11 @@ assert(false);
 
 
 QCString VhdlParser::interface_list() {QCString s,s1,s2;if (!hasError) {
-    
+
     s = interface_element();
     }
     if (!hasError) {
-    
+
     while (!hasError) {
       switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
       case SEMI_T:{
@@ -5475,62 +5475,62 @@ QCString VhdlParser::interface_list() {QCString s,s1,s2;if (!hasError) {
         jj_la1[123] = jj_gen;
         goto end_label_25;
       }if (!hasError) {
-      
+
       jj_consume_token(SEMI_T);
       }
       if (!hasError) {
-      
+
       s1 = interface_element();
       }
       if (!hasError) {
-      
+
 s2+=";";s2+=s1;
       }
-      
+
     }
     end_label_25: ;
     }
-    
+
 return s+s2;
 assert(false);
 }
 
 
 QCString VhdlParser::interface_variable_declaration() {Token *tok=0;Token *tok1=0;Token *tok2=0;QCString s,s1,s2,s3,s4,s5;if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case CONSTANT_T:
     case SIGNAL_T:
     case SHARED_T:
     case VARIABLE_T:{if (!hasError) {
-      
+
       switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
       case VARIABLE_T:{if (!hasError) {
-        
+
         tok = jj_consume_token(VARIABLE_T);
         }
-        
+
         break;
         }
       case SIGNAL_T:{if (!hasError) {
-        
+
         tok = jj_consume_token(SIGNAL_T);
         }
-        
+
         break;
         }
       case CONSTANT_T:{if (!hasError) {
-        
+
         tok = jj_consume_token(CONSTANT_T);
         }
-        
+
         break;
         }
       case SHARED_T:{if (!hasError) {
-        
+
         tok = jj_consume_token(SHARED_T);
         }
-        
+
         break;
         }
       default:
@@ -5539,7 +5539,7 @@ QCString VhdlParser::interface_variable_declaration() {Token *tok=0;Token *tok1=
         errorHandler->handleParseError(token, getToken(1), __FUNCTION__, this), hasError = true;
       }
       }
-      
+
       break;
       }
     default:
@@ -5548,25 +5548,25 @@ QCString VhdlParser::interface_variable_declaration() {Token *tok=0;Token *tok1=
     }
     }
     if (!hasError) {
-    
+
     s = identifier_list();
     }
     if (!hasError) {
-    
+
     jj_consume_token(COLON_T);
     }
     if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case BUFFER_T:
     case IN_T:
     case INOUT_T:
     case LINKAGE_T:
     case OUT_T:{if (!hasError) {
-      
+
       s1 = mode();
       }
-      
+
       break;
       }
     default:
@@ -5575,17 +5575,17 @@ QCString VhdlParser::interface_variable_declaration() {Token *tok=0;Token *tok1=
     }
     }
     if (!hasError) {
-    
+
     s2 = subtype_indication();
     }
     if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case BUS_T:{if (!hasError) {
-      
+
       tok1 = jj_consume_token(BUS_T);
       }
-      
+
       break;
       }
     default:
@@ -5594,17 +5594,17 @@ QCString VhdlParser::interface_variable_declaration() {Token *tok=0;Token *tok1=
     }
     }
     if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case VARASSIGN_T:{if (!hasError) {
-      
+
       tok2 = jj_consume_token(VARASSIGN_T);
       }
       if (!hasError) {
-      
+
       s4 = expression();
       }
-      
+
       break;
       }
     default:
@@ -5612,7 +5612,7 @@ QCString VhdlParser::interface_variable_declaration() {Token *tok=0;Token *tok1=
       ;
     }
     }
-    
+
 if(tok)
                     s5=tok->image.c_str();
 
@@ -5647,39 +5647,39 @@ assert(false);
 QCString VhdlParser::iteration_scheme() {QCString s;
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case WHILE_T:{if (!hasError) {
-      
+
       jj_consume_token(WHILE_T);
       }
       if (!hasError) {
-      
+
       s = condition();
       }
       if (!hasError) {
-      
+
 s.prepend("while ");
    FlowChart::addFlowChart(FlowChart::WHILE_NO,0,s.data(),lab.data());
    lab="";
   return s;
       }
-      
+
       break;
       }
     case FOR_T:{if (!hasError) {
-      
+
       jj_consume_token(FOR_T);
       }
       if (!hasError) {
-      
+
       s = parameter_specification();
       }
       if (!hasError) {
-      
+
 QCString q=lab+" for "+s;
     FlowChart::addFlowChart(FlowChart::FOR_NO,0,q.data(),lab.data());
     lab="";
     return q;
       }
-      
+
       break;
       }
     default:
@@ -5692,10 +5692,10 @@ assert(false);
 
 
 QCString VhdlParser::label() {QCString s;if (!hasError) {
-    
+
     s = identifier();
     }
-    
+
 return s;
 assert(false);
 }
@@ -5703,20 +5703,20 @@ assert(false);
 
 QCString VhdlParser::library_clause() {QCString s;if (!hasError) {
     if (!hasError) {
-    
+
     jj_consume_token(LIBRARY_T);
     }
     if (!hasError) {
-    
+
     s = identifier_list();
     }
     if (!hasError) {
-    
+
     jj_consume_token(SEMI_T);
     }
-    
+
     }
-    
+
 if ( parse_sec==0 && Config_getBool(SHOW_INCLUDE_FILES) )
                    {
                            addVhdlType(s.data(),getLine(),Entry::VARIABLE_SEC,VhdlDocGen::LIBRARY,s.data(),"_library_",Public);
@@ -5729,33 +5729,33 @@ assert(false);
 
 QCString VhdlParser::library_unit() {QCString s;
     if (jj_2_43(2)) {if (!hasError) {
-      
+
       primary_unit();
       }
       if (!hasError) {
-      
+
 return s;
       }
-      
+
     } else {
       switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
       case ARCHITECTURE_T:
       case PACKAGE_T:{if (!hasError) {
-        
+
         secondary_unit();
         }
         if (!hasError) {
-        
+
 return s;
         }
-        
+
         break;
         }
       case CONTEXT_T:{if (!hasError) {
-        
+
         context_declaration();
         }
-        
+
         break;
         }
       default:
@@ -5770,54 +5770,54 @@ assert(false);
 
 QCString VhdlParser::literal() {QCString s;
     if (jj_2_44(2147483647)) {if (!hasError) {
-      
+
       s = bit_string_literal();
       }
       if (!hasError) {
-      
+
 return s;
       }
-      
+
     } else if (jj_2_45(2147483647)) {if (!hasError) {
-      
+
       s = numeric_literal();
       }
       if (!hasError) {
-      
+
 return s;
       }
-      
+
     } else if (jj_2_46(2147483647)) {if (!hasError) {
-      
+
       s = enumeration_literal();
       }
       if (!hasError) {
-      
+
 return s;
       }
-      
+
     } else {
       switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
       case STRINGLITERAL:{if (!hasError) {
-        
+
         s = string_literal();
         }
         if (!hasError) {
-        
+
 return s;
         }
-        
+
         break;
         }
       case NULL_T:{if (!hasError) {
-        
+
         jj_consume_token(NULL_T);
         }
         if (!hasError) {
-        
+
 return "null";
         }
-        
+
         break;
         }
       default:
@@ -5831,32 +5831,32 @@ assert(false);
 
 
 QCString VhdlParser::logical_operator() {QCString s;if (!hasError) {
-    
+
     s = logop();
     }
-    
+
 return s;
 assert(false);
 }
 
 
 QCString VhdlParser::loop_statement() {QCString s,s1,s2,s3;if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case BASIC_IDENTIFIER:
     case EXTENDED_CHARACTER:{if (!hasError) {
-      
+
       s = identifier();
       }
       if (!hasError) {
-      
+
       jj_consume_token(COLON_T);
       }
       if (!hasError) {
-      
+
 s+=":";
       }
-      
+
       break;
       }
     default:
@@ -5865,14 +5865,14 @@ s+=":";
     }
     }
     if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case FOR_T:
     case WHILE_T:{if (!hasError) {
-      
+
       s1 = iteration_scheme();
       }
-      
+
       break;
       }
     default:
@@ -5881,35 +5881,35 @@ s+=":";
     }
     }
     if (!hasError) {
-    
+
 if(s1.isEmpty())
         FlowChart::addFlowChart(FlowChart::LOOP_NO,0,"infinite");
     }
     if (!hasError) {
-    
+
     jj_consume_token(LOOP_T);
     }
     if (!hasError) {
-    
+
     s2 = sequence_of_statement();
     }
     if (!hasError) {
-    
+
     jj_consume_token(END_T);
     }
     if (!hasError) {
-    
+
     jj_consume_token(LOOP_T);
     }
     if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case BASIC_IDENTIFIER:
     case EXTENDED_CHARACTER:{if (!hasError) {
-      
+
       s3 = identifier();
       }
-      
+
       break;
       }
     default:
@@ -5918,10 +5918,10 @@ if(s1.isEmpty())
     }
     }
     if (!hasError) {
-    
+
     jj_consume_token(SEMI_T);
     }
-    
+
 QCString q = s+" loop "+s2+" end loop" +s3;
          QCString endLoop="end loop" + s3;
          FlowChart::moveToPrevLevel();
@@ -5934,36 +5934,36 @@ assert(false);
 QCString VhdlParser::miscellaneous_operator() {Token *t=0;
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case DOUBLEMULT_T:{if (!hasError) {
-      
+
       jj_consume_token(DOUBLEMULT_T);
       }
       if (!hasError) {
-      
+
 return "**";
       }
-      
+
       break;
       }
     case ABS_T:{if (!hasError) {
-      
+
       jj_consume_token(ABS_T);
       }
       if (!hasError) {
-      
+
 return "abs";
       }
-      
+
       break;
       }
     case NOT_T:{if (!hasError) {
-      
+
       jj_consume_token(NOT_T);
       }
       if (!hasError) {
-      
+
 return "not";
       }
-      
+
       break;
       }
     default:
@@ -5978,58 +5978,58 @@ assert(false);
 QCString VhdlParser::mode() {Token *tok=0;
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case IN_T:{if (!hasError) {
-      
+
       tok = jj_consume_token(IN_T);
       }
       if (!hasError) {
-      
+
 return "in";
       }
-      
+
       break;
       }
     case OUT_T:{if (!hasError) {
-      
+
       tok = jj_consume_token(OUT_T);
       }
       if (!hasError) {
-      
+
 return "out";
       }
-      
+
       break;
       }
     case INOUT_T:{if (!hasError) {
-      
+
       tok = jj_consume_token(INOUT_T);
       }
       if (!hasError) {
-      
+
 return "inout";
       }
-      
+
       break;
       }
     case BUFFER_T:{if (!hasError) {
-      
+
       tok = jj_consume_token(BUFFER_T);
       }
       if (!hasError) {
-      
+
 return "buffer";
       }
-      
+
       break;
       }
     case LINKAGE_T:{if (!hasError) {
-      
+
       tok = jj_consume_token(LINKAGE_T);
       }
       if (!hasError) {
-      
+
 return "linkage";
       }
-      
+
       break;
       }
     default:
@@ -6044,47 +6044,47 @@ assert(false);
 QCString VhdlParser::multiplying_operation() {Token *tok=0;
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case MULT_T:{if (!hasError) {
-      
+
       tok = jj_consume_token(MULT_T);
       }
       if (!hasError) {
-      
+
 return tok->image.c_str();
       }
-      
+
       break;
       }
     case SLASH_T:{if (!hasError) {
-      
+
       tok = jj_consume_token(SLASH_T);
       }
       if (!hasError) {
-      
+
 return tok->image.c_str();
       }
-      
+
       break;
       }
     case MOD_T:{if (!hasError) {
-      
+
       tok = jj_consume_token(MOD_T);
       }
       if (!hasError) {
-      
+
 return tok->image.c_str();
       }
-      
+
       break;
       }
     case REM_T:{if (!hasError) {
-      
+
       tok = jj_consume_token(REM_T);
       }
       if (!hasError) {
-      
+
 return tok->image.c_str();
       }
-      
+
       break;
       }
     default:
@@ -6097,28 +6097,28 @@ assert(false);
 
 
 QCString VhdlParser::name() {QCString s,s1;if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case STRINGLITERAL:{if (!hasError) {
-      
+
       s = operator_symbol();
       }
-      
+
       break;
       }
     case BASIC_IDENTIFIER:
     case EXTENDED_CHARACTER:{if (!hasError) {
-      
+
       s = identifier();
       }
-      
+
       break;
       }
     case SLSL_T:{if (!hasError) {
-      
+
       s = external_name();
       }
-      
+
       break;
       }
     default:
@@ -6128,110 +6128,110 @@ QCString VhdlParser::name() {QCString s,s1;if (!hasError) {
     }
     }
     if (!hasError) {
-    
+
     if (jj_2_47(2147483647)) {if (!hasError) {
-      
+
       s1 = name_ext1();
       }
       if (!hasError) {
-      
+
 s+=s1;
       }
-      
+
     } else {
       ;
     }
     }
-    
+
 return s;
 assert(false);
 }
 
 
 QCString VhdlParser::name_ext1() {QCString s,s1,s2;if (!hasError) {
-    
+
     s = name_ext();
     }
     if (!hasError) {
-    
+
     while (!hasError) {
       if (jj_2_48(2147483647)) {
         ;
       } else {
         goto end_label_26;
       }if (!hasError) {
-      
+
       s1 = name_ext();
       }
       if (!hasError) {
-      
+
 s+=s1;
       }
-      
+
     }
     end_label_26: ;
     }
-    
+
 return s;
 assert(false);
 }
 
 
 QCString VhdlParser::name_ext() {QCString s,s1,s2;if (!hasError) {
-    
+
     if (jj_2_49(2147483647)) {if (!hasError) {
-      
+
       jj_consume_token(DOT_T);
       }
       if (!hasError) {
-      
+
       s1 = suffix();
       }
       if (!hasError) {
-      
+
 s+=".";s+=s1;
       }
-      
+
     } else if (jj_2_50(2147483647)) {if (!hasError) {
-      
+
       s1 = test_att_name();
       }
       if (!hasError) {
-      
+
 s+=s1;
       }
-      
+
     } else if (jj_2_51(2147483647)) {if (!hasError) {
-      
+
       jj_consume_token(LPAREN_T);
       }
       if (!hasError) {
-      
+
       s1 = discrete_range();
       }
       if (!hasError) {
-      
+
       jj_consume_token(RPAREN_T);
       }
       if (!hasError) {
-      
+
 s+="(";s+=s1;s+=")";
       }
-      
+
     } else if (jj_2_52(2147483647)) {if (!hasError) {
-      
+
       jj_consume_token(LPAREN_T);
       }
       if (!hasError) {
-      
+
       s1 = expression();
       }
       if (!hasError) {
-      
+
 s+="(";s+=s1;
       }
       if (!hasError) {
-      
+
       while (!hasError) {
         switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
         case COMMA_T:{
@@ -6242,88 +6242,88 @@ s+="(";s+=s1;
           jj_la1[139] = jj_gen;
           goto end_label_27;
         }if (!hasError) {
-        
+
         jj_consume_token(COMMA_T);
         }
         if (!hasError) {
-        
+
         s1 = expression();
         }
         if (!hasError) {
-        
+
 s+=",";s+=s1;
         }
-        
+
       }
       end_label_27: ;
       }
       if (!hasError) {
-      
+
       jj_consume_token(RPAREN_T);
       }
       if (!hasError) {
-      
+
 s+=")";
       }
-      
+
     } else {
       jj_consume_token(-1);
       errorHandler->handleParseError(token, getToken(1), __FUNCTION__, this), hasError = true;
     }
     }
-    
+
 return s;
 assert(false);
 }
 
 
 QCString VhdlParser::test_att_name() {QCString s,s1;if (!hasError) {
-    
+
     if (jj_2_53(2147483647)) {if (!hasError) {
-      
+
       s1 = signature();
       }
       if (!hasError) {
-      
+
 s=s1;
       }
-      
+
     } else {
       ;
     }
     }
     if (!hasError) {
-    
+
     jj_consume_token(APOSTROPHE_T);
     }
     if (!hasError) {
-    
+
     s1 = attribute_designator();
     }
     if (!hasError) {
-    
+
 s+="'";s+=s1;
     }
     if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case LPAREN_T:{if (!hasError) {
-      
+
       jj_consume_token(LPAREN_T);
       }
       if (!hasError) {
-      
+
       s1 = expression();
       }
       if (!hasError) {
-      
+
       jj_consume_token(RPAREN_T);
       }
       if (!hasError) {
-      
+
 s+="(";s+=s1;s+=")";
       }
-      
+
       break;
       }
     default:
@@ -6331,30 +6331,30 @@ s+="(";s+=s1;s+=")";
       ;
     }
     }
-    
+
 return s;
 assert(false);
 }
 
 
 QCString VhdlParser::indexed_name() {QCString s,s1,s2;if (!hasError) {
-    
+
     s2 = identifier();
     }
     if (!hasError) {
-    
+
     jj_consume_token(LPAREN_T);
     }
     if (!hasError) {
-    
+
     s1 = expression();
     }
     if (!hasError) {
-    
+
 s=s2+"("+s1;
     }
     if (!hasError) {
-    
+
     while (!hasError) {
       switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
       case COMMA_T:{
@@ -6365,44 +6365,44 @@ s=s2+"("+s1;
         jj_la1[141] = jj_gen;
         goto end_label_28;
       }if (!hasError) {
-      
+
       jj_consume_token(COMMA_T);
       }
       if (!hasError) {
-      
+
       s1 = expression();
       }
       if (!hasError) {
-      
+
 s+=",";s+=s1;
       }
-      
+
     }
     end_label_28: ;
     }
     if (!hasError) {
-    
+
     jj_consume_token(RPAREN_T);
     }
-    
+
 return s+")";
 assert(false);
 }
 
 
 QCString VhdlParser::next_statement() {QCString s,s1,s2;Token *t=0;Token *t1=0;if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case BASIC_IDENTIFIER:
     case EXTENDED_CHARACTER:{if (!hasError) {
-      
+
       s = identifier();
       }
       if (!hasError) {
-      
+
       t = jj_consume_token(COLON_T);
       }
-      
+
       break;
       }
     default:
@@ -6411,18 +6411,18 @@ QCString VhdlParser::next_statement() {QCString s,s1,s2;Token *t=0;Token *t1=0;i
     }
     }
     if (!hasError) {
-    
+
     jj_consume_token(NEXT_T);
     }
     if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case BASIC_IDENTIFIER:
     case EXTENDED_CHARACTER:{if (!hasError) {
-      
+
       s1 = identifier();
       }
-      
+
       break;
       }
     default:
@@ -6431,17 +6431,17 @@ QCString VhdlParser::next_statement() {QCString s,s1,s2;Token *t=0;Token *t1=0;i
     }
     }
     if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case WHEN_T:{if (!hasError) {
-      
+
       t1 = jj_consume_token(WHEN_T);
       }
       if (!hasError) {
-      
+
       s2 = condition();
       }
-      
+
       break;
       }
     default:
@@ -6450,10 +6450,10 @@ QCString VhdlParser::next_statement() {QCString s,s1,s2;Token *t=0;Token *t1=0;i
     }
     }
     if (!hasError) {
-    
+
     jj_consume_token(SEMI_T);
     }
-    
+
 if(t) s+=":";
    FlowChart::addFlowChart(FlowChart::NEXT_NO,"next ",s2.data(),s1.data());
     lab.resize(0);
@@ -6464,22 +6464,22 @@ assert(false);
 
 
 QCString VhdlParser::null_statement() {QCString s;if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case BASIC_IDENTIFIER:
     case EXTENDED_CHARACTER:{if (!hasError) {
-      
+
       s = identifier();
       }
       if (!hasError) {
-      
+
       jj_consume_token(COLON_T);
       }
       if (!hasError) {
-      
+
 s+=":";
       }
-      
+
       break;
       }
     default:
@@ -6488,14 +6488,14 @@ s+=":";
     }
     }
     if (!hasError) {
-    
+
     jj_consume_token(NULL_T);
     }
     if (!hasError) {
-    
+
     jj_consume_token(SEMI_T);
     }
-    
+
 return s+="null";
 assert(false);
 }
@@ -6503,27 +6503,27 @@ assert(false);
 
 QCString VhdlParser::numeric_literal() {QCString s;
     if (jj_2_54(2147483647)) {if (!hasError) {
-      
+
       s = physical_literal();
       }
       if (!hasError) {
-      
+
 return s;
       }
-      
+
     } else {
       switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
       case INTEGER:
       case DECIMAL_LITERAL:
       case BASED_LITERAL:{if (!hasError) {
-        
+
         s = abstract_literal();
         }
         if (!hasError) {
-        
+
 return s;
         }
-        
+
         break;
         }
       default:
@@ -6539,73 +6539,73 @@ assert(false);
 QCString VhdlParser::object_class() {
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case CONSTANT_T:{if (!hasError) {
-      
+
       jj_consume_token(CONSTANT_T);
       }
       if (!hasError) {
-      
+
 return "constant";
       }
-      
+
       break;
       }
     case SIGNAL_T:{if (!hasError) {
-      
+
       jj_consume_token(SIGNAL_T);
       }
       if (!hasError) {
-      
+
 return "signal";
       }
-      
+
       break;
       }
     case VARIABLE_T:{if (!hasError) {
-      
+
       jj_consume_token(VARIABLE_T);
       }
       if (!hasError) {
-      
+
 return "variable";
       }
-      
+
       break;
       }
     case SHARED_T:{if (!hasError) {
-      
+
       jj_consume_token(SHARED_T);
       }
       if (!hasError) {
-      
+
       jj_consume_token(VARIABLE_T);
       }
       if (!hasError) {
-      
+
 return "shared variable";
       }
-      
+
       break;
       }
     case FILE_T:{if (!hasError) {
-      
+
       jj_consume_token(FILE_T);
       }
       if (!hasError) {
-      
+
 return "file";
       }
-      
+
       break;
       }
     case TYPE_T:{if (!hasError) {
-      
+
       jj_consume_token(TYPE_T);
       }
       if (!hasError) {
-      
+
 return "type";
       }
-      
+
       break;
       }
     default:
@@ -6618,23 +6618,23 @@ assert(false);
 
 
 QCString VhdlParser::operator_symbol() {Token *tok=0;if (!hasError) {
-    
+
     tok = jj_consume_token(STRINGLITERAL);
     }
-    
+
 return tok->image.c_str();
 assert(false);
 }
 
 
 void VhdlParser::options() {if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case GUARDED_T:{if (!hasError) {
-      
+
       jj_consume_token(GUARDED_T);
       }
-      
+
       break;
       }
     default:
@@ -6643,15 +6643,15 @@ void VhdlParser::options() {if (!hasError) {
     }
     }
     if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case INERTIAL_T:
     case REJECT_T:
     case TRANSPORT_T:{if (!hasError) {
-      
+
       delay_mechanism();
       }
-      
+
       break;
       }
     default:
@@ -6659,52 +6659,52 @@ void VhdlParser::options() {if (!hasError) {
       ;
     }
     }
-    
+
 }
 
 
 void VhdlParser::package_body() {QCString s;if (!hasError) {
-    
+
     jj_consume_token(PACKAGE_T);
     }
     if (!hasError) {
-    
+
     jj_consume_token(BODY_T);
     }
     if (!hasError) {
-    
+
     s = name();
     }
     if (!hasError) {
-    
+
     jj_consume_token(IS_T);
     }
     if (!hasError) {
-    
+
 lastCompound=current;
                         s.prepend("_");
                         addVhdlType(s,getLine(),Entry::CLASS_SEC,VhdlDocGen::PACKAGE_BODY,0,0,Protected);
     }
     if (!hasError) {
-    
+
     package_body_declarative_part();
     }
     if (!hasError) {
-    
+
     jj_consume_token(END_T);
     }
     if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case PACKAGE_T:{if (!hasError) {
-      
+
       jj_consume_token(PACKAGE_T);
       }
       if (!hasError) {
-      
+
       jj_consume_token(BODY_T);
       }
-      
+
       break;
       }
     default:
@@ -6713,16 +6713,16 @@ lastCompound=current;
     }
     }
     if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case SLSL_T:
     case STRINGLITERAL:
     case BASIC_IDENTIFIER:
     case EXTENDED_CHARACTER:{if (!hasError) {
-      
+
       name();
       }
-      
+
       break;
       }
     default:
@@ -6731,10 +6731,10 @@ lastCompound=current;
     }
     }
     if (!hasError) {
-    
+
     jj_consume_token(SEMI_T);
     }
-    
+
 lastCompound=0; genLabels.resize(0);
 }
 
@@ -6745,76 +6745,76 @@ void VhdlParser::package_body_declarative_item() {
     case IMPURE_T:
     case PROCEDURE_T:
     case PURE_T:{if (!hasError) {
-      
+
       subprogram_declaration();
       }
-      
+
       break;
       }
     case TYPE_T:{if (!hasError) {
-      
+
       type_declaration();
       }
-      
+
       break;
       }
     case SUBTYPE_T:{if (!hasError) {
-      
+
       subtype_declaration();
       }
-      
+
       break;
       }
     case CONSTANT_T:{if (!hasError) {
-      
+
       constant_declaration();
       }
-      
+
       break;
       }
     case SHARED_T:
     case VARIABLE_T:{if (!hasError) {
-      
+
       variable_declaration();
       }
-      
+
       break;
       }
     case FILE_T:{if (!hasError) {
-      
+
       file_declaration();
       }
-      
+
       break;
       }
     case ALIAS_T:{if (!hasError) {
-      
+
       alias_declaration();
       }
-      
+
       break;
       }
     case USE_T:{if (!hasError) {
-      
+
       use_clause();
       }
-      
+
       break;
       }
     default:
       jj_la1[152] = jj_gen;
       if (jj_2_55(3)) {if (!hasError) {
-        
+
         group_template_declaration();
         }
-        
+
       } else {
         switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
         case GROUP_T:{if (!hasError) {
-          
+
           group_declaration();
           }
-          
+
           break;
           }
         default:
@@ -6828,7 +6828,7 @@ void VhdlParser::package_body_declarative_item() {
 
 
 void VhdlParser::package_body_declarative_part() {if (!hasError) {
-    
+
     while (!hasError) {
       switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
       case ALIAS_T:
@@ -6851,31 +6851,31 @@ void VhdlParser::package_body_declarative_part() {if (!hasError) {
         jj_la1[154] = jj_gen;
         goto end_label_29;
       }if (!hasError) {
-      
+
       package_body_declarative_item();
       }
-      
+
     }
     end_label_29: ;
     }
-    
+
 }
 
 
 void VhdlParser::package_declaration() {QCString s;if (!hasError) {
-    
+
     jj_consume_token(PACKAGE_T);
     }
     if (!hasError) {
-    
+
     s = identifier();
     }
     if (!hasError) {
-    
+
     jj_consume_token(IS_T);
     }
     if (!hasError) {
-    
+
 lastCompound=current;
                           Entry *clone=new Entry(*current);
                           clone->section=Entry::NAMESPACE_SEC;
@@ -6888,21 +6888,21 @@ lastCompound=current;
                           addVhdlType(s,getLine(PACKAGE_T),Entry::CLASS_SEC,VhdlDocGen::PACKAGE,0,0,Package);
     }
     if (!hasError) {
-    
+
     package_declarative_part();
     }
     if (!hasError) {
-    
+
     jj_consume_token(END_T);
     }
     if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case PACKAGE_T:{if (!hasError) {
-      
+
       jj_consume_token(PACKAGE_T);
       }
-      
+
       break;
       }
     default:
@@ -6911,16 +6911,16 @@ lastCompound=current;
     }
     }
     if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case SLSL_T:
     case STRINGLITERAL:
     case BASIC_IDENTIFIER:
     case EXTENDED_CHARACTER:{if (!hasError) {
-      
+
       name();
       }
-      
+
       break;
       }
     default:
@@ -6929,37 +6929,37 @@ lastCompound=current;
     }
     }
     if (!hasError) {
-    
+
     jj_consume_token(SEMI_T);
     }
-    
+
 lastEntity=0;lastCompound=0; genLabels.resize(0);
 }
 
 
 void VhdlParser::geninter() {if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case GENERIC_T:{if (!hasError) {
-      
+
       gen_interface_list();
       }
       if (!hasError) {
-      
+
       jj_consume_token(SEMI_T);
       }
       if (!hasError) {
-      
+
       switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
       case GENERIC_T:{if (!hasError) {
-        
+
         gen_assoc_list();
         }
         if (!hasError) {
-        
+
         jj_consume_token(SEMI_T);
         }
-        
+
         break;
         }
       default:
@@ -6967,7 +6967,7 @@ void VhdlParser::geninter() {if (!hasError) {
         ;
       }
       }
-      
+
       break;
       }
     default:
@@ -6975,7 +6975,7 @@ void VhdlParser::geninter() {if (!hasError) {
       ;
     }
     }
-    
+
 }
 
 
@@ -6985,129 +6985,129 @@ void VhdlParser::package_declarative_item() {
     case IMPURE_T:
     case PROCEDURE_T:
     case PURE_T:{if (!hasError) {
-      
+
       subprogram_declaration();
       }
-      
+
       break;
       }
     case TYPE_T:{if (!hasError) {
-      
+
       type_declaration();
       }
-      
+
       break;
       }
     case SUBTYPE_T:{if (!hasError) {
-      
+
       subtype_declaration();
       }
-      
+
       break;
       }
     case CONSTANT_T:{if (!hasError) {
-      
+
       constant_declaration();
       }
-      
+
       break;
       }
     case SIGNAL_T:{if (!hasError) {
-      
+
       signal_declaration();
       }
-      
+
       break;
       }
     case SHARED_T:
     case VARIABLE_T:{if (!hasError) {
-      
+
       variable_declaration();
       }
-      
+
       break;
       }
     case FILE_T:{if (!hasError) {
-      
+
       file_declaration();
       }
-      
+
       break;
       }
     case ALIAS_T:{if (!hasError) {
-      
+
       alias_declaration();
       }
-      
+
       break;
       }
     case COMPONENT_T:{if (!hasError) {
-      
+
       component_declaration();
       }
-      
+
       break;
       }
     default:
       jj_la1[159] = jj_gen;
       if (jj_2_56(2147483647)) {if (!hasError) {
-        
+
         attribute_declaration();
         }
-        
+
       } else {
         switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
         case ATTRIBUTE_T:{if (!hasError) {
-          
+
           attribute_specification();
           }
-          
+
           break;
           }
         case DISCONNECT_T:{if (!hasError) {
-          
+
           disconnection_specification();
           }
-          
+
           break;
           }
         case USE_T:{if (!hasError) {
-          
+
           use_clause();
           }
-          
+
           break;
           }
         default:
           jj_la1[160] = jj_gen;
           if (jj_2_57(3)) {if (!hasError) {
-            
+
             group_template_declaration();
             }
-            
+
           } else {
             switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
             case GROUP_T:{if (!hasError) {
-              
+
               group_declaration();
               }
-              
+
               break;
               }
             default:
               jj_la1[161] = jj_gen;
               if (jj_2_58(5)) {if (!hasError) {
-                
+
                 package_instantiation_declaration();
                 }
-                
+
               } else {
                 switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
                 case PACKAGE_T:{if (!hasError) {
-                  
+
                   package_declaration();
                   }
-                  
+
                   break;
                   }
                 default:
@@ -7125,7 +7125,7 @@ void VhdlParser::package_declarative_item() {
 
 
 void VhdlParser::package_declarative_part() {if (!hasError) {
-    
+
     while (!hasError) {
       switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
       case ALIAS_T:
@@ -7153,70 +7153,70 @@ void VhdlParser::package_declarative_part() {if (!hasError) {
         jj_la1[163] = jj_gen;
         goto end_label_30;
       }if (!hasError) {
-      
+
       package_declarative_item();
       }
-      
+
     }
     end_label_30: ;
     }
-    
+
 }
 
 
 QCString VhdlParser::parameter_specification() {QCString s,s1;if (!hasError) {
-    
+
     s = identifier();
     }
     if (!hasError) {
-    
+
     jj_consume_token(IN_T);
     }
     if (!hasError) {
-    
+
     s1 = discrete_range();
     }
-    
+
 return s+" in "+s1;
 assert(false);
 }
 
 
 QCString VhdlParser::physical_literal() {QCString s,s1;if (!hasError) {
-    
+
     if (jj_2_59(2147483647)) {if (!hasError) {
-      
+
       s = abstract_literal();
       }
-      
+
     } else {
       ;
     }
     }
     if (!hasError) {
-    
+
     s1 = name();
     }
-    
+
 s+=" ";s+=s1;s.prepend(" "); return s;
 assert(false);
 }
 
 
 QCString VhdlParser::physical_type_definition() {QCString s,s1,s2;if (!hasError) {
-    
+
     jj_consume_token(UNITS_T);
     }
     if (!hasError) {
-    
+
     s = identifier();
     }
     if (!hasError) {
-    
+
     jj_consume_token(SEMI_T);
     }
     if (!hasError) {
-    
+
 addVhdlType(s.data(),getLine(),Entry::VARIABLE_SEC,VhdlDocGen::UNITS,0,0,Public);
     }
     if (!hasError) {
@@ -7232,32 +7232,32 @@ addVhdlType(s.data(),getLine(),Entry::VARIABLE_SEC,VhdlDocGen::UNITS,0,0,Public)
         jj_la1[164] = jj_gen;
         goto end_label_31;
       }if (!hasError) {
-      
+
       s1 = secondary_unit_declaration();
       }
-      
+
     }
     end_label_31: ;
     }
     if (!hasError) {
-    
+
     jj_consume_token(END_T);
     }
     if (!hasError) {
-    
+
     jj_consume_token(UNITS_T);
     }
     if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case SLSL_T:
     case STRINGLITERAL:
     case BASIC_IDENTIFIER:
     case EXTENDED_CHARACTER:{if (!hasError) {
-      
+
       name();
       }
-      
+
       break;
       }
     default:
@@ -7265,156 +7265,156 @@ addVhdlType(s.data(),getLine(),Entry::VARIABLE_SEC,VhdlDocGen::UNITS,0,0,Public)
       ;
     }
     }
-    
+
 return s+"%";
 assert(false);
 }
 
 
 void VhdlParser::port_clause() {if (!hasError) {
-    
+
     jj_consume_token(PORT_T);
     }
     if (!hasError) {
-    
+
     jj_consume_token(LPAREN_T);
     }
     if (!hasError) {
-    
+
     port_list();
     }
     if (!hasError) {
-    
+
     jj_consume_token(RPAREN_T);
     }
     if (!hasError) {
-    
+
     jj_consume_token(SEMI_T);
     }
-    
+
 currP=0;
 }
 
 
 QCString VhdlParser::port_list() {QCString s;if (!hasError) {
-    
+
     s = interface_list();
     }
-    
+
 return s;
 assert(false);
 }
 
 
 void VhdlParser::port_map_aspect() {if (!hasError) {
-    
+
     jj_consume_token(PORT_T);
     }
     if (!hasError) {
-    
+
     jj_consume_token(MAP_T);
     }
     if (!hasError) {
-    
+
     jj_consume_token(LPAREN_T);
     }
     if (!hasError) {
-    
+
     association_list();
     }
     if (!hasError) {
-    
+
     jj_consume_token(RPAREN_T);
     }
-    
+
 }
 
 
 QCString VhdlParser::primary() {QCString s,s1;
     if (jj_2_60(2147483647)) {if (!hasError) {
-      
+
       s = function_call();
       }
       if (!hasError) {
-      
+
 return s;
       }
-      
+
     } else if (jj_2_61(2147483647)) {if (!hasError) {
-      
+
       jj_consume_token(LPAREN_T);
       }
       if (!hasError) {
-      
+
       s1 = expression();
       }
       if (!hasError) {
-      
+
       jj_consume_token(RPAREN_T);
       }
       if (!hasError) {
-      
+
 s="("+s1+")"; return s;
       }
-      
+
     } else if (jj_2_62(2147483647)) {if (!hasError) {
-      
+
       s = qualified_expression();
       }
       if (!hasError) {
-      
+
 return s;
       }
-      
+
     } else if (jj_2_63(2147483647)) {if (!hasError) {
-      
+
       s = type_conversion();
       }
       if (!hasError) {
-      
+
 return s;
       }
-      
+
     } else if (jj_2_64(2147483647)) {if (!hasError) {
-      
+
       s = literal();
       }
       if (!hasError) {
-      
+
 s.prepend(" ");return s;
       }
-      
+
     } else if (jj_2_65(2147483647)) {if (!hasError) {
-      
+
       s = name();
       }
       if (!hasError) {
-      
+
 return s;
       }
-      
+
     } else {
       switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
       case NEW_T:{if (!hasError) {
-        
+
         allocator();
         }
         if (!hasError) {
-        
+
 return "";
         }
-        
+
         break;
         }
       case LPAREN_T:{if (!hasError) {
-        
+
         s = aggregate();
         }
         if (!hasError) {
-        
+
 return s;
         }
-        
+
         break;
         }
       default:
@@ -7430,38 +7430,38 @@ assert(false);
 void VhdlParser::primary_unit() {
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case ENTITY_T:{if (!hasError) {
-      
+
       entity_declaration();
       }
-      
+
       break;
       }
     case CONFIGURATION_T:{if (!hasError) {
-      
+
       configuration_declaration();
       }
-      
+
       break;
       }
     default:
       jj_la1[167] = jj_gen;
       if (jj_2_66(2147483647)) {if (!hasError) {
-        
+
         package_instantiation_declaration();
         }
-        
+
       } else if (jj_2_67(4)) {if (!hasError) {
-        
+
         interface_package_declaration();
         }
-        
+
       } else {
         switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
         case PACKAGE_T:{if (!hasError) {
-          
+
           package_declaration();
           }
-          
+
           break;
           }
         default:
@@ -7475,29 +7475,29 @@ void VhdlParser::primary_unit() {
 
 
 QCString VhdlParser::procedure_call() {QCString s,s1;if (!hasError) {
-    
+
     s = name();
     }
     if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case LPAREN_T:{if (!hasError) {
-      
+
       jj_consume_token(LPAREN_T);
       }
       if (!hasError) {
-      
+
       s1 = actual_parameter_part();
       }
       if (!hasError) {
-      
+
       jj_consume_token(RPAREN_T);
       }
       if (!hasError) {
-      
+
 s1.prepend("("); s1.append(")");
       }
-      
+
       break;
       }
     default:
@@ -7505,40 +7505,40 @@ s1.prepend("("); s1.append(")");
       ;
     }
     }
-    
+
 return s+s1;
 assert(false);
 }
 
 
 QCString VhdlParser::procedure_call_statement() {QCString s,s1;if (!hasError) {
-    
+
     if (jj_2_68(2)) {if (!hasError) {
-      
+
       s = identifier();
       }
       if (!hasError) {
-      
+
       jj_consume_token(COLON_T);
       }
       if (!hasError) {
-      
+
 s+=":";
       }
-      
+
     } else {
       ;
     }
     }
     if (!hasError) {
-    
+
     s1 = procedure_call();
     }
     if (!hasError) {
-    
+
     jj_consume_token(SEMI_T);
     }
-    
+
 return s+s1+";";
 assert(false);
 }
@@ -7550,140 +7550,140 @@ QCString VhdlParser::process_declarative_item() {QCString s;
     case IMPURE_T:
     case PROCEDURE_T:
     case PURE_T:{if (!hasError) {
-      
+
       subprogram_declaration();
       }
       if (!hasError) {
-      
+
 return "";
       }
-      
+
       break;
       }
     case TYPE_T:{if (!hasError) {
-      
+
       s = type_declaration();
       }
       if (!hasError) {
-      
+
 return s;
       }
-      
+
       break;
       }
     case SUBTYPE_T:{if (!hasError) {
-      
+
       s = subtype_declaration();
       }
       if (!hasError) {
-      
+
 return s;
       }
-      
+
       break;
       }
     case CONSTANT_T:{if (!hasError) {
-      
+
       s = constant_declaration();
       }
       if (!hasError) {
-      
+
 return s;
       }
-      
+
       break;
       }
     case SHARED_T:
     case VARIABLE_T:{if (!hasError) {
-      
+
       s = variable_declaration();
       }
       if (!hasError) {
-      
+
 return s;
       }
-      
+
       break;
       }
     case FILE_T:{if (!hasError) {
-      
+
       s = file_declaration();
       }
       if (!hasError) {
-      
+
 return s;
       }
-      
+
       break;
       }
     case ALIAS_T:{if (!hasError) {
-      
+
       s = alias_declaration();
       }
       if (!hasError) {
-      
+
 return s;
       }
-      
+
       break;
       }
     default:
       jj_la1[170] = jj_gen;
       if (jj_2_69(3)) {if (!hasError) {
-        
+
         s = attribute_declaration();
         }
         if (!hasError) {
-        
+
 return s;
         }
-        
+
       } else {
         switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
         case ATTRIBUTE_T:{if (!hasError) {
-          
+
           s = attribute_specification();
           }
           if (!hasError) {
-          
+
 return s;
           }
-          
+
           break;
           }
         case USE_T:{if (!hasError) {
-          
+
           s = use_clause();
           }
           if (!hasError) {
-          
+
 return s;
           }
-          
+
           break;
           }
         default:
           jj_la1[171] = jj_gen;
           if (jj_2_70(3)) {if (!hasError) {
-            
+
             s = group_template_declaration();
             }
             if (!hasError) {
-            
+
 return s;
             }
-            
+
           } else {
             switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
             case GROUP_T:{if (!hasError) {
-              
+
               s = group_declaration();
               }
               if (!hasError) {
-              
+
 return s;
               }
-              
+
               break;
               }
             default:
@@ -7700,7 +7700,7 @@ assert(false);
 
 
 QCString VhdlParser::process_declarative_part() {QCString s,s1;if (!hasError) {
-    
+
     while (!hasError) {
       switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
       case ALIAS_T:
@@ -7724,36 +7724,36 @@ QCString VhdlParser::process_declarative_part() {QCString s,s1;if (!hasError) {
         jj_la1[173] = jj_gen;
         goto end_label_32;
       }if (!hasError) {
-      
+
       s1 = process_declarative_item();
       }
       if (!hasError) {
-      
+
 s+=s1;
       }
-      
+
     }
     end_label_32: ;
     }
-    
+
 return s;
 assert(false);
 }
 
 
 void VhdlParser::process_statement() {QCString s,s1,s2;Token *tok=0;if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case BASIC_IDENTIFIER:
     case EXTENDED_CHARACTER:{if (!hasError) {
-      
+
       s = identifier();
       }
       if (!hasError) {
-      
+
       jj_consume_token(COLON_T);
       }
-      
+
       break;
       }
     default:
@@ -7762,13 +7762,13 @@ void VhdlParser::process_statement() {QCString s,s1,s2;Token *tok=0;if (!hasErro
     }
     }
     if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case POSTPONED_T:{if (!hasError) {
-      
+
       jj_consume_token(POSTPONED_T);
       }
-      
+
       break;
       }
     default:
@@ -7777,40 +7777,40 @@ void VhdlParser::process_statement() {QCString s,s1,s2;Token *tok=0;if (!hasErro
     }
     }
     if (!hasError) {
-    
+
 currP=VhdlDocGen::PROCESS;
                current->startLine=getLine();
                current->bodyLine=getLine();
     }
     if (!hasError) {
-    
+
     jj_consume_token(PROCESS_T);
     }
     if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case LPAREN_T:{if (!hasError) {
-      
+
       jj_consume_token(LPAREN_T);
       }
       if (!hasError) {
-      
+
       switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
       case ALL_T:{if (!hasError) {
-        
+
         tok = jj_consume_token(ALL_T);
         }
-        
+
         break;
         }
       case SLSL_T:
       case STRINGLITERAL:
       case BASIC_IDENTIFIER:
       case EXTENDED_CHARACTER:{if (!hasError) {
-        
+
         s1 = sensitivity_list();
         }
-        
+
         break;
         }
       default:
@@ -7820,10 +7820,10 @@ currP=VhdlDocGen::PROCESS;
       }
       }
       if (!hasError) {
-      
+
       jj_consume_token(RPAREN_T);
       }
-      
+
       break;
       }
     default:
@@ -7832,13 +7832,13 @@ currP=VhdlDocGen::PROCESS;
     }
     }
     if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case IS_T:{if (!hasError) {
-      
+
       jj_consume_token(IS_T);
       }
-      
+
       break;
       }
     default:
@@ -7847,35 +7847,35 @@ currP=VhdlDocGen::PROCESS;
     }
     }
     if (!hasError) {
-    
+
     s2 = process_declarative_part();
     }
     if (!hasError) {
-    
+
 if (s2.data())
                   FlowChart::addFlowChart(FlowChart::VARIABLE_NO,s2.data(),0);
                 FlowChart::addFlowChart(FlowChart::BEGIN_NO,"BEGIN",0);
     }
     if (!hasError) {
-    
+
     jj_consume_token(BEGIN_T);
     }
     if (!hasError) {
-    
+
     process_statement_part();
     }
     if (!hasError) {
-    
+
     jj_consume_token(END_T);
     }
     if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case POSTPONED_T:{if (!hasError) {
-      
+
       jj_consume_token(POSTPONED_T);
       }
-      
+
       break;
       }
     default:
@@ -7884,18 +7884,18 @@ if (s2.data())
     }
     }
     if (!hasError) {
-    
+
     jj_consume_token(PROCESS_T);
     }
     if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case BASIC_IDENTIFIER:
     case EXTENDED_CHARACTER:{if (!hasError) {
-      
+
       identifier();
       }
-      
+
       break;
       }
     default:
@@ -7904,10 +7904,10 @@ if (s2.data())
     }
     }
     if (!hasError) {
-    
+
     jj_consume_token(SEMI_T);
     }
-    
+
 if(s.isEmpty())
    currName=VhdlDocGen::getProcessNumber();
    else
@@ -7927,7 +7927,7 @@ if(s.isEmpty())
 
 
 void VhdlParser::process_statement_part() {if (!hasError) {
-    
+
     while (!hasError) {
       switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
       case ASSERT_T:
@@ -7955,59 +7955,59 @@ void VhdlParser::process_statement_part() {if (!hasError) {
         jj_la1[181] = jj_gen;
         goto end_label_33;
       }if (!hasError) {
-      
+
       sequential_statement();
       }
-      
+
     }
     end_label_33: ;
     }
-    
+
 }
 
 
 QCString VhdlParser::qualified_expression() {QCString s,s1;if (!hasError) {
-    
+
     s1 = identifier();
     }
     if (!hasError) {
-    
+
     jj_consume_token(APOSTROPHE_T);
     }
     if (!hasError) {
-    
+
 s=s1+"'";
     }
     if (!hasError) {
-    
+
     if (jj_2_71(2147483647)) {if (!hasError) {
-      
+
       s1 = aggregate();
       }
       if (!hasError) {
-      
+
 s+=s1;
       }
-      
+
     } else {
       switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
       case LPAREN_T:{if (!hasError) {
-        
+
         jj_consume_token(LPAREN_T);
         }
         if (!hasError) {
-        
+
         s1 = expression();
         }
         if (!hasError) {
-        
+
         jj_consume_token(RPAREN_T);
         }
         if (!hasError) {
-        
+
 s+="(";s+=s1;s+=")";
         }
-        
+
         break;
         }
       default:
@@ -8017,7 +8017,7 @@ s+="(";s+=s1;s+=")";
       }
     }
     }
-    
+
 return s;
 assert(false);
 }
@@ -8025,31 +8025,31 @@ assert(false);
 
 QCString VhdlParser::range() {QCString s,s1,s2;
     if (jj_2_72(2147483647)) {if (!hasError) {
-      
+
       s = simple_expression();
       }
       if (!hasError) {
-      
+
       s1 = direction();
       }
       if (!hasError) {
-      
+
       s2 = simple_expression();
       }
       if (!hasError) {
-      
+
 return s+" "+s1+" "+s2;
       }
-      
+
     } else if (jj_2_73(2147483647)) {if (!hasError) {
-      
+
       s = attribute_name();
       }
       if (!hasError) {
-      
+
 return s;
       }
-      
+
     } else {
       jj_consume_token(-1);
       errorHandler->handleParseError(token, getToken(1), __FUNCTION__, this), hasError = true;
@@ -8059,30 +8059,30 @@ assert(false);
 
 
 QCString VhdlParser::range_constraint() {QCString s,s1;if (!hasError) {
-    
+
     jj_consume_token(RANGE_T);
     }
     if (!hasError) {
-    
+
     s = range();
     }
-    
+
 return " range "+s;
 assert(false);
 }
 
 
 void VhdlParser::record_type_definition() {if (!hasError) {
-    
+
     jj_consume_token(RECORD_T);
     }
     if (!hasError) {
-    
+
     while (!hasError) {if (!hasError) {
-      
+
       element_declaration();
       }
-      
+
       switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
       case BASIC_IDENTIFIER:
       case EXTENDED_CHARACTER:{
@@ -8097,24 +8097,24 @@ void VhdlParser::record_type_definition() {if (!hasError) {
     end_label_34: ;
     }
     if (!hasError) {
-    
+
     jj_consume_token(END_T);
     }
     if (!hasError) {
-    
+
     jj_consume_token(RECORD_T);
     }
     if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case SLSL_T:
     case STRINGLITERAL:
     case BASIC_IDENTIFIER:
     case EXTENDED_CHARACTER:{if (!hasError) {
-      
+
       name();
       }
-      
+
       break;
       }
     default:
@@ -8122,16 +8122,16 @@ void VhdlParser::record_type_definition() {if (!hasError) {
       ;
     }
     }
-    
+
 }
 
 
 QCString VhdlParser::relation() {QCString s,s1,s2;if (!hasError) {
-    
+
     s = shift_expression();
     }
     if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case LESSTHAN_T:
     case GREATERTHAN_T:
@@ -8139,14 +8139,14 @@ QCString VhdlParser::relation() {QCString s,s1,s2;if (!hasError) {
     case GT_T:
     case EQU_T:
     case NOTEQU_T:{if (!hasError) {
-      
+
       s1 = relation_operator();
       }
       if (!hasError) {
-      
+
       s2 = shift_expression();
       }
-      
+
       break;
       }
     default:
@@ -8154,7 +8154,7 @@ QCString VhdlParser::relation() {QCString s,s1,s2;if (!hasError) {
       ;
     }
     }
-    
+
 return s+s1+s2;
 assert(false);
 }
@@ -8163,69 +8163,69 @@ assert(false);
 QCString VhdlParser::relation_operator() {
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case LT_T:{if (!hasError) {
-      
+
       jj_consume_token(LT_T);
       }
       if (!hasError) {
-      
+
 return "<";
       }
-      
+
       break;
       }
     case GT_T:{if (!hasError) {
-      
+
       jj_consume_token(GT_T);
       }
       if (!hasError) {
-      
+
 return ">";
       }
-      
+
       break;
       }
     case EQU_T:{if (!hasError) {
-      
+
       jj_consume_token(EQU_T);
       }
       if (!hasError) {
-      
+
 return "=";
       }
-      
+
       break;
       }
     case GREATERTHAN_T:{if (!hasError) {
-      
+
       jj_consume_token(GREATERTHAN_T);
       }
       if (!hasError) {
-      
+
 return ">=";
       }
-      
+
       break;
       }
     case LESSTHAN_T:{if (!hasError) {
-      
+
       jj_consume_token(LESSTHAN_T);
       }
       if (!hasError) {
-      
+
 return "<=";
       }
-      
+
       break;
       }
     case NOTEQU_T:{if (!hasError) {
-      
+
       jj_consume_token(NOTEQU_T);
       }
       if (!hasError) {
-      
+
 return "/=";
       }
-      
+
       break;
       }
     default:
@@ -8238,18 +8238,18 @@ assert(false);
 
 
 QCString VhdlParser::report_statement() {Token *t=0;Token *t1=0;QCString s,s1,s2;if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case BASIC_IDENTIFIER:
     case EXTENDED_CHARACTER:{if (!hasError) {
-      
+
       s = identifier();
       }
       if (!hasError) {
-      
+
       t = jj_consume_token(COLON_T);
       }
-      
+
       break;
       }
     default:
@@ -8258,25 +8258,25 @@ QCString VhdlParser::report_statement() {Token *t=0;Token *t1=0;QCString s,s1,s2
     }
     }
     if (!hasError) {
-    
+
     jj_consume_token(REPORT_T);
     }
     if (!hasError) {
-    
+
     s1 = expression();
     }
     if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case SEVERITY_T:{if (!hasError) {
-      
+
       t1 = jj_consume_token(SEVERITY_T);
       }
       if (!hasError) {
-      
+
       s2 = expression();
       }
-      
+
       break;
       }
     default:
@@ -8285,10 +8285,10 @@ QCString VhdlParser::report_statement() {Token *t=0;Token *t1=0;QCString s,s1,s2
     }
     }
     if (!hasError) {
-    
+
     jj_consume_token(SEMI_T);
     }
-    
+
 if(t) s.append(":");
         s1.prepend(" report ");
         if(t1) s2.prepend(" severity ");
@@ -8298,22 +8298,22 @@ assert(false);
 
 
 QCString VhdlParser::return_statement() {QCString s,s1;if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case BASIC_IDENTIFIER:
     case EXTENDED_CHARACTER:{if (!hasError) {
-      
+
       s = identifier();
       }
       if (!hasError) {
-      
+
       jj_consume_token(COLON_T);
       }
       if (!hasError) {
-      
+
 s+=":";
       }
-      
+
       break;
       }
     default:
@@ -8322,11 +8322,11 @@ s+=":";
     }
     }
     if (!hasError) {
-    
+
     jj_consume_token(RETURN_T);
     }
     if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case ABS_T:
     case NEW_T:
@@ -8344,10 +8344,10 @@ s+=":";
     case DECIMAL_LITERAL:
     case BASED_LITERAL:
     case BIT_STRING_LITERAL:{if (!hasError) {
-      
+
       s1 = expression();
       }
-      
+
       break;
       }
     default:
@@ -8356,10 +8356,10 @@ s+=":";
     }
     }
     if (!hasError) {
-    
+
     jj_consume_token(SEMI_T);
     }
-    
+
 return s+" return "+s1+";";
 assert(false);
 }
@@ -8368,36 +8368,36 @@ assert(false);
 QCString VhdlParser::scalar_type_definition() {QCString s,s1;
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case LPAREN_T:{if (!hasError) {
-      
+
       s = enumeration_type_definition();
       }
       if (!hasError) {
-      
+
 return s;
       }
-      
+
       break;
       }
     case RANGE_T:{if (!hasError) {
-      
+
       s = range_constraint();
       }
       if (!hasError) {
-      
+
       if (jj_2_74(2147483647)) {if (!hasError) {
-        
+
         s1 = physical_type_definition();
         }
-        
+
       } else {
         ;
       }
       }
       if (!hasError) {
-      
+
 return s+" "+s1+"%";
       }
-      
+
       break;
       }
     default:
@@ -8412,17 +8412,17 @@ assert(false);
 void VhdlParser::secondary_unit() {
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case ARCHITECTURE_T:{if (!hasError) {
-      
+
       architecture_body();
       }
-      
+
       break;
       }
     case PACKAGE_T:{if (!hasError) {
-      
+
       package_body();
       }
-      
+
       break;
       }
     default:
@@ -8434,22 +8434,22 @@ void VhdlParser::secondary_unit() {
 
 
 QCString VhdlParser::secondary_unit_declaration() {QCString s,s1;if (!hasError) {
-    
+
     s = identifier();
     }
     if (!hasError) {
-    
+
     jj_consume_token(EQU_T);
     }
     if (!hasError) {
-    
+
     s1 = physical_literal();
     }
     if (!hasError) {
-    
+
     jj_consume_token(SEMI_T);
     }
-    
+
 //printf("\n %s %s [%d]",s.data(),s1.data(),getLine());
   addVhdlType(s.data(),getLine(),Entry::VARIABLE_SEC,VhdlDocGen::UNITS,0,s1.data(),Public);
 
@@ -8459,73 +8459,73 @@ assert(false);
 
 
 QCString VhdlParser::selected_name() {QCString s,s1;if (!hasError) {
-    
+
     s = identifier();
     }
     if (!hasError) {
-    
+
     jj_consume_token(DOT_T);
     }
     if (!hasError) {
-    
+
     s1 = suffix();
     }
-    
+
 return s+"."+s1;
 assert(false);
 }
 
 
 void VhdlParser::selected_signal_assignment() {if (!hasError) {
-    
+
     jj_consume_token(WITH_T);
     }
     if (!hasError) {
-    
+
     expression();
     }
     if (!hasError) {
-    
+
     jj_consume_token(SELECT_T);
     }
     if (!hasError) {
-    
+
     target();
     }
     if (!hasError) {
-    
+
     jj_consume_token(LESSTHAN_T);
     }
     if (!hasError) {
-    
+
     options();
     }
     if (!hasError) {
-    
+
     selected_waveforms();
     }
     if (!hasError) {
-    
+
     jj_consume_token(SEMI_T);
     }
-    
+
 }
 
 
 void VhdlParser::selected_waveforms() {if (!hasError) {
-    
+
     waveform();
     }
     if (!hasError) {
-    
+
     jj_consume_token(WHEN_T);
     }
     if (!hasError) {
-    
+
     choices();
     }
     if (!hasError) {
-    
+
     while (!hasError) {
       switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
       case COMMA_T:{
@@ -8536,38 +8536,38 @@ void VhdlParser::selected_waveforms() {if (!hasError) {
         jj_la1[193] = jj_gen;
         goto end_label_35;
       }if (!hasError) {
-      
+
       jj_consume_token(COMMA_T);
       }
       if (!hasError) {
-      
+
       waveform();
       }
       if (!hasError) {
-      
+
       jj_consume_token(WHEN_T);
       }
       if (!hasError) {
-      
+
       choices();
       }
-      
+
     }
     end_label_35: ;
     }
-    
+
 }
 
 
 QCString VhdlParser::sensitivity_clause() {QCString s;if (!hasError) {
-    
+
     jj_consume_token(ON_T);
     }
     if (!hasError) {
-    
+
     s = sensitivity_list();
     }
-    
+
 s.prepend(" on ");
   return s;
 assert(false);
@@ -8575,11 +8575,11 @@ assert(false);
 
 
 QCString VhdlParser::sensitivity_list() {QCString s,s1;if (!hasError) {
-    
+
     s = name();
     }
     if (!hasError) {
-    
+
     while (!hasError) {
       switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
       case COMMA_T:{
@@ -8590,47 +8590,47 @@ QCString VhdlParser::sensitivity_list() {QCString s,s1;if (!hasError) {
         jj_la1[194] = jj_gen;
         goto end_label_36;
       }if (!hasError) {
-      
+
       jj_consume_token(COMMA_T);
       }
       if (!hasError) {
-      
+
       s1 = name();
       }
       if (!hasError) {
-      
+
 s+=",";s+=s1;
       }
-      
+
     }
     end_label_36: ;
     }
-    
+
 return s;
 assert(false);
 }
 
 
 QCString VhdlParser::sequence_of_statement() {QCString s,s1;if (!hasError) {
-    
+
     while (!hasError) {
       if (jj_2_75(3)) {
         ;
       } else {
         goto end_label_37;
       }if (!hasError) {
-      
+
       s1 = sequential_statement();
       }
       if (!hasError) {
-      
+
 s+=s1;
       }
-      
+
     }
     end_label_37: ;
     }
-    
+
 return s;
 assert(false);
 }
@@ -8638,126 +8638,126 @@ assert(false);
 
 QCString VhdlParser::sequential_statement() {QCString s;
     if (jj_2_76(2147483647)) {if (!hasError) {
-      
+
       s = signal_assignment_statement();
       }
       if (!hasError) {
-      
+
 FlowChart::addFlowChart(FlowChart::TEXT_NO,s.data(),0);return s;
       }
-      
+
     } else if (jj_2_77(3)) {if (!hasError) {
-      
+
       s = assertion_statement();
       }
       if (!hasError) {
-      
+
 FlowChart::addFlowChart(FlowChart::TEXT_NO,s.data(),0);return s;
       }
-      
+
     } else if (jj_2_78(3)) {if (!hasError) {
-      
+
       s = report_statement();
       }
       if (!hasError) {
-      
+
 FlowChart::addFlowChart(FlowChart::TEXT_NO,s.data(),0);return s;
       }
-      
+
     } else if (jj_2_79(3)) {if (!hasError) {
-      
+
       s = wait_statement();
       }
       if (!hasError) {
-      
+
 FlowChart::addFlowChart(FlowChart::TEXT_NO,s.data(),0);return s;
       }
-      
+
     } else if (jj_2_80(2147483647)) {if (!hasError) {
-      
+
       s = variable_assignment_statement();
       }
       if (!hasError) {
-      
+
 FlowChart::addFlowChart(FlowChart::TEXT_NO,s.data(),0);return s;
       }
-      
+
     } else if (jj_2_81(3)) {if (!hasError) {
-      
+
       s = procedure_call_statement();
       }
       if (!hasError) {
-      
+
 FlowChart::addFlowChart(FlowChart::TEXT_NO,s.data(),0);return s;
       }
-      
+
     } else if (jj_2_82(3)) {if (!hasError) {
-      
+
       if_statement();
       }
       if (!hasError) {
-      
+
 return s;
       }
-      
+
     } else if (jj_2_83(3)) {if (!hasError) {
-      
+
       case_statement();
       }
       if (!hasError) {
-      
+
 return s;
       }
-      
+
     } else if (jj_2_84(3)) {if (!hasError) {
-      
+
       loop_statement();
       }
       if (!hasError) {
-      
+
 return s;
       }
-      
+
     } else if (jj_2_85(3)) {if (!hasError) {
-      
+
       s = next_statement();
       }
       if (!hasError) {
-      
+
 return s;
       }
-      
+
     } else if (jj_2_86(3)) {if (!hasError) {
-      
+
       s = exit_statement();
       }
       if (!hasError) {
-      
+
 return s;
       }
-      
+
     } else if (jj_2_87(3)) {if (!hasError) {
-      
+
       s = return_statement();
       }
       if (!hasError) {
-      
+
 FlowChart::addFlowChart(FlowChart::RETURN_NO,s.data(),0);return s;
       }
-      
+
     } else {
       switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
       case NULL_T:
       case BASIC_IDENTIFIER:
       case EXTENDED_CHARACTER:{if (!hasError) {
-        
+
         s = null_statement();
         }
         if (!hasError) {
-        
+
 FlowChart::addFlowChart(FlowChart::TEXT_NO,s.data(),0);return s;
         }
-        
+
         break;
         }
       default:
@@ -8771,11 +8771,11 @@ assert(false);
 
 
 QCString VhdlParser::shift_expression() {QCString s,s1,s2;if (!hasError) {
-    
+
     s = simple_expression();
     }
     if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case ROL_T:
     case ROR_T:
@@ -8783,14 +8783,14 @@ QCString VhdlParser::shift_expression() {QCString s,s1,s2;if (!hasError) {
     case SLL_T:
     case SRA_T:
     case SRL_T:{if (!hasError) {
-      
+
       s1 = shift_operator();
       }
       if (!hasError) {
-      
+
       s2 = simple_expression();
       }
-      
+
       break;
       }
     default:
@@ -8798,7 +8798,7 @@ QCString VhdlParser::shift_expression() {QCString s,s1,s2;if (!hasError) {
       ;
     }
     }
-    
+
 return s+s1+s2;
 assert(false);
 }
@@ -8807,69 +8807,69 @@ assert(false);
 QCString VhdlParser::shift_operator() {
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case SLL_T:{if (!hasError) {
-      
+
       jj_consume_token(SLL_T);
       }
       if (!hasError) {
-      
+
 return "sll";
       }
-      
+
       break;
       }
     case SRL_T:{if (!hasError) {
-      
+
       jj_consume_token(SRL_T);
       }
       if (!hasError) {
-      
+
 return "srl";
       }
-      
+
       break;
       }
     case SLA_T:{if (!hasError) {
-      
+
       jj_consume_token(SLA_T);
       }
       if (!hasError) {
-      
+
 return "sla";
       }
-      
+
       break;
       }
     case SRA_T:{if (!hasError) {
-      
+
       jj_consume_token(SRA_T);
       }
       if (!hasError) {
-      
+
 return "sra";
       }
-      
+
       break;
       }
     case ROL_T:{if (!hasError) {
-      
+
       jj_consume_token(ROL_T);
       }
       if (!hasError) {
-      
+
 return "rol";
       }
-      
+
       break;
       }
     case ROR_T:{if (!hasError) {
-      
+
       jj_consume_token(ROR_T);
       }
       if (!hasError) {
-      
+
 return "ror";
       }
-      
+
       break;
       }
     default:
@@ -8884,25 +8884,25 @@ assert(false);
 QCString VhdlParser::sign() {
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case PLUS_T:{if (!hasError) {
-      
+
       jj_consume_token(PLUS_T);
       }
       if (!hasError) {
-      
+
 return "+";
       }
-      
+
       break;
       }
     case MINUS_T:{if (!hasError) {
-      
+
       jj_consume_token(MINUS_T);
       }
       if (!hasError) {
-      
+
 return "-";
       }
-      
+
       break;
       }
     default:
@@ -8916,23 +8916,23 @@ assert(false);
 
 QCString VhdlParser::signal_assignment_statement() {QCString s,s1,s2,s3;
     if (jj_2_89(2147483647)) {if (!hasError) {
-      
+
       conditional_signal_assignment_wave();
       }
       if (!hasError) {
-      
+
 return "";
       }
-      
+
     } else if (jj_2_90(2147483647)) {if (!hasError) {
-      
+
       selected_signal_assignment_wave();
       }
       if (!hasError) {
-      
+
 return "";
       }
-      
+
     } else {
       switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
       case LPAREN_T:
@@ -8940,42 +8940,42 @@ return "";
       case STRINGLITERAL:
       case BASIC_IDENTIFIER:
       case EXTENDED_CHARACTER:{if (!hasError) {
-        
+
         if (jj_2_88(2)) {if (!hasError) {
-          
+
           s = identifier();
           }
           if (!hasError) {
-          
+
           jj_consume_token(COLON_T);
           }
           if (!hasError) {
-          
+
 s+=":";
           }
-          
+
         } else {
           ;
         }
         }
         if (!hasError) {
-        
+
         s1 = target();
         }
         if (!hasError) {
-        
+
         jj_consume_token(LESSTHAN_T);
         }
         if (!hasError) {
-        
+
         switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
         case INERTIAL_T:
         case REJECT_T:
         case TRANSPORT_T:{if (!hasError) {
-          
+
           s2 = delay_mechanism();
           }
-          
+
           break;
           }
         default:
@@ -8984,18 +8984,18 @@ s+=":";
         }
         }
         if (!hasError) {
-        
+
         s3 = waveform();
         }
         if (!hasError) {
-        
+
         jj_consume_token(SEMI_T);
         }
         if (!hasError) {
-        
+
 return s+s1+"<="+s2+s3+";";
         }
-        
+
         break;
         }
       default:
@@ -9009,38 +9009,38 @@ assert(false);
 
 
 void VhdlParser::semi() {if (!hasError) {
-    
+
     jj_consume_token(SEMI_T);
     }
-    
+
 }
 
 
 void VhdlParser::signal_declaration() {Token* tok=0;QCString s,s1,s2,s3,s4;if (!hasError) {
-    
+
     jj_consume_token(SIGNAL_T);
     }
     if (!hasError) {
-    
+
     s = identifier_list();
     }
     if (!hasError) {
-    
+
     jj_consume_token(COLON_T);
     }
     if (!hasError) {
-    
+
     s1 = subtype_indication();
     }
     if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case BUS_T:
     case REGISTER_T:{if (!hasError) {
-      
+
       s2 = signal_kind();
       }
-      
+
       break;
       }
     default:
@@ -9049,17 +9049,17 @@ void VhdlParser::signal_declaration() {Token* tok=0;QCString s,s1,s2,s3,s4;if (!
     }
     }
     if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case VARASSIGN_T:{if (!hasError) {
-      
+
       tok = jj_consume_token(VARASSIGN_T);
       }
       if (!hasError) {
-      
+
       s3 = expression();
       }
-      
+
       break;
       }
     default:
@@ -9068,10 +9068,10 @@ void VhdlParser::signal_declaration() {Token* tok=0;QCString s,s1,s2,s3,s4;if (!
     }
     }
     if (!hasError) {
-    
+
     jj_consume_token(SEMI_T);
     }
-    
+
 if(tok)
       s3.prepend(":=");
      s4=s1+s2+s3;
@@ -9082,25 +9082,25 @@ if(tok)
 QCString VhdlParser::signal_kind() {
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case REGISTER_T:{if (!hasError) {
-      
+
       jj_consume_token(REGISTER_T);
       }
       if (!hasError) {
-      
+
 return "register";
       }
-      
+
       break;
       }
     case BUS_T:{if (!hasError) {
-      
+
       jj_consume_token(BUS_T);
       }
       if (!hasError) {
-      
+
 return "bus";
       }
-      
+
       break;
       }
     default:
@@ -9118,11 +9118,11 @@ QCString VhdlParser::signal_list() {QCString s,s1;
     case STRINGLITERAL:
     case BASIC_IDENTIFIER:
     case EXTENDED_CHARACTER:{if (!hasError) {
-      
+
       s = name();
       }
       if (!hasError) {
-      
+
       while (!hasError) {
         switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
         case COMMA_T:{
@@ -9133,44 +9133,44 @@ QCString VhdlParser::signal_list() {QCString s,s1;
           jj_la1[204] = jj_gen;
           goto end_label_38;
         }if (!hasError) {
-        
+
         jj_consume_token(COMMA_T);
         }
         if (!hasError) {
-        
+
         s1 = name();
         }
         if (!hasError) {
-        
+
 s+=",";s+=s1;
         }
-        
+
       }
       end_label_38: ;
       }
-      
+
       break;
       }
     case OTHER_T:{if (!hasError) {
-      
+
       jj_consume_token(OTHER_T);
       }
       if (!hasError) {
-      
+
 return "other";
       }
-      
+
       break;
       }
     case ALL_T:{if (!hasError) {
-      
+
       jj_consume_token(ALL_T);
       }
       if (!hasError) {
-      
+
 return "all";
       }
-      
+
       break;
       }
     default:
@@ -9183,21 +9183,21 @@ assert(false);
 
 
 QCString VhdlParser::signature() {QCString s,s1,s2;if (!hasError) {
-    
+
     jj_consume_token(LBRACKET_T);
     }
     if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case SLSL_T:
     case STRINGLITERAL:
     case BASIC_IDENTIFIER:
     case EXTENDED_CHARACTER:{if (!hasError) {
-      
+
       s = name();
       }
       if (!hasError) {
-      
+
       while (!hasError) {
         switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
         case COMMA_T:{
@@ -9208,22 +9208,22 @@ QCString VhdlParser::signature() {QCString s,s1,s2;if (!hasError) {
           jj_la1[206] = jj_gen;
           goto end_label_39;
         }if (!hasError) {
-        
+
         jj_consume_token(COMMA_T);
         }
         if (!hasError) {
-        
+
         s1 = name();
         }
         if (!hasError) {
-        
+
 s+=",";s+=s1;
         }
-        
+
       }
       end_label_39: ;
       }
-      
+
       break;
       }
     default:
@@ -9232,21 +9232,21 @@ s+=",";s+=s1;
     }
     }
     if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case RETURN_T:{if (!hasError) {
-      
+
       jj_consume_token(RETURN_T);
       }
       if (!hasError) {
-      
+
       s1 = name();
       }
       if (!hasError) {
-      
+
 s+="return ";s+=s1;
       }
-      
+
       break;
       }
     default:
@@ -9255,24 +9255,24 @@ s+="return ";s+=s1;
     }
     }
     if (!hasError) {
-    
+
     jj_consume_token(RBRACKET_T);
     }
-    
+
 s1="["+s+"]";return s1;
 assert(false);
 }
 
 
 QCString VhdlParser::simple_expression() {QCString s,s1,s2;if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case PLUS_T:
     case MINUS_T:{if (!hasError) {
-      
+
       s = sign();
       }
-      
+
       break;
       }
     default:
@@ -9281,93 +9281,93 @@ QCString VhdlParser::simple_expression() {QCString s,s1,s2;if (!hasError) {
     }
     }
     if (!hasError) {
-    
+
     s1 = term();
     }
     if (!hasError) {
-    
+
 s+=s1;
     }
     if (!hasError) {
-    
+
     while (!hasError) {
       if (jj_2_91(2147483647)) {
         ;
       } else {
         goto end_label_40;
       }if (!hasError) {
-      
+
       s1 = adding_operator();
       }
       if (!hasError) {
-      
+
       s2 = term();
       }
       if (!hasError) {
-      
+
 s+=s1;s+=s2;
       }
-      
+
     }
     end_label_40: ;
     }
-    
+
 return s;
 assert(false);
 }
 
 
 void VhdlParser::simple_name() {if (!hasError) {
-    
+
     name();
     }
-    
+
 }
 
 
 QCString VhdlParser::slice_name() {QCString s,s1;if (!hasError) {
-    
+
     s = identifier();
     }
     if (!hasError) {
-    
+
     jj_consume_token(LPAREN_T);
     }
     if (!hasError) {
-    
+
     s1 = discrete_range();
     }
     if (!hasError) {
-    
+
     jj_consume_token(RPAREN_T);
     }
-    
+
 return s+"("+s1+")";
 assert(false);
 }
 
 
 QCString VhdlParser::string_literal() {Token *tok=0;if (!hasError) {
-    
+
     tok = jj_consume_token(STRINGLITERAL);
     }
-    
+
 return tok->image.c_str();
 assert(false);
 }
 
 
 void VhdlParser::subprogram_body() {QCString s;if (!hasError) {
-    
+
     jj_consume_token(IS_T);
     }
     if (!hasError) {
-    
+
     //try{
      s = subprogram_declarative_part();
     }
     if (!hasError) {
-    
+
 if (s.data())
       {
         FlowChart::addFlowChart(FlowChart::VARIABLE_NO,s,0);
@@ -9375,26 +9375,26 @@ if (s.data())
       FlowChart::addFlowChart(FlowChart::BEGIN_NO,"BEGIN",0);
     }
     if (!hasError) {
-    
+
     jj_consume_token(BEGIN_T);
     }
     if (!hasError) {
-    
+
     subprogram_statement_part();
     }
     if (!hasError) {
-    
+
     jj_consume_token(END_T);
     }
     if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case FUNCTION_T:
     case PROCEDURE_T:{if (!hasError) {
-      
+
       subprogram_kind();
       }
-      
+
       break;
       }
     default:
@@ -9403,15 +9403,15 @@ if (s.data())
     }
     }
     if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case STRINGLITERAL:
     case BASIC_IDENTIFIER:
     case EXTENDED_CHARACTER:{if (!hasError) {
-      
+
       designator();
       }
-      
+
       break;
       }
     default:
@@ -9420,10 +9420,10 @@ if (s.data())
     }
     }
     if (!hasError) {
-    
+
     jj_consume_token(SEMI_T);
     }
-    
+
 tempEntry->endBodyLine=getLine(END_T);
       createFlow();
       currP=0;
@@ -9432,28 +9432,28 @@ tempEntry->endBodyLine=getLine(END_T);
 
 void VhdlParser::subprogram_declaration() {
     if (jj_2_92(2147483647)) {if (!hasError) {
-      
+
       subprogram_instantiation_declaration();
       }
-      
+
     } else {
       switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
       case FUNCTION_T:
       case IMPURE_T:
       case PROCEDURE_T:
       case PURE_T:{if (!hasError) {
-        
+
         subprogram_specification();
         }
         if (!hasError) {
-        
+
         subprogram_1();
         }
         if (!hasError) {
-        
+
 currP=0;
         }
-        
+
         break;
         }
       default:
@@ -9468,17 +9468,17 @@ currP=0;
 void VhdlParser::subprogram_1() {
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case IS_T:{if (!hasError) {
-      
+
       subprogram_body();
       }
-      
+
       break;
       }
     case SEMI_T:{if (!hasError) {
-      
+
       jj_consume_token(SEMI_T);
       }
-      
+
       break;
       }
     default:
@@ -9495,151 +9495,151 @@ QCString VhdlParser::subprogram_declarative_item() {QCString s;
     case IMPURE_T:
     case PROCEDURE_T:
     case PURE_T:{if (!hasError) {
-      
+
       subprogram_declaration();
       }
       if (!hasError) {
-      
+
 return "";
       }
-      
+
       break;
       }
     case TYPE_T:{if (!hasError) {
-      
+
       s = type_declaration();
       }
       if (!hasError) {
-      
+
 return s;
       }
-      
+
       break;
       }
     case IS_T:{if (!hasError) {
-      
+
       subprogram_body();
       }
       if (!hasError) {
-      
+
 return "";
       }
-      
+
       break;
       }
     case SUBTYPE_T:{if (!hasError) {
-      
+
       s = subtype_declaration();
       }
       if (!hasError) {
-      
+
 return s;
       }
-      
+
       break;
       }
     case CONSTANT_T:{if (!hasError) {
-      
+
       s = constant_declaration();
       }
       if (!hasError) {
-      
+
 return s;
       }
-      
+
       break;
       }
     case SHARED_T:
     case VARIABLE_T:{if (!hasError) {
-      
+
       s = variable_declaration();
       }
       if (!hasError) {
-      
+
 return s;
       }
-      
+
       break;
       }
     case FILE_T:{if (!hasError) {
-      
+
       s = file_declaration();
       }
       if (!hasError) {
-      
+
 return s;
       }
-      
+
       break;
       }
     case ALIAS_T:{if (!hasError) {
-      
+
       s = alias_declaration();
       }
       if (!hasError) {
-      
+
 return s;
       }
-      
+
       break;
       }
     default:
       jj_la1[214] = jj_gen;
       if (jj_2_93(2147483647)) {if (!hasError) {
-        
+
         s = attribute_declaration();
         }
         if (!hasError) {
-        
+
 return s;
         }
-        
+
       } else {
         switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
         case ATTRIBUTE_T:{if (!hasError) {
-          
+
           s = attribute_specification();
           }
           if (!hasError) {
-          
+
 return s;
           }
-          
+
           break;
           }
         case USE_T:{if (!hasError) {
-          
+
           s = use_clause();
           }
           if (!hasError) {
-          
+
 return s;
           }
-          
+
           break;
           }
         default:
           jj_la1[215] = jj_gen;
           if (jj_2_94(3)) {if (!hasError) {
-            
+
             s = group_template_declaration();
             }
             if (!hasError) {
-            
+
 return s;
             }
-            
+
           } else {
             switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
             case GROUP_T:{if (!hasError) {
-              
+
               s = group_declaration();
               }
               if (!hasError) {
-              
+
 return s;
               }
-              
+
               break;
               }
             default:
@@ -9656,7 +9656,7 @@ assert(false);
 
 
 QCString VhdlParser::subprogram_declarative_part() {QCString s,s1;if (!hasError) {
-    
+
     while (!hasError) {
       switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
       case ALIAS_T:
@@ -9681,18 +9681,18 @@ QCString VhdlParser::subprogram_declarative_part() {QCString s,s1;if (!hasError)
         jj_la1[217] = jj_gen;
         goto end_label_41;
       }if (!hasError) {
-      
+
       s1 = subprogram_declarative_item();
       }
       if (!hasError) {
-      
+
 s+=s1;
       }
-      
+
     }
     end_label_41: ;
     }
-    
+
 return s;
 assert(false);
 }
@@ -9701,17 +9701,17 @@ assert(false);
 void VhdlParser::subprogram_kind() {
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case FUNCTION_T:{if (!hasError) {
-      
+
       jj_consume_token(FUNCTION_T);
       }
-      
+
       break;
       }
     case PROCEDURE_T:{if (!hasError) {
-      
+
       jj_consume_token(PROCEDURE_T);
       }
-      
+
       break;
       }
     default:
@@ -9725,15 +9725,15 @@ void VhdlParser::subprogram_kind() {
 void VhdlParser::subprogram_specification() {QCString s;Token *tok=0;Token *t;
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case PROCEDURE_T:{if (!hasError) {
-      
+
       jj_consume_token(PROCEDURE_T);
       }
       if (!hasError) {
-      
+
       s = designator();
       }
       if (!hasError) {
-      
+
 currP=VhdlDocGen::PROCEDURE;
               createFunction(s.data(),currP,0);
               tempEntry=current;
@@ -9741,29 +9741,29 @@ currP=VhdlDocGen::PROCEDURE;
                current->bodyLine=getLine(PROCEDURE_T);
       }
       if (!hasError) {
-      
+
       switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
       case LPAREN_T:{if (!hasError) {
-        
+
         jj_consume_token(LPAREN_T);
         }
         if (!hasError) {
-        
+
 param_sec=PARAM_SEC;
         }
         if (!hasError) {
-        
+
         interface_list();
         }
         if (!hasError) {
-        
+
 param_sec=0;
         }
         if (!hasError) {
-        
+
         jj_consume_token(RPAREN_T);
         }
-        
+
         break;
         }
       default:
@@ -9772,59 +9772,59 @@ param_sec=0;
       }
       }
       if (!hasError) {
-      
+
       if (jj_2_95(2)) {if (!hasError) {
-        
+
         gen_interface_list();
         }
-        
+
       } else {
         ;
       }
       }
       if (!hasError) {
-      
+
       if (jj_2_96(2)) {if (!hasError) {
-        
+
         gen_assoc_list();
         }
-        
+
       } else {
         ;
       }
       }
       if (!hasError) {
-      
+
       param();
       }
       if (!hasError) {
-      
+
 newEntry();
       }
-      
+
       break;
       }
     case FUNCTION_T:
     case IMPURE_T:
     case PURE_T:{if (!hasError) {
-      
+
       switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
       case IMPURE_T:
       case PURE_T:{if (!hasError) {
-        
+
         switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
         case PURE_T:{if (!hasError) {
-          
+
           tok = jj_consume_token(PURE_T);
           }
-          
+
           break;
           }
         case IMPURE_T:{if (!hasError) {
-          
+
           tok = jj_consume_token(IMPURE_T);
           }
-          
+
           break;
           }
         default:
@@ -9833,7 +9833,7 @@ newEntry();
           errorHandler->handleParseError(token, getToken(1), __FUNCTION__, this), hasError = true;
         }
         }
-        
+
         break;
         }
       default:
@@ -9842,15 +9842,15 @@ newEntry();
       }
       }
       if (!hasError) {
-      
+
       t = jj_consume_token(FUNCTION_T);
       }
       if (!hasError) {
-      
+
       s = designator();
       }
       if (!hasError) {
-      
+
 currP=VhdlDocGen::FUNCTION;
      if(tok)
      createFunction(tok->image.c_str(),currP,s.data());
@@ -9861,29 +9861,29 @@ currP=VhdlDocGen::FUNCTION;
       current->bodyLine=getLine(FUNCTION_T);
       }
       if (!hasError) {
-      
+
       switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
       case LPAREN_T:{if (!hasError) {
-        
+
 param_sec=PARAM_SEC;
         }
         if (!hasError) {
-        
+
         jj_consume_token(LPAREN_T);
         }
         if (!hasError) {
-        
+
         formal_parameter_list();
         }
         if (!hasError) {
-        
+
         jj_consume_token(RPAREN_T);
         }
         if (!hasError) {
-        
+
 param_sec=0;
         }
-        
+
         break;
         }
       default:
@@ -9892,20 +9892,20 @@ param_sec=0;
       }
       }
       if (!hasError) {
-      
+
       jj_consume_token(RETURN_T);
       }
       if (!hasError) {
-      
+
       s = type_mark();
       }
       if (!hasError) {
-      
+
 tempEntry=current;
                 current->type=s;
                 newEntry();
       }
-      
+
       break;
       }
     default:
@@ -9917,7 +9917,7 @@ tempEntry=current;
 
 
 void VhdlParser::subprogram_statement_part() {if (!hasError) {
-    
+
     while (!hasError) {
       switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
       case ASSERT_T:
@@ -9945,38 +9945,38 @@ void VhdlParser::subprogram_statement_part() {if (!hasError) {
         jj_la1[224] = jj_gen;
         goto end_label_42;
       }if (!hasError) {
-      
+
       sequential_statement();
       }
-      
+
     }
     end_label_42: ;
     }
-    
+
 }
 
 
 QCString VhdlParser::subtype_declaration() {QCString s,s1;if (!hasError) {
-    
+
     jj_consume_token(SUBTYPE_T);
     }
     if (!hasError) {
-    
+
     s = identifier();
     }
     if (!hasError) {
-    
+
     jj_consume_token(IS_T);
     }
     if (!hasError) {
-    
+
     s1 = subtype_indication();
     }
     if (!hasError) {
-    
+
     jj_consume_token(SEMI_T);
     }
-    
+
 addVhdlType(s.data(),getLine(),Entry::VARIABLE_SEC,VhdlDocGen::SUBTYPE,0,s1.data(),Public);
   return " subtype "+s+" is "+s1+";";
 assert(false);
@@ -9984,32 +9984,32 @@ assert(false);
 
 
 QCString VhdlParser::subtype_indication() {QCString s,s1,s2;if (!hasError) {
-    
+
     s = name();
     }
     if (!hasError) {
-    
+
     if (jj_2_97(2147483647)) {if (!hasError) {
-      
+
       s1 = name();
       }
-      
+
     } else {
       ;
     }
     }
     if (!hasError) {
-    
+
     if (jj_2_98(2147483647)) {if (!hasError) {
-      
+
       s2 = constraint();
       }
-      
+
     } else {
       ;
     }
     }
-    
+
 return s+" "+s1+" "+s2;
 assert(false);
 }
@@ -10017,47 +10017,47 @@ assert(false);
 
 QCString VhdlParser::suffix() {QCString s;
     if (jj_2_99(2147483647)) {if (!hasError) {
-      
+
       s = name();
       }
       if (!hasError) {
-      
+
 return s;
       }
-      
+
     } else {
       switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
       case CHARACTER_LITERAL:{if (!hasError) {
-        
+
         s = character_literal();
         }
         if (!hasError) {
-        
+
 return s;
         }
-        
+
         break;
         }
       case STRINGLITERAL:{if (!hasError) {
-        
+
         s = operator_symbol();
         }
         if (!hasError) {
-        
+
 return s;
         }
-        
+
         break;
         }
       case ALL_T:{if (!hasError) {
-        
+
         jj_consume_token(ALL_T);
         }
         if (!hasError) {
-        
+
 return " all ";
         }
-        
+
         break;
         }
       default:
@@ -10076,25 +10076,25 @@ QCString VhdlParser::target() {QCString s;
     case STRINGLITERAL:
     case BASIC_IDENTIFIER:
     case EXTENDED_CHARACTER:{if (!hasError) {
-      
+
       s = name();
       }
       if (!hasError) {
-      
+
 return s;
       }
-      
+
       break;
       }
     case LPAREN_T:{if (!hasError) {
-      
+
       s = aggregate();
       }
       if (!hasError) {
-      
+
 return s;
       }
-      
+
       break;
       }
     default:
@@ -10107,69 +10107,69 @@ assert(false);
 
 
 QCString VhdlParser::term() {QCString s,s1,s2;if (!hasError) {
-    
+
     s = factor();
     }
     if (!hasError) {
-    
+
     while (!hasError) {
       if (jj_2_100(2)) {
         ;
       } else {
         goto end_label_43;
       }if (!hasError) {
-      
+
       s1 = multiplying_operation();
       }
       if (!hasError) {
-      
+
       s2 = factor();
       }
       if (!hasError) {
-      
+
 s+=s1;s+=s2;
       }
-      
+
     }
     end_label_43: ;
     }
-    
+
 return s;
 assert(false);
 }
 
 
 QCString VhdlParser::timeout_clause() {QCString s;if (!hasError) {
-    
+
     jj_consume_token(FOR_T);
     }
     if (!hasError) {
-    
+
     s = expression();
     }
-    
+
 return " for "+s;
 assert(false);
 }
 
 
 QCString VhdlParser::type_conversion() {QCString s,s1;if (!hasError) {
-    
+
     s = name();
     }
     if (!hasError) {
-    
+
     jj_consume_token(LPAREN_T);
     }
     if (!hasError) {
-    
+
     s1 = expression();
     }
     if (!hasError) {
-    
+
     jj_consume_token(RPAREN_T);
     }
-    
+
 return s+"("+s1+")";
 assert(false);
 }
@@ -10177,25 +10177,25 @@ assert(false);
 
 QCString VhdlParser::type_declaration() {QCString s;
     if (jj_2_101(3)) {if (!hasError) {
-      
+
       s = full_type_declaration();
       }
       if (!hasError) {
-      
+
 return s;
       }
-      
+
     } else {
       switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
       case TYPE_T:{if (!hasError) {
-        
+
         s = incomplete_type_declaration();
         }
         if (!hasError) {
-        
+
 return s;
         }
-        
+
         break;
         }
       default:
@@ -10212,73 +10212,73 @@ QCString VhdlParser::type_definition() {QCString s;
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case RANGE_T:
     case LPAREN_T:{if (!hasError) {
-      
+
       //try{
       s = scalar_type_definition();
       }
       if (!hasError) {
-      
+
 return s;
       }
-      
+
       break;
       }
     case ARRAY_T:
     case RECORD_T:{if (!hasError) {
-      
+
       s = composite_type_definition();
       }
       if (!hasError) {
-      
+
 return s;
       }
-      
+
       break;
       }
     case ACCESS_T:{if (!hasError) {
-      
+
       s = access_type_definition();
       }
       if (!hasError) {
-      
+
 return s;
       }
-      
+
       break;
       }
     case FILE_T:{if (!hasError) {
-      
+
       s = file_type_definition();
       }
       if (!hasError) {
-      
+
 return s;
       }
-      
+
       break;
       }
     default:
       jj_la1[228] = jj_gen;
       if (jj_2_102(2)) {if (!hasError) {
-        
+
         protected_type_body();
         }
         if (!hasError) {
-        
+
 return "";
         }
-        
+
       } else {
         switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
         case PROTECTED_T:{if (!hasError) {
-          
+
           protected_type_declaration();
           }
           if (!hasError) {
-          
+
 return "";
           }
-          
+
           break;
           }
         default:
@@ -10293,29 +10293,29 @@ assert(false);
 
 
 QCString VhdlParser::type_mark() {QCString s;if (!hasError) {
-    
+
     s = name();
     }
-    
+
 return s;
 assert(false);
 }
 
 
 QCString VhdlParser::unconstraint_array_definition() {QCString s,s1,s2,s3;if (!hasError) {
-    
+
     jj_consume_token(ARRAY_T);
     }
     if (!hasError) {
-    
+
     jj_consume_token(LPAREN_T);
     }
     if (!hasError) {
-    
+
     s = index_subtype_definition();
     }
     if (!hasError) {
-    
+
     while (!hasError) {
       switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
       case COMMA_T:{
@@ -10326,49 +10326,49 @@ QCString VhdlParser::unconstraint_array_definition() {QCString s,s1,s2,s3;if (!h
         jj_la1[230] = jj_gen;
         goto end_label_44;
       }if (!hasError) {
-      
+
       jj_consume_token(COMMA_T);
       }
       if (!hasError) {
-      
+
       s1 = index_subtype_definition();
       }
       if (!hasError) {
-      
+
 s3+=",";s3+=s1;
       }
-      
+
     }
     end_label_44: ;
     }
     if (!hasError) {
-    
+
     jj_consume_token(RPAREN_T);
     }
     if (!hasError) {
-    
+
     jj_consume_token(OF_T);
     }
     if (!hasError) {
-    
+
     s2 = subtype_indication();
     }
-    
+
 return "array("+s+s3+") of "+s2;
 assert(false);
 }
 
 
 QCString VhdlParser::use_clause() {QCString s,s1;if (!hasError) {
-    
+
     jj_consume_token(USE_T);
     }
     if (!hasError) {
-    
+
     s = selected_name();
     }
     if (!hasError) {
-    
+
     while (!hasError) {
       switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
       case COMMA_T:{
@@ -10379,26 +10379,26 @@ QCString VhdlParser::use_clause() {QCString s,s1;if (!hasError) {
         jj_la1[231] = jj_gen;
         goto end_label_45;
       }if (!hasError) {
-      
+
       jj_consume_token(COMMA_T);
       }
       if (!hasError) {
-      
+
       s1 = selected_name();
       }
       if (!hasError) {
-      
+
 s+=",";s+=s1;
       }
-      
+
     }
     end_label_45: ;
     }
     if (!hasError) {
-    
+
     jj_consume_token(SEMI_T);
     }
-    
+
 QStringList ql1=QStringList::split(",",s,FALSE);
                    for (uint j=0;j<ql1.count();j++)
                    {
@@ -10422,56 +10422,56 @@ QCString VhdlParser::variable_assignment_statement() {QCString s,s1,s2;
     case STRINGLITERAL:
     case BASIC_IDENTIFIER:
     case EXTENDED_CHARACTER:{if (!hasError) {
-      
+
       if (jj_2_103(2)) {if (!hasError) {
-        
+
         s = identifier();
         }
         if (!hasError) {
-        
+
         jj_consume_token(COLON_T);
         }
         if (!hasError) {
-        
+
 s+=":";
         }
-        
+
       } else {
         ;
       }
       }
       if (!hasError) {
-      
+
       s1 = target();
       }
       if (!hasError) {
-      
+
       jj_consume_token(VARASSIGN_T);
       }
       if (!hasError) {
-      
+
       s2 = expression();
       }
       if (!hasError) {
-      
+
       jj_consume_token(SEMI_T);
       }
       if (!hasError) {
-      
+
 return s+s1+":="+s2+";";
       }
-      
+
       break;
       }
     case WITH_T:{if (!hasError) {
-      
+
       selected_variable_assignment();
       }
       if (!hasError) {
-      
+
 return "";
       }
-      
+
       break;
       }
     default:
@@ -10484,13 +10484,13 @@ assert(false);
 
 
 QCString VhdlParser::variable_declaration() {Token *tok=0;Token *t1=0;QCString s,s1,s2;if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case SHARED_T:{if (!hasError) {
-      
+
       tok = jj_consume_token(SHARED_T);
       }
-      
+
       break;
       }
     default:
@@ -10499,33 +10499,33 @@ QCString VhdlParser::variable_declaration() {Token *tok=0;Token *t1=0;QCString s
     }
     }
     if (!hasError) {
-    
+
     jj_consume_token(VARIABLE_T);
     }
     if (!hasError) {
-    
+
     s = identifier_list();
     }
     if (!hasError) {
-    
+
     jj_consume_token(COLON_T);
     }
     if (!hasError) {
-    
+
     s1 = subtype_indication();
     }
     if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case VARASSIGN_T:{if (!hasError) {
-      
+
       t1 = jj_consume_token(VARASSIGN_T);
       }
       if (!hasError) {
-      
+
       s2 = expression();
       }
-      
+
       break;
       }
     default:
@@ -10534,10 +10534,10 @@ QCString VhdlParser::variable_declaration() {Token *tok=0;Token *t1=0;QCString s
     }
     }
     if (!hasError) {
-    
+
     jj_consume_token(SEMI_T);
     }
-    
+
 int spec;
     if(t1)
      s2.prepend(":=");
@@ -10563,18 +10563,18 @@ assert(false);
 
 
 QCString VhdlParser::wait_statement() {QCString s,s1,s2,s3;Token *t=0;if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case BASIC_IDENTIFIER:
     case EXTENDED_CHARACTER:{if (!hasError) {
-      
+
       s = identifier();
       }
       if (!hasError) {
-      
+
       t = jj_consume_token(COLON_T);
       }
-      
+
       break;
       }
     default:
@@ -10583,17 +10583,17 @@ QCString VhdlParser::wait_statement() {QCString s,s1,s2,s3;Token *t=0;if (!hasEr
     }
     }
     if (!hasError) {
-    
+
     jj_consume_token(WAIT_T);
     }
     if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case ON_T:{if (!hasError) {
-      
+
       s1 = sensitivity_clause();
       }
-      
+
       break;
       }
     default:
@@ -10602,13 +10602,13 @@ QCString VhdlParser::wait_statement() {QCString s,s1,s2,s3;Token *t=0;if (!hasEr
     }
     }
     if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case UNTIL_T:{if (!hasError) {
-      
+
       s2 = condition_clause();
       }
-      
+
       break;
       }
     default:
@@ -10617,13 +10617,13 @@ QCString VhdlParser::wait_statement() {QCString s,s1,s2,s3;Token *t=0;if (!hasEr
     }
     }
     if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case FOR_T:{if (!hasError) {
-      
+
       s3 = timeout_clause();
       }
-      
+
       break;
       }
     default:
@@ -10632,10 +10632,10 @@ QCString VhdlParser::wait_statement() {QCString s,s1,s2,s3;Token *t=0;if (!hasEr
     }
     }
     if (!hasError) {
-    
+
     jj_consume_token(SEMI_T);
     }
-    
+
 if(t) s.append(":");
   return s+" wait "+s1+s2+s3+";";
 assert(false);
@@ -10660,11 +10660,11 @@ QCString VhdlParser::waveform() {QCString s,s1;
     case DECIMAL_LITERAL:
     case BASED_LITERAL:
     case BIT_STRING_LITERAL:{if (!hasError) {
-      
+
       s = waveform_element();
       }
       if (!hasError) {
-      
+
       while (!hasError) {
         switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
         case COMMA_T:{
@@ -10675,37 +10675,37 @@ QCString VhdlParser::waveform() {QCString s,s1;
           jj_la1[239] = jj_gen;
           goto end_label_46;
         }if (!hasError) {
-        
+
         jj_consume_token(COMMA_T);
         }
         if (!hasError) {
-        
+
         s1 = waveform_element();
         }
         if (!hasError) {
-        
+
 s+=","; s+=s1;
         }
-        
+
       }
       end_label_46: ;
       }
       if (!hasError) {
-      
+
 return s;
       }
-      
+
       break;
       }
     case UNAFFECTED_T:{if (!hasError) {
-      
+
       jj_consume_token(UNAFFECTED_T);
       }
       if (!hasError) {
-      
+
 return " unaffected ";
       }
-      
+
       break;
       }
     default:
@@ -10718,25 +10718,25 @@ assert(false);
 
 
 QCString VhdlParser::waveform_element() {QCString s,s1;if (!hasError) {
-    
+
     s = expression();
     }
     if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case AFTER_T:{if (!hasError) {
-      
+
       jj_consume_token(AFTER_T);
       }
       if (!hasError) {
-      
+
       s1 = expression();
       }
       if (!hasError) {
-      
+
 s1.prepend(" after ");
       }
-      
+
       break;
       }
     default:
@@ -10744,45 +10744,45 @@ s1.prepend(" after ");
       ;
     }
     }
-    
+
 return s+s1;
 assert(false);
 }
 
 
 QCString VhdlParser::protected_type_body() {if (!hasError) {
-    
+
     jj_consume_token(PROTECTED_T);
     }
     if (!hasError) {
-    
+
     jj_consume_token(BODY_T);
     }
     if (!hasError) {
-    
+
     protected_type_body_declarative_part();
     }
     if (!hasError) {
-    
+
     jj_consume_token(END_T);
     }
     if (!hasError) {
-    
+
     jj_consume_token(PROTECTED_T);
     }
     if (!hasError) {
-    
+
     jj_consume_token(BODY_T);
     }
     if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case BASIC_IDENTIFIER:
     case EXTENDED_CHARACTER:{if (!hasError) {
-      
+
       identifier();
       }
-      
+
       break;
       }
     default:
@@ -10790,7 +10790,7 @@ QCString VhdlParser::protected_type_body() {if (!hasError) {
       ;
     }
     }
-    
+
 return "";
 assert(false);
 }
@@ -10802,99 +10802,99 @@ void VhdlParser::protected_type_body_declarative_item() {
     case IMPURE_T:
     case PROCEDURE_T:
     case PURE_T:{if (!hasError) {
-      
+
       subprogram_declaration();
       }
-      
+
       break;
       }
     case IS_T:{if (!hasError) {
-      
+
       subprogram_body();
       }
-      
+
       break;
       }
     case TYPE_T:{if (!hasError) {
-      
+
       type_declaration();
       }
-      
+
       break;
       }
     case SUBTYPE_T:{if (!hasError) {
-      
+
       subtype_declaration();
       }
-      
+
       break;
       }
     case CONSTANT_T:{if (!hasError) {
-      
+
       constant_declaration();
       }
-      
+
       break;
       }
     case SHARED_T:
     case VARIABLE_T:{if (!hasError) {
-      
+
       variable_declaration();
       }
-      
+
       break;
       }
     case FILE_T:{if (!hasError) {
-      
+
       file_declaration();
       }
-      
+
       break;
       }
     case ALIAS_T:{if (!hasError) {
-      
+
       alias_declaration();
       }
-      
+
       break;
       }
     default:
       jj_la1[243] = jj_gen;
       if (jj_2_104(2147483647)) {if (!hasError) {
-        
+
         attribute_declaration();
         }
-        
+
       } else {
         switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
         case ATTRIBUTE_T:{if (!hasError) {
-          
+
           attribute_specification();
           }
-          
+
           break;
           }
         case USE_T:{if (!hasError) {
-          
+
           use_clause();
           }
-          
+
           break;
           }
         default:
           jj_la1[244] = jj_gen;
           if (jj_2_105(3)) {if (!hasError) {
-            
+
             group_template_declaration();
             }
-            
+
           } else {
             switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
             case GROUP_T:{if (!hasError) {
-              
+
               group_declaration();
               }
-              
+
               break;
               }
             default:
@@ -10910,7 +10910,7 @@ void VhdlParser::protected_type_body_declarative_item() {
 
 
 void VhdlParser::protected_type_body_declarative_part() {if (!hasError) {
-    
+
     while (!hasError) {
       switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
       case ALIAS_T:
@@ -10935,49 +10935,49 @@ void VhdlParser::protected_type_body_declarative_part() {if (!hasError) {
         jj_la1[246] = jj_gen;
         goto end_label_47;
       }if (!hasError) {
-      
+
       protected_type_body_declarative_item();
       }
-      
+
     }
     end_label_47: ;
     }
-    
+
 }
 
 
 QCString VhdlParser::protected_type_declaration() {if (!hasError) {
-    
+
     jj_consume_token(PROTECTED_T);
     }
     if (!hasError) {
-    
+
     try {if (!hasError) {
-      
+
       protected_type_declarative_part();
       }
-      
+
     } catch ( ...) {
 error_skipto(END_T);
     }
     }
     if (!hasError) {
-    
+
     jj_consume_token(END_T);
     }
     if (!hasError) {
-    
+
     jj_consume_token(PROTECTED_T);
     }
     if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case BASIC_IDENTIFIER:
     case EXTENDED_CHARACTER:{if (!hasError) {
-      
+
       identifier();
       }
-      
+
       break;
       }
     default:
@@ -10985,7 +10985,7 @@ error_skipto(END_T);
       ;
     }
     }
-    
+
 return "";
 assert(false);
 }
@@ -10997,24 +10997,24 @@ void VhdlParser::protected_type_declarative_item() {
     case IMPURE_T:
     case PROCEDURE_T:
     case PURE_T:{if (!hasError) {
-      
+
       subprogram_specification();
       }
-      
+
       break;
       }
     case ATTRIBUTE_T:{if (!hasError) {
-      
+
       attribute_specification();
       }
-      
+
       break;
       }
     case USE_T:{if (!hasError) {
-      
+
       use_clause();
       }
-      
+
       break;
       }
     default:
@@ -11026,7 +11026,7 @@ void VhdlParser::protected_type_declarative_item() {
 
 
 void VhdlParser::protected_type_declarative_part() {if (!hasError) {
-    
+
     while (!hasError) {
       switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
       case ATTRIBUTE_T:
@@ -11042,57 +11042,57 @@ void VhdlParser::protected_type_declarative_part() {if (!hasError) {
         jj_la1[249] = jj_gen;
         goto end_label_48;
       }if (!hasError) {
-      
+
       protected_type_declarative_item();
       }
       if (!hasError) {
-      
+
       jj_consume_token(SEMI_T);
       }
-      
+
     }
     end_label_48: ;
     }
-    
+
 }
 
 
 QCString VhdlParser::context_ref() {QCString s;if (!hasError) {
-    
+
     jj_consume_token(CONTEXT_T);
     }
     if (!hasError) {
-    
+
     s = identifier_list();
     }
     if (!hasError) {
-    
+
     jj_consume_token(SEMI_T);
     }
-    
+
 return "context "+s ;
 assert(false);
 }
 
 
 void VhdlParser::context_declaration() {QCString s,s1;if (!hasError) {
-    
+
     jj_consume_token(CONTEXT_T);
     }
     if (!hasError) {
-    
+
     s = identifier();
     }
     if (!hasError) {
-    
+
     jj_consume_token(IS_T);
     }
     if (!hasError) {
-    
+
 parse_sec=CONTEXT_SEC;
     }
     if (!hasError) {
-    
+
     while (!hasError) {
       switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
       case CONTEXT_T:
@@ -11105,25 +11105,25 @@ parse_sec=CONTEXT_SEC;
         jj_la1[250] = jj_gen;
         goto end_label_49;
       }if (!hasError) {
-      
+
       s1 = libustcont_stats();
       }
-      
+
     }
     end_label_49: ;
     }
     if (!hasError) {
-    
+
     jj_consume_token(END_T);
     }
     if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case CONTEXT_T:{if (!hasError) {
-      
+
       jj_consume_token(CONTEXT_T);
       }
-      
+
       break;
       }
     default:
@@ -11132,14 +11132,14 @@ parse_sec=CONTEXT_SEC;
     }
     }
     if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case BASIC_IDENTIFIER:
     case EXTENDED_CHARACTER:{if (!hasError) {
-      
+
       identifier();
       }
-      
+
       break;
       }
     default:
@@ -11148,10 +11148,10 @@ parse_sec=CONTEXT_SEC;
     }
     }
     if (!hasError) {
-    
+
     jj_consume_token(SEMI_T);
     }
-    
+
 parse_sec=0;
                           addVhdlType(s.data(),getLine(LIBRARY_T),Entry::VARIABLE_SEC,VhdlDocGen::LIBRARY,"context",s1.data(),Public);
 }
@@ -11160,36 +11160,36 @@ parse_sec=0;
 QCString VhdlParser::libustcont_stats() {QCString s;
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case USE_T:{if (!hasError) {
-      
+
       s = use_clause();
       }
       if (!hasError) {
-      
+
 return s;
       }
-      
+
       break;
       }
     case LIBRARY_T:{if (!hasError) {
-      
+
       s = library_clause();
       }
       if (!hasError) {
-      
+
 return s;
       }
-      
+
       break;
       }
     case CONTEXT_T:{if (!hasError) {
-      
+
       s = context_ref();
       }
       if (!hasError) {
-      
+
 return s;
       }
-      
+
       break;
       }
     default:
@@ -11202,37 +11202,37 @@ assert(false);
 
 
 void VhdlParser::package_instantiation_declaration() {QCString s,s1,s2;if (!hasError) {
-    
+
     jj_consume_token(PACKAGE_T);
     }
     if (!hasError) {
-    
+
     s = identifier();
     }
     if (!hasError) {
-    
+
     jj_consume_token(IS_T);
     }
     if (!hasError) {
-    
+
     jj_consume_token(NEW_T);
     }
     if (!hasError) {
-    
+
     s1 = name();
     }
     if (!hasError) {
-    
+
     s2 = signature();
     }
     if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case GENERIC_T:{if (!hasError) {
-      
+
       gen_assoc_list();
       }
-      
+
       break;
       }
     default:
@@ -11241,43 +11241,43 @@ void VhdlParser::package_instantiation_declaration() {QCString s,s1,s2;if (!hasE
     }
     }
     if (!hasError) {
-    
+
     jj_consume_token(SEMI_T);
     }
-    
+
 QCString q=" is new "+s1+s2;
       addVhdlType(s.data(),getLine(PACKAGE_T),Entry::VARIABLE_SEC,VhdlDocGen::INSTANTIATION,"package",q.data(),Public);
 }
 
 
 QCString VhdlParser::interface_package_declaration() {QCString s,s1;if (!hasError) {
-    
+
     jj_consume_token(PACKAGE_T);
     }
     if (!hasError) {
-    
+
     s = identifier();
     }
     if (!hasError) {
-    
+
     jj_consume_token(IS_T);
     }
     if (!hasError) {
-    
+
     jj_consume_token(NEW_T);
     }
     if (!hasError) {
-    
+
     s1 = name();
     }
     if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case GENERIC_T:{if (!hasError) {
-      
+
       gen_assoc_list();
       }
-      
+
       break;
       }
     default:
@@ -11285,7 +11285,7 @@ QCString VhdlParser::interface_package_declaration() {QCString s,s1;if (!hasErro
       ;
     }
     }
-    
+
 current->name=s;
                             return "package "+s+" is new "+s1;
 assert(false);
@@ -11293,37 +11293,37 @@ assert(false);
 
 
 QCString VhdlParser::subprogram_instantiation_declaration() {QCString s,s1,s2;if (!hasError) {
-    
+
     jj_consume_token(FUNCTION_T);
     }
     if (!hasError) {
-    
+
     s = identifier();
     }
     if (!hasError) {
-    
+
     jj_consume_token(IS_T);
     }
     if (!hasError) {
-    
+
     jj_consume_token(NEW_T);
     }
     if (!hasError) {
-    
+
     s1 = name();
     }
     if (!hasError) {
-    
+
     s2 = signature();
     }
     if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case GENERIC_T:{if (!hasError) {
-      
+
       gen_assoc_list();
       }
-      
+
       break;
       }
     default:
@@ -11332,10 +11332,10 @@ QCString VhdlParser::subprogram_instantiation_declaration() {QCString s,s1,s2;if
     }
     }
     if (!hasError) {
-    
+
     jj_consume_token(SEMI_T);
     }
-    
+
 QCString q= " is new "+s1+s2;
       addVhdlType(s.data(),getLine(FUNCTION_T),Entry::VARIABLE_SEC,VhdlDocGen::INSTANTIATION,"function ",q.data(),Public);
     return q;
@@ -11344,140 +11344,140 @@ assert(false);
 
 
 void VhdlParser::gen_assoc_list() {if (!hasError) {
-    
+
     jj_consume_token(GENERIC_T);
     }
     if (!hasError) {
-    
+
     jj_consume_token(MAP_T);
     }
     if (!hasError) {
-    
+
     jj_consume_token(LPAREN_T);
     }
     if (!hasError) {
-    
+
     association_list();
     }
     if (!hasError) {
-    
+
     jj_consume_token(RPAREN_T);
     }
-    
+
 }
 
 
 void VhdlParser::gen_interface_list() {if (!hasError) {
-    
+
     jj_consume_token(GENERIC_T);
     }
     if (!hasError) {
-    
+
     jj_consume_token(LPAREN_T);
     }
     if (!hasError) {
-    
+
 //int u=s_str.iLine;
                           parse_sec=GEN_SEC;
     }
     if (!hasError) {
-    
+
     interface_list();
     }
     if (!hasError) {
-    
+
 //  QCString vo=$3;
                           parse_sec=0;
     }
     if (!hasError) {
-    
+
     jj_consume_token(RPAREN_T);
     }
-    
+
 }
 
 
 void VhdlParser::case_scheme() {if (!hasError) {
-    
+
     jj_consume_token(CASE_T);
     }
     if (!hasError) {
-    
+
     expression();
     }
     if (!hasError) {
-    
+
     jj_consume_token(GENERATE_T);
     }
     if (!hasError) {
-    
+
     when_stats();
     }
     if (!hasError) {
-    
+
     if (jj_2_106(3)) {if (!hasError) {
-      
+
       ttend();
       }
-      
+
     } else {
       ;
     }
     }
     if (!hasError) {
-    
+
     jj_consume_token(END_T);
     }
     if (!hasError) {
-    
+
     jj_consume_token(GENERATE_T);
     }
     if (!hasError) {
-    
+
     generate_statement_body();
     }
     if (!hasError) {
-    
+
     jj_consume_token(SEMI_T);
     }
-    
+
 }
 
 
 void VhdlParser::when_stats() {if (!hasError) {
-    
+
     while (!hasError) {if (!hasError) {
-      
+
       jj_consume_token(WHEN_T);
       }
       if (!hasError) {
-      
+
       if (jj_2_107(2)) {if (!hasError) {
-        
+
         label();
         }
         if (!hasError) {
-        
+
         jj_consume_token(COLON_T);
         }
-        
+
       } else {
         ;
       }
       }
       if (!hasError) {
-      
+
       choices();
       }
       if (!hasError) {
-      
+
       jj_consume_token(ARROW_T);
       }
       if (!hasError) {
-      
+
       generate_statement_body();
       }
-      
+
       switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
       case WHEN_T:{
         ;
@@ -11490,23 +11490,23 @@ void VhdlParser::when_stats() {if (!hasError) {
     }
     end_label_50: ;
     }
-    
+
 }
 
 
 void VhdlParser::ttend() {if (!hasError) {
-    
+
     jj_consume_token(END_T);
     }
     if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case BASIC_IDENTIFIER:
     case EXTENDED_CHARACTER:{if (!hasError) {
-      
+
       identifier();
       }
-      
+
       break;
       }
     default:
@@ -11515,22 +11515,22 @@ void VhdlParser::ttend() {if (!hasError) {
     }
     }
     if (!hasError) {
-    
+
     jj_consume_token(SEMI_T);
     }
-    
+
 }
 
 
 void VhdlParser::generate_statement_body() {if (!hasError) {
-    
+
     jj_consume_token(BEGIN_T);
     }
     if (!hasError) {
-    
+
     generate_statement_body();
     }
-    
+
 }
 
 
@@ -11556,25 +11556,25 @@ void VhdlParser::generate_statement_body1() {if (!hasError) {
     case TYPE_T:
     case USE_T:
     case VARIABLE_T:{if (!hasError) {
-      
+
       while (!hasError) {
         if (jj_2_108(2147483647)) {
           ;
         } else {
           goto end_label_51;
         }if (!hasError) {
-        
+
         block_declarative_item();
         }
-        
+
       }
       end_label_51: ;
       }
       if (!hasError) {
-      
+
       jj_consume_token(BEGIN_T);
       }
-      
+
       break;
       }
     default:
@@ -11607,44 +11607,39 @@ void VhdlParser::generate_statement_body1() {if (!hasError) {
 
       concurrent_statement();
       }
-      
+
     }
     end_label_52: ;
     }
-<<<<<<< HEAD
 
-  }
-=======
-    
 }
->>>>>>> 59a8f09137ebfc25c2f238a417088b50b8fbb631
 
 
 QCString VhdlParser::external_name() {QCString s,s1,s2;if (!hasError) {
-    
+
     jj_consume_token(SLSL_T);
     }
     if (!hasError) {
-    
+
     s = sig_stat();
     }
     if (!hasError) {
-    
+
     s1 = external_pathname();
     }
     if (!hasError) {
-    
+
     jj_consume_token(COLON_T);
     }
     if (!hasError) {
-    
+
     s2 = subtype_indication();
     }
     if (!hasError) {
-    
+
     jj_consume_token(RSRS_T);
     }
-    
+
 QCString t="<<"+s;
                          QCString t1=s1+":"+s2+">>";
                          return   s+s1;
@@ -11655,36 +11650,36 @@ assert(false);
 QCString VhdlParser::sig_stat() {Token *t;
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case CONSTANT_T:{if (!hasError) {
-      
+
       t = jj_consume_token(CONSTANT_T);
       }
       if (!hasError) {
-      
+
 return t->image.data();
       }
-      
+
       break;
       }
     case SIGNAL_T:{if (!hasError) {
-      
+
       t = jj_consume_token(SIGNAL_T);
       }
       if (!hasError) {
-      
+
 return t->image.data();
       }
-      
+
       break;
       }
     case VARIABLE_T:{if (!hasError) {
-      
+
       t = jj_consume_token(VARIABLE_T);
       }
       if (!hasError) {
-      
+
 return t->image.data();
       }
-      
+
       break;
       }
     default:
@@ -11699,36 +11694,36 @@ assert(false);
 QCString VhdlParser::external_pathname() {QCString s;
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case DOT_T:{if (!hasError) {
-      
+
       s = absolute_pathname();
       }
       if (!hasError) {
-      
+
 return s;
       }
-      
+
       break;
       }
     case NEG_T:{if (!hasError) {
-      
+
       s = relative_pathname();
       }
       if (!hasError) {
-      
+
 return s;
       }
-      
+
       break;
       }
     case AT_T:{if (!hasError) {
-      
+
       s = package_path_name();
       }
       if (!hasError) {
-      
+
 return s;
       }
-      
+
       break;
       }
     default:
@@ -11742,37 +11737,37 @@ assert(false);
 
 QCString VhdlParser::absolute_pathname() {QCString s,s1;
     if (jj_2_109(2147483647)) {if (!hasError) {
-      
+
       jj_consume_token(DOT_T);
       }
       if (!hasError) {
-      
+
       s = pathname_element_list();
       }
       if (!hasError) {
-      
+
       s1 = identifier();
       }
       if (!hasError) {
-      
+
 return "."+s+s1;
       }
-      
+
     } else {
       switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
       case DOT_T:{if (!hasError) {
-        
+
         jj_consume_token(DOT_T);
         }
         if (!hasError) {
-        
+
         s = identifier();
         }
         if (!hasError) {
-        
+
 return "."+s;
         }
-        
+
         break;
         }
       default:
@@ -11786,45 +11781,45 @@ assert(false);
 
 
 QCString VhdlParser::relative_pathname() {QCString s,s1,s2;if (!hasError) {
-    
+
     s = neg_list();
     }
     if (!hasError) {
-    
+
     if (jj_2_110(2147483647)) {if (!hasError) {
-      
+
       s1 = pathname_element_list();
       }
-      
+
     } else {
       ;
     }
     }
     if (!hasError) {
-    
+
     s2 = identifier();
     }
-    
+
 return s+s1+s2;
 assert(false);
 }
 
 
 QCString VhdlParser::neg_list() {QCString s;if (!hasError) {
-    
+
     while (!hasError) {if (!hasError) {
-      
+
       jj_consume_token(NEG_T);
       }
       if (!hasError) {
-      
+
       jj_consume_token(DOT_T);
       }
       if (!hasError) {
-      
+
 s+="^.";
       }
-      
+
       switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
       case NEG_T:{
         ;
@@ -11837,32 +11832,32 @@ s+="^.";
     }
     end_label_53: ;
     }
-    
+
 return s;
 assert(false);
 }
 
 
 QCString VhdlParser::pathname_element() {QCString s,s1;if (!hasError) {
-    
+
     s = identifier();
     }
     if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case LPAREN_T:{if (!hasError) {
-      
+
       jj_consume_token(LPAREN_T);
       }
       if (!hasError) {
-      
+
       s1 = expression();
       }
       if (!hasError) {
-      
+
       jj_consume_token(RPAREN_T);
       }
-      
+
       break;
       }
     default:
@@ -11870,7 +11865,7 @@ QCString VhdlParser::pathname_element() {QCString s,s1;if (!hasError) {
       ;
     }
     }
-    
+
 if(!s1.isEmpty())
      return s+"("+s1+")";
 
@@ -11881,57 +11876,57 @@ assert(false);
 
 QCString VhdlParser::pathname_element_list() {QCString s,s1,s2;if (!hasError) {
     if (!hasError) {
-    
+
     s = pathname_element();
     }
     if (!hasError) {
-    
+
     jj_consume_token(DOT_T);
     }
-    
+
     }
     if (!hasError) {
-    
+
 s+=".";
     }
     if (!hasError) {
-    
+
     while (!hasError) {
       if (jj_2_111(2147483647)) {
         ;
       } else {
         goto end_label_54;
       }if (!hasError) {
-      
+
       s1 = pathname_element();
       }
       if (!hasError) {
-      
+
       jj_consume_token(DOT_T);
       }
       if (!hasError) {
-      
+
 s2+=s1;s2+=".";
       }
-      
+
     }
     end_label_54: ;
     }
-    
+
 return s+s2;
 assert(false);
 }
 
 
 QCString VhdlParser::package_path_name() {QCString s;if (!hasError) {
-    
+
     jj_consume_token(AT_T);
     }
     if (!hasError) {
-    
+
     s = name();
     }
-    
+
 return "@"+s;
 assert(false);
 }
@@ -11939,10 +11934,10 @@ assert(false);
 
 void VhdlParser::conditional_signal_assignment_wave() {
     if (jj_2_112(2147483647)) {if (!hasError) {
-      
+
       conditional_force_assignment();
       }
-      
+
     } else {
       switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
       case LPAREN_T:
@@ -11950,10 +11945,10 @@ void VhdlParser::conditional_signal_assignment_wave() {
       case STRINGLITERAL:
       case BASIC_IDENTIFIER:
       case EXTENDED_CHARACTER:{if (!hasError) {
-        
+
         conditional_waveform_assignment();
         }
-        
+
         break;
         }
       default:
@@ -11966,23 +11961,23 @@ void VhdlParser::conditional_signal_assignment_wave() {
 
 
 void VhdlParser::conditional_waveform_assignment() {if (!hasError) {
-    
+
     target();
     }
     if (!hasError) {
-    
+
     jj_consume_token(LESSTHAN_T);
     }
     if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case INERTIAL_T:
     case REJECT_T:
     case TRANSPORT_T:{if (!hasError) {
-      
+
       delay_mechanism();
       }
-      
+
       break;
       }
     default:
@@ -11991,25 +11986,25 @@ void VhdlParser::conditional_waveform_assignment() {if (!hasError) {
     }
     }
     if (!hasError) {
-    
+
     waveform_element();
     }
     if (!hasError) {
-    
+
     jj_consume_token(WHEN_T);
     }
     if (!hasError) {
-    
+
     expression();
     }
     if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case ELSE_T:{if (!hasError) {
-      
+
       else_wave_list();
       }
-      
+
       break;
       }
     default:
@@ -12018,33 +12013,33 @@ void VhdlParser::conditional_waveform_assignment() {if (!hasError) {
     }
     }
     if (!hasError) {
-    
+
     jj_consume_token(SEMI_T);
     }
-    
+
 }
 
 
 void VhdlParser::else_wave_list() {if (!hasError) {
-    
+
     jj_consume_token(ELSE_T);
     }
     if (!hasError) {
-    
+
     expression();
     }
     if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case WHEN_T:{if (!hasError) {
-      
+
       jj_consume_token(WHEN_T);
       }
       if (!hasError) {
-      
+
       expression();
       }
-      
+
       break;
       }
     default:
@@ -12052,31 +12047,31 @@ void VhdlParser::else_wave_list() {if (!hasError) {
       ;
     }
     }
-    
+
 }
 
 
 void VhdlParser::conditional_force_assignment() {if (!hasError) {
-    
+
     target();
     }
     if (!hasError) {
-    
+
     jj_consume_token(LESSTHAN_T);
     }
     if (!hasError) {
-    
+
     jj_consume_token(FORCE_T);
     }
     if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case IN_T:
     case OUT_T:{if (!hasError) {
-      
+
       inout_stat();
       }
-      
+
       break;
       }
     default:
@@ -12085,15 +12080,15 @@ void VhdlParser::conditional_force_assignment() {if (!hasError) {
     }
     }
     if (!hasError) {
-    
+
     expression();
     }
     if (!hasError) {
-    
+
     jj_consume_token(WHEN_T);
     }
     if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case ABS_T:
     case NEW_T:
@@ -12111,14 +12106,14 @@ void VhdlParser::conditional_force_assignment() {if (!hasError) {
     case DECIMAL_LITERAL:
     case BASED_LITERAL:
     case BIT_STRING_LITERAL:{if (!hasError) {
-      
+
       expression();
       }
       if (!hasError) {
-      
+
       else_stat();
       }
-      
+
       break;
       }
     default:
@@ -12127,26 +12122,26 @@ void VhdlParser::conditional_force_assignment() {if (!hasError) {
     }
     }
     if (!hasError) {
-    
+
     jj_consume_token(SEMI_T);
     }
-    
+
 }
 
 
 void VhdlParser::selected_signal_assignment_wave() {
     if (jj_2_113(2147483647)) {if (!hasError) {
-      
+
       selected_force_assignment();
       }
-      
+
     } else {
       switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
       case WITH_T:{if (!hasError) {
-        
+
         selected_waveform_assignment();
         }
-        
+
         break;
         }
       default:
@@ -12159,25 +12154,25 @@ void VhdlParser::selected_signal_assignment_wave() {
 
 
 void VhdlParser::selected_variable_assignment() {if (!hasError) {
-    
+
     jj_consume_token(WITH_T);
     }
     if (!hasError) {
-    
+
     expression();
     }
     if (!hasError) {
-    
+
     jj_consume_token(SELECT_T);
     }
     if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case Q_T:{if (!hasError) {
-      
+
       jj_consume_token(Q_T);
       }
-      
+
       break;
       }
     default:
@@ -12186,37 +12181,37 @@ void VhdlParser::selected_variable_assignment() {if (!hasError) {
     }
     }
     if (!hasError) {
-    
+
     select_name();
     }
     if (!hasError) {
-    
+
     jj_consume_token(VARASSIGN_T);
     }
     if (!hasError) {
-    
+
     sel_var_list();
     }
-    
+
 }
 
 
 void VhdlParser::select_name() {
     if (jj_2_114(2147483647)) {if (!hasError) {
-      
+
       aggregate();
       }
-      
+
     } else {
       switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
       case SLSL_T:
       case STRINGLITERAL:
       case BASIC_IDENTIFIER:
       case EXTENDED_CHARACTER:{if (!hasError) {
-        
+
         name();
         }
-        
+
         break;
         }
       default:
@@ -12229,25 +12224,25 @@ void VhdlParser::select_name() {
 
 
 void VhdlParser::selected_waveform_assignment() {if (!hasError) {
-    
+
     jj_consume_token(WITH_T);
     }
     if (!hasError) {
-    
+
     expression();
     }
     if (!hasError) {
-    
+
     jj_consume_token(SELECT_T);
     }
     if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case Q_T:{if (!hasError) {
-      
+
       jj_consume_token(Q_T);
       }
-      
+
       break;
       }
     default:
@@ -12256,23 +12251,23 @@ void VhdlParser::selected_waveform_assignment() {if (!hasError) {
     }
     }
     if (!hasError) {
-    
+
     target();
     }
     if (!hasError) {
-    
+
     jj_consume_token(LESSTHAN_T);
     }
     if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case INERTIAL_T:
     case REJECT_T:
     case TRANSPORT_T:{if (!hasError) {
-      
+
       delay_mechanism();
       }
-      
+
       break;
       }
     default:
@@ -12281,33 +12276,33 @@ void VhdlParser::selected_waveform_assignment() {if (!hasError) {
     }
     }
     if (!hasError) {
-    
+
     sel_wave_list();
     }
-    
+
 }
 
 
 void VhdlParser::selected_force_assignment() {if (!hasError) {
-    
+
     jj_consume_token(WITH_T);
     }
     if (!hasError) {
-    
+
     expression();
     }
     if (!hasError) {
-    
+
     jj_consume_token(SELECT_T);
     }
     if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case Q_T:{if (!hasError) {
-      
+
       jj_consume_token(Q_T);
       }
-      
+
       break;
       }
     default:
@@ -12316,26 +12311,26 @@ void VhdlParser::selected_force_assignment() {if (!hasError) {
     }
     }
     if (!hasError) {
-    
+
     target();
     }
     if (!hasError) {
-    
+
     jj_consume_token(LESSTHAN_T);
     }
     if (!hasError) {
-    
+
     jj_consume_token(FORCE_T);
     }
     if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case IN_T:
     case OUT_T:{if (!hasError) {
-      
+
       inout_stat();
       }
-      
+
       break;
       }
     default:
@@ -12344,41 +12339,41 @@ void VhdlParser::selected_force_assignment() {if (!hasError) {
     }
     }
     if (!hasError) {
-    
+
     sel_var_list();
     }
-    
+
 }
 
 
 void VhdlParser::sel_var_list() {if (!hasError) {
     if (!hasError) {
-    
+
     expression();
     }
     if (!hasError) {
-    
+
     jj_consume_token(WHEN_T);
     }
     if (!hasError) {
-    
+
     choices();
     }
     if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case COMMA_T:{if (!hasError) {
-      
+
       jj_consume_token(COMMA_T);
       }
-      
+
       break;
       }
     case SEMI_T:{if (!hasError) {
-      
+
       jj_consume_token(SEMI_T);
       }
-      
+
       break;
       }
     default:
@@ -12387,42 +12382,42 @@ void VhdlParser::sel_var_list() {if (!hasError) {
       errorHandler->handleParseError(token, getToken(1), __FUNCTION__, this), hasError = true;
     }
     }
-    
+
     }
     if (!hasError) {
-    
+
     while (!hasError) {
       if (jj_2_115(2147483647)) {
         ;
       } else {
         goto end_label_55;
       }if (!hasError) {
-      
+
       expression();
       }
       if (!hasError) {
-      
+
       jj_consume_token(WHEN_T);
       }
       if (!hasError) {
-      
+
       choices();
       }
       if (!hasError) {
-      
+
       switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
       case COMMA_T:{if (!hasError) {
-        
+
         jj_consume_token(COMMA_T);
         }
-        
+
         break;
         }
       case SEMI_T:{if (!hasError) {
-        
+
         jj_consume_token(SEMI_T);
         }
-        
+
         break;
         }
       default:
@@ -12431,28 +12426,28 @@ void VhdlParser::sel_var_list() {if (!hasError) {
         errorHandler->handleParseError(token, getToken(1), __FUNCTION__, this), hasError = true;
       }
       }
-      
+
     }
     end_label_55: ;
     }
-    
+
 }
 
 
 void VhdlParser::sel_wave_list() {if (!hasError) {
-    
+
     waveform_element();
     }
     if (!hasError) {
-    
+
     jj_consume_token(WHEN_T);
     }
     if (!hasError) {
-    
+
     choices();
     }
     if (!hasError) {
-    
+
     while (!hasError) {
       switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
       case COMMA_T:{
@@ -12463,39 +12458,39 @@ void VhdlParser::sel_wave_list() {if (!hasError) {
         jj_la1[281] = jj_gen;
         goto end_label_56;
       }if (!hasError) {
-      
+
       jj_consume_token(COMMA_T);
       }
       if (!hasError) {
-      
+
       sel_wave_list();
       }
-      
+
     }
     end_label_56: ;
     }
     if (!hasError) {
-    
+
     jj_consume_token(SEMI_T);
     }
-    
+
 }
 
 
 void VhdlParser::inout_stat() {
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case IN_T:{if (!hasError) {
-      
+
       jj_consume_token(IN_T);
       }
-      
+
       break;
       }
     case OUT_T:{if (!hasError) {
-      
+
       jj_consume_token(OUT_T);
       }
-      
+
       break;
       }
     default:
@@ -12507,27 +12502,27 @@ void VhdlParser::inout_stat() {
 
 
 void VhdlParser::else_stat() {if (!hasError) {
-    
+
     while (!hasError) {if (!hasError) {
-      
+
       jj_consume_token(ELSE_T);
       }
       if (!hasError) {
-      
+
       expression();
       }
       if (!hasError) {
-      
+
       switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
       case WHEN_T:{if (!hasError) {
-        
+
         jj_consume_token(WHEN_T);
         }
         if (!hasError) {
-        
+
         expression();
         }
-        
+
         break;
         }
       default:
@@ -12535,7 +12530,7 @@ void VhdlParser::else_stat() {if (!hasError) {
         ;
       }
       }
-      
+
       switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
       case ELSE_T:{
         ;
@@ -12548,34 +12543,34 @@ void VhdlParser::else_stat() {if (!hasError) {
     }
     end_label_57: ;
     }
-    
+
 }
 
 
 QCString VhdlParser::interface_subprogram_declaration() {QCString s;
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case PROCEDURE_T:{if (!hasError) {
-      
+
       s = iproc();
       }
       if (!hasError) {
-      
+
 return s;
       }
-      
+
       break;
       }
     case FUNCTION_T:
     case IMPURE_T:
     case PURE_T:{if (!hasError) {
-      
+
       s = ifunc();
       }
       if (!hasError) {
-      
+
 return s;
       }
-      
+
       break;
       }
     default:
@@ -12588,18 +12583,18 @@ assert(false);
 
 
 QCString VhdlParser::iproc() {QCString s,s1;if (!hasError) {
-    
+
     jj_consume_token(PROCEDURE_T);
     }
     if (!hasError) {
-    
+
     s = identifier();
     }
     if (!hasError) {
-    
+
     s1 = param();
     }
-    
+
 current->name=s;
   return "procedure "+s+s1;
 assert(false);
@@ -12607,23 +12602,23 @@ assert(false);
 
 
 QCString VhdlParser::ifunc() {QCString s,s1,s2,s3;Token *t=0;Token *t1=0;Token *t2=0;if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case IMPURE_T:
     case PURE_T:{
       switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
       case PURE_T:{if (!hasError) {
-        
+
         t = jj_consume_token(PURE_T);
         }
-        
+
         break;
         }
       case IMPURE_T:{if (!hasError) {
-        
+
         t = jj_consume_token(IMPURE_T);
         }
-        
+
         break;
         }
       default:
@@ -12639,48 +12634,48 @@ QCString VhdlParser::ifunc() {QCString s,s1,s2,s3;Token *t=0;Token *t1=0;Token *
     }
     }
     if (!hasError) {
-    
+
     jj_consume_token(FUNCTION_T);
     }
     if (!hasError) {
-    
+
     s = name();
     }
     if (!hasError) {
-    
+
     s1 = param();
     }
     if (!hasError) {
-    
+
     jj_consume_token(RETURN_T);
     }
     if (!hasError) {
-    
+
     s2 = name();
     }
     if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case IS_T:{if (!hasError) {
-      
+
       t1 = jj_consume_token(IS_T);
       }
       if (!hasError) {
-      
+
       switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
       case BASIC_IDENTIFIER:
       case EXTENDED_CHARACTER:{if (!hasError) {
-        
+
         s3 = identifier();
         }
-        
+
         break;
         }
       case BOX_T:{if (!hasError) {
-        
+
         t2 = jj_consume_token(BOX_T);
         }
-        
+
         break;
         }
       default:
@@ -12689,7 +12684,7 @@ QCString VhdlParser::ifunc() {QCString s,s1,s2,s3;Token *t=0;Token *t1=0;Token *
         errorHandler->handleParseError(token, getToken(1), __FUNCTION__, this), hasError = true;
       }
       }
-      
+
       break;
       }
     default:
@@ -12697,7 +12692,7 @@ QCString VhdlParser::ifunc() {QCString s,s1,s2,s3;Token *t=0;Token *t1=0;Token *
       ;
     }
     }
-    
+
 QCString q;
       if(t) q=t->image.data();
       if(t2) s3="<>";
@@ -12721,13 +12716,13 @@ assert(false);
 
 
 QCString VhdlParser::param() {QCString s,s1;Token *tok=0;if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case PARAMETER_T:{if (!hasError) {
-      
+
       tok = jj_consume_token(PARAMETER_T);
       }
-      
+
       break;
       }
     default:
@@ -12736,25 +12731,25 @@ QCString VhdlParser::param() {QCString s,s1;Token *tok=0;if (!hasError) {
     }
     }
     if (!hasError) {
-    
+
 param_sec=PARAM_SEC;
     }
     if (!hasError) {
-    
+
     switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
     case LPAREN_T:{if (!hasError) {
-      
+
       jj_consume_token(LPAREN_T);
       }
       if (!hasError) {
-      
+
       s1 = interface_list();
       }
       if (!hasError) {
-      
+
       jj_consume_token(RPAREN_T);
       }
-      
+
       break;
       }
     default:
@@ -12762,7 +12757,7 @@ param_sec=PARAM_SEC;
       ;
     }
     }
-    
+
 if(tok)
                      {
                       s = tok->image.data();
@@ -12780,20 +12775,20 @@ void VhdlParser::parseInline() {
     case PROCESS_T:
     case BASIC_IDENTIFIER:
     case EXTENDED_CHARACTER:{if (!hasError) {
-      
+
       process_statement();
       }
-      
+
       break;
       }
     case FUNCTION_T:
     case IMPURE_T:
     case PROCEDURE_T:
     case PURE_T:{if (!hasError) {
-      
+
       subprogram_declaration();
       }
-      
+
       break;
       }
     default:
